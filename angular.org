* Angular Rocks

** Tips
- Speaking of =src/app/app.module.ts=
  + Componentes goes into =declarations=.
  + In general, the declarations array contains a list of application
    components, pipes, and directives that belong to the module.
  + Modules (e.g forms, http,...) goes into =imports=
    + also routes (e.g =RouterModule.forRoot([{path: 'heroes',
      component: HeroesComponent}])=) goes into =imports= section of
      =app.module.ts=
  + services goes into =providers=
    * The providers array tells Angular to create a fresh instance of
      the HeroService when it creates an AppComponent. The
      AppComponent, as well as its child components, can use that
      service to get hero data.

- data services are invariably asynchronous,

- The =forRoot()=  method is called because a configured router is
  provided at the app's root. The forRoot() method supplies the Router
  service providers and directives needed for routing, and performs
  the initial navigation based on the current browser URL.

- An Observable is a stream of events that you can process with array-like operators.
  + A request-cancel-new-request sequence is difficult to implement with Promises, but easy with Observables.

- =encapsulation: ViewEncapsulation.Emulated= // other options None,
  Native (native means using Shadow DOM)

** The Component Lifecycle

|   | Lifecycle Hook        | Timing                                                                                    |
|---+-----------------------+-------------------------------------------------------------------------------------------|
| 1 | ngOnChanges           | Before #2 and when data-bound property value changes (so it may be called multiple times) |
| 2 | ngOnInit              | On component initialization, after first ngOnChanges                                      |
| 3 | ngDoCheck             | During every Angular change detection cycle                                               |
| 4 | ngAfterContentInit    | After inserting content(=<ng-content>=) has been projected into view                      |
| 5 | ngAfterContentChecked | After every check of inserted content                                                     |
| 6 | ngAfterViewInit       | After initializing the component's views/child views                                      |
| 7 | ngAfterViewChecked    | After every check of the component's views/ child view                                    |
| 8 | ngOnDestroy           | Just before Angular 2 destroys the Directive/ component                                   |

** Basics
How this whole thing is getting started?
main.ts => app.module.ts => app.component.ts => ...

** Component & Databinding
*** Databinding
The comunication between "Business Logic" and Template (HTML file)
1. Output data
   1. String interpolation *{{data}}*
   2. Property Binding *[property]="data"*. BTW these two are
      equal. <img src="{{item.imagePath}}"/> and <img [src]="item.imagePath"/>
2. React to user event
   1. *(event)="expression"*
3. two-way databinding *[(ngModel)]="data"*
4. Custom property binding:
   + By default all properies of a given component are accessible only
     inside that component. To bind to a property of a given component
     by its parent component use =@Input()= decorator.
   + We also can inform parent component of a given component that a
     property of its child has changed. We do this by the help of
     =@Output()= and =EventEmitter=. For e.g.

    #+BEGIN_SRC typescript
      import { Component, Output, EventEmitter } from '@angular/core';

      @Component({
        selector: 'app-foobar',
        templateUrl: './foobar.component.html',
      })
      export class FoobarComponent implements OnInit {
        @Output('deleted') delete = new EventEmitter();

        onDelete() {
          this.delete.emit(this.myname);
        }
        constructor() { }
      }
    #+END_SRC

    And in the parent component template:
    #+BEGIN_SRC html
    <app-foobar (deleted)="what($event)"></app-foobar>
    #+END_SRC

    And in the parent component class
    #+BEGIN_SRC typescript
      import { Component } from '@angular/core';

      @Component({
        selector: 'app-root',
        templateUrl: './app.component.html',
      })
      export class AppComponent {
        what(event) {
          console.log(event);
        }
      }
    #+END_SRC

5. =@ViewChild('Desired-selector-we-want-to-get-from-telmplate')=: You
   can use ViewChild to get the first element or the directive
   matching the selector from the view DOM. If the view DOM changes,
   and a new child matches the selector, the property will be updated.
   Note that it's only available after =ngAfterViewInit()= is called. 
6. =@ContentChild('selector')= we can't get its value before we reach
   =ngAfterContentInit()=

   inside app.component.html
   #+BEGIN_SRC html
     <app-foobar>
      <p #stuff> foobarzoomar </p>
     </app-foobar>
   #+END_SRC

   inside foobar.component.html
   #+BEGIN_SRC html
   <ng-content></ng-content>
   #+END_SRC

   inside foobar.component.ts
   #+BEGIN_SRC typescript
   @ContentChild('stuff') pStuff: ElementRef;
  
   ngAfterContentInit(): void {
     console.log(this.pStuff.nativeElement.textContent)
   }
   #+END_SRC

** Directives
They are instructions in the DOM.
*** Structural Directives
Note that we can only have one structural directive on a given
element.
**** ngIf;else
#+BEGIN_SRC html
<p *ngIf="serverName; else noServer">{{ serverName }}</p>
<ng-template #noServer>
  <p>There's No Server</p>
</ng-template>
#+END_SRC

**** ngFor
**** ngSwitch
#+BEGIN_SRC html
<div [ngSwitch]="value">
  <p *ngSwitchCase = "5">Value is 5</p>
  <p *ngSwitchCase = "10">Value is 10</p>
  <p *ngSwitchCase = "100">Value is 100</p>
  <p *ngSwitchDefault> foobar </p>
</div>
#+END_SRC
*** Attribute Directives
**** ngStyle
#+BEGIN_SRC html
<p [ngStyle]="{backgroundColor: isServerOnline ? 'lightgreen' : 'lightpink'}">{{ isServerOnline }}</p>
#+END_SRC

**** ngClass

*** Build Your Own Directive
**** Basic approach 
Start with =ng g d foo-bar=.

#+BEGIN_SRC typescript
import { Directive, ElementRef, OnInit } from '@angular/core';

@Directive({
  selector: '[appBasicHighlight]'
})
export class BasicHighlightDirective implements OnInit {
  constructor(private elementRef: ElementRef) {}
  ngOnInit(): void {
    this.elementRef.nativeElement.style.backgroundColor = 'deeppink';
  }
}
#+END_SRC

#+BEGIN_SRC html
<p appBasicHighlight>This Is A Paragraph.</p>
#+END_SRC
**** Better approach
#+BEGIN_SRC typescript
import { Directive, ElementRef, OnInit, Renderer2 } from '@angular/core';

@Directive({
  selector: '[appBasicHighlight]'
})
export class BasicHighlightDirective implements OnInit {
  constructor(private elRef: ElementRef, private renderer: Renderer2) { }

  ngOnInit(): void {
    this.renderer.setStyle(this.elRef.nativeElement, 'background-color', 'lightblue');
  }
}
#+END_SRC
**** HostListener
#+BEGIN_SRC typescript
import { Directive, ElementRef, Renderer2, HostListener } from '@angular/core';

@Directive({
  selector: '[appBasicHighlight]'
})
export class BasicHighlightDirective {
  constructor(private elRef: ElementRef, private renderer: Renderer2) { }

  @HostListener('mouseenter') mouseover(eventData: Event) {
    this.renderer.setStyle(this.elRef.nativeElement, 'background-color', 'lightblue');
  }
  @HostListener('mouseleave') mouseleave(eventData: Event) {
    this.renderer.setStyle(this.elRef.nativeElement, 'background-color', 'unset');
  }
}
#+END_SRC
**** HostBinding
#+BEGIN_SRC typescript
import { Directive, HostListener, HostBinding } from '@angular/core';

@Directive({
  selector: '[appBasicHighlight]'
})
export class BasicHighlightDirective {
  @HostBinding('style.backgroundColor') myBackgroundColor: string;

  constructor() { }

  @HostListener('mouseenter') mouseover() {
    this.myBackgroundColor = 'lightgreen';
  }
  @HostListener('mouseleave') mouseleave() {
    this.myBackgroundColor = 'unset';
  }
}
#+END_SRC
**** Passing Data to a Directive
#+BEGIN_SRC typescript
  import { Directive, HostListener, HostBinding, Input, OnInit } from '@angular/core';

  @Directive({
    selector: '[appBasicHighlight]'
  })

  export class BasicHighlightDirective implements OnInit {
    @Input('defaultColor') defColor = 'unset'; // we can also use an
                                               // alias with the name of
                                               // directive just like
                                               // [ngClas]
    @HostBinding('style.backgroundColor') myBackgroundColor: string;
    constructor() { }
    ngOnInit(): void { this.myBackgroundColor = this.defColor; }
    @HostListener('mouseenter') mouseover() { this.myBackgroundColor = 'lightgreen'; }
    @HostListener('mouseleave') mouseleave() { this.myBackgroundColor = this.defColor; }
  }
#+END_SRC     
**** Custom Structural Directive
#+BEGIN_SRC typescript
import { Directive, Input, TemplateRef, ViewContainerRef } from '@angular/core';
@Directive({
  selector: '[appUnless]'
})
export class UnlessDirective {
  @Input() set appUnless(condition: boolean) {
    // For outside world this is
    // technically is a property. When we
    // assign something to `unless` this
    // method gets executed
    if (!condition) {
      this.vcRef.createEmbeddedView(this.templateRef);
    } else {
      this.vcRef.clear();
    }
  }
  constructor(private templateRef: TemplateRef<any>, private vcRef: ViewContainerRef) { }
}
#+END_SRC

#+BEGIN_SRC html
<p *appUnless="toggler">foobar</p>
#+END_SRC

** Services and DI
- Note that Angular dependency injecor is a hierarchical injector. That
  is to say if we provide our service in a given component, the same
  instance of our service is available for that component and all its
  child. For e.g. if we add our service to =providers= of
  =app.module.ts= the same instance of that service will be available
  application-wide.
- If you inject a service to something, that something should have a
  metadata atached to it. That's why we have to add =@Injectable()=
  decorator to services when we want to inject something into them.

** Routing
*** Defining the Routes

#+BEGIN_SRC typescript
  import { BrowserModule } from '@angular/platform-browser';
  import { NgModule } from '@angular/core';
  import { Routes, RouterModule } from '@angular/router'
  // other imports ...

  const appRoutes: Routes = [
    { path: '', component: HomeComponent },
    { path: 'users', component: UsersComponent }, // note there's not / at the beginning of routes
    { path: 'servers', component: ServersComponent }, // note there's not / at the beginning of routes
  ];

  @NgModule({
    declarations: [
      AppComponent,
      /* ... */
    ],
    imports: [
      BrowserModule,
      RouterModule.forRoot(appRoutes)
    ],
    providers: [],
    bootstrap: [AppComponent]
  })
  export class AppModule { }
#+END_SRC

*** Where to load the components

#+BEGIN_SRC html
<router-outlet></router-outlet>
#+END_SRC

This marks the place in our document where we want the angular router
to load the component of currently selected route.

*** =routerLink= Directive
#+BEGIN_SRC html
<a routerLink="/">HOME</a>
<a routerLink="/servers">SERVERs</a>
<a routerLink="['/users']">USER</a>
#+END_SRC
Paths beginning with =/= are absolute and without =/= they are
relative to the current path.

*** Styling active route
#+BEGIN_SRC html
<a
  routerLinkActive="myClassForActiveLinks"
  [routerLinkActiveOptions]="{exact: true}"
  routerLink="">HOME</a>

<a routerLinkActive="myClassForActiveLinks" routerLink="servers">SERVERs</a>
<a routerLinkActive="myClassForActiveLinks" routerLink="users">USER</a>
#+END_SRC
If we don't provide `[routerLinkActiveOptions]="{exact: true}"`
=myClassForActiveLinks= will be added to HOME for all the paths
becuase it kinda matches all the paths.

*** Navigating Programmatically
#+BEGIN_SRC typescript
  import { Component, Input } from '@angular/core';
  import { LoggingService } from "app/logging.service";
  import { Router } from "@angular/router";

  @Component({
    selector: 'app-root',
    templateUrl: './app.component.html',
  })

  export class AppComponent {
    constructor(private router: Router) { }

    onClick() {
      this.router.navigate(['/servers']); // <= This is how we navigate programmatically
    }
  }
#+END_SRC

To navigate around relatively:

#+BEGIN_SRC typescript
  constructor(private router: Router, private: ActivatedRoute) { }
  this.router.navigate(['servers'], {relativeTo: this.route});
#+END_SRC

To handle query parameters
#+BEGIN_SRC typescript
  this.router.navigate(['servers'], {relativeTo: this.route, queryParamsHandling: 'preserve'});
#+END_SRC
The other option is 'merge'

**** Note

By default, Angular matches paths by prefix. That means, that the
following route will match both =/recipes= and just =/=

={ path: '', redirectTo: '/somewhere-else' }=

Actually, Angular will give you an error here, because that's a common
gotcha: This route will now ALWAYS redirect you! Why?

Since the default matching strategy is "prefix" , Angular checks if
the path you entered in the URL does start with the path specified in
the route. Of course every path starts with '' (Important: That's no
whitespace, it's simply "nothing").

To fix this behavior, you need to change the matching strategy to
="full"=:

={ path: '', redirectTo: '/somewhere-else', pathMatch: 'full' }=

Now, you only get redirected, if the full path is '' (so only if you
got NO other content in your path in this example).

*** redirectTo
#+BEGIN_SRC typescript
const appRoutes: Routes = [
  { path: '', component: HomeComponent },
  { path: 'not-found', component: PageNotFoundComponent },
  { path: '**', redirectTo: '/not-found' }
];
#+END_SRC

Make sure the generic path '**' is the last path in your route.

*** Passing Parameters to Routes
Use =constructor(private route: ActivatedRoute) { }= to get access to
currently active route

In app.module.ts
#+BEGIN_SRC typescript
const appRoutes: Routes = [
  { path: '', component: HomeComponent },
  { path: 'users', component: UsersComponent },
  { path: 'users/:id/:name', component: UserComponent },
  { path: 'servers', component: ServersComponent },
];
#+END_SRC

In UserComponent
#+BEGIN_SRC typescript
import { Component, OnInit } from '@angular/core';
import { ActivatedRoute } from "@angular/router";

@Component({
  selector: 'app-user',
  templateUrl: './user.component.html',
})

export class UserComponent implements OnInit {

  constructor(private route: ActivatedRoute) { }

  ngOnInit() {
    const id = this.route.snapshot.params['id']; // get the :id
    const name = this.route.snapshot.params['name']; // get the :name
    console.log(`id = ${id}, name = ${name}`);
  }
}
#+END_SRC

Let's say we are in '/users/9/farhad' so we loaded the `UserComponent`
and while we are in that route and component we go to
'/users/42/jafar' in this case =ngOnInit()= of UserComponent won't
execute again and we can't use 
#+BEGIN_SRC typescript
  ngOnInit() {
    const id = this.route.snapshot.params['id']; // get the :id
    const name = this.route.snapshot.params['name']; // get the :name
    console.log(`id = ${id}, name = ${name}`);
  }
#+END_SRC
to get the Params the remedy is to =subscribe()= to Params:

In UserComponent:
#+BEGIN_SRC typescript
  import { Component, OnInit } from '@angular/core';
  import { ActivatedRoute, Params } from "@angular/router";

  @Component({
    selector: 'app-user',
    templateUrl: './user.component.html',
  })

  export class UserComponent implements OnInit {

    constructor(private route: ActivatedRoute) { }

    ngOnInit() {
      let id = this.route.snapshot.params['id']; // get the :id
      let name = this.route.snapshot.params['name']; // get the :name
      console.log(`id = ${id}, name = ${name}`);

      this.route.params.subscribe((p: Params) => { // here we subscribe to params
        id = p['id'];
        name = p['name'];
        console.log(`id = ${id}, name = ${name}`);
      });
    }

  }
#+END_SRC

and in user.component.html
#+BEGIN_SRC html
  <p>
    user works!
  </p>
  <button [routerLink]="['/users', 9, 'Mosa']">goto /users/9/mosa</button>
#+END_SRC

**** How to unsubscribe
Note that Angular does this for us, but it's good to know;
#+BEGIN_SRC typescript
import { Component, OnInit, OnDestroy } from '@angular/core';
import { ActivatedRoute, Params } from "@angular/router";
import { Subscription } from "rxjs/Subscription";

@Component({
  selector: 'app-user',
  templateUrl: './user.component.html',
})

export class UserComponent implements OnInit, OnDestroy {
  paramSubscription: Subscription;

  constructor(private route: ActivatedRoute) { }

  ngOnInit() {
    let id = this.route.snapshot.params['id']; // get the :id
    let name = this.route.snapshot.params['name']; // get the :name
    console.log(`id = ${id}, name = ${name}`);

    this.paramSubscription = this.route.params.subscribe((p: Params) => {
      id = p['id'];
      name = p['name'];
      console.log(`id = ${id}, name = ${name}`);
    });
  }

  ngOnDestroy(): void {
    this.paramSubscription.unsubscribe();
  }
}
#+END_SRC

*** Passing Query Parameters and Fragments
**** Query Parameters
#+BEGIN_SRC html
<button
  [routerLink]="['/servers', 9, 'edit']"
  [queryParams]="{allowEdit: '1'}">/servers/9/edit</button>
#+END_SRC
This becomes http://localhost:4200/servers/9/edit?allowEdit=1 

**** Fragments
#+BEGIN_SRC html
<button
  routerLinkActive="active-link"
  [routerLink]="['/servers', 9, 'edit']"
  fragment="loading">/servers/9/edit</button>
#+END_SRC

This becomes http://localhost:4200/servers/9/edit#loading

**** Do it programmatically
***** Query Parameters
#+BEGIN_SRC typescript
  onClick() {
    this.router.navigate(['/servers', 998, 'edit'], { queryParams: { allowEdit: '1' } });
  }
#+END_SRC
This goes to http://localhost:4200/servers/9/edit#loading

**** Retrieving Query Parameters and Fragments
#+BEGIN_SRC typescript
import { Component, OnInit } from '@angular/core';
import { ActivatedRoute } from "@angular/router";

@Component({
  selector: 'app-edit-server',
  templateUrl: './edit-server.component.html',
})
export class EditServerComponent implements OnInit {

  constructor(private route: ActivatedRoute) { }
  ngOnInit() {
    console.log(this.route.snapshot.queryParams);
    console.log(this.route.snapshot.fragment);
  }
}
#+END_SRC

For example for http://localhost:4200/servers/9/edit?name=jafar#loading 
we get ={name: jafar}= for =this.route.snapshot.queryParams= and =loading= for
=this.route.snapshot.fragment=.

The alternative is to use observable. Like:
#+BEGIN_SRC javascript
this.route.queryParams.subscribe(...);
this.route.fragment.subscribe(...);
#+END_SRC

*** Child Nested Routes

#+BEGIN_SRC typescript
const appRoutes: Routes = [
  { path: '', component: HomeComponent },
  {
    path: 'user', component: UserComponent, children: [
      { path: 'jafar', component: JafarComponent },
      { path: 'farhad', component: FarhadComponent }
    ]
  },
];
#+END_SRC
Note that child routes need seperate outlet. i.e. they need
=router-outlet= in user.component.html. 

In user.component.html
#+BEGIN_SRC html
<p>
  user works!
</p>

<router-outlet>
</router-outlet>
#+END_SRC

*** Seperate Routing module
In app.module.ts
#+BEGIN_SRC typescript
  import { BrowserModule } from '@angular/platform-browser';
  import { NgModule } from '@angular/core';
  import { AppComponent } from "app/app.component";
  import { HomeComponent } from './home/home.component';
  import { UserComponent } from './user/user.component';
  import { JafarComponent } from './jafar/jafar.component';
  import { FarhadComponent } from './farhad/farhad.component';
  import { PageNotFoundComponent } from './page-not-found/page-not-found.component';
  import { AppRoutingModule } from './app-routing.module';


  @NgModule({
    declarations: [
      AppComponent,
      HomeComponent,
      UserComponent,
      JafarComponent,
      FarhadComponent,
      PageNotFoundComponent,
    ],
    imports: [
      BrowserModule,
      AppRoutingModule,           // <<== importing our routing module
    ],
    providers: [],
    bootstrap: [AppComponent]
  })
  export class AppModule { }
#+END_SRC

In app-routing.module.ts
#+BEGIN_SRC typescript
import { NgModule } from '@angular/core';
import { Routes, RouterModule } from '@angular/router'
import { AppComponent } from "app/app.component";
import { HomeComponent } from './home/home.component';
import { UserComponent } from './user/user.component';
import { JafarComponent } from './jafar/jafar.component';
import { FarhadComponent } from './farhad/farhad.component';
import { PageNotFoundComponent } from './page-not-found/page-not-found.component';

const appRoutes: Routes = [
  { path: '', component: HomeComponent },
  {
    path: 'user', component: UserComponent, children: [
      { path: 'jafar', component: JafarComponent },
      { path: 'farhad', component: FarhadComponent }
    ]
  },
  { path: 'user/:id', component: UserComponent },
  { path: 'not-found', component: PageNotFoundComponent },
  { path: '**', redirectTo: '/not-found' }
];

@NgModule({
  imports: [
    RouterModule.forRoot(appRoutes)
  ],
  exports: [RouterModule]
})

export class AppRoutingModule { }
#+END_SRC

*** Fucking Guards
Functionality, logic, code which is excuted before a route is loaded
or once you want to leave a route.

**** canActivate
There's so much non-relative thing in this example. Ignore them.

app.module.ts
#+BEGIN_SRC typescript
  import { BrowserModule } from '@angular/platform-browser';
  import { NgModule } from '@angular/core';
  import { AppComponent } from "app/app.component";
  import { HomeComponent } from './home/home.component';
  import { UserComponent } from './user/user.component';
  import { JafarComponent } from './jafar/jafar.component';
  import { FarhadComponent } from './farhad/farhad.component';
  import { PageNotFoundComponent } from './page-not-found/page-not-found.component';
  import { AppRoutingModule } from './app-routing.module';
  import { AuthGuardService } from "app/auth-guard.service";
  import { AuthService } from "app/auth.service";


  @NgModule({
    declarations: [
      AppComponent,
      HomeComponent,
      UserComponent,
      JafarComponent,
      FarhadComponent,
      PageNotFoundComponent,
    ],
    imports: [
      BrowserModule,
      AppRoutingModule,
    ],
    providers: [AuthService, AuthGuardService], // Here's we add to service that we need
    bootstrap: [AppComponent]
  })
  export class AppModule { }
#+END_SRC

auth.service.ts
#+BEGIN_SRC typescript
import { Injectable } from '@angular/core';

@Injectable()
export class AuthService {
  loggedIn = false;

  isAuthenticated() {
    return new Promise(
      (resolve, reject) => setTimeout(() => resolve(this.loggedIn), 800));
  }

  login() {
    this.loggedIn = true;
  }

  logout() {
    this.logout;
  }
}
#+END_SRC

auth-guard.service.ts
#+BEGIN_SRC typescript
import { Injectable } from '@angular/core';
import { CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot, Router } from "@angular/router";
import { Observable } from "rxjs/Observable";
import { AuthService } from "app/auth.service";

@Injectable()
export class AuthGuardService implements CanActivate {
  constructor(private authService: AuthService, private router: Router) { }

  canActivate(route: ActivatedRouteSnapshot,
    state: RouterStateSnapshot): boolean | Observable<boolean> | Promise<boolean> {

    return this.authService.isAuthenticated()
      .then((authenticated: boolean) => {
        if (authenticated) {
          return true;
        }
        this.router.navigate(['/'])
      })
  }
}
#+END_SRC

app-routing.module.ts
#+BEGIN_SRC typescript
  import { NgModule } from '@angular/core';
  import { Routes, RouterModule } from '@angular/router'
  import { AppComponent } from "app/app.component";
  import { HomeComponent } from './home/home.component';
  import { UserComponent } from './user/user.component';
  import { JafarComponent } from './jafar/jafar.component';
  import { FarhadComponent } from './farhad/farhad.component';
  import { PageNotFoundComponent } from './page-not-found/page-not-found.component';
  import { AuthGuardService } from "app/auth-guard.service";

  const appRoutes: Routes = [
    { path: '', component: HomeComponent },
    {
      path: 'user', component: UserComponent, children: [
        { path: 'jafar', component: JafarComponent },
        { path: 'farhad', component: FarhadComponent },
      ]
    },
    { path: 'user/:id', canActivate: [AuthGuardService], component: UserComponent }, // we added canActivate
    { path: 'not-found', component: PageNotFoundComponent },
    { path: '**', redirectTo: '/not-found' }
  ];

  @NgModule({
    imports: [
      RouterModule.forRoot(appRoutes)
    ],
    exports: [RouterModule]
  })

  export class AppRoutingModule { }
#+END_SRC

**** canActivateChild
It's the same as =canActivate= but also works for childs.

auth-guard.service.ts
#+BEGIN_SRC typescript
  import { Injectable } from '@angular/core';
  import { CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot, Router, CanActivateChild } from "@angular/router";
  import { Observable } from "rxjs/Observable";
  import { AuthService } from "app/auth.service";

  @Injectable()
  export class AuthGuardService implements CanActivate, CanActivateChild {

    constructor(private authService: AuthService, private router: Router) { }

    canActivate(route: ActivatedRouteSnapshot,
      state: RouterStateSnapshot): boolean | Observable<boolean> | Promise<boolean> {

      return this.authService.isAuthenticated()
        .then((authenticated: boolean) => {
          if (authenticated) {
            return true;
          }
          this.router.navigate(['/'])
        })
    }

    // here we implement canActivateChild
    canActivateChild(childRoute: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean | Observable<boolean> | Promise<boolean> {
      return this.canActivate(childRoute, state);
    }
  }
#+END_SRC

app-routing.module.ts
#+BEGIN_SRC typescript
  import { NgModule } from '@angular/core';
  import { Routes, RouterModule } from '@angular/router'
  import { AppComponent } from "app/app.component";
  import { HomeComponent } from './home/home.component';
  import { UserComponent } from './user/user.component';
  import { JafarComponent } from './jafar/jafar.component';
  import { FarhadComponent } from './farhad/farhad.component';
  import { PageNotFoundComponent } from './page-not-found/page-not-found.component';
  import { AuthGuardService } from "app/auth-guard.service";

  const appRoutes: Routes = [
    { path: '', component: HomeComponent },
    {
      path: 'user', canActivateChild: [AuthGuardService], component: UserComponent, children: [ // here we add canActivateChild
        { path: 'jafar', component: JafarComponent },
        { path: 'farhad', component: FarhadComponent },
        { path: ':id', component: UserComponent },
      ]
    },
    { path: 'not-found', component: PageNotFoundComponent },
    { path: '**', redirectTo: '/not-found' }
  ];

  @NgModule({
    imports: [
      RouterModule.forRoot(appRoutes)
    ],
    exports: [RouterModule]
  })

  export class AppRoutingModule { }
#+END_SRC

**** canDeactivate
For e.g it can be used to keep the user from accidentally navigating
away from a route.

app.module.ts
#+BEGIN_SRC typescript
  import { BrowserModule } from '@angular/platform-browser';
  import { NgModule } from '@angular/core';
  import { AppComponent } from "app/app.component";
  import { HomeComponent } from './home/home.component';
  import { UserComponent } from './user/user.component';
  import { FarhadComponent } from './farhad/farhad.component';
  import { PageNotFoundComponent } from './page-not-found/page-not-found.component';
  import { AppRoutingModule } from './app-routing.module';
  import { AuthGuardService } from "app/auth-guard.service";
  import { AuthService } from "app/auth.service";
  import { CanDeactivateService } from "app/can-deactivate.service";


  @NgModule({
    declarations: [
      AppComponent,
      HomeComponent,
      UserComponent,
      FarhadComponent,
      PageNotFoundComponent,
    ],
    imports: [
      BrowserModule,
      AppRoutingModule,
    ],
    providers: [AuthService, AuthGuardService, CanDeactivateService], // we added CanDeactivateService
    bootstrap: [AppComponent]
  })
  export class AppModule { }

#+END_SRC

app-routing.module.ts
#+BEGIN_SRC typescript
  import { NgModule } from '@angular/core';
  import { Routes, RouterModule } from '@angular/router'
  import { AppComponent } from "app/app.component";
  import { HomeComponent } from './home/home.component';
  import { UserComponent } from './user/user.component';
  import { FarhadComponent } from './farhad/farhad.component';
  import { PageNotFoundComponent } from './page-not-found/page-not-found.component';
  import { AuthGuardService } from "app/auth-guard.service";
  import { CanDeactivateService } from "app/can-deactivate.service";

  const appRoutes: Routes = [
    { path: '', component: HomeComponent },
    {
      path: 'user', canActivateChild: [AuthGuardService], component: UserComponent, children: [
        { path: 'farhad', component: FarhadComponent, canDeactivate: [CanDeactivateService] }, // we added CanDeactivateService
      ]
    },
    { path: 'not-found', component: PageNotFoundComponent },
    { path: '**', redirectTo: '/not-found' }
  ];

  @NgModule({
    imports: [
      RouterModule.forRoot(appRoutes)
    ],
    exports: [RouterModule]
  })

  export class AppRoutingModule { }
#+END_SRC

can-deactivate.service.ts
#+BEGIN_SRC  typescript
  import { Injectable } from '@angular/core';
  import { Observable } from "rxjs/Observable";
  import { CanDeactivate, RouterStateSnapshot, ActivatedRouteSnapshot } from "@angular/router";

  @Injectable()
  export class CanDeactivateService implements CanDeactivate<CanComponentDeactivate> {

    // this will run by angular once we try to leave a route
    canDeactivate(
      component: CanComponentDeactivate,
      currentRoute: ActivatedRouteSnapshot,
      currentState: RouterStateSnapshot,
      nextState?: RouterStateSnapshot): boolean | Observable<boolean> | Promise<boolean> {

      return component.canDeactivate();
    }

    constructor() { }
  }

  export interface CanComponentDeactivate { // we use this interface in our module (in this case farhad.component.ts)
    canDeactivate: () => Observable<boolean> | Promise<boolean> | boolean
  }

#+END_SRC

auth-guard.service.ts
#+BEGIN_SRC typescript
import { Injectable } from '@angular/core';
import { CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot, Router, CanActivateChild } from "@angular/router";
import { Observable } from "rxjs/Observable";
import { AuthService } from "app/auth.service";

@Injectable()
export class AuthGuardService implements CanActivate, CanActivateChild {

  constructor(private authService: AuthService, private router: Router) { }

  canActivate(route: ActivatedRouteSnapshot,
    state: RouterStateSnapshot): boolean | Observable<boolean> | Promise<boolean> {

    return this.authService.isAuthenticated()
      .then((authenticated: boolean) => {
        if (authenticated) {
          return true;
        }
        this.router.navigate(['/'])
      })
  }


  canActivateChild(childRoute: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean | Observable<boolean> | Promise<boolean> {
    return this.canActivate(childRoute, state);
  }
}
#+END_SRC

farhad.component.html
#+BEGIN_SRC html
<p>
  farhad works!
</p>

<button (click)="onHappy()">I'm happy</button>
<button (click)="onBlue()">I'm blue</button>
<button (click)="goAway()">GoAway</button>
#+END_SRC

farhad.component.ts
#+BEGIN_SRC typescript
  import { Component, OnInit } from '@angular/core';
  import { Router, ActivatedRoute } from "@angular/router";
  import { CanComponentDeactivate } from "app/can-deactivate.service";
  import { Observable } from "rxjs/Observable";

  @Component({
    selector: 'app-farhad',
    templateUrl: './farhad.component.html',
    styleUrls: ['./farhad.component.css']
  })
  export class FarhadComponent implements OnInit, CanComponentDeactivate {
    happy = false;

    constructor(private router: Router, private route: ActivatedRoute) { }
    ngOnInit() { }
    onHappy() {
      this.happy = true;
      console.log(`happy is ${this.happy}`);
    }
    onBlue() {
      this.happy = false;
      console.log(`happy is ${this.happy}`);
    }

    goAway() {
      this.router.navigate(['../'], { relativeTo: this.route });
    }

    canDeactivate(): boolean | Observable<boolean> | Promise<boolean> { // our component must have canDeactivate
      console.log(`happy is ${this.happy}`);
      if (this.happy) {
        return true;
      }
      return false;
    }
  }
#+END_SRC

*** Passing Static Data to a Route

app-routing.module.ts
#+BEGIN_SRC typescript
  import { NgModule } from '@angular/core';
  import { Routes, RouterModule } from '@angular/router'
  import { AppComponent } from "app/app.component";
  import { HomeComponent } from './home/home.component';
  import { UserComponent } from './user/user.component';
  import { FarhadComponent } from './farhad/farhad.component';
  import { PageNotFoundComponent } from './page-not-found/page-not-found.component';
  import { AuthGuardService } from "app/auth-guard.service";
  import { CanDeactivateService } from "app/can-deactivate.service";
  import { ErrorPageComponent } from "app/error-page/error-page.component";

  const appRoutes: Routes = [
    { path: '', component: HomeComponent },
    {
      path: 'user', canActivateChild: [AuthGuardService], component: UserComponent, children: [
        { path: 'farhad', component: FarhadComponent, canDeactivate: [CanDeactivateService] },
      ]
    },
    { path: 'not-found', component: ErrorPageComponent, data: { message: 'Page not found bitch' } }, // ErrorPageComponent receives message
    { path: '**', redirectTo: '/not-found' }
  ];

  @NgModule({
    imports: [
      RouterModule.forRoot(appRoutes)
    ],
    exports: [RouterModule]
  })

  export class AppRoutingModule { }
#+END_SRC

error-page.component.ts
#+BEGIN_SRC typescript
  import { Component, OnInit } from '@angular/core';
  import { ActivatedRoute, Data } from "@angular/router";

  @Component({
    selector: 'app-error-page',
    templateUrl: './error-page.component.html',
    styleUrls: ['./error-page.component.css']
  })
  export class ErrorPageComponent implements OnInit {
    errorMessage: string;

    constructor(private route: ActivatedRoute) { }

    ngOnInit() {
      this.errorMessage = this.route.snapshot.data['message']; // here we get the message
      this.route.data.subscribe((data: Data) => {
        this.errorMessage = data['message'];
      })
    }
  }
#+END_SRC
*** Resolving Dynamic Data with the resolve Guard
**** Resolver:
This is also a service like CanActivate or CanDeactivateService,
unlike them =Resolve= doesn't decide weather a route should loaded or
not, but allows to run some code (like fetching some data) before a route is rendered.

server-resolve.service.ts
#+BEGIN_SRC typescript
import { Injectable } from '@angular/core';
import { Resolve, ActivatedRouteSnapshot, RouterStateSnapshot } from "@angular/router";
import { Observable } from "rxjs/Observable";

@Injectable()
export class ServerResolveService implements Resolve<III> {

  resolve(
    route: ActivatedRouteSnapshot,
    state: RouterStateSnapshot): III | Observable<III> | Promise<III> {
    return {                    // or do something important like fetching data from server
      id: route.params['id'],
    }
  }

  constructor() { }
}

interface III {
  id: number
}
#+END_SRC

user.component.ts
#+BEGIN_SRC typescript
import { Component, OnInit } from '@angular/core';
import { ActivatedRoute, Data } from "@angular/router";

@Component({
  selector: 'app-user',
  templateUrl: './user.component.html',
})

export class UserComponent implements OnInit {
  constructor(private route: ActivatedRoute) { }

  ngOnInit() {
    this.route.data.subscribe((data: Data) => {
      if (data.foobar) {      // to prevent undefined error
        console.dir(data.foobar.id)
      }
    })
  }
}
#+END_SRC

app-routing.module.ts
#+BEGIN_SRC typescript
import { NgModule } from '@angular/core';
import { Routes, RouterModule } from '@angular/router'
import { AppComponent } from "app/app.component";
import { HomeComponent } from './home/home.component';
import { UserComponent } from './user/user.component';
import { FarhadComponent } from './farhad/farhad.component';
import { PageNotFoundComponent } from './page-not-found/page-not-found.component';
import { AuthGuardService } from "app/auth-guard.service";
import { CanDeactivateService } from "app/can-deactivate.service";
import { ErrorPageComponent } from "app/error-page/error-page.component";
import { ServerResolveService } from "app/server-resolve.service";

const appRoutes: Routes = [
  { path: '', component: HomeComponent },
  {
    path: 'user', canActivateChild: [AuthGuardService], component: UserComponent, children: [
      { path: 'farhad', component: FarhadComponent, canDeactivate: [CanDeactivateService] },
      {
        path: ':id',
        component: UserComponent,
        resolve: { foobar: ServerResolveService }
      }, // Adding our resolver. Whatever is returned by =resolve=
      // method of =ServerResolveService= is mapped to =foobar=
    ]
  },
  // { path: 'not-found', component: PageNotFoundComponent },
  { path: 'not-found', component: ErrorPageComponent, data: { message: 'Page not found bitch' } },
  { path: '**', redirectTo: '/not-found' }
];

@NgModule({
  imports: [
    RouterModule.forRoot(appRoutes)
  ],
  exports: [RouterModule]
})

export class AppRoutingModule { }
#+END_SRC

** Observables
#+BEGIN_SRC typescript
const myObservable = Observable.create((observer: Observer<string>) => {
      setTimeout(() => {
        observer.next('First package');
      }, 2000);
      setTimeout(() => {
        observer.next('Second package');
      }, 4000);
      // setTimeout(() => {
      //   observer.error('This does not work');
      // }, 5000);
      setTimeout(() => {
        observer.complete();
      }, 5000);
    })

    myObservable.subscribe(
      (val: string) => console.log(val),
      (error: string) => console.error(error),
      () => console.log('completed'));
#+END_SRC   

*Remember to unsubscribe from the observables when you're done. Usually in ngOnDestroy hook*

*** Subjects
The =Subject= class inherits both =Observable= and =Observer=, in the
sense that it is both an observer and an observable. It's kinda
comparable to EventEmitter that is shipped with Angular

** Forms
*** Template-Driven Approach
In this approach Angular infers the form object from the
DOM. Template-Driven approach mostly happens in template (rather than
our .ts file)

- In app.module.ts add =FormsModule= to imports 
- By doing so Angular automatically creates a form object for us when it sees
  =<form></form>=. We can think of =<form>= as a selector for an Angular directive.
- We need to register controls manually. Angular doesn't so
  automatically. We do this by adding =ngModel= to our inputs in the
  form.
- Remember inputs must have a html =name= attribute. Angular uses that.
- Submitting and Using the Form: 

Example:

app.component.html
#+BEGIN_SRC html
  <form (ngSubmit)="onSubmit(f)" #f="ngForm">
          <!--  -->
          <div id="user-data">
            <div class="form-group">
              <label for="username">Username</label>
              <input
                ngModel <!-- here -->
                type="text"
                id="username"
                name="username" <!-- here -->
                class="form-control">
            </div>
            <button class="btn btn-default" type="button">Suggest an Username</button>
            <div class="form-group">
              <label for="email">Mail</label>
              <input ngModel <!-- here -->
                     name="email" <!-- here -->
                     type="email"
                     id="email"
                     class="form-control">
            </div>
          </div>
          <!--  -->
          <div class="form-group">
            <label for="secret">Secret Questions</label>
            <select
              ngModel <!-- here -->
              name="secret" <!-- here -->
              id="secret"
              class="form-control">
              <option value="pet">Your first Pet?</option>
              <option value="teacher">Your first teacher?</option>
            </select>
          </div>
          <!--  -->
          <button class="btn btn-primary" type="submit">Submit</button>
          <!--  -->
        </form>
#+END_SRC

app.component.ts
#+BEGIN_SRC typescript
import { Component } from '@angular/core';
import { NgForm } from "@angular/forms";

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
})
export class AppComponent {
  onSubmit(form: NgForm) {
    console.log(form.value.username);
    console.log(form.value.email);
    console.log(form.value.secret);
  }
}
#+END_SRC

Alternatively: We can use @ViewChild. This approach is also useful
when we want to access the form before user submitting it.

app.component.ts
#+BEGIN_SRC typescript
  import { Component, ViewChild } from '@angular/core';
  import { NgForm } from "@angular/forms";

  @Component({
    selector: 'app-root',
    templateUrl: './app.component.html',
    styleUrls: ['./app.component.css']
  })
  export class AppComponent {
    @ViewChild('f') signupForm: NgForm; // here

    onSubmit() {
      console.log(this.signupForm);
    }
  }
#+END_SRC

**** Validity of inputs
By adding directives such as =required= and =email= we can check the
validity of our form and individual inputs. Angular adds appropriate
classes to the forms and inputs, like =ng-valid=, =ng-invalid=

app.component.html
#+BEGIN_SRC html
  <div class="container">
    <div class="row">
      <div class="col-xs-12 col-sm-10 col-md-8 col-sm-offset-1 col-md-offset-2">

        <form (ngSubmit)="onSubmit(f)" #f="ngForm">
          <!--  -->
          <div id="user-data">
            <div class="form-group">
              <label for="username">Username</label>
              <input
                required <!-- here -->
                ngModel
                type="text"
                id="username"
                name="username"
                class="form-control">
            </div>
            <button class="btn btn-default" type="button">Suggest an Username</button>
            <div class="form-group">
              <label for="email">Mail</label>
              <input ngModel
                     required <!-- here -->
                     email    <!-- here -->
                     #email="ngModel" <!-- here -->
                     name="email"
                     type="email"
                     id="email"
                     class="form-control">
              <span *ngIf="email.invalid && email.touched" class="help-block">Please Enter a Valid Email!</span> <!-- here -->
            </div>
          </div>
          <!--  -->
          <div class="form-group">
            <label for="secret">Secret Questions</label>
            <select
              ngModel
              name="secret"
              id="secret"
              class="form-control">
              <option value="pet">Your first Pet?</option>
              <option value="teacher">Your first teacher?</option>
            </select>
          </div>
          <!--  -->
          <button
            [disabled]="f.invalid"
            class="btn btn-primary"
            type="submit">Submit</button>
          <!--  -->
        </form>

      </div>
    </div>
  </div>
#+END_SRC

***** Pattern
#+BEGIN_SRC html
  <input
    pattern="^[1-9]+[0-9]*$" <!-- adding a Regex -->
    required
    ngModel
    name="amount"
    type="number"
    id="amount"
    class="form-control" />
#+END_SRC

**** Providing default value
#+BEGIN_SRC html
          <select
            [ngModel]="defaultQuestion"<!-- Providing Default Value. defaultQuestion is defined in our component.ts file -->
            name="secret"
            id="secret"
            class="form-control">
            <option value="pet">Your first Pet?</option>
            <option value="teacher">Your first teacher?</option>
          </select>
#+END_SRC

**** Two-way binding
#+BEGIN_SRC html
  <textarea [(ngModel)]="answer" name="questionAnswer" >
  </textarea>
  <p>Your reply: {{ answer }}</p>
#+END_SRC

**** Grouping Form Controls
We use =ngModelGroup= directive to group some =ngModel=

#+BEGIN_SRC html
  <div id="user-data" ngModelGroup="userData" #userData="ngModelGroup"><!-- here we added ngModelGroup to group username and email-->
            <div class="form-group">
              <label for="username">Username</label>
              <input
                required
                ngModel
                type="text"
                id="username"
                name="username"
                class="form-control">
            </div>
            <button class="btn btn-default" type="button">Suggest an Username</button>
            <div class="form-group">
              <label for="email">Mail</label>
              <input ngModel
                     required
                     email
                     #email="ngModel"
                     name="email"
                     type="email"
                     id="email"
                     class="form-control">
              <span *ngIf="email.invalid && email.touched" class="help-block">Please Enter a Valid Email!</span>
            </div>
          </div>
          <p *ngIf="userData.invalid && userData.touched">User data is invalid</p><!-- here we check the validity of our ngModelGroup -->
#+END_SRC

**** Setting values
We can use =this.signupForm.setValue= to set the whole form.
#+BEGIN_SRC typescript
  fillTheFromForMe() {
    this.signupForm.setValue({
      userData: {
        username: 'farhad',
        email: 'farhad.hsni@gmail.com',
      },
      secret: 'pet',
      questionAnswer: 'nana yo buzines',
      gender: 'male',
    })
  }
#+END_SRC

Or fill just one ngModel with =this.signupForm.form.patchValue=
#+BEGIN_SRC typescript
  fillTheFromForMe() {
    this.signupForm.form.patchValue({
      userData: {
        username: 'foobar'
      }
    })
  }
#+END_SRC

**** Reset a From
=this.signupForm.reset()=

*** Reactive Approach
Form is created programmatically and synchronized with the DOM

We start by creating a property which is of =FormGroup= type.

app.component.html
#+BEGIN_SRC html
<div class="container">
  <div class="row">
    <div class="col-xs-12 col-sm-10 col-md-8 col-sm-offset-1 col-md-offset-2">
      <form [formGroup]="signupForm" (ngSubmit)="onSubmit()">
        <!-- userData -->
        <div formGroupName="userData">
          <div class="form-group">
            <label for="username">Username</label>
            <!-- username is what we used in signupForm -->
            <input formControlName="username" type="text" id="username" class="form-control"/>

            <span
              *ngIf="!signupForm.get('userData.username').valid && signupForm.get('userData.username').touched"
              class="help-block">

              <span *ngIf="signupForm.get('userData.username').errors['nameIsForbidden']">
                This name is invalid.
              </span>

              <span *ngIf="signupForm.get('userData.username').errors['required']">
                This field is required.
              </span>
            </span>

          </div>
          <div class="form-group">
            <label for="email">email</label>
            <!-- email is what we used in signupForm -->
            <input formControlName="email" type="text" id="email" class="form-control"/>
            <span
              *ngIf="!signupForm.get('userData.email').valid && signupForm.get('userData.email').touched"
              class="help-block">Please Enter a Valid Email Address</span>
          </div>          
        </div>
        <!-- /userData ends here -->
        <div class="radio" *ngFor="let gender of genders">
          <label>
            <!-- gender is what we used in signupForm -->
            <input formControlName="gender" type="radio" [value]="gender"/>
            {{ gender }}
          </label>
        </div>
        <div formArrayName="hobbies">
          <h4>Your Hobbies</h4>
          <button class="btn btn-default"
                  type="submit"
                  (click)="onAddHobby()">Add Hobby</button>
          <div
            *ngFor="let hobby of signupForm.get('hobbies').controls; let i = index"
            class="form-group">
            <input type="text" class="form-control" [formControlName]="i"/>
          </div>
        </div>
        <span
          *ngIf="!signupForm.valid && signupForm.touched"
          class="help-block">Something is wrong</span>
        <button class="btn btn-primary" type="submit">Submit</button>
      </form>
    </div>
  </div>
</div>
#+END_SRC

app.component.ts
#+BEGIN_SRC typescript
import { Component, OnInit } from '@angular/core';
import { FormGroup, FormControl, Validators, FormArray } from "@angular/forms";
import { Observable } from "rxjs/Observable";

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent implements OnInit {
  genders = ['male', 'female'];
  signupForm: FormGroup;
  forbiddenUsernames = ['me', 'you'];

  ngOnInit(): void {
    this.signupForm = new FormGroup({
      'userData': new FormGroup({                               // nested FormGroup
        'username': new FormControl(null, [Validators.required, this.forbiddenNames.bind(this)]), // null as default value
        'email': new FormControl(null, [Validators.required, Validators.email], this.forbiddenEmails.bind(this)), // more than one validator. Third parameter is for asynchronous validator
      }),
      'gender': new FormControl('female'),
      'hobbies': new FormArray([])
    });

    this.signupForm.valueChanges.subscribe(
      (value) => {
        // react to value changes
        console.log(value);
      })

    this.signupForm.statusChanges.subscribe(
      (status) => {
        // react to status changes
        console.log(status);
      })

    this.signupForm.setValue({
      'userData': {
        'username': 'someone',
        'email': 'something@someone.com'
      },
      'gender': 'male',
      'hobbies': [],
    })

    this.signupForm.patchValue({
      'userData': {
        'username': 'Anna'
      }
    })

  }

  onSubmit() {
    console.log(this.signupForm);
    this.signupForm.reset();
  }

  onAddHobby() {
    const control = new FormControl(null, Validators.required);

    (<FormArray>this.signupForm.get('hobbies')).push(control);
  }

  forbiddenNames(control: FormControl): { [s: string]: boolean } {
    if (this.forbiddenUsernames.indexOf(control.value) !== -1) {
      return { 'nameIsForbidden': true }
    }
    return null;                // validation was successful
  }

  forbiddenEmails(control: FormControl): Promise<any> | Observable<any> {
    return new Promise<any>((resolve, reject) => {
      setTimeout(() => {
        if (control.value === 'test@test.com') {
          resolve({ 'emailIsForbidden': true });
        }
        resolve(null);
      }, 1000)
    });
  }
}
#+END_SRC

app.module.ts
#+BEGIN_SRC typescript
import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';
import { HttpModule } from '@angular/http';

import { AppComponent } from './app.component';
import { ReactiveFormsModule } from "@angular/forms";

@NgModule({
  declarations: [
    AppComponent
  ],
  imports: [
    BrowserModule,
    HttpModule,
    ReactiveFormsModule,
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }
#+END_SRC

*** Notes
Since it's Angular job to handle the forms we don't add =action= or
=method= to =<form></form>=

** Pipes
** Http

** Authentication

** Optimization & ngModules

** Deployment

** Animation & Testing
