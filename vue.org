From Sara Drasner =intro to Vue= workshop and official doc.


** DIRECTIVES
HTML attributes, that basically attaches some functionality to that HTML markup.
- =v-text=: &nbsp; Similar to using mustache templates
- =v-html=: &nbsp; for strings that have html elements that need to be rendered!
- =v-show=: it uses =display: none= Note that =v-show= doesn’t support the =<template>= element, nor does it  work with =v-else=.
- =v-if=: completely takes the element out of  =DOM=: Unlike =v-show=, =v-if= is “real” conditional rendering because it ensures that event listeners and child components inside the conditional block are properly destroyed and re-created during toggles.
- =v-else=
- =v-else-if=
- =v-for=: Other than lists, you can also use =v-for= to iterate through the properties of an object. You can also provide a second argument for the key, and another for the index.

- =@= or =v-on=: &nbsp; for binding to events like click and mouseenter

Multiple binding is also possible

#+BEGIN_SRC html
<div v-on="
  click   : onClick,
  keyup   : onKeyup,
  keydown : onKeydown
">
</div>
<!-- same as -->
<div @="
  click   : onClick,
  keyup   : onKeyup,
  keydown : onKeydown
">
</div>
#+END_SRC
*** MODIFIERs
    - =@mousemove.stop= is comparable to e.stopPropogation()
    - =@mousemove.prevent= this is like e.preventDefault()
    - =@submit.prevent= this will no longer reload the page on submission
    - =@click.once= not to be confused with v-once, this click event will be triggered once.
    - =@click.native= so that you can listen to native events (not virtual-dom events) in the DOM

- =:= or =v-bind=: &nbsp;
          We can use it for so many things- class and style binding, creating dynamic props, etc...

cool example:
#+BEGIN_SRC html
<template>
  <div>
    <input type="text" v-model="name">
    <p :style="{ color: =${name}=}">sample text</p>
  </div>
</template>

<script>
export default {
  data () {
    return {
      name: ''
    }
  }
}
</script>
#+END_SRC
- =v-model=:
            Creates a relationship between the data in the instance/component and a form input, so you can dynamically update values
- =v-pre=: &nbsp; skip the mustache, that is to say literally print ={{ stuff }}=
- =v-cloak=
- =v-once=: &nbsp; to do one-time interpolations that do not update on data change, keep in mind this will also affect any binding on the same node:

*** MODIFIERS
=v-model.trim=: will strip any leading or trailing whitespace from the bound string
=v-model.number= changes strings to number inputs
=v-model.lazy= won’t populate the content automatically, it will wait to bind until an event happens. (It listens to change events instead of input)

** COMPUTED properties
(cached until dependency is changed)
Computed properties are calculations that will be cached and will only update when needed. Highly performant but use with understanding. They are the different view of the same data.

The function provide will be used as the getter function for the property of the same name.

| computed                                            |      methods                                |
|-----------------------------------------------------|:-------------------------------------------:|
| Runs only when a dependency has changed             | Runs whenever an update occurs              |
| Cached                                              | Not cached                                  |
| Should be used as a property, in place of data      | Typically invoked from v-on/@, but flexible |
| By default getter only, but you can define a setter | Getter/setter                               |


*** Computed Caching vs Methods
#+BEGIN_SRC javascript
new Vue({
  el: '#example',
  data: {
    message: 'Hello'
  },
  computed: {
    // a computed getter
    reversedMessage: function () {
      return this.message.split('').reverse().join('')
    }
  }
#+END_SRC

computed properties are cached based on their dependencies
This means as long as =message= has not changed, multiple access to the =reversedMessage= computed property will immediately return the previously computed result without having to run the function again.
This also means the following computed property will never update, because =Date.now()= is not a reactive dependency:
#+BEGIN_SRC javascript
computed: {
  now: function () {
    return Date.now()
  }
}
#+END_SRC
In comparison, a method invocation will always run the function whenever a re-render happens

Computed properties are by default getter-only, but you can also provide a setter when you need it:
#+BEGIN_SRC javascript
// ...
computed: {
  fullName: {
    // getter
    get: function () {
      return this.firstName + ' ' + this.lastName
    },
    // setter
    set: function (newValue) {
      var names = newValue.split(' ')
      this.firstName = names[0]
      this.lastName = names[names.length - 1]
    }
  }
}
// ...
#+END_SRC

** WATCHERs
For reactivity Vus.js uses a variation of =getters/setters=

Vue takes the object, walks through its properties and converts them to getter/setters
#+BEGIN_SRC javascript
new Vue({
  data: {
    text: 'msg'
  }
})

#+END_SRC
Vue cannot detect property addition or deletion so we create this object to keep track of it.

Each component has a watcher instance. The properties touched by the watcher during the render are registered as dependencies. When the setter is triggered, it lets the watcher know, and causes the component to re-render.

Watchers are most useful when you want to perform asynchronous or expensive operations in response to changing data.

The Vue instance is the middleman between the DOM and the business logic

example:
#+BEGIN_SRC html
<template>
  <div id="app">
    <input type="number" v-model.number="counter">
  </div>
</template>

<script>
export default {
  data () {
    return {
      counter: 0
    }
  },
  watch: {
    counter () {/* name must be the same as data */
      console.log('counter changed')
    }
  }
}
</script>
#+END_SRC

We also have access to the new value and the old value:

#+BEGIN_SRC javascript
watch: {
  watchedProperty (value, oldValue) {
    //your dope code here
  }
},
#+END_SRC

We can also gain access to nested values with 'deep':

#+BEGIN_SRC javascript
watch: {
  myWatchedProperty: {
    deep: true,
    handler: function (value, oldValue) {
      //your dope code here
    }
  }
},
#+END_SRC

** TEMPLATE

Vue.js uses HTML-based template syntax to bind the Vue instance to the DOM, very useful for components.
Templates are optional, you can also write render functions with optional JSX support.

*** props
Passing data down from the parent to the child. Props are intended for one way communication
You can think of it a little like the component holds a variable that is waiting to be filled out by whatever the parent sends down to it.

App.vue
#+BEGIN_SRC html
<template>
  <div>
    <hello :person="myname"></hello> <!-- person is a prop -->
  </div>
</template>

<script>
import Hello from "./components/Hello.vue"

export default {
  components: { Hello }, // also possible: components: { 'my-compo': Hello },
  data () {
    return {
      myname: 'farhad'
    }
  },
}
</script>
#+END_SRC

Hello.vue
#+BEGIN_SRC html
<template>
  <div>
    <p>{{ msg }} {{person}}</p> <!-- person is a =prop= -->
  </div>
</template>

<script>
export default {
  props: ["person"],
  data () {
    return {
      msg: 'hello'
    }
  }
}
</script>
#+END_SRC

=Props= can have types/validation/default,...

#+BEGIN_SRC javascript
<script>
export default {
  props: {
    person: {
      type: String,
      required: true,
      default: 'hello mr. magoo'
    }
  },

  data () {
    return {
      msg: 'hello'
    }
  }
}
</script>
#+END_SRC

Note: Objects and arrays need their defaults to be returned from a function:
#+BEGIN_SRC javascript
text: {
  type: Object,
  default: function () {
    return { message: 'hello mr. magoo' }
  }
}
#+END_SRC

camelCasing will be converted

In HTML it will be kebab-case:
 #+BEGIN_SRC javascript
  props: ['booleanValue']
#+END_SRC
#+BEGIN_SRC html
  <checkbox :boolean-value="booleanValue"></checkbox>
#+END_SRC

*** x-template
Another way to define templates is inside of a script element with the type text/x-template, then referencing the template by an id. For example:

#+BEGIN_SRC javascript
Vue.component('individual-comment', {
  template: '#comment-template',
  props: ['commentpost']
})
#+END_SRC

#+BEGIN_SRC html
  <ul>
    <li
      is="individual-comment"
      v-for="comment in comments"
      v-bind:commentpost="comment"
    ></li>
  </ul>

  <!-- template -->
<script type="text/x-template" id="comment-template">
  <li>
    <img class="post-img" :src="commentpost.authorImg" />
    <small>{{ commentpost.author }}</small>
    <p class="post-comment">"{{ commentpost.text }}"</p>
  </li>
</script>
#+END_SRC
*** Events
#+BEGIN_SRC html
<my-component @myEvent="parentHandler($event)"></my-component>
#+END_SRC

#+BEGIN_SRC javascript
methods: {
  fireEvent() {
    this.$emit('myEvent', eventValueOne, eventValueTwo);
  }
}
#+END_SRC

*** Slots
#+BEGIN_SRC html
<template>
    <slot>default text</slot>
</template>
#+END_SRC

When we have more than one slot we can name them
#+BEGIN_SRC html
<slot name="headerinfo"></slot>
<!-- to use it >> -->
<h1 slot="headerinfo">I will populate the headerinfo slot</h1>
#+END_SRC

*** Keep Alive

If you want to keep the switched-out components in memory so that you can preserve their state or avoid re-rendering, you can wrap a dynamic component in a <keep-alive> element:
#+BEGIN_SRC html
<keep-alive>
  <component :is="currentView">
    <!-- inactive components will be cached! -->
  </component>
</keep-alive>
#+END_SRC

*** lifecycle hooks
The lifecycle hooks provide you a method so that you might trigger something precisely at different junctures of a component's lifecycle. Components are mounted when we instantiate them, and in turn unmounted, for instance when we toggle them in a v-if/v-else statement.

- =beforeCreate=
- =created=
- =beforeMount=
- =mounted=
- =beforeUpdate=
- =updated=
- =activated=
- =deactivated=
- =beforeDestroy=
- =destroyed=

Lifecycle hooks also auto-bind to the instance so that you can use the component’s state, and methods. Again, you don't have to console.log to find out what this refers to!

 For this reason though, you shouldn’t use an arrow function on a lifecycle method, as it will return the parent instead of giving you nice binding out of the box.

*** NUXT


*** Animation
[[https://s3.amazonaws.com/media-p.slid.es/uploads/75854/images/3639060/transition.png][Vue animation diagram]]

Transition Classes

There are six classes applied for enter/leave transitions.

=v-enter=: Starting state for enter. Added before element is inserted,
removed one frame after element is inserted.

=v-enter-active=: Active state for enter. Applied during the entire
entering phase. Added before element is inserted, removed when
transition/animation finishes. This class can be used to define the
duration, delay and easing curve for the entering transition.

=v-enter-to=: Only available in versions 2.1.8+. Ending state for
enter. Added one frame after element is inserted (at the same time
v-enter is removed), removed when transition/animation finishes.

=v-leave=: Starting state for leave. Added immediately when a leaving
transition is triggered, removed after one frame.

=v-leave-active=: Active state for leave. Applied during the entire
leaving phase. Added immediately when leave transition is triggered,
removed when the transition/animation finishes. This class can be used
to define the duration, delay and easing curve for the leaving
transition.

=v-leave-to=: Only available in versions 2.1.8+. Ending state for
leave. Added one frame after a leaving transition is triggered (at the
same time v-leave is removed), removed when the transition/animation
finishes.

Each of these classes will be prefixed with the name of the
transition. Here the =v-= prefix is the default when you use a
=<transition>= element with no name.
If you use `<transition name="my-transition">`
for example, then the =v-enter= class would
instead be =my-transition-enter=.  =v-enter-active= and =v-leave-active=
give you the ability to specify different easing curves for
enter/leave transitions.

#+BEGIN_SRC html
<template>
  <transition name="fade">
    <app-child v-if="isShowing" class="modal">
      <button @click="toggleShow">
        Close
      </button>
    </app-child>
  </transition>
</template>
<!-- style >> -->
<style>
  .fade-enter-active, .fade-leave-active {
    transition: opacity 0.25s ease-out;
  }

  .fade-enter, .fade-leave-to {
    opacity: 0;
  }
</style>
#+END_SRC
[[https://codepen.io/sdras/pen/6ef951b970faf929d8580199fe8ea6ba][example]] of using transition
[[https://codepen.io/sdras/pen/6ef951b970faf929d8580199fe8ea6ba][example]]2 of using transition.
[[https://codepen.io/sdras/pen/pRWxGg][example]] of using CSS animation.

*** Transition Modes
to specify an order

*IN-OUT*:
The current element waits until the new element is done transitioning in to fire

*OUT-IN*:
The current element transitions out and then the new element transitions in.

#+BEGIN_SRC html
<transition name="flip" mode="out-in">
  <slot v-if="!isShowing"></slot>
  <img v-else src="https://s3-us-west-2.amazonaws.com/s.cdpn.io/28963/cartoonvideo14.jpeg" />
</transition>
#+END_SRC
[example](https://codepen.io/sdras/pen/mRpoOG)

**** Javascript Hooks for Animation
#+BEGIN_SRC html
<transition
  @before-enter="beforeEnter"
  @enter="enterEl"
  @after-enter="afterEnter"
  @enter-cancelled="enterCancelled"

  @before-leave="beforeLeave"
  @leave="leaveEl"
  @after-leave="afterLeave"
  @leave-cancelled="leaveCancelled"
  :css="false">

 </transition>

<script>
  methods: {
     enterEl(el, done) {
       //entrance animation
       done();
    },
    leaveEl(el, done) {
      //exit animation
      done();
    },
  }
</script>
#+END_SRC
** Filters
The first thing to understand about filters is that they aren't replacements for methods, computed values, or watchers, because filters don't transform the data, just the output that the user sees.

#+BEGIN_SRC javascript
//global
Vue.filter('filterName', function(value) {
  return // thing to transform
});

//locally, like methods or computed
filters: {
  filterName(value) {
    return // thing to transform
  }
}
#+END_SRC
You can pass arguments:
#+BEGIN_SRC javascript
{{ data | filterName(arg1, arg2) }}
// arguments are passed in order after the value
filters: {
  filterName(value, arg1, arg2) {
    return //thing to transform
  }
}
#+END_SRC
Filters sounds like it would be good to filter a lot of data, but filters are rerun on every single update, so better to use computed, for values like these that should be cached

** MIXINS
It's a common situation: you have two components that are pretty
similar, they share the same basic functionality, but there's enough
that's different about each of them that you come to a crossroads: do
I split this component into two different components? Or do I keep one
component, but create enough variance with props that I can alter each
one?

A mixin allows you to encapsulate one piece of functionality so that
you can use it in different components throughout the application.

#+BEGIN_SRC html
<div id="app">
  <app-modal></app-modal>
  <hr />
  <app-tooltip></app-tooltip>
</div>

<script type="text/x-template" id="modal">
  <div>
    <h3>Let's trigger this here modal!</h3>
  	<button @click="toggleShow">
      <span v-if="isShowing">Hide child</span>
      <span v-else>Show child</span>
    </button>
  	<app-child v-if="isShowing" class="modal">
    	<button @click="toggleShow">Close</button>
  	</app-child>
  </div>
</script>
#+END_SRC

#+BEGIN_SRC javascript
const Child = {
  template: '#childarea'
};

const toggle = {/* common functionality between modal and  tooltip */
  data() {
    return {
      isShowing: false
    }
  },
  methods: {
    toggleShow() {
      this.isShowing = !this.isShowing;
    }
  }
}

const Modal = {
  template: '#modal',
  mixins: [toggle],
  components: {
    appChild: Child
  }
};

const Tooltip = {
  template: '#tooltip',
  mixins: [toggle],
  components: {
    appChild: Child
  }
};

new Vue({
  el: '#app',
  components: {
    appModal: Modal,
    appTooltip: Tooltip
  }
});
#+END_SRC
By default, mixins will be applied first, and the component will be applied second so that we can override it as necessary.

The component has the last say.

#+BEGIN_SRC javascript
//mixin
const hi = {
  mounted() {
    console.log('hello from mixin!')
  }
}

//vue instance or component
new Vue({
  el: '#app',
  mixins: [hi],
  mounted() {
    console.log('hello from Vue instance!')
  }
});

//Output in console
//> hello from mixin!
//> hello from Vue instance!
#+END_SRC

Another example that component overrides the mixin method.
#+BEGIN_SRC javascript
//mixin
const hi = {
  methods: {
    sayHello: function() {
      console.log('hello from mixin!')
    }
  },
  mounted() {
    this.sayHello()
  }
}

//vue instance or component
new Vue({
  el: '#app',
  mixins: [hi],
  methods: {
    sayHello: function() {
      console.log('hello from Vue instance!')
    }
  },
  mounted() {
    this.sayHello()
  }
})

// Output in console
//> hello from Vue instance!
//> hello from Vue instance!
#+END_SRC

** GLOBAL MIXINS

#+BEGIN_SRC javascript
Vue.mixin({
  mounted() {
    console.log('hello from mixin!')
  }
})

new Vue({
  ...
})

/* This console.log would now appear in every component */
#+END_SRC

Global mixins are literally applied to every single component. One use I can think of that makes sense is something like a plugin, where you may need to gain access to everything.

But still, the use case for them is extremely limited and they should be considered with great caution.

** Custom Directives
#+BEGIN_SRC html
<p v-tack>I will now be tacked onto the page</p>
#+END_SRC

#+BEGIN_SRC javascript
Vue.directive('tack', {
 bind(el, binding, vnode) {
    el.style.position = 'fixed'
  }
});
#+END_SRC

=v-example= - this will instantiate a directive, but doesn't accept any arguments. Without passing a value, this would not be very flexible, but you could still hang some piece of functionality off of the DOM element.

=v-example="value"= - this will pass a value into the directive, and the directive figures out what to do based off of that value.


=v-example:arg="value"= - this allows us to pass in an argument to the directive. In the example below, we're binding to a class, and we'd style it with an object, stored separately.
=v-example:arg.modifier="value"= - this allows us to use a modifier. The example below allows us to call =preventDefault()= on the click event.

=<button v-on:submit.prevent="onSubmit"></button>=

We have different hooks for binding like =v-bind=, =v-inserted=, =v-updated=, and [more](https://s3.amazonaws.com/media-p.slid.es/uploads/75854/images/3909041/custom-directives-flat.svg)

example
#+BEGIN_SRC html
  <div id="app">
    <p>Scroll down the page</p>
    <p v-tack="70">Stick me 70px from the top of the page</p>
  </div>
#+END_SRC

and its implementation
#+BEGIN_SRC javascript
  Vue.directive('tack', {
    bind(el, binding, vnode) {
      el.style.position = 'fixed'
      el.style.top = binding.value + 'px'
    }
  });
#+END_SRC

**Pass an argument**

#+BEGIN_SRC html
<p v-tack:left="70">I'll now be offset from the left instead of the top</p>
#+END_SRC

#+BEGIN_SRC javascript
Vue.directive('tack', {
  bind(el, binding, vnode) {
    el.style.position = 'fixed';
    const s = (binding.arg == 'left' ? 'left' : 'top');
    el.style[s] = binding.value + 'px';
  }
});
#+END_SRC

**More than one value**

#+BEGIN_SRC html
<p v-tack="{ top: '40', left: '100' }">
  Stick me 40px from the top of the page and 100px from the left of the page
</p>
#+END_SRC

#+BEGIN_SRC javascript
Vue.directive('tack', {
  bind(el, binding, vnode) {
    el.style.position = 'fixed';
    el.style.top = binding.value.top + 'px';
    el.style.left = binding.value.left + 'px';
  }
});
#+END_SRC
2

A real example

#+BEGIN_SRC javascript
Vue.directive('scroll', {
  inserted: function(el, binding) {
    let f = function(evt) {
      if (binding.value(evt, el)) {
        window.removeEventListener('scroll', f);
      }
    };
    window.addEventListener('scroll', f);
  },
});

// main app
new Vue({
  el: '#app',
  methods: {
   handleScroll: function(evt, el) {
    if (window.scrollY > 50) {
      TweenMax.to(el, 1.5, {
        y: -10,
        opacity: 1,
        ease: Sine.easeOut
      })
    }
    return window.scrollY > 100;
    }
  }
});
#+END_SRC

to use it

#+BEGIN_SRC html
<div class="box" v-scroll="handleScroll">
  <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. A atque amet harum aut ab veritatis earum porro praesentium ut corporis. Quasi provident dolorem officia iure fugiat, eius mollitia sequi quisquam.</p>
</div>
#+END_SRC

live [example](https://codepen.io/sdras/pen/5ca1e0c724d7d900603d8898b5551189)

** vuex

*WHAT* is it?
Centralized store for shared data and logic, even shared methods or async

*WHY* should we use it?
In a complex single page application, passing state between many
components, and especially deeply nested or sibling components, can
get complicated quickly. Having one centralized place to access your
data can help you stay organized.


*HOW*?
The initial set up in =store.js= would look something like this

#+BEGIN_SRC javascript
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)

export const store = new Vuex.Store({
  state: {
    key: value
  }
})
#+END_SRC

In our =main.js= file, we'd perform the following updates (updated lines highlighted):

#+BEGIN_SRC javascript
import Vue from 'vue';
import App from './App.vue';

import { store } from './store/store';/* added line */

new Vue({
  el: '#app',
  store, /* added line */
  template: '<App/>',
  components: { App }
});
#+END_SRC

*Getters*: will make values able to show statically in our
templates. In other words, getters can read the value, but not mutate
the state.

*Mutations* will allow us to update the state, but they will always be
*synchronous*. Mutations are the only way to change data in the state
in the store.

*Actions* will allow us to update the state, *asynchronously*, but
will use an existing mutation. This can be very helpful if you need to
perform a few different mutations at once in a particular order, or
reach out to a server.


Basic Abstract Example

#+BEGIN_SRC javascript
export const store = new Vuex.Store({
  state: {
    counter: 0
  },
  //showing things, not mutating state
  getters: {
    tripleCounter: state => {
      return state.counter * 3;
    }
  },
  //mutating the state
  //mutations are always synchronous
  mutations: {
    //showing passed with payload, represented as num
    increment: (state, num) => {
      state.counter += num;
    }
  },
  //commits the mutation, it's asynchronous
  actions: {
    // showing passed with payload, represented as asynchNum (an object)
    asyncIncrement: ({ commit }, asyncNum) => {
      setTimeout(() => {
        //the asyncNum objects could also just be static amounts
        commit('increment', asyncNum.by);
      }, asyncNum.duration);
    }
  }
})
#+END_SRC

To actually use it in our component
#+BEGIN_SRC html
<template>
  <div>
    <button @click="increment">increment</button>
    <button @click="incrementImmediately">increment immediately</button>
    <br> {{getValue}}
  </div>
</template>

<script>
export default {

  methods: {
    increment () {
      return this.$store.dispatch('asyncIncrement', {
        by: 99,
        duration: 1000,
      })
    },
    incrementImmediately () {
      this.$store.commit('increment', 88)
    }
  },
  computed: {
    getValue () {
      return this.$store.state.counter;
    },
    value() {
      return this.$store.getters.tripleCounter;/* using getters */
    }
  }
}
</script>
#+END_SRC

On the component itself, we would use =computed= for =getters= (this makes sense because the value is already computed for us), and =methods= with =commit= to access the =mutations=, and methods with =dispatch= for the =actions=:

# From Vue Doc
- All Vue components are also Vue instances, and so accept the same options object (except for a few root-specific options).

** Class and Style Bindings
Vue provides special enhancements when =v-bind= is used with =class= and =style=. In addition to strings, the expressions can also evaluate to objects or arrays.

*** Object Syntax

#+BEGIN_SRC html
<div v-bind:class="{ active: isActive }"></div>
#+END_SRC
=activle= is the name of a class, =isActive= is an expression

When =isActive= changes, the class list will be updated accordingly.


The bound object doesn’t have to be inline:

#+BEGIN_SRC html
<div v-bind:class="classObject"></div>
#+END_SRC

#+BEGIN_SRC javascript
data: {
  classObject: {
    active: true,
    'text-danger': false
  }
}
#+END_SRC

*** Array Syntax

We can pass an array to v-bind:class to apply a list of classes:
#+BEGIN_SRC html
  <div v-bind:class="[activeClass, errorClass]"></div>
#+END_SRC

#+BEGIN_SRC javascript
data: {
  activeClass: 'active',
  errorClass: 'text-danger'
}
#+END_SRC

Which will render:
#+BEGIN_SRC html
  <div class="active text-danger"></div>
#+END_SRC

Also possible

#+BEGIN_SRC html
<div v-bind:class="[{ active: isActive }, errorClass]"></div>
#+END_SRC

*** With Components

When you use the class attribute on a custom component, those classes
will be added to the component’s root element. Existing classes on
this element will not be overwritten.

** Binding Inline Styles

#+BEGIN_SRC html
<div :style="[{backgroundColor: '#eee'}, someCss]">
#+END_SRC

#+BEGIN_SRC javascript
  data () {
    return {
      someCss: {
        fontSize: '22px'
      }
    }
  },
#+END_SRC
# Conditional Rendering

#+BEGIN_SRC html
<h1 v-if="ok">Yes</h1>
<h1 v-else-if="maybe">Maybe</h1>
<h1 v-else>No</h1>
#+END_SRC
A =v-else= and =v-else-if= element must immediately follow a =v-if= element - otherwise it will not be recognized.


The final rendered result will not include the <template> element.
#+BEGIN_SRC html
<template v-if="ok">
  <h1>Title</h1>
  <p>Paragraph 1</p>
  <p>Paragraph 2</p>
</template>
#+END_SRC

** Controlling Reusable Elements with =key=

Consider this example

#+BEGIN_SRC html
<template v-if="loginType === 'username'">
  <label>Username</label>
  <input placeholder="Enter your username">
</template>
<template v-else>
  <label>Email</label>
  <input placeholder="Enter your email address">
</template>
#+END_SRC
switching the =loginType= in the code above will not erase what the user has already entered. Since both templates use the same elements, the =<input>= is not replaced - just its placeholder.


This isn’t always desirable though, so Vue offers a way for you to say, “These two elements are completely separate - don’t re-use them.” Add a =key= attribute with unique values:

#+BEGIN_SRC html
<template v-if="loginType === 'username'">
  <label>Username</label>
  <input placeholder="Enter your username" key="username-input">
</template>
<template v-else>
  <label>Email</label>
  <input placeholder="Enter your email address" key="email-input">
</template>
#+END_SRC
Note that the =<label>= elements are still efficiently re-used, because they don’t have key attributes.

** Array Change Detection

Vue wraps an observed array’s mutation methods so they will also trigger view updates. The wrapped methods are:
- =push()=
- =pop()=
- =shift()=
- =unshift()=
- =splice()=
- =sort()=
- =reverse()=

*** Caveats

Due to limitations in Javascript, Vue cannot detect the following changes to an array:

When you directly set an item with the index, e.g. =vm.items[indexOfItem] = newValue=
When you modify the length of the array, e.g. =vm.items.length = newLength=

To overcome caveat 1, both of the following will accomplish the same as =vm.items[indexOfItem] = newValue=, but will also trigger state updates in the reactivity system:
// Vue.set
=Vue.set(example1.items, indexOfItem, newValue)=
// Array.prototype.splice
=example1.items.splice(indexOfItem, 1, newValue)=
To deal with caveat 2, you can use splice:
=example1.items.splice(newLength)=

*** Object Change Detection Caveats

Vue does not allow dynamically adding new root-level reactive properties to an already created instance. However, it’s possible to add reactive properties to a nested object using the Vue.set(object, key, value) method. For example, given:

#+BEGIN_SRC javascript
var vm = new Vue({
  data: {
    userProfile: {
      name: 'Anika'
    }
  }
})
#+END_SRC
You could add a new age property to the nested userProfile object with:
=Vue.set(vm.userProfile, 'age', 27)=

You can also use the =vm.$set= instance method, which is an alias for the global =Vue.set=:
=this.$set(this.userProfile, 'age', 27)=

Sometimes you may want to assign a number of new properties to an existing object, for example using =Object.assign()= or =_.extend()=. In such cases, you should create a fresh object with properties from both objects. So instead of:
#+BEGIN_SRC javascript
Object.assign(this.userProfile, {
  age: 27,
  favoriteColor: 'Vue Green'
})
#+END_SRC
You would add new, reactive properties with:
#+BEGIN_SRC javascript
this.userProfile = Object.assign({}, this.userProfile, {
  age: 27,
  favoriteColor: 'Vue Green'
})
#+END_SRC

*** v-for with v-if

When they exist on the same node, v-for has a higher priority than v-if. That means the v-if will be run on each iteration of the loop separately. This can be useful when you want to render nodes for only some items, like below:

#+BEGIN_SRC html
<li v-for="todo in todos" v-if="!todo.isComplete">
  {{ todo }}
</li>
#+END_SRC


# Listening to Events

Vue provides event modifiers for v-on. Recall that modifiers are directive postfixes denoted by a dot.
- =.stop=
- =.prevent=
- =.capture=
- =.self=
- =.once=

#+BEGIN_SRC html
  <!-- the click event's propagation will be stopped -->
  <a v-on:click.stop="doThis"></a>
  <!-- the submit event will no longer reload the page -->
  <form v-on:submit.prevent="onSubmit"></form>
  <!-- modifiers can be chained -->
  <a v-on:click.stop.prevent="doThat"></a>
  <!-- just the modifier -->
  <form v-on:submit.prevent></form>
  <!-- use capture mode when adding the event listener -->
  <!-- i.e. an event targeting an inner element is handled here before being handled by that element -->
  <div v-on:click.capture="doThis">...</div>
  <!-- only trigger handler if event.target is the element itself -->
  <!-- i.e. not from a child element -->
  <div v-on:click.self="doThat">...</div>
#+END_SRC

**** Key Modifiers

When listening for keyboard events, we often need to check for common key codes. Vue also allows adding key modifiers for v-on when listening for key events:
<!-- only call vm.submit() when the keyCode is 13 -->
<input v-on:keyup.13="submit">

Here’s the full list of key modifier aliases:
- =.enter=
- =.tab=
- =.delete= (captures both “Delete” and “Backspace” keys)
- =.esc=
- =.space=
- =.up=
- =.down=
- =.left=
- =.right=

You can also define custom key modifier aliases via the global config.keyCodes object:
#+BEGIN_SRC javascript
// enable v-on:keyup.f1
Vue.config.keyCodes.f1 = 112
#+END_SRC

**** System Modifier Keys
You can use the following modifiers to trigger mouse or keyboard event listeners only when the corresponding modifier key is pressed:
=.ctrl=
=.alt=
=.shift=
=.meta=

** Form Input Bindings

v-model will ignore the initial value, checked or selected attributes found on any form elements. It will always treat the Vue instance data as the source of truth. You should declare the initial value on the Javascript side, inside the data option of your component.


*** MODIFIERs

**** .number
**** .trim
**** .lazy

By default, v-model syncs the input with the data after each input event (with the exception of IME composition as stated above). You can add the lazy modifier to instead sync after change events:
#+BEGIN_SRC html
<!-- synced after "change" instead of "input" -->
  <input v-model.lazy="msg" >
#+END_SRC

# Components

At a high level, components are custom elements that Vue’s compiler attaches behavior to. In some cases, they may also appear as a native HTML element extended with the special =is= attribute.

** DOM Template Parsing Caveats

When using the DOM as your template (e.g. using the el option to mount an element with existing content), you will be subject to some restrictions that are inherent to how HTML works,

A workaround is to use the is special attribute:
#+BEGIN_SRC javascript
<table>
  <tr is="my-row"></tr>
</table>
#+END_SRC
It should be noted that these limitations do not apply if you are using string templates from one of the following sources:

- =<script type="text/x-template">=
- Javascript inline template strings
- .vue components

Therefore, prefer using string templates whenever possible.

** Composing components
In Vue, the parent-child component relationship can be summarized as props down, events up. The parent passes data down to the child via props, and the child sends messages to the parent via events.

** Dyramic Props

If you want to pass all the properties in an object as props, you can use v-bind without an argument (v-bind instead of v-bind:prop-name). For example, given a todo object:
#+BEGIN_SRC javascript
todo: {
  text: 'Learn Vue',
  isComplete: false
}
#+END_SRC
Then:

#+BEGIN_SRC html
<todo-item v-bind="todo"></todo-item>
#+END_SRC

Will be equivalent to:

#+BEGIN_SRC html
<todo-item
  v-bind:text="todo.text"
  v-bind:is-complete="todo.isComplete">
  </todo-item>
#+END_SRC

** One-Way Data Flow

All props form a **one-way-down** binding between the child property and the parent one: when the parent property updates, it will flow down to the child, but not the other way around. This prevents child components from accidentally mutating the parent’s state, which can make your app’s data flow harder to understand.

In addition, every time the parent component is updated, all props in the child component will be refreshed with the latest value. This means you should not attempt to mutate a prop inside a child component.


There are usually two cases where it’s tempting to mutate a prop:
1. The =prop= is used to pass in an initial value; the child component wants to use it as a local data property afterwards.

2. The prop is passed in as a raw value that needs to be transformed.

The proper answer to these use cases are:

- Define a local data property that uses the prop’s initial value as its initial value:

#+BEGIN_SRC javascript
props: ['initialCounter'],
data: function () {
  return { counter: this.initialCounter } // counter doesn't react to =initialCounter= changes. If you need take the following approach
}
#+END_SRC

- Define a computed property that is computed from the prop’s value:

#+BEGIN_SRC javascript
props: ['size'],
computed: {
  normalizedSize: function () {
    return this.size.trim().toLowerCase() // totally reactive to =size= changes
  }
}
#+END_SRC

**Note that objects and arrays in Javascript are passed by reference, so if the prop is an array or object, mutating the object or array itself inside the child will affect parent state.**


*** Prop Validation

Instead of defining the props as an array of strings, you can use an object with validation requirements:

#+BEGIN_SRC javascript
Vue.component('example', {
  props: {
    // basic type check (=null= means accept any type)
    propA: Number,
    // multiple possible types
    propB: [String, Number],
    // a required string
    propC: {
      type: String,
      required: true
    },
    // a number with default value
    propD: {
      type: Number,
      default: 100
    },
    // object/array defaults should be returned from a
    // factory function
    propE: {
      type: Object,
      default: function () {
        return { message: 'hello' }
      }
    },
    // custom validator function
    propF: {
      validator: function (value) {
        return value > 10
      }
    }
  }
})
#+END_SRC

The type can be one of the following native constructors:
- =String=
- =Number=
- =Boolean=
- =Function=
- =Object=
- =Array=
- =Symbol=

In addition, type can also be a custom constructor function and the assertion will be made with an =instanceof= check.

When =prop= validation fails, Vue will produce a console warning (if using the development build). Note that =props= are validated before a component instance is created, **so within default or validator functions, instance properties such as from data, computed, or methods will not be available**.

** Non-Prop Attributes
A non-prop attribute is an attribute that is passed to a component, but does not have a corresponding prop defined.

While explicitly defined props are preferred for passing information to a child component, authors of component libraries can’t always foresee the contexts in which their components might be used. That’s why components can accept arbitrary attributes, which are added to the component’s root element.

For example, imagine we’re using a 3rd-party bs-date-input component with a Bootstrap plugin that requires a data-3d-date-picker attribute on the input. We can add this attribute to our component instance:

#+BEGIN_SRC html
  <bs-date-input data-3d-date-picker="true"></bs-date-input
#+END_SRC
And the =data-3d-date-picker="true"= attribute will automatically be added to the root element of =bs-date-input=.

*** Replacing/Merging with Existing Attributes

Imagine this is the template for bs-date-input:

#+BEGIN_SRC html
  <input type="date" class="form-control">
#+END_SRC

To specify a theme for our date picker plugin, we might need to add a specific class, like this:

#+BEGIN_SRC html
<bs-date-input
  data-3d-date-picker="true"
  class="date-picker-theme-dark"
></bs-date-input>
#+END_SRC
In this case, two different values for class are defined:

=form-control=, which is set by the component in its template
=date-picker-theme-dark=, which is passed to the component by its parent


For most attributes, the value provided to the component will replace the value set by the component. So for example, passing =type="large"= will replace =type="date"= and probably break it! Fortunately, the class and style attributes are a little smarter, so both values are merged, making the final value: =form-control date-picker-theme-dark=.

** Custom Events

*** Binding Native Events to Components

There may be times when you want to listen for a native event on the root element of a component. In these cases, you can use the .native modifier for v-on. For example:
<my-component v-on:click.native="doTheThing"></my-component>

*** =.sync=

The following
#+BEGIN_SRC html
<comp :foo.sync="bar"></comp>
#+END_SRC

is expanded into:
#+BEGIN_SRC html
<comp :foo="bar" @update:foo="val => bar = val"></comp>
#+END_SRC
For the child component to update foo‘s value, it needs to explicitly emit an event instead of mutating the prop:

=this.$emit('update:foo', newValue)=


*** Form Input Components using Custom Events

#+BEGIN_SRC html
<input v-model="something">
#+END_SRC

is syntactic sugar for:
#+BEGIN_SRC html
<input
  v-bind:value="something"
  v-on:input="something = $event.target.value">
#+END_SRC

When used with a component, it instead simplifies to:
#+BEGIN_SRC html

<custom-input
  :value="something"
  @input="value => { something = value }">
</custom-input>
#+END_SRC

So for a component to work with v-model, it should (these can be configured in 2.2.0+):
- accept a =value= prop
- emit an =input= event with the new value

#+BEGIN_SRC html
<template>
  <div>
    <input type="text" :value="value" @input="updateValue">
  </div>
</template>

<script>
export default {
  props: ["value"],
  methods: {
    updateValue(event) {
      this.$emit("input", event.target.value);
    },
  },
};
</script>
#+END_SRC
and to use the above component

#+BEGIN_SRC html
<template>
  <div id="app">
    <hello v-model="bar"></hello>
  </div>
</template>

<script>
import Hello from "./components/Hello";

export default {
  components: {
    Hello,
  },
  data() {
    return {
      bar: "blah blah",
    };
  },
  watch: {
    bar(newval) {
      console.log(=bar changed to ${newval}=);
    },
  },
};
</script>

#+END_SRC


Customizing Component =v-model=

**By default, =v-model= on a component uses =value= as the prop and =input= as the event**, but some input types such as checkboxes and radio buttons may want to use the value prop for a different purpose. Using the model option can avoid the conflict in such cases:

#+BEGIN_SRC javascript
Vue.component('my-checkbox', {
  model: {
    prop: 'checked',
    event: 'change'
  },
  props: {
    checked: Boolean,
    // this allows using the =value= prop for a different purpose
    value: String
  },
  // ...
})
#+END_SRC

#+BEGIN_SRC html
<my-checkbox v-model="foo" value="some value"></my-checkbox>
#+END_SRC
The above will be equivalent to:

#+BEGIN_SRC html
<my-checkbox
  :checked="foo"
  @change="val => { foo = val }"
  value="some value">
</my-checkbox>
#+END_SRC

*** Non Parent-Child Communication

Sometimes two components may need to communicate with one-another but they are not parent/child to each other. In simple scenarios, you can use an empty Vue instance as a central event bus:

#+BEGIN_SRC javascript
  var bus = new Vue()
  // in component A's method
  bus.$emit('id-selected', 1)
  // in component B's created hook
  bus.$on('id-selected', function (id) {
    // ...
  })
#+END_SRC
*** Content Distribution with Slots

Distributed content will be compiled in the parent scope.

*** Single slot

*** Named Slots

suppose we have an =app-layout= component with the following template:
#+BEGIN_SRC html
<div class="container">
  <header>
    <slot name="header"></slot>
  </header>
  <main>
    <slot></slot>
  </main>
  <footer>
    <slot name="footer"></slot>
  </footer>
</div>
#+END_SRC

Parent markup:


#+BEGIN_SRC html
<app-layout>
  <h1 slot="header">Here might be a page title</h1>
  <p>A paragraph for the main content.</p>
  <p>And another one.</p>
  <p slot="footer">Here's some contact info</p>
</app-layout>
#+END_SRC

The rendered result will be:

#+BEGIN_SRC html
<div class="container">
  <header>
    <h1>Here might be a page title</h1>
  </header>
  <main>
    <p>A paragraph for the main content.</p>
    <p>And another one.</p>
  </main>
  <footer>
    <p>Here's some contact info</p>
  </footer>
</div>
#+END_SRC

*** Scoped Slots

A scoped slot is a special type of slot that functions as a reusable template (that can be passed data to) instead of already-rendered-elements.
In a child component, pass data into a slot as if you are passing =props= to a component:

hello component
#+BEGIN_SRC html
<template>
  <div>
    <slot color="red" text="sample text">
    </slot>
  </div>
</template>

<script>
  export default {};
</script>
#+END_SRC

app.vue
#+BEGIN_SRC html
<template>
  <div>
    <hello>
      <template slot-scope="jafar">
        <span>hello from parent</span>
        <br>
        <span :style="{ color: jafar.color }"> {{jafar.text}} </span>
      </template>
    </hello>
  </div>
</template>

<script>
import Hello from "./components/Hello";

export default {
  components: {
    Hello,
  },
};

</script>
#+END_SRC

Another example

#+BEGIN_SRC html
<my-awesome-list :items="items">
  <!-- scoped slot can be named too -->
  <li
    slot="item"
    slot-scope="props"
    class="my-fancy-item">
    {{ props.text }}
  </li>
</my-awesome-list>
#+END_SRC

And the template for the list component:

#+BEGIN_SRC html
<ul>
  <slot name="item"
    v-for="item in items"
    :text="item.text">
    <!-- fallback content here -->
  </slot>
</ul>
#+END_SRC

**** Destructuring

scope-slot‘s value is in fact a valid Javascript expression that can appear in the argument position of a function signature. This means in supported environments (in single-file components or in modern browsers) you can also use ES2015 destructuring in the expression:
#+BEGIN_SRC html
<child>
  <span slot-scope="{ text }">{{ text }}</span>
</child>
#+END_SRC

** Dynamic Components

You can use the same mount point and dynamically switch between multiple components using the reserved <component> element and dynamically bind to its is attribute:

#+BEGIN_SRC html
var vm = new Vue({
  el: '#example',
  data: {
    currentView: 'home'
  },
  components: {
    home: { /* ... */ },
    posts: { /* ... */ },
    archive: { /* ... */ }
  }
})
<component v-bind:is="currentView">
  <!-- component changes when vm.currentView changes! -->
</component>
<!-- If you prefer, you can also bind directly to component objects -->
var Home = {
  template: '<p>Welcome home!</p>'
}
var vm = new Vue({
  el: '#example',
  data: {
    currentView: Home
  }
})
#+END_SRC

*** keep-alive

If you want to keep the switched-out components in memory so that you can preserve their state or avoid re-rendering, you can wrap a dynamic component in a <keep-alive> element:
#+BEGIN_SRC html
<keep-alive>
  <component :is="currentView">
    <!-- inactive components will be cached! -->
  </component>
</keep-alive>
#+END_SRC

** Authoring Reusable Components


The API for a Vue component comes in three parts - props, events, and slots:

Props allow the external environment to pass data into the component

Events allow the component to trigger side effects in the external environment

Slots allow the external environment to compose the component with extra content.

With the dedicated shorthand syntaxes for v-bind and v-on, the intents can be clearly and succinctly conveyed in the template:

#+BEGIN_SRC html
<my-component :foo="baz" :bar="qux" @event-a="doThis" @event-b="doThat">

  <img slot="icon" src="...">
  <p slot="main-text">Hello!</p>
</my-component>
#+END_SRC

*** Child Component Refs

#+BEGIN_SRC html
<div id="parent">
  <user-profile ref="profile"></user-profile>
</div>
#+END_SRC

#+BEGIN_SRC javascript
var parent = new Vue({ el: '#parent' })
// access child component instance
var child = parent.$refs.profile
#+END_SRC

*** Async Components
https://vuejs.org/v2/guide/components.html#Async-Components

in large applications, we may need to divide the app into smaller
chunks and only load a component from the server when it’s actually
needed. to make that easier, vue allows you to define your component
as a factory function that asynchronously resolves your component
definition. vue will only trigger the factory function when the
component actually needs to be rendered and will cache the result for
future re-renders. for example

#+BEGIN_SRC javascript
vue.component('async-example', function (resolve, reject) {
  settimeout(function () {
    // pass the component definition to the resolve callback
    resolve({
      template: '<div>i am async!</div>'
    })
  }, 1000)
})
#+END_SRC

you can also return a promise in the factory function, so with webpack 2 + es2015 syntax you can do:

#+BEGIN_SRC javascript
vue.component(
  'async-webpack-example',
  // the =import= function returns a =Promise=.
  () => import('./my-async-component')
)
#+END_SRC

When using local registration, you can also directly provide a function that returns a Promise:

#+BEGIN_SRC javascript
new Vue({
  // ...
  components: {
    'my-component': () => import('./my-async-component')
  }
})
#+END_SRC

** Recursive Components


Components can recursively invoke themselves in their own
template. However, they can only do so with the name option:

=name: 'unique-name-of-my-component'=

When you register a component globally using Vue.component, the global
ID is automatically set as the component’s name option.

#+BEGIN_SRC html
Vue.component('unique-name-of-my-component', {
  // ...
})
#+END_SRC

If you’re not careful, recursive components can also lead to infinite
loops:

#+BEGIN_SRC javascript
name: 'stack-overflow',
template: '<div><stack-overflow></stack-overflow></div>'
#+END_SRC
A component like the above will result in a “max stack size exceeded” error, so make sure recursive invocation is conditional (i.e. uses a =v-if= that will eventually be false).

** Inline Templates

When the inline-template special attribute is present on a child
component, the component will use its inner content as its template,

#+BEGIN_SRC html
<my-component inline-template>
  <div>
    <p>These are compiled as the component's own template.</p>
    <p>Not parent's transclusion content.</p>
  </div>
</my-component>
#+END_SRC

** Cheap Static Components with v-once

Rendering plain HTML elements is very fast in Vue, but sometimes you
might have a component that contains a lot of static content. In these
cases, you can ensure that it’s only evaluated once and then cached by
adding the =v-once= directive to the root element, like this:

#+BEGIN_SRC javascript
Vue.component('terms-of-service', {
  template: `
    <div v-once>
      <h1>Terms of Service</h1>
      ... a lot of static content ...
    </div>
  `
})
#+END_SRC

** Transition
** mixin

** Under The Hood
Every component instance has a corresponding watcher instance, which
records any properties “touched” during the component’s render as
dependencies. Later on when a dependency’s setter is triggered, it
notifies the watcher, which in turn causes the component to re-render.

Vue does not allow dynamically adding new root-level reactive
properties to an already created instance. However, it’s possible to
add reactive properties to a nested object using the =Vue.set(object, key, value)= method:
=Vue.set(vm.someObject, 'b', 2)=

You can also use the =vm.$set= instance method, which is an alias to the global =Vue.set=:
=this.$set(this.someObject, 'b', 2)=
