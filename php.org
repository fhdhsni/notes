Modern PHP by Josh Lockhart

- Provisioning tools like: =Ansible=, =Chef=, and =Puppet=.

- To import a function, change =use= to =use func=:

- *Traits*:
  1. Traits behave like classes but look like interfaces. Which one are
     they? Neither and both.

  2. A trait is a partial class implementation (i.e., constants,
     properties, and methods) that can be mixed into one or more existing
     PHP classes. Traits work double duty: they say what a class can do
     (like an interface), and they provide a modular implementation (like
     a class). They enable modular implementations that can be injected
     into otherwise unrelated classes. Traits also encourage code reuse.

  3. Both namespaces and traits are imported with the use keyword. Where
     they are imported is different. We import namespaces, classes,
     interfaces, functions, and constants outside of a class
     definition. We import traits inside a class definition. The
     difference is subtle but important.

  4. The PHP interpreter copies and pastes traits into class definitions
     at compile time, and it does not protect against incompatibilities
     introduced by this action. If your PHP trait assumes a class
     property or method exists (that is not defined in the trait itself),
     be sure those properties and methods exist in the appropriate classes.
- *Generators*
  1. Generators are simple iterators.
  #+BEGIN_SRC php
  function getRows($file) {
    $handle = fopen($file, 'rb');
    if ($handle === false) {
      throw new Exception();
    }
    while (feof($handle) === false) {
      yield fgetcsv($handle);
    }
    fclose($handle);
  }
  foreach (getRows('data.csv') as $row) {
    print_r($row);
  }
  #+END_SRC

- *Closures*

Don’t forget, PHP closures are objects. Each closure instance has its own internal state that
is accessible with the $this keyword just like any other PHP object. A closure object’s
default state is pretty boring; it has a magic __invoke() method and a bindTo() method.
That’s it.

#+BEGIN_SRC php
<?php
$closure = function ($name) {
  return sprintf('Hello %s', $name);
};
echo $closure("Josh");
// Outputs --> "Hello Josh"
#+END_SRC

- We can invoke the =$closure= variable because the variable’s value is
  a closure, and closure objects implement the =\__invoke()= magic
  method. PHP looks for and calls the =__invoke()= method whenever =()=
  follows a variable name.

- Attach State
#+BEGIN_SRC php
<?php
function enclosePerson($name) {
    return function ($doCommand) use ($name) {
        return sprintf('%s, %s', $name, $doCommand);
    };
}
// Enclose "Clay" string in closure
$clay = enclosePerson('Clay');
// Invoke closure with command
echo $clay('get me sweet tea!');
// Outputs --> "Clay, get me sweet tea!"
#+END_SRC

- Zend OPcache
sample php.ini configuration file
#+BEGIN_SRC
    opcache.validate_timestamps = 1 // "0" in production
    opcache.revalidate_freq = 0
    opcache.memory_consumption = 64
    opcache.interned_strings_buffer = 16
    opcache.max_accelerated_files = 4000
    opcache.fast_shutdown = 1
#+END_SRC

Be careful if the opcache.validate_timestamps INI directive is
false. When this setting is false, the Zend OPcache does not know
about changes to your PHP scripts, and you must manually clear Zend
OPcache’s bytecode cache before it recognizes changes to your PHP
files. This setting is good for production but inconvenient for
development. You can enable automatic cache revalidation with these
php.ini configuration settings:

#+BEGIN_SRC
    opcache.validate_timestamps=1
    opcache.revalidate_freq=0
#+END_SRC

Configure the Server to use its own PHP INI configuration file
#+BEGIN_SRC
php -S localhost:8000 -c app/config/php.ini
#+END_SRC

What is a *front controller*?  A front controller is a single PHP file
to which all HTTP requests are forwarded (via .htaccess files or
rewrite rules). The front-controller PHP file is responsible for
routing the request and dispatching the appropriate PHP code.

The PHP built-in server mitigates this omission with router scripts. The router script is
executed before every HTTP request. If the router script returns false, the static asset
referenced by the current HTTP request URI is returned. Otherwise, the output of the
router script is returned as the HTTP response body. In other words, if you use a router
script you’re effectively hardcoding the same functionality as an .htaccess file.
Using a router script is easy. Just pass the PHP script file path as a an argument when you
start up the PHP built-in server:
#+BEGIN_SRC
php -S localhost:8000 router.php
#+END_SRC

- The *PHP-FIG* is a group of PHP framework representatives who,
  according to the PHP-FIG website, “talk about the commonalities
  between our projects and find ways we can work together.”

- *Autoloading*

PHP frameworks work together via autoloading. Autoloading is the
process by which a PHP class is automatically located and loaded
on-demand by the PHP interpreter during runtime.

- *PSR*
The PHP-FIG has published five recommendations as of this book’s
publication:

- PSR-1: Basic code style
  + *PHP tags*
    You must surround your PHP code with either the <?php ?> or <?= ?> tags. You must
    not use any other PHP tag syntax.
  + *Encoding*
    All PHP files must be encoded with the UTF-8 character set without a byte order mark
    (BOM). This sounds complicated, but your text editor or IDE can do this for you
    automatically.
  + *Objective*
    A single PHP file can either define symbols (a class, trait, function, constant, etc.) or
    perform an action that has side effects (e.g., create output or manipulate data). A PHP
    file should not do both. This is a simple task and requires only a little foresight and
    planning on your part.
  + *Autoloading*
    Your PHP namespaces and classes must support the PSR-4 autoloader standard. All you
    have to do is choose appropriate names for your PHP symbols and make sure their
    definition files are in the expected location. We’ll chat about PSR-4 soon.
  + *Class names*
    Your PHP class names must use the common CamelCase format. This format is also
    called TitleCase. Examples are CoffeeGrinder, CoffeeBean, and PourOver.
  + *Constant names*
    Your PHP constants must use all uppercase characters. They may use underscores to
    separate words if necessary. Examples are WOOT, LET_OUR_POWERS_COMBINE, and
    GREAT_SCOTT.
  + *Method names*
    Your PHP method names must use the common camelCase format. This means the
    method name’s first character is lowercase, and the first letter of each subsequent word
    in the method name is uppercase. Examples are phpIsAwesome, iLoveBacon, and
    tennantIsMyFavoriteDoctor.
- PSR-2: Strict code style
  + Implement PSR-1
  + Indentation: Four space
  + Files and lines
    Your PHP files must use Unix linefeed (LF)
    endings, must end with a single blank line, and must not include a
    trailing ?> PHP tag. Each line of code should not exceed 80
    characters. Ultimately, each line of code must not exceed 120
    characters. Each line must not have trailing white space. This
    sounds like a lot of work, but it’s really not. Most code editors
    can automatically wrap code to a specific width, strip trailing
    whitespace, and use Unix line endings. All of these should happen
    automatically with little to no thought on your part.

    Why does it "must end with a single blank line"?  Because that’s
    how the POSIX standard defines a line: A sequence of zero or more
    non- <newline> characters plus a terminating <newline> character.
    Therefore, lines not ending in a newline character aren't
    considered actual lines. That's why some programs have problems
    processing the last line of a file if it isn't newline terminated.
  + Keywords: type all PHP keywords in lowercase.
  + Namespaces: Each namespace declaration must be followed by one
    blank line. Likewise, when you import or alias namespaces with the
    use keyword, you must follow the block of use declarations with
    one blank line.
  + Methods
    #+BEGIN_SRC php
    <?php
    namespace Animals;

    class StrawNeckedIbis
    {
        public function flapWings($numberOfTimes = 3, $speed = 'fast')
        {
            // Method definition body
        }
    }
    #+END_SRC

  + Visibility You must declare a visibility for each class property
    and method. A visibility is one of =public= , =protected=, or
    =private=; If you declare a class property or method as =abstract=
    or =final=, the =abstract= and =final= qualifiers must appear before the
    visibility. If you declare a property or method as =static=, the
    =static= qualifier must appear after the visibility:

    #+BEGIN_SRC php
    <?php
    namespace Animals;
    class StrawNeckedIbis
    {
        // Static property with visibility
        public static $numberOfBirds = 0;

        // Method with visibility
        public function __construct()
        {
            static::$numberOfBirds++;
        }
    }
    #+END_SRC

  + Control structures
    All control structure keywords must be followed by a single space
    character.
    #+BEGIN_SRC php
    <?php
    $gorilla = new \Animals\Gorilla;
    $ibis = new \Animals\StrawNeckedIbis;
    if ($gorilla->isAwake() === true) {
        do {
            $gorilla->beatChest();
        } while ($ibis->isAsleep() === true);
        $ibis->flyAway();
    }
    #+END_SRC
  +
- PSR-3: Logger interface

- PSR-4: Autoloading The fourth PHP-FIG recommendation describes a
  standardized autoloader strategy. An autoloader is a strategy for
  finding a PHP class, interface, or trait and loading it into the PHP
  interpreter on-demand at runtime. PHP components and frameworks that
  support the PSR-4 autoloader standard can be located by and loaded
  into the PHP interpreter with only one autoloader. This is a big
  deal given the modern PHP ecosystem’s affinity for many
  interoperable components.
  An autoloader is a strategy for finding a PHP class, interface, or
  trait and loading it into the PHP interpreter on-demand at runtime,
  without explicitly including files as the example does.

* Components
  the Composer dependency manager automatically generates a PSR-compatible autoloader for all of our project’s PHP
  components. Composer effectively abstracts away dependency management and
  autoloading.

* Good Practices

** Sanitize, Validate, and Escape

   - A few external sources are:
     1- =$_GET=
     2- =$_POST=
     3- =$_REQUEST=
     4- =$_COOKIE=
     5- =$argv=
     6- =php://stdin=
     7- =php://input=
     8- =file_get_contents()=
     9- Remote databases
     10- Remote APIs
     11- Data from your clients

*** Sanitize Input
- Sanitize input with the =htmlentities()= function
#+BEGIN_SRC php
<?php
$input = '<p><script>alert("You won the Nigerian lottery!");</script></p>';
echo htmlentities($input, ENT_QUOTES, 'UTF-8');
#+END_SRC
- SQL queries
#+BEGIN_SRC php
<?php
$string = "\nIñtërnâtiônàlizætiøn\t";
$safeString = filter_var(
    $string,
    FILTER_SANITIZE_STRING,
    FILTER_FLAG_STRIP_LOW|FILTER_FLAG_ENCODE_HIGH
);
#+END_SRC

*** Validate Data
**** Validate Email
#+BEGIN_SRC php
<?php
$input = 'john@example.com';
$isEmail = filter_var($input, FILTER_VALIDATE_EMAIL);

if ($isEmail !== false) {
    echo "Success";
} else {
    echo "Fail";
}
#+END_SRC

*** Escape Output

** Passwords
*** Never Know User Passwords
*** Never Restrict User Passwords
*** Never Email User Passwords
*** Hash User Passwords with bcrypt

Register
#+BEGIN_SRC php
 // Validate password
 $password = filter_input(INPUT_POST, 'password');

 if (!$password || mb_strlen($password) < 8) {
     throw new Exception('Password must contain 8+ characters');
 }
 // Create password hash
 $passwordHash = password_hash(
     $password,
     PASSWORD_DEFAULT,
     ['cost' => 12]
 );
 if ($passwordHash === false) {
     throw new Exception('Password hash failed');
 }
#+END_SRC

Login
#+BEGIN_SRC php
<?php
session_start();
try {
    // Get email address from request body
    $email = filter_input(INPUT_POST, 'email');
    // Get password from request body
    $password = filter_input(INPUT_POST, 'password');
    // Find account with email address (THIS IS PSUEDO-CODE)
    $user = User::findByEmail($email);
    // Verify password with account password hash
    if (password_verify($password, $user->password_hash) === false) {
        throw new Exception('Invalid password');
    }
    // Re-hash password if necessary (see note below)
    $currentHashAlgorithm = PASSWORD_DEFAULT;
    $currentHashOptions = array('cost' => 15);
    $passwordNeedsRehash = password_needs_rehash(
        $user->password_hash,
        $currentHashAlgorithm,
        $currentHashOptions
    );
    if ($passwordNeedsRehash === true) {
        // Save new password hash (THIS IS PSUEDO-CODE)
        $user->password_hash = password_hash(
            $password,
            $currentHashAlgorithm,
            $currentHashOptions
        );
        $user->save();
    }
    // Save login status to session
    $_SESSION['user_logged_in'] = 'yes';
    $_SESSION['user_email'] = $email;
    // Redirect to profile page
    header('HTTP/1.1 302 Redirect');
    header('Location: /user-profile.php');
} catch (Exception $e) {
    header('HTTP/1.1 401 Unauthorized');
    echo $e->getMessage();
}
#+END_SRC


    You should hash user passwords. Do not encrypt user
    passwords. Encryption and hashing are not synonymous. Encryption is a
    two-way algorithm, meaning what is encrypted can later be decrypted by
    design. Hashing is a one-way algorithm. Hashed data cannot be reverted
    to its original form, and identical data always produces the same hash
    values.

**** Hash
**** bcrypt
     Bcrypt is a Blowfish-based hashing algorithm which is commonly used
     for password hashing because of its potentially expensive key setup
     phase. A Bcrypt hash has the following structure:

     =$2a$(2 chars work)$(22 chars salt)(31 chars hash)=

     The reason that the key setup phase can be potentially expensive is
     because it is run 2^work times.

**** Salt
**** Peper
**** Encrypt
**** Dictionary Attack
**** Rainbow Table

*** Dates, Times, and Time Zones
#+BEGIN_SRC php
<?php
// Create DateTime instance
$datetime = new DateTime('2014-01-01 14:00:00');
// Create two weeks interval
$interval = new DateInterval('P2W');
// Modify DateTime instance
$datetime->add($interval);

echo $datetime->format('Y-m-d H:i:s');

#+END_SRC

An inverted DateInterval class
#+BEGIN_SRC php
  $dateStart = new \DateTime();
  $dateInterval = \DateInterval::createFromDateString('-1 day');
  $datePeriod = new \DatePeriod($dateStart, $dateInterval, 3);

  foreach ($datePeriod as $date) {
      echo $date->format('Y-m-d'), PHP_EOL;
  }
  // This outputs:
  // 2014-12-08
  // 2014-12-07
  // 2014-12-06
  // 2014-12-05
#+END_SRC

=DateTimeZone= usage
#+BEGIN_SRC php
<?php
$timezone = new DateTimeZone('America/New_York');
$datetime = new \DateTime('2014-08-20', $timezone);
$datetime->setTimezone(new DateTimeZone('Asia/Hong_Kong'));
#+END_SRC


=DatePeriod= class usage
#+BEGIN_SRC php
<?php
$start = new DateTime();
$interval = new DateInterval('P2W');
$period = new DatePeriod($start, $interval, 3);

foreach ($period as $nextDateTime) {
    echo $nextDateTime->format('Y-m-d H:i:s'), PHP_EOL;
}
#+END_SRC

=DatePeriod= class usage with options
#+BEGIN_SRC php
<?php
$start = new DateTime();
$interval = new DateInterval('P2W');
$period = new DatePeriod(
    $start,
    $interval,
    3,
    DatePeriod::EXCLUDE_START_DATE
);

foreach ($period as $nextDateTime) {
    echo $nextDateTime->format('Y-m-d H:i:s'), PHP_EOL;
}
#+END_SRC

The =nesbot/carbon= Component is usefull for working with time stuffs.

*** Databases
The PDO Extension
This is exactly why PHP provides the native PDO extension. PDO (or PHP
data objects) is a collection of PHP classes that communicate with
many different SQL databases via a single user interface. Database
implementations are abstracted away. Instead, we can write and execute
database queries with a single interface regardless of the particular
database system we happen to be using at the time.

#+BEGIN_SRC php
  try {
      $pdo = new PDO(
          'mysql:host=127.0.0.1;dbname=foobar;port=3306;charset=utf8', // DSN:  data source name,
          'USERNAME',
          'PASSWORD'
      );
  } catch (PDOException $e) {
      // Database connection failed
      echo "Database connection failed";
      exit;
  }
#+END_SRC

Keep your database credentials secret

#+BEGIN_SRC php
  <?php
  include('../settings.php');
  $pdo = new PDO(
      sprintf(
          'mysql:host=%s;dbname=%s;port=%s;charset=%s',
          $settings['host'],
          $settings['name'],
          $settings['port'],
          $settings['charset']
      ),
      $settings['username'],
      $settings['password']
  );

  $sql = 'SELECT id FROM users WHERE email = :email';
  $statement = $pdo->prepare($sql);
  $email = filter_input(INPUT_GET, 'email');
  $statement->bindValue(':email', $email); //  automatically sanitizes the $email value

  $sql = 'SELECT email FROM users WHERE id = :id';
  $statement = $pdo->prepare($sql);
  $userId = filter_input(INPUT_GET, 'id');
  $statement->bindValue(':id', $userId, PDO::PARAM_INT); // PDO::PARAM_INT tells PDO that the bound data is an integer.
#+END_SRC

**** Query Results

If you are executing =INSERT=, =UPDATE=, or =DELETE= statements,
invoke the =execute()= method and you’re done. If you execute a
=SELECT= statement, you probably expect the database to return
matching records. You can fetch query results with the prepared
statement’s =fetch()=, =fetchAll()=, =fetchColumn()=, and
=fetchObject()= methods.  The =PDOStatement= instance’s =fetch()= method
returns the next row from the result set.

#+BEGIN_SRC php
<?php
// Build and execute SQL query
$sql = 'SELECT id, email FROM users WHERE email = :email';
$statement = $pdo->prepare($sql);
$email = filter_input(INPUT_GET, 'email');
$statement->bindValue(':email', $email, PDO::PARAM_INT);
$statement->execute();
// Iterate results
while (($result = $statement->fetch(PDO::FETCH_ASSOC)) !== false) {
    echo $result['email'];
}
#+END_SRC

=PDO::FETCH_ASSOC=: Prompts the =fetch()= or =fetchAll()= method to
return an associative array. The array keys are database column names.

=PDO::FETCH_NUM=: Prompts the =fetch()= or =fetchAll()= method to
return a numeric array. The array keys are the numeric index of
database columns in your query result.

=PDO::FETCH_BOTH=: Prompts the =fetch()= or =fetchAll()= method to
return an array that contains both associative and numeric array
keys. This is a combination of =PDO::FETCH_ASSOC= and
=PDO::FETCH_NUM.=

=PDO::FETCH_OBJ=: Prompts the =fetch()= or =fetchAll()= method to
return an object whose properties are database column names.

**** Transactions

The PDO extension also supports transactions. A transaction is a set
of database statements that execute atomically. In other words, a
transaction is a collection of SQL queries that are either all
executed successfully or not executed at all. Transaction atomicity
encourages data consistency, safety, and durability. A nice side
effect of transactions is improved performance, because you are
effectively queuing multiple queries to be executed together at one
time. Remember, a transaction is all or nothing.

#+BEGIN_SRC php
require 'settings.php';
// PDO connection
try {
    $pdo = new PDO(
        sprintf(
            'mysql:host=%s;dbname=%s;port=%s;charset=%s',
            $settings['host'],
            $settings['name'],
            $settings['port'],
            $settings['charset']
        ),
        $settings['username'],
        $settings['password']
    );
} catch (PDOException $e) {
    // Database connection failed
    echo "Database connection failed";
    exit;
}
// Statements
$stmtSubtract = $pdo->prepare('
    UPDATE accounts
    SET amount = amount - :amount
    WHERE name = :name
');
$stmtAdd = $pdo->prepare('
    UPDATE accounts
    SET amount = amount + :amount
    WHERE name = :name
');
// Start transaction
$pdo->beginTransaction();
// Withdraw funds from account 1
$fromAccount = 'Checking';
$withdrawal = 50;
$stmtSubtract->bindParam(':name', $fromAccount);
$stmtSubtract->bindParam(':amount', $withDrawal, PDO::PARAM_INT);
$stmtSubtract->execute();
// Deposit funds into account 2
$toAccount = 'Savings';
$deposit = 50;
$stmtAdd->bindParam(':name', $toAccount);
$stmtAdd->bindParam(':amount', $deposit, PDO::PARAM_INT);
$stmtAdd->execute();
// Commit transaction
$pdo->commit();
#+END_SRC

** Unicode and UTF-8

*ASCII*: which was able to represent every character using a number
 between 32 and 127. Space was 32, the letter “A” was 65, etc. This
 could conveniently be stored in 7 bits. Most computers in those days
 were using 8-bit bytes, so not only could you store every possible
 ASCII character, but you had a whole bit to spare. Codes below 32
 were called unprintable. They were used for control characters, like
 7 which made your computer beep.

*Unicode*: In Unicode, a letter maps to something called a code point
 which is still just a theoretical concept. How that code point is
 represented in memory or on disk is a whole nuther story.  Every
 platonic letter in every alphabet is assigned a magic number by the
 Unicode consortium which is written like this: U+0639.  This magic
 number is called a code point. The U+ means “Unicode” and the numbers
 are hexadecimal. U+0639 is the Arabic letter Ain. The English letter
 A would be U+0041. We haven’t yet said anything about how to store
 this in memory or represent it in an email message.

*Encodings*: That’s where encodings come in. In UTF-8, every code
 point from 0-127 is stored in a single byte. Only code points 128 and
 above are stored using 2, 3, in fact, up to 6 bytes.  So far I’ve
 told you three ways of encoding Unicode. The traditional
 store-it-in-two-byte methods are called UCS-2 (because it has two
 bytes) or UTF-16 (because it has 16 bits), and you still have to
 figure out if it’s high-endian UCS-2 or low-endian UCS-2. And there’s
 the popular new UTF-8 standard which has the nice property of also
 working respectably if you have the happy coincidence of English text
 and braindead programs that are completely unaware that there is
 anything other than ASCII.

** Streams
1. Open communication.
2. Read data.
3. Write data.
4. Close communication.

Every stream has a scheme and a target. We specify the scheme and
target in the stream’s identifier using this familiar format:
=<scheme>://<target>=
The =<scheme>= identifies the stream’s wrapper. The =<target>= identifies the stream data
source.
#+BEGIN_SRC php
<?php
$json = file_get_contents(
    'http://api.flickr.com/services/feeds/photos_public.gne?format=json'
);
#+END_SRC

Don’t be fooled by what appears to be a traditional website URL. The
=file_get_contents()= function’s string argument is actually a stream
identifier. The http scheme prompts PHP to use the HTTP stream
wrapper. The argument’s remainder is the stream target. The stream
target looks like a traditional website URL only because that’s what
the HTTP stream wrapper expects. This may not be true for other stream
wrappers.

*** The =php://= stream wrapper

=php://stdin=
This read-only PHP stream exposes data provided via standard input. For example, a
PHP script can use this stream to receive information piped into the script on the
command line.

=php://stdout=
This PHP stream lets you write data to the current output buffer. This stream is write-
only and cannot be read or seeked.

=php://memory=
This PHP stream lets you read and write data to system memory. The downside to this
PHP stream is that available memory is finite. It’s safer to use the php://temp stream
instead.

=php://temp=
This PHP stream acts just like =php://memory=, except that when available memory is
gone, PHP instead writes to a temporary file.

*** Stream Context
Some PHP streams accept an optional set of parameters, or a stream
context, to customize the stream’s behavior. Different stream wrappers
expect different context parameters. You create a stream context with
the =stream_context_create()= function.

#+BEGIN_SRC php
<?php
$requestBody = '{"username":"josh"}';
$context = stream_context_create(array(
    'http' => array(
        'method' => 'POST',
        'header' => "Content-Type: application/json;charset=utf-8;\r\n" .
        "Content-Length: " . mb_strlen($requestBody),
        'content' => $requestBody
    )
));
$response = file_get_contents('https://my-api.com/users', false, $context);
#+END_SRC

*** Stream Filters

#+BEGIN_SRC php
<?php
$handle = fopen('data.txt', 'rb');
stream_filter_append($handle, 'string.toupper');
while(feof($handle) !== true) {
    echo fgets($handle); // <-- Outputs all uppercase characters
}
fclose($handle);
#+END_SRC
Also does the same thing

#+BEGIN_SRC php
<?php
$handle = fopen('php://filter/read=string.toupper/resource=data.txt', 'rb');

while(feof($handle) !== true) {
    echo fgets($handle); // <-- Outputs all uppercase characters
}
fclose($handle);
#+END_SRC

*** A custom Filter
#+BEGIN_SRC php
class DirtyWordsFilter extends php_user_filter
{
    /**
     * @param resource $in Incoming bucket brigade
     * @param resource $out Outgoing bucket brigade
     * @param int $consumed Number of bytes consumed
     * @param bool $closing Last bucket brigade in stream?
    */
    public function filter($in, $out, &$consumed, $closing)
    {
        $words = array('grime', 'dirt', 'grease');
        $wordData = array();
        foreach ($words as $word) {
            $replacement = array_fill(0, mb_strlen($word), '*');
            $wordData[$word] = implode('', $replacement);
        }
        $bad = array_keys($wordData);
        $good = array_values($wordData);
        // Iterate each bucket from incoming bucket brigade
        while ($bucket = stream_bucket_make_writeable($in)) {
            // Censor dirty words in bucket data
            $bucket->data = str_replace($bad, $good, $bucket->data);
        }
        // Increment total data consumed
        $consumed += $bucket->datalen;
        // Send bucket to downstream brigade
        stream_bucket_append($out, $bucket);
        return PSFS_PASS_ON;
    }
}


stream_filter_register('dirty_words_filter', 'DirtyWordsFilter');
$handle = fopen('data.txt', 'rb');
stream_filter_append($handle, 'dirty_words_filter');
while (feof($handle) !== true) {
    echo fgets($handle); // <-- Outputs censored text
}
fclose($handle);
#+END_SRC

** Errors and Exceptions
You can only throw an instance of class =Exception= (or a subclass of
=Exception=). PHP provides these built-in =Exception= subclasses:
=Exception=
=ErrorException=

The Standard PHP Library (SPL) supplements PHP’s built-in exceptions
with these additional =Exception= subclasses:

=LogicException=
=BadFunctionCallException=
=BadMethodCallException=
=DomainException=
=InvalidArgumentException=
=LengthException=
=OutOfRangeException=
=RuntimeException=
=OutOfBoundsException=
=OverflowException=
=RangeException=
=UnderflowException=
=UnexpectedValueException=

*** Catch multiple thrown exceptions
#+BEGIN_SRC php
  <?php
  try {
      throw new Exception('Not a PDO exception');
      $pdo = new PDO('mysql://host=wrong_host;dbname=wrong_name');
  } catch (PDOException $e) {
      // Handle PDO exception
      echo "Caught PDO exception";
  } catch (Exception $e) {
      // Handle all other exceptions
      echo "Caught generic exception";
  } finally {
      // Always do this
      echo "Always do this";
  }
#+END_SRC

Set global exception handler
#+BEGIN_SRC php
  <?php
  // Register your exception handler
  set_exception_handler(function (Exception $e) {
      // Handle and log exception
  });
  // Your code goes here...
  // Restore previous exception handler
  restore_exception_handler();
#+END_SRC
*** Errors
The difference between errors and exceptions is subtle. Errors are
often triggered when a PHP script cannot fundamentally run as expected
for whatever reason (e.g., there is a syntax mistake). It is also
possible to trigger your own errors with the =trigger_error()= function
and handle them with a custom error handler, but it is better to use
exceptions when writing userland code. Unlike errors, PHP exceptions
can be thrown and caught at any level of your PHP
application. Exceptions provide more contextual information than PHP
errors. And you can extend the topmost Exception class with your own
custom exception subclasses. Exceptions and a good logger like Monolog
are a far more versatile solution than PHP errors. However, modern PHP
developers must anticipate and handle both PHP errors and PHP
exceptions.


- Always turn on error reporting.
- Display errors during development.
- Do not display errors during production.
- Log errors during development and production

Here are error-reporting =php.ini= settings for development:
#+BEGIN_SRC
; Display errors
display_startup_errors = On
display_errors = On
; Report all errors
error_reporting = -1
; Turn on error logging
log_errors = On
#+END_SRC

Here are error-reporting php.ini settings for production:
#+BEGIN_SRC
; DO NOT display errors
display_startup_errors = Off
display_errors = Off
; Report all errors EXCEPT notices
error_reporting = E_ALL & ~E_NOTICE
; Turn on error logging
log_errors = On
#+END_SRC

**** Error Handlers
An error handler, like an exception handler, is anything that is
=callable= (e.g., a function or class method). It is your responsibility
to =die()= or =exit()= inside of your error handler. If you don’t manually
terminate the PHP script inside your error handler, the PHP script
will continue executing from where the error occurred. You register
your global error handler with the =set_error_handler()=, and you pass
it an argument that is callable:

Set global error handler

#+BEGIN_SRC php
<?php
// Register error handler
set_error_handler(function ($errno, $errstr, $errfile, $errline) {
    if (!(error_reporting() & $errno)) {
        // Error is not specified in the error_reporting
        // setting, so we ignore it.
        return;
    }

    throw new ErrorException($errstr, $errno, 0, $errfile, $errline);
});
// Your code goes here...
// Restore previous error handler
restore_error_handler();
#+END_SRC

** Deploy
*** update and create nonroot user
  =apt-get update && apt-get upgrade=
- create user
  + debian: =adduser foo && usermod -a -G sudo foo= # you can see groups of a give user via =groups foo=
  + centos: =adduser foo && passwd foo && usermod -a -G wheel deploy=
-
*** SSH Key-Pair Authentication
In basic terms, you create a pair of “keys” on your local machine. One
key is private (this stays on your local machine), and one key is
public (this goes on the remote server). They are called a key pair
because messages encrypted with the public key can be decrypted only
by the related private key.  When you log in to the remote machine
using SSH key-pair authentication, the remote machine creates a random
message, encrypts it with your public key, and sends it to your local
machine. Your local machine decrypts the message with your private key
and returns the decrypted message to the remote server. The remote
server then validates the decrypted message and grants you access to
the server. This is a dramatic simplification, but you get the point.

You can create an SSH key-pair on your local machine with this
command: =ssh-keygen=, Public key, must be copied onto your new
server. We can copy the public key with the =scp= command:
+ =scp ~/.ssh/id_rsa.pub deploy@123.456.78.90:=
+ =mkdir ~/.ssh=
+ =touch ~/.ssh/authorized_keys= # This file will contain a list of public keys that are allowed to log into this remote server.
+ =cat ~/id_rsa.pub >> ~/.ssh/authorized_keys=
+ =chown -R deploy:deploy ~/.ssh=
+ =chmod 700 ~/.ssh=
+ =chmod 600 ~/.ssh/authorized_keys=
You can only ssh into your remote server without a password from the
local machine that has your private key!

*** Disable Passwords and Root Login
edit =/etc/ssh/sshd_config= and do
#+BEGIN_SRC
PermitRootLogin no
PasswordAuthentication no
#+END_SRC
restart ssh service
#+BEGIN_SRC
# Ubuntu
sudo service ssh restart
# CentOS
sudo systemctl restart sshd.service
#+END_SRC

Also implement a firewall in addition to my previous
instructions. Ubuntu users can use =UFW=.  CentOS users can use
=iptables=.
*** PHP-FPM (PHP FastCGI Process Manager)
    PHP-FPM (PHP FastCGI Process Manager) is software that manages a pool
    of related PHP processes that receive and handle requests from a web
    server like nginx. The PHP- FPM software creates one master process
    (usually run by the operating system’s root user) that controls how
    and when HTTP requests are forwarded to one or more child
    processes. The PHP-FPM master process also controls when child PHP
    processes are created (to answer additional web application traffic)
    and destroyed (if they are too old or no longer necessary). Each
    PHP-FPM pool process lives longer than a single HTTP request, and it
    can handle 10, 50, 100, 500, or more HTTP requests.
**** CGI
     In computing, Common Gateway Interface (CGI) offers a standard
    protocol for web servers to execute programs that execute like Console
    applications (also called Command-line interface programs) running on
    a server that generates web pages dynamically. Such programs are known
    as CGI scripts or simply as CGIs. The specifics of how the script is
    executed by the server are determined by the server. In the common
    case, a CGI script executes at the time a request is made and
    generates HTML.[1] In brief, the CGI program receives HTTP forms data
    via Unix/Linux standard input, and most other data (such as URL paths,
    URL arguments, and HTTP header data) via well-known Unix/Linux process
    environment variables.
**** FastCGI
     FastCGI is a _binary protocol_ (*binary protocol* is a protocol
     which is intended to be read by a machine rather than a human
     being, as opposed to a plain text protocol such as IRC, SMTP, or
     HTTP. Binary protocols have the advantage of terseness, which
     translates into speed of transmission and interpretation.) for
     interfacing interactive programs with a web server. FastCGI is a
     variation on the earlier Common Gateway Interface (CGI);
     FastCGI's main aim is to reduce the overhead associated with
     interfacing the web server and CGI programs, allowing a server to
     handle more web page requests at once.


**** Installation
#+BEGIN_SRC
sudo apt-get install python-software-properties;
sudo add-apt-repository ppa:ondrej/php5-5.6;
sudo apt-get update;
sudo apt-get install php5-fpm php5-cli php5-curl \
php5-gd php5-json php5-mcrypt php5-mysqlnd;
#+END_SRC

**** Config
On Ubuntu, the primary PHP-FPM cofiguration file is
=/etc/php5/fpm/php-fpm.conf=. On CentOS, the primary PHP-FPM
configuration file is /etc/php-fpm.conf

Change to respective field to be like
#+BEGIN_SRC
emergency_restart_threshold = 10
emergency_restart_interval = 1m
#+END_SRC

**** Pool Config
A PHP-FPM pool is a collection of related PHP child processes. One PHP
application typically has its own PHP- FPM pool.
The config file is located somewere like =/etc/php/7.2/fpm/pool.d/www.conf=

*** nginx
#+BEGIN_SRC
sudo add-apt-repository ppa:nginx/stable;
sudo apt-get update;
sudo apt-get install nginx;
#+END_SRC

***** Virtual Host

Next, we’ll configure an nginx /virtual host/ for our PHP application. A
virtual host is a group of settings that tell nginx our application’s
domain name, where the PHP application lives on the filesystem, and
how to forward HTTP requests to the PHP-FPM pool.

#+BEGIN_SRC
mkdir -p /home/deploy/apps/example.com/current/public;
mkdir -p /home/deploy/apps/logs;
chmod -R +rx /home/deploy;
#+END_SRC

nginx virtual host configuration assumes your PHP application has a
=public/= directory; this is the virtual host document root.

#+BEGIN_SRC
nginx virtual host settings live inside a server {} block. Here is the complete virtual host
configuration file:
server {
    listen 80;
    server_name example.com;
    index index.php;
    client_max_body_size 50M;
    error_log /home/deploy/apps/logs/example.error.log;
    access_log /home/deploy/apps/logs/example.access.log;
    root /home/deploy/apps/example.com/current/public;

    location / {
        try_files $uri $uri/ /index.php$is_args$args;
    }

    location ~ \.php {
        try_files $uri =404;
        fastcgi_split_path_info ^(.+\.php)(/.+)$;
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        fastcgi_param SCRIPT_NAME $fastcgi_script_name;
        fastcgi_index index.php;
        fastcgi_pass 127.0.0.1:9000;
    }
}
#+END_SRC

On Ubuntu, we must symlink the virtual host configuration file into
the /etc/nginx/sites- enabled/ directory with this command:

#+BEGIN_SRC
sudo ln -s /etc/nginx/sites-available/example.conf \
/etc/nginx/sites-enabled/example.conf;
#+END_SRC

There are also two location blocks. These tell nginx how to handle
HTTP requests that match specific URL patterns. The first =location /
{}= block uses a =try_files= directive that looks for real files that
match the request URI. If a file is not found, it looks for a
directory that matches the request URI. If a directory is not found,
it rewrites the HTTP request URI to =/index.php= and appends the query
string if available. The rewritten URL, or any request whose URI ends
with =.php=, is managed by the location =~ \.php {}= block.  The
=location ~ \.php {}= block forwards HTTP requests to our PHP-FPM
pool.  Remember how we set up our PHP-FPM pool to listen for requests
on port 9000? This block forwards PHP requests to port 9000, and the
PHP-FPM pool takes over.  Note: There are a few extra lines in the
=location ~ \.php {}= block. These lines prevent potential remote code
execution attacks.  On Ubuntu, we must symlink the virtual host
configuration file into the /etc/nginx/sites-enabled/ directory with
this command:
#+BEGIN_SRC
sudo ln -s /etc/nginx/sites-available/example.conf \
/etc/nginx/sites-enabled/example.conf;
#+END_SRC

*** Automate Server Provisioning
Some popular server provisioning tools are:
    Puppet
    Chef
    Ansible
    SaltStack
** Tuning
*** The php.ini File
use =composer global require psecio/iniscan= for some advice.

Use =Apache Bench= or =Seige= to stress-test your PHP applications
under production-like conditions.

*** Zend OPcache
Let’s first examine how a typical PHP script is processed for every
HTTP request. First, nginx forwards an HTTP request to PHP-FPM, and
PHP-FPM assigns the request to a child PHP process. The PHP process
finds the appropriate PHP scripts, it reads the PHP scripts, it
compiles the PHP scripts into an opcode (or bytecode) format, and it
executes the compiled PHP opcode to generate an HTTP response. The
HTTP response is returned to nginx, and nginx returns the HTTP
response to the HTTP client. This is a lot of overhead for every HTTP
request.

php.ini for OPcache
#+BEGIN_SRC
opcache.memory_consumption = 64
opcache.interned_strings_buffer = 16
opcache.max_accelerated_files = 4000
opcache.validate_timestamps = 1
opcache.revalidate_freq = 0
opcache.fast_shutdown = 1
#+END_SRC

=opcache.interned_strings_buffer = 16=: The amount of memory (in
megabytes) used to store interned strings. What the heck is an
interned string? That was my first question, too. The PHP interpreter,
behind the scenes, detects multiple instances of identical strings and
stores the string in memory once and uses pointers whenever the string
is used again. This saves memory. By default, PHP’s string interning
is isolated in each PHP process. This setting lets all PHP- FPM pool
processes store their interned strings in a shared buffer so that
interned strings can be referenced across multiple PHP-FPM pool
processes. This saves even more memory. The default value is 4 MB, but
I prefer to bump this to 16 MB.

=opcache.fast_shutdown = 1=: This prompts the opcache to use a faster
shutdown sequence by delegating object deconstruction and memory
release to the Zend Engine memory manager.  Documentation is lacking
for this setting. All you need to know is turn this on.

*** File Uploads
#+BEGIN_SRC
file_uploads = 1
upload_max_filesize = 10M
max_file_uploads = 3
#+END_SRC

If you accept very large file uploads, be sure your web server is
configured accordingly.  You may need to adjust the
client_max_body_size setting in your nginx virtual host configuration
in addition to your php.ini file.

*** Max Execution Time
The max_execution_time setting in your php.ini file determines the
maximum length of time that a single PHP process can run before
terminating. By default, this is set to 30 seconds. You don’t want PHP
processes running for 30 seconds. We want our applications to be
super-fast (measured in milliseconds). I recommend you change this to
5 seconds: =max_execution_time = 5=

*** Session Handling
PHP’s default session handler can slow down larger applications
because it stores session data on disk. This creates unnecessary file
I/O that takes time. Instead, offload session handling to a faster
in-memory data store like Memcached or Redis. This has the added
benefit of future scalability. If your session data is stored on disk,
this prevents you from scaling PHP across additional servers. If your
session data is, instead, stored on a central Memcached or Redis data
store, it can be accessed from any number of distributed PHP- FPM
servers.

#+BEGIN_SRC
session.save_handler = 'memcached'
session.save_path = '127.0.0.2:11211'
#+END_SRC

*** Output Buffering
Networks are more efficient when sending more data in fewer chunks,
rather than less data in more chunks. In other words, deliver content
to your visitor’s web browser in fewer pieces to reduce the total
number of HTTP requests.  This is why you enable PHP output
buffering. By default, PHP’s output buffer is enabled (except on the
command line). PHP’s output buffer collects up to 4,096 bytes before
flushing its contents back to the web server. Here are my recommended
php.ini settings:

#+BEGIN_SRC php
output_buffering = 4096
implicit_flush = false
#+END_SRC
** Automate Deployment
- Make it simple
- Make it predictable
- Make it reversible

*** Capistrano
=gem install capistrano=
=cap install= in project's topmost dir

Example directory structure
#+BEGIN_SRC
/
    home/
        deploy/
            apps/
                my_app/
                    current/
                    releases/
                        release1/
                        release2/
                        release3/
                        release4/
                        release5/
#+END_SRC

Other deployment tools
- =Deployer=
- =Magallanes=
- =Rocketeer=

** Testing
** Profiling
- =Xdebug= is a popular PHP profiling tool written by Derick Rethans,
  but it should only be used as a profiler during development because
  it consumes a lot of system resources to analyze your
  application. Xdebug profiler results are not human-readable, so
  you’ll need an application to parse and display the
  results. KCacheGrind, WinCacheGrind and WebGrind are good applications for
  visualizing Xdebug profiler results.

#+BEGIN_SRC
xdebug.profiler_enable = 0
xdebug.profiler_enable_trigger = 1
xdebug.profiler_output_dir = /path/to/profiler/results
#+END_SRC

By =xdebug.profiler_enable_trigger = 1= we instructs Xdebug to run
on-demand. We can activate Xdebug profiling per-request by adding the
XDEBUG_PROFILE=1 query parameter to any of our PHP application’s
URLs. When Xdebug detects this query parameter, it profiles the
current request and generates a report in the output directory
specified by the xdebug.profiler_output_dir setting.



- =XHProf= is a popular PHP profiler written by Facebook. It is intended
  to be run during development and production. XHProf’s profiler
  results are also not human-readable, but Facebook provides a
  companion web application called XHGUI to visualize and compare
  profiler results. I’ll talk more about XHGUI later in this chapter.

#+BEGIN_SRC
extension=xhprof.so
extension=mongo.so
#+END_SRC

* Tips
You can find your PHP extensions directory with the =php-config
--extension-dir= or =php -i | grep extension_dir= commands.

** What is an IoC Container in Laravel?

An IoC container is basically just a “box” to resolve specific objects
out of. So when you want an instance of an object that has
dependencies, the IoC container will ensure that the objects are
created for you so you don’t have to manually set it up.

An IoC container also allows you to bind an implementation to an
interface. This means you can easily switch out an implementation if
your application requires it to be different without changing your
code outside of the container.

That’s basically all an IoC container is. It’s just away of storing
how an object should be resolved and then allowing you to resolve it
whenever you need an instance of it.
