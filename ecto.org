- Mostly from ecto documentation

* add ecto
1) generate necessities
   #+BEGIN_SRC
   mix ecto.gen.repo -r Friends.Repo
   #+END_SRC
2) checkout configuration at ~config/config.exs~
   #+BEGIN_SRC elixir
     config :friends, Friends.Repo,
       database: "friends_repo",
       username: "user",
       password: "pass",
       hostname: "localhost"
   #+END_SRC
3) ~lib/friends/repo.ex~
   #+BEGIN_SRC elixir
     defmodule Friends.Repo do
       use Ecto.Repo,
         otp_app: :friends,
         adapter: Ecto.Adapters.Postgres
     end
   #+END_SRC
   + ~otp_app~ tells Ecto which Elixir application it can look for
     database configuration in
4) start the repo process in ~lib/friends/application.ex~
   #+BEGIN_SRC elixir
     def start(_type, _args) do
       children = [
         Friends.Repo,
       ]
   #+END_SRC
5) add this to ~config/config.exs~
   #+BEGIN_SRC elixir
   config :friends, ecto_repos: [Friends.Repo]
   #+END_SRC
   This tells our application about the repo, which will allow us to
   run commands such as ~mix ecto.create~

* Setting up the database
- create the database
  #+BEGIN_SRC
  mix ecto.create
  #+END_SRC
- create a migration
  #+BEGIN_SRC elixir
  mix ecto.gen.migration create_people
  #+END_SRC
  generates a new migration file in ~priv/repo/migrations~
  #+BEGIN_SRC elixir
    defmodule Friends.Repo.Migrations.CreatePeople do
      use Ecto.Migration

      def change do
        create table(:people) do
          add(:first_name, :string)
          add(:last_name, :string)
          add(:age, :integer)
        end
      end
    end
  #+END_SRC
  NOTE: The naming convention for tables in Ecto databases is to use a
  pluralized name.

- run the migration to create the table
  #+BEGIN_SRC
  mix ecto.migrate
  #+END_SRC
  if you you made any mistake you can run ~mix ecto.rollback~

* Creating the schema
- The schema is an Elixir representation of data from our database.
- Schemas are commonly associated with a database table, however they
  can be associated with a database view as well
  #+BEGIN_SRC elixir
    defmodule Friends.Person do
      use Ecto.Schema

      schema "people" do            # database name
        field :first_name, :string
        field :last_name, :string
        field :age, :integer
      end
    end
  #+END_SRC
  + we’re telling Ecto that the ~Friends.Person~ schema maps to the
    ~people~ table in the database
  + We’ve called this schema ~Person~ because the naming convention in
    Ecto for schemas is a singularized name.
  + in iex
    #+BEGIN_SRC elixir
      iex(1)> person = %Friends.Person{}
      %Friends.Person{
        __meta__: #Ecto.Schema.Metadata<:built, "people">,
        age: nil,
        first_name: nil,
        id: nil,
        last_name: nil
      }
    #+END_SRC

* Inserting data
- We can insert a new record into our ~people~ table with this code:
  #+BEGIN_SRC elixir
  person = %Friends.Person{}
  Friends.Repo.insert(person)
  {:ok,
    %Friends.Person{
      __meta__: #Ecto.Schema.Metadata<:loaded, "people">,
      age: nil, first_name: nil, id: 1, last_name: nil
    }
  }
  # or
  {:ok, person} = Friends.Repo.insert(person)
  #+END_SRC
* Validating changes
- For this, Ecto has [[https://hexdocs.pm/ecto/Ecto.Changeset.html][changesets]]
  + how to use it
    1. filter and cast input
       #+BEGIN_SRC elixir
         import Ecto.Changeset

         params = %{"title" => "So What", "index" => "1", "duration" => 180, "foo" => "LOL"}

         changeset =
           %Track{}
           |> cast(params, [:title, :index, :duration])
       #+END_SRC
    2. validate
       #+BEGIN_SRC elixir
         changeset =
           validate_required(changeset, [:title, :index])
           |> validate_number(:index, greater_than: 0)
       #+END_SRC
    3. capture errors
       #+BEGIN_SRC elixir
         # see if it works
         case Repo.insert(changeset) do
           {:ok, track} -> IO.puts "Track #{track.name} successfully added"
           {:error, changeset} -> IO.puts changeset.errors
         end
       #+END_SRC

- sample
  #+BEGIN_SRC elixir
    defmodule Friends.Person do
      use Ecto.Schema

      schema "people" do
        field(:first_name, :string)
        field(:last_name, :string)
        field(:age, :integer)
      end


      # This changeset takes a `person` and a set of `params`, which are to be
      # the changes to apply to this person
      def changeset(person, params \\ %{}) do
        person
        |> Ecto.Changeset.cast(params, [:first_name, :last_name, :age])
        |> Ecto.Changeset.validate_required([:first_name, :last_name])
      end
    end
  #+END_SRC
- ~Ecto.Changeset.cast(person, params, [:first_name, :last_name, :age])~
  + it's ~cast(data, params, permitted, opts \\ [])~
  + Casting tells the changeset what parameters are allowed to be
    passed through in this changeset, and anything not in the list
    will be ignored.
- ~Ecto.Changeset.validate_required([:first_name, :last_name])~
  + it's ~validate_required(changeset, fields, opts \\ [])~
  + says that, for this changeset, we expect ~first_name~ and ~last_name~
    to have values specified

    with error
    #+BEGIN_SRC elixir
      iex(9)> person = %Friends.Person{}
      %Friends.Person{
        __meta__: #Ecto.Schema.Metadata<:built, "people">,
        age: nil,
        first_name: nil,
        id: nil,
        last_name: nil
      }

      iex(10)> changeset = Friends.Person.changeset(person, %{})
      #Ecto.Changeset<
        action: nil,
        changes: %{},
        errors: [
        first_name: {"can't be blank", [validation: :required]},
        last_name: {"can't be blank", [validation: :required]}
        ],
        data: #Friends.Person<>,
        valid?: false
      >

      iex(11)> {:error, changeset} = Friends.Repo.insert(changeset)
      {:error,
       #Ecto.Changeset<
         action: :insert,
         changes: %{},
         errors: [
         first_name: {"can't be blank", [validation: :required]},
         last_name: {"can't be blank", [validation: :required]}
         ],
         data: #Friends.Person<>,
         valid?: false
       >
      }

      iex(14)> changeset.errors
      [
        first_name: {"can't be blank", [validation: :required]},
        last_name: {"can't be blank", [validation: :required]}
      ]
    #+END_SRC

    valid changeset
    #+BEGIN_SRC elixir
      iex> person = %Friends.Person{}
      %Friends.Person{
        __meta__: #Ecto.Schema.Metadata<:built, "people">,
        age: nil,
        first_name: nil,
        id: nil,
        last_name: nil
      }

      iex> changeset = Friends.Person.changeset(person, %{first_name: "Ryan", last_name: "Bigg"})
      #Ecto.Changeset<
        action: nil,
        changes: %{first_name: "Ryan", last_name: "Bigg"},
        errors: [],
        data: #Friends.Person<>,
        valid?: true
      >

      iex(17)> changeset.valid?
      true

      iex> Friends.Repo.insert(changeset)

      10:02:59.746 [debug] QUERY OK db=3.9ms queue=1.9ms
      INSERT INTO "people" ("first_name","last_name") VALUES ($1,$2) RETURNING "id" ["Ryan", "Bigg"]
      {:ok,
       %Friends.Person{
         __meta__: #Ecto.Schema.Metadata<:loaded, "people">,
         age: nil,
         first_name: "Ryan",
         id: 3,
         last_name: "Bigg"
       }}
    #+END_SRC

  + NOTE: ~changeset.valid?~ will not check constraints (such as
    ~uniqueness_constraint~). For that, you will need to attempt to do
    an insertion and check for errors from the database. It’s for this
    reason it’s best practice to try inserting data and validate the
    returned tuple from ~Friends.Repo.insert~ to get the correct errors,
    as prior to insertion the changeset will only contain validation
    errors from the application itself.
* queries
1. construct the query
2. execute that query against the database by passing the query to the
   repository
** Fetching a single record
- build the query
  ~Friends.Person |> Ecto.Query.first~
  will generate an ~Ecto.Query~
  #+BEGIN_SRC
  #Ecto.Query<from p in Friends.Person, order_by: [asc: p.id], limit: 1>
  #+END_SRC

  We could construct this query ourselves
  #+BEGIN_SRC elixir
  require Ecto.Query
  Ecto.Query.from p in Friends.Person, order_by: [asc: p.id], limit: 1
  #+END_SRC
- execute the query
  #+BEGIN_SRC elixir
  iex> Friends.Person |> Ecto.Query.first |> Friends.Repo.one

  %Friends.Person{__meta__: #Ecto.Schema.Metadata<:loaded>,
  age: 28, first_name: "Ryan", id: 1, last_name: "Bigg"}
  #+END_SRC
  or get the last one
  #+BEGIN_SRC elixir
  iex> Friends.Person |> Ecto.Query.last |> Friends.Repo.one

  %Friends.Person{__meta__: #Ecto.Schema.Metadata<:loaded>,
  age: 26, first_name: "Jane", id: 3, last_name: "Smith"}
  #+END_SRC
  The ~Ecto.Repo.one~ function will only return a struct if there is
  one record in the result from the database. If there is more than
  one record returned, an ~Ecto.MultipleResultsError~ exception will be
  thrown.

** Fetching all records
#+BEGIN_SRC elixir
iex> Friends.Person |> Friends.Repo.all
#+END_SRC
** Fetch a single record based on ID
#+BEGIN_SRC elixir
iex> Friends.Person |> Friends.Repo.get(1)
%Friends.Person{__meta__: #Ecto.Schema.Metadata<:loaded>,
 age: 28, first_name: "Ryan", id: 1, last_name: "Bigg"}
#+END_SRC
** Fetch a single record based on a specific attribute
- If we want to get a record based on something other than the ~id~
  attribute, we can use ~get_by~:
  #+BEGIN_SRC elixir
    iex> Friends.Person |> Friends.Repo.get_by(first_name: "Ryan")

    %Friends.Person{__meta__: #Ecto.Schema.Metadata<:loaded>,
                    age: 28, first_name: "Ryan", id: 1, last_name: "Bigg"}
  #+END_SRC
** Filtering results
- If we want to get multiple records matching a specific attribute, we
  can use ~where~:
  #+BEGIN_SRC elixir
  Friends.Person |> Ecto.Query.where(last_name: "Smith") |> Friends.Repo.all

  [%Friends.Person{__meta__: #Ecto.Schema.Metadata<:loaded>, age: 27,
  first_name: "John", id: 2, last_name: "Smith"},

  %Friends.Person{__meta__: #Ecto.Schema.Metadata<:loaded>, age: 26,
  first_name: "Jane", id: 3, last_name: "Smith"}]
  #+END_SRC
  the generated query is
  #+BEGIN_SRC
  #Ecto.Query<from p in Friends.Person, where: p.last_name == "Smith">
  #+END_SRC
  which means we can get the same result with
  #+BEGIN_SRC
  Ecto.Query.from(p in Friends.Person, where: p.last_name == "Smith") |> Friends.Repo.all
  #+END_SRC
  with both syntax we have to pin (^) the variables
  #+BEGIN_SRC elixir
    iex> last_name = "Smith"
    iex> Friends.Person |> Ecto.Query.where(last_name: ^last_name) |> Friends.Repo.all

    # Or:

    iex> last_name = "Smith"
    iex> Ecto.Query.from(p in Friends.Person, where: p.last_name == ^last_name) |> Friends.Repo.all
  #+END_SRC
  The pin operator instructs the query builder to use parameterised
  SQL queries protecting against SQL injection.

** Composing Ecto queries
   #+BEGIN_SRC elixir
     query = Friends.Person |> Ecto.Query.where(last_name: "Smith")

     query = query |> Ecto.Query.where(first_name: "Jane")

     #Ecto.Query<
                   from p in Friends.Person, where: p.last_name == "Smith", where: p.first_name == "Jane">
   #+END_SRC
** Updating records
- Updating records in Ecto requires us to first fetch a record from
  the database. We then create a changeset from that record and the
  changes we want to make to that record, and then call the
  ~Ecto.Repo.update~ function.
  + fetch
    #+BEGIN_SRC
    person = Friends.Person |> Ecto.Query.first |> Friends.Repo.one
    #+END_SRC
  + build a changeset
    #+BEGIN_SRC
    changeset = Friends.Person.changeset(person, %{age: 29})
    #+END_SRC
    We need to build a changeset because if we just create a new
    ~Friends.Person~ struct with the new age, Ecto wouldn’t be able to
    know that the age has changed without inspecting the database
  + update
    #+BEGIN_SRC
    iex> Friends.Repo.update(changeset)
    {:ok,
    %Friends.Person{__meta__: #Ecto.Schema.Metadata<:loaded>, age: 29,
    first_name: "Ryan", id: 1, last_name: "Bigg"}}
    #+END_SRC
** Deleting records
- Similar to updating, we must first fetch a record from the database
  and then call ~Friends.Repo.delete~ to delete that record:
  #+BEGIN_SRC elixir
  iex> person = Friends.Repo.get(Friends.Person, 1)
  iex> Friends.Repo.delete(person)
  #=> {:ok,
  %Friends.Person{__meta__: #Ecto.Schema.Metadata<:deleted>, age: 29,
  first_name: "Ryan", id: 2, last_name: "Bigg"}}

  #+END_SRC
===================
* Ecto
** Ecto.Repo
- repositories are wrappers around the data store. Via the repository,
  we can create, update, destroy and query existing entries. A
  repository needs an adapter and credentials to communicate to the
  databas

** Ecto.Schema
- schemas are used to map any data source into an Elixir struct. We
  will often use them to map tables into Elixir data but that’s one of
  their use cases and not a requirement for using Ecto

** Ecto.Changeset
- changesets provide a way for developers to filter and cast external
  parameters, as well as a mechanism to track and validate changes
  before they are applied to your data

** Ecto.Query
- written in Elixir syntax, queries are used to retrieve information
  from a given repository. Queries in Ecto are secure, avoiding common
  problems like SQL Injection, while still being composable, allowing
  developers to build queries piece by piece instead of all at once
  #+BEGIN_SRC elixir
    import Ecto.Query, only: [from: 2]

    query = from u in User,
      where: u.age > 18 or is_nil(u.email),
      select: u

    # Returns %User{} structs matching the query
    Repo.all(query)
  #+END_SRC
  In the example above we relied on our schema but queries can also be
  made directly against a table by giving the table name as a
  string. In such cases, the data to be fetched must be explicitly
  outlined:
  #+BEGIN_SRC elixir
    query = from u in "users",
              where: u.age > 18 or is_nil(u.email),
              select: %{name: u.name, age: u.age}

    # Returns maps as defined in select
    Repo.all(query)
  #+END_SRC

- Queries are defined and extended with the from macro. The supported
  keywords are:
  #+BEGIN_SRC
  :distinct
  :where
  :order_by
  :offset
  :limit
  :lock
  :group_by
  :having
  :join
  :select
  :preload
  #+END_SRC
- When writing a query, you are inside Ecto’s query syntax. In order
  to access params values or invoke Elixir functions, you need to use
  the ^ operator, which is overloaded by Ecto:
  #+BEGIN_SRC elixir
    def min_age(min) do
      from u in User, where: u.age > ^min
    end
  #+END_SRC

* Associations
- Ecto supports defining associations on schemas:

  create ~comments~ table
  #+BEGIN_SRC elixir
    defmodule Friends.Repo.Migrations.CreateComments do
      use Ecto.Migration

      def change do
        create table(:comments) do
          add(:post_id, references(:posts))
          add(:body, :text)
          timestamps()
        end
      end
    end
  #+END_SRC
  create ~posts~ table
  #+BEGIN_SRC elixir
    defmodule Friends.Repo.Migrations.CreatePosts do
      use Ecto.Migration

      def change do
        create table(:posts) do
          add(:title, :string)
          add(:body, :text)
          timestamps()
        end
      end
    end
  #+END_SRC
  create ~Post~ schema
  #+BEGIN_SRC elixir
    defmodule Friends.Post do
      use Ecto.Schema

      schema "posts" do
        field(:title)
        field(:body)
        has_many(:comments, Friends.Comment)

        timestamps()
      end
    end
  #+END_SRC
  create ~Comment~ schema
  #+BEGIN_SRC elixir
  defmodule Friends.Post do
    use Ecto.Schema

    schema "posts" do
      field(:title)
      field(:body)
      has_many(:comments, Friends.Comment)

      timestamps()
    end
  end
  #+END_SRC
- The difference between ~has_one/3~ and ~belongs_to/3~ is that the
  foreign key is always defined in the schema that invokes
  ~belongs_to/3~. You can think of the schema that calls ~has_*~ as
  the parent schema and the one that invokes ~belongs_to~ as the child
  one.

- When an association is defined, Ecto also defines a field in the
  schema with the association name. By default, associations are not
  loaded into this field:

  #+BEGIN_SRC
  iex> post = Repo.get(Post, 42)
  iex> post.comments
  #Ecto.Association.NotLoaded<...>
  #+END_SRC
  + but you can preload
    #+BEGIN_SRC elixir
    Repo.all(from(p in Post, preload: [:comments])) # it runs two queries
    #+END_SRC

  + Preloading can also be done with a pre-defined join value:
    #+BEGIN_SRC elixir
    Repo.all from p in Post,
            join: c in assoc(p, :comments),
            preload: [comments: c]
    #+END_SRC
    + performs a single query, finding all posts and the respective
      comments that match the criteria. Because this query performs a
      JOIN

  + for the simple cases, preloading can also be done after a
    collection was fetched:
    #+BEGIN_SRC
    posts = Repo.all(Post) |> Repo.preload(:comments)
    #+END_SRC
  + get all the comments
    #+BEGIN_SRC elixir
      import Ecto

      post = Repo.get(Post, 1)

      # Get all comments for the given post
      Repo.all assoc(post, :comments)

      # Or build a query on top of the associated comments
      query = from c in assoc(post, :comments), where: not is_nil(c.title)
      Repo.all(query)
    #+END_SRC
** Manipulating associations
-
  #+BEGIN_SRC elixir
    Repo.insert!(%Post{
      title: "Hello",
      body: "world",
      comments: [
        %Comment{body: "Excellent!"}
      ]
    })
  #+END_SRC
-
  #+BEGIN_SRC elixir
    post = Ecto.Changeset.change(%Post{}, title: "Hello", body: "world")
    comment = Ecto.Changeset.change(%Comment{}, body: "Excellent!")
    post_with_comments = Ecto.Changeset.put_assoc(post, :comments, [comment])
    Repo.insert!(post_with_comments)
  #+END_SRC
- handling each entry individually inside a transaction
  #+BEGIN_SRC elixir
    Repo.transaction fn ->
      post = Repo.insert!(%Post{title: "Hello", body: "world"})

      # Build a comment from the post struct
      comment = Ecto.build_assoc(post, :comments, body: "Excellent!")

      Repo.insert!(comment)
    end
  #+END_SRC
  + ~Ecto.build_assoc/3~ builds the comment using the id currently set
    in the post struct. It is equivalent to:
    #+BEGIN_SRC elixir
    %Comment{post_id: post.id, body: "Excellent!"}
    #+END_SRC
- ~Ecto.build_assoc/3~
  + The ~Ecto.build_assoc/3~ function is specially useful in Phoenix
    controllers. For example, when creating the post, one would do:
    #+BEGIN_SRC elixir
    Ecto.build_assoc(current_user, :post)
    #+END_SRC
    As we likely want to associate the post to the user currently
    signed in the application. In another controller, we could build a
    comment for an existing post with:
    #+BEGIN_SRC elixir
    Ecto.build_assoc(post, :comments)
    #+END_SRC
** Deleting associations
- When defining a ~has_many/3~, ~has_one/3~ and friends, you can also pass
  a ~:on_delete~ option that specifies which action should be performed
  on associations when the parent is deleted.
  #+BEGIN_SRC elixir
  has_many :comments, MyApp.Comment, on_delete: :delete_all
  #+END_SRC
  - Besides the value above, ~:nilify_all~ is also supported, with
    ~:nothing~ being the default.
* Embeds
- Ecto also supports embeds. While associations keep parent and child
  entries in different tables, embeds stores the child along side the
  parent.

- Databases like MongoDB have native support for embeds. Databases
  like PostgreSQL uses a mixture of JSONB (~embeds_one/3~) and ARRAY
  columns to provide this functionality.

* Ecto.Changeset module
- Changesets allow filtering, casting, validation and definition of
  constraints when manipulating structs.
- The functions ~cast/4~ and ~change/2~ are the usual entry points for
  creating changesets
  #+BEGIN_SRC elixir
  comment = Ecto.Changeset.change(%Comment{}, body: "Excellent!")
  #+END_SRC
** External vs internal data
- Changesets allow working with both kinds of data:
  + internal to the application - for example programmatically
    generated, or coming from other subsystems. This use case is
    primarily covered by the ~change/2~ and ~put_change/3~ functions.
  + external to the application - for example data provided by the
    user in a form that needs to be type-converted and properly
    validated. This use case is primarily covered by the ~cast/4~
    function.
** Validations and constraints
- The difference between validations and constraints
  + is that most validations can be executed without a need to
    interact with the database and, therefore, are always executed
    before attempting to insert or update the entry in the
    database. Some validations may happen against the database but
    they are inherently unsafe. Those validations start with a
    ~unsafe_~ prefix, such as ~unsafe_validate_unique/3~.
  + constraints rely on the database and are always safe
  + validations are always checked before constraints. Constraints
    won’t even be checked in case validations failed
- example
  create the table
  #+BEGIN_SRC elixir
    defmodule Friends.Repo.Migrations.CreateUsers do
      use Ecto.Migration

      def change do
        create table(:users) do
          add(:name, :string)
          add(:email, :string)
          add(:age, :integer)
          timestamps()
        end

        create(unique_index(:users, [:email]))
      end
    end

  #+END_SRC
  define the schema
  #+BEGIN_SRC elixir
    defmodule User do
      use Ecto.Schema
      import Ecto.Changeset

      schema "users" do
        field :name
        field :email
        field :age, :integer
      end

      def changeset(user, params \\ %{}) do
        user
        |> cast(params, [:name, :email, :age])
        |> validate_required([:name, :email])
        |> validate_format(:email, ~r/@/)
        |> validate_inclusion(:age, 18..100)
        |> unique_constraint(:email)
      end
    end

    changeset = User.changeset(%User{}, %{age: 0, email: "mary@example.com"})
    {:error, changeset} = Repo.insert(changeset)
    changeset.errors #=> [age: {"is invalid", []}, name: {"can't be blank", []}]
  #+END_SRC
** Associations, embeds and on replace
- There are two primary APIs:
  1. ~cast_assoc/3~ and ~cast_embed/3~
  2. ~put_assoc/4~ and ~put_embed/4~

- ~cast_assoc/3~ and ~cast_embed/3~ - those functions are used when
  working with external data. In particular, they allow you to
  change associations and embeds alongside the parent struct, all at
  once.

- ~put_assoc/4~ and ~put_embed/4~ - it allows you to replace the
  association or embed as a whole. This can be used to move
  associated data from one entry to another, to completely remove or
  replace existing entries.

- The same way we have used changesets to manipulate embeds, we can
  also use them to change child associations at the same time we are
  manipulating the parent.

- ~cast_assoc~ (or ~cast_embed~) is used when you want to manage
  associations or embeds based on external parameters, such as the
  data received through Phoenix forms. In such cases, Ecto will
  compare the data existing in the struct with the data sent through
  the form and generate the proper operations. On the other hand, we
  use ~put_assoc~ (or ~put_embed~) when we aleady have the associations
  (or embeds) as structs and changesets, and we simply want to tell
  Ecto to take those entries as is.

- ~cast_assoc~ is the pendant to ~cast~. aka casting external data
  like coming from a form, while ~put_assocs~ expects you to supply
  already validated and properly checked structs or changesets of the
  association.

- ~cast_assoc(changeset, name, opts \\ [])~
  + This function should be used when working with the entire
    association at once (and not a single element of a many-style
    association) and using data external to the application.
  + ~cast_assoc/3~ is used when you want to create the associated record
    along with your changeset.
    #+BEGIN_SRC elixir
      defmodule User do
        def changeset(user, params) do
          user
          |> cast(params, @allowed_params)
          |> validate_required(@required_params)
          # Account.changeset is inferred by default
          |> cast_assoc(:account, required: true, with: &Account.registration_changeset/2)
        end
      end

      account = %{plan: "free"}
      user = %{email: "coolio@example.com", password: "bananas", account: account}
      User.changeset(%User{}, user)
    #+END_SRC
    + By default ~cast_assoc/3~ will use ~changeset/2~ in your associated
      model, but you can specify a different by passing the ~:with~
      option.

- ~put_assoc/4~
  is used when you already have an associated struct and
  you want to assign the association in your changset.
  #+BEGIN_SRC elixir
    defmodule Comment do
      def changeset(comment, params) do
        comment
        |> cast(params, @allowed_params)
        |> validate_required([:text])
        |> put_assoc(:user, params.user)
      end
    end

    comment = %{text: "Hey, sup?", user: some_user}
    Comment.changeset(%Comment{}, comment)
  #+END_SRC




** Schemaless changesets
- Such functionality makes Ecto extremely useful to cast, validate and
  prune data even if it is not meant to be persisted to the database.
  #+BEGIN_SRC elixir
    data  = %{}
    types = %{name: :string}
    params = %{name: "Callum"}
    changeset =
      {data, types}
      |> Ecto.Changeset.cast(params, Map.keys(types))
      |> Ecto.Changeset.validate_required(...)
      |> Ecto.Changeset.validate_length(...)
  #+END_SRC
**  The Ecto.Changeset struct
- The public fields are:
  + ~valid?~ - Stores if the changeset is valid
  + ~data~ - The changeset source data, for example, a struct
  + ~params~ - The parameters as given on changeset creation
  + ~changes~ - The changes from parameters that were approved in
    casting
  + ~errors~ - All errors from validations
  + ~required~ - All required fields as a list of atoms
  + ~action~ - The action to be performed with the changeset
  + ~types~ - Cache of the data’s field types
  + ~empty~_values - A list of values to be considered empty
  + ~repo~ - The repository applying the changeset (only set after a
    Repo function is called)
  + ~repo_opts~ - A keyword list of options given to the underlying
    repository operation
- The following fields are private and must not be accessed directly.
  + ~validations~
  + ~constraints~
  + ~filters~
* Ecto.LogEntry
* Ecto.Multi
- ~Ecto.Multi~ is a data structure for grouping multiple Repo
  operations.
- ~Ecto.Multi~ makes it possible to pack operations that should be
  performed in a single database transaction and gives a way to
  introspect the queued operations without actually performing them.
- Each operation is given a name that is unique and will identify its
  result in case of success or failure.
- All operations will be executed in the order they were added.
- The ~Ecto.Multi~ structure should be considered opaque. You can use
  ~%Ecto.Multi{}~ to pattern match the type, but accessing fields or
  directly modifying them is not advised.
- ~Ecto.Multi.to_list/1~ returns a canonical representation of the
  structure that can be used for introspection.

- Example

  The use case we’ll be looking into is resetting a password. We
  need to update the account with proper information, log the
  request and remove all current sessions:
  #+BEGIN_SRC elixir
        defmodule PasswordManager do
          alias Ecto.Multi

          def reset(account, params) do
            Multi.new
            |> Multi.update(:account, Account.password_reset_changeset(account, params))
            |> Multi.insert(:log, Log.password_reset_changeset(account, params))
            |> Multi.delete_all(:sessions, Ecto.assoc(account, :sessions))
          end
        end

        result = Repo.transaction(PasswordManager.reset(account, params))

        case result do
          {:ok, %{account: account, log: log, sessions: sessions}} ->
            # Operation was successful, we can access results (exactly the same
            # we would get from running corresponding Repo functions) under keys
            # we used for naming the operations.
            {:error, failed_operation, failed_value, changes_so_far} ->
            # One of the operations failed. We can access the operation's failure
            # value (like changeset for operations on changesets) to prepare a
            # proper response. We also get access to the results of any operations
            # that succeeded before the indicated operation failed. However, any
            # successful operations would have been rolled back.
    end
  #+END_SRC
  + test it
    #+BEGIN_SRC elixir

      test "dry run password reset" do
        account = %Account{password: "letmein"}
        multi = PasswordManager.reset(account, params)

        assert [
          {:account, {:update, account_changeset, []}},
          {:log, {:insert, log_changeset, []}},
          {:sessions, {:delete_all, query, []}}
        ] = Ecto.Multi.to_list(multi)

        # We can introspect changesets and query to see if everything
        # is as expected, for example:
        assert account_changeset.valid?
        assert log_changeset.valid?
        assert inspect(query) == "#Ecto.Query<from a in Session>"
      end
    #+END_SRC
  + The name of each operation does not have to be an atom. This can
    be particularly useful when you wish to update a collection of
    changesets at once, and track their errors individually:
    #+BEGIN_SRC elixir
      accounts = [%Account{id: 1}, %Account{id: 2}]

      Enum.reduce(accounts, Multi.new(), fn account, multi ->
        Multi.update(
          multi,
          {:account, account.id},
          Account.password_reset_changeset(account, params)
        )
      end)
    #+END_SRC
* Ecto.Query
- Queries are used to retrieve and manipulate data from a repository
- Ecto queries come in two flavors: keyword-based and macro-based.
-
  #+BEGIN_SRC elixir
    # Imports only from/2 of Ecto.Query
    import Ecto.Query, only: [from: 2]

    # Create a query
    query = from u in "users",
              where: u.age > 18,
              select: u.name

    # Send the query to the repository
    Repo.all(query)
  #+END_SRC
** Query expressions
- Ecto allows a limited set of expressions inside queries. In the
  query below, for example, we use ~u.age~ to access a field, the ~>~
  comparison operator and the literal ~0~:
  #+BEGIN_SRC elixir
  query = from u in "users", where: u.age > 0, select: u.name
  #+END_SRC
  + Lists all functions allowed in the query API.
    * Comparison operators: ~==~, ~!=~, ~<=~, ~>=~, ~<~, ~>~
    * Arithmetic operators: ~+~, ~-~, ~*~, ~/~
    * Boolean operators: ~and~, ~or~, ~not~
    * Inclusion operator: ~in/2~
    * Search functions: ~like/2~ and ~ilike/2~
    * Null check functions: ~is_nil/1~
    * Aggregates: ~count/0~, ~count/1~, ~avg/1~, ~sum/1~, ~min/1~, ~max/1~
    * Date/time intervals: ~datetime_add/3~, ~date_add/3~, ~from_now/2~, ~ago/2~
    * Inside select: ~struct/2~, ~map/2~, ~merge/2~ and literals (map, tuples, lists, etc)
    * General: ~fragment/1~, ~field/2~ and ~type/2~
  + also following literals are supported in queries
    * Integers: ~1~, ~2~, ~3~
    * Floats: ~1.0~, ~2.0~, ~3.0~
    * Booleans: ~true~, ~false~
    * Binaries: ~<<1, 2, 3>>~
    * Strings: ~"foo bar"~, ~~s(this is a string)~
    * Arrays: ~[1, 2, 3]~, ~~w(interpolate words)~

** Interpolation and casting
- External values and Elixir expressions can be injected into a query
  expression with ~^~:
  #+BEGIN_SRC elixir
    def with_minimum(age, height_ft) do
      from u in "users",
        where: u.age > ^age and u.height > ^(height_ft * 3.28),
        select: u.name
    end

    with_minimum(18, 5.0)
  #+END_SRC
- explicitly tell Ecto what is the expected type of the value being
  interpolated
  #+BEGIN_SRC elixir
    age = "18"
    Repo.all(from u in "users",
              where: u.age > type(^age, :integer),
              select: u.name)
  #+END_SRC
** ~nil~ comparison
- nil comparison in filters, such as where and having, is forbidden
  and it will raise an error:
  #+BEGIN_SRC elixir
  # Raises if the variable age (in this case used with ^ operator) is nil
  from u in User, where: u.age == ^age
  #+END_SRC
- check that value is nil, use ~is_nil/1~
  #+BEGIN_SRC elixir
  from u in User, where: is_nil(u.age)
  #+END_SRC
** Composition
- Ecto queries are composable
  #+BEGIN_SRC elixir
    # Create a query
    query = from u in User, where: u.age > 18

    # Extend the query
    query = from u in query, select: u.name
  #+END_SRC
- Any value can be used on the right-side of ~in~ as long as it
  implements the [[https://hexdocs.pm/ecto/Ecto.Queryable.html][~Ecto.Queryable]]~ protocol.
** Positional bindings
- On the left side of ~in~ we specify the query bindings. This is done
  inside ~from~ and ~join~ clauses
- In the query below ~u~ is a binding and ~u.age~ is a field access using
  this binding
  #+BEGIN_SRC elixir
  query = from u in User, where: u.age > 18
  #+END_SRC
- When using joins, the bindings should be matched in the order they
  are specified:
  #+BEGIN_SRC elixir
    # Create a query
    query = from p in Post,
              join: c in Comment, where: c.post_id == p.id

    # Extend the query
    query = from [p, c] in query,
              select: {p.title, c.body}
  #+END_SRC
  + You are not required to specify all bindings when composing
  + if you are interested only on the last binding (or the last
    bindings) in a query, you can use ~...~ to specify “all bindings
    before” and match on the last one.
    #+BEGIN_SRC elixir
    from [p, ..., c] in posts_with_comments, select: {p.title, c.body}
    #+END_SRC
    * In other words, ~...~ will include all the binding between the
      first and the last, which may be no binding at all, one or many.
** Named bindings
- We can named the bindings. This approach lets us not worry about
  keeping track of the position of the bindings when composing the
  query.
  #+BEGIN_SRC elixir
    posts_with_comments =
      from p in query,
        join: c in Comment, as: :comment, where: c.post_id == p.id

    from [p, comment: c] in posts_with_comments, select: {p.title, c.body}
  #+END_SRC
  a name can be assigned to the first binding as well:
  #+BEGIN_SRC elixir
    from p in Post, as: :post
  #+END_SRC
  Only atoms are accepted for binding names. Named binding references
  are expected to be placed in the tail position of the bindings list

** Bindingless operations
- bindings are not necessary when the query has only the ~from~ clause.
  #+BEGIN_SRC elixir
    from Post,
      where: [category: "fresh and new"],
      order_by: [desc: :published_at],
      select: [:id, :title, :body]


    # It is equivalent to:
    from p in Post,
      where: p.category == "fresh and new",
      order_by: [desc: p.published_at],
      select: struct(p, [:id, :title, :body])


    # we can also dynamically build them
    where = [category: "fresh and new"]
    order_by = [desc: :published_at]
    select = [:id, :title, :body]
    from Post, where: ^where, order_by: ^order_by, select: ^select
  #+END_SRC
** Fragments
- It is not possible to represent all possible database queries using
  Ecto’s query syntax. When such is required, it is possible to use
  fragments to send any expression to the database
- Ecto provides fragments to inject SQL (and non-SQL) fragments into
  queries
  #+BEGIN_SRC elixir
    from p in Post,
      where: is_nil(p.published_at) and
             fragment("lower(?)", p.title) == ^title
  #+END_SRC
  we are using the ~lower~ procedure in the database to downcase the
  ~title~ column
- [[https://hexdocs.pm/ecto/Ecto.Query.API.html#fragment/1][doc]]

** Macro API
- keywords query syntax
  #+BEGIN_SRC elixir
    import Ecto.Query
    from u in "users", where: u.age > 18, select: u.name
  #+END_SRC
- Ecto also supports a pipe-based syntax:
  #+BEGIN_SRC elixir
    "users"
    |> where([u], u.age > 18)
    |> select([u], u.name)
  #+END_SRC
- The downside of using macros is that the binding must be specified
  for every operation. However, since keyword-based and pipe-based
  examples are equivalent, the bindingless syntax also works for
  macros:
  #+BEGIN_SRC elixir
    "users"
    |> where([u], u.age > 18)
    |> select([:name])
  #+END_SRC

** Query Prefix
- It is possible to set a prefix for the queries. For Postgres users,
  this will specify the schema where the table is located, while for
  MySQL users this will specify the database where the table is
  located. When no prefix is set, Postgres queries are assumed to be
  in the public schema, while MySQL queries are assumed to be in the
  database set in the config for the repo.
- The query prefix may be set either for the whole query or on each
  individual ~from~ and ~join~ expression. If a ~prefix~ is not given to a
  ~from~ or a ~join~, the prefix of the schema given to the from or join
  is used.
- examples
  #+BEGIN_SRC elixir
  results = Repo.all(query, prefix: "accounts")
  #+END_SRC
  #+BEGIN_SRC elixir
    results =
      query # May be User or an Ecto.Query itself
      |> Ecto.Queryable.to_query
      |> Map.put(:prefix, "accounts")
      |> Repo.all()
  #+END_SRC
  #+BEGIN_SRC elixir
    results =from u in User,
      prefix: "accounts",
      join: p in assoc(u, :posts),
      prefix: "public"
  #+END_SRC
- prefix lookup precedence:
  + The ~:prefix~ option given to ~from~ / ~join~ has the highest precedence
  + Then it falls back to the ~@schema_prefix~ attribute declared in the
    schema given to ~from~ / ~join~
  + Then it falls back to the query prefix

*** functions
- ~distinct(query, binding \\ [], expr)~
  #+BEGIN_SRC elixir
    # Returns the list of different categories in the Post schema
    from(p in Post, distinct: true, select: p.category)

    # If your database supports DISTINCT ON(),
    # you can pass expressions to distinct too
    from(p in Post,
       distinct: p.category,
       order_by: [p.date])

    # The DISTINCT ON() also supports ordering similar to ORDER BY.
    from(p in Post,
       distinct: [desc: p.category],
       order_by: [p.date])

    # Using atoms
    from(p in Post, distinct: :category, order_by: :date)


    # Expressions example
    Post
    |> distinct(true)
    |> order_by([p], [p.category, p.author])
  #+END_SRC
- ~exclude(query, field)~
  Resets a previously set field on a query.
  #+BEGIN_SRC elixir
  Ecto.Query.exclude(query, :join)
  Ecto.Query.exclude(query, :where)
  Ecto.Query.exclude(query, :order_by)
  Ecto.Query.exclude(query, :group_by)
  Ecto.Query.exclude(query, :having)
  Ecto.Query.exclude(query, :distinct)
  Ecto.Query.exclude(query, :select)
  Ecto.Query.exclude(query, :combinations)
  Ecto.Query.exclude(query, :limit)
  Ecto.Query.exclude(query, :offset)
  Ecto.Query.exclude(query, :lock)
  Ecto.Query.exclude(query, :preload)
  Ecto.Query.exclude(query, :inner_join)
  Ecto.Query.exclude(query, :cross_join)
  Ecto.Query.exclude(query, :left_join)
  Ecto.Query.exclude(query, :right_join)
  Ecto.Query.exclude(query, :full_join)
  Ecto.Query.exclude(query, :inner_lateral_join)
  Ecto.Query.exclude(query, :left_lateral_join)
  #+END_SRC
  keep in mind that if a join is removed and its bindings were
  referenced elsewhere, the bindings won’t be removed, leading to a
  query that won’t compile.
- ~group_by(query, binding \\ [], expr)~
  + Groups together rows from the schema that have the same values in
    the given fields.
    #+BEGIN_SRC elixir
      # Returns the number of posts in each category
      from(p in Post,
        group_by: p.category,
        select: {p.category, count(p.id)})

      # Using atoms
      from(p in Post, group_by: :category, select: {p.category, count(p.id)})

      # Using direct fields access
      from(p in Post,
        join: c in assoc(p, :category)
        group_by: [p.id, c.name])

      # Expressions example
      Post |> group_by([p], p.category) |> select([p], count(p.id))
    #+END_SRC
- ~having(query, binding \\ [], expr)~
  + Like ~where~, ~having~ filters rows from the schema, but after the
    grouping is performed giving it the same semantics as ~select~ for a
    grouped query. ~having~ groups the query even if
    the query has no ~group_by~ expression.
    #+BEGIN_SRC elixir
      # Returns the number of posts in each category where the
      # average number of comments is above ten
      from(p in Post,
        group_by: p.category,
        having: avg(p.num_comments) > 10,
        select: {p.category, count(p.id)})

      # Expressions example
      Post
      |> group_by([p], p.category)
      |> having([p], avg(p.num_comments) > 10)
      |> select([p], count(p.id))
    #+END_SRC
- ~preload(query, bindings \\ [], expr)~
  #+BEGIN_SRC elixir
  Repo.all from p in Post, preload: [:comments]
  #+END_SRC
  + The example above will fetch all posts from the database and then
    do a separate query returning all comments associated with the
    given posts.
  + you may want posts and comments to be selected and filtered in the
    same query:
    #+BEGIN_SRC elixir
      Repo.all from p in Post,
                 join: c in assoc(p, :comments),
                 where: c.published_at > p.updated_at,
                 preload: [comments: c]
    #+END_SRC
  + Note: keep in mind operations like limit and offset in the preload
    query will affect the whole result set and not each
    association. For example, the query below:
    #+BEGIN_SRC elixir
      comments_query = from c in Comment, order_by: c.popularity, limit: 5
      Repo.all from p in Post, preload: [comments: ^comments_query]
    #+END_SRC
    won’t bring the top of comments per post. Rather, it will only
    bring the 5 top comments across all posts.
* Ecto.Repo behaviour
- A repository maps to an underlying data store, controlled by the
  adapter. For example, Ecto ships with a Postgres adapter
- When used, the repository expects the ~:otp_app~ as option. The
  ~:otp_app~ should point to an OTP application that has the repository
  configuration.
  #+BEGIN_SRC elixir
    defmodule Repo do
      use Ecto.Repo,
        otp_app: :my_app,
        adapter: Ecto.Adapters.Postgres
    end
  #+END_SRC
  + Could be configured with:
    #+BEGIN_SRC elixir
      config :my_app, Repo,
        database: "ecto_simple",
        username: "postgres",
        password: "postgres",
        hostname: "localhost"
    #+END_SRC
  + Most of the configuration that goes into the config is specific to
    the adapter, so check ~Ecto.Adapters.Postgres~ documentation
- Almost all of the repository operations accept the following
  options:
    + ~:timeout~ - The time in milliseconds to wait for the query call
      to finish, ~:infinity~ will wait indefinitely (default: 15000);
    + ~:log~ - When false, does not log the query
    + ~:telemetry_event~ - The telemetry event name to dispatch the
      event under
