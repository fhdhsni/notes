* add ecto
1) generate necessities
   #+BEGIN_SRC
   mix ecto.gen.repo -r Friends.Repo
   #+END_SRC
2) checkout configuration at ~config/config.exs~
   #+BEGIN_SRC elixir
     config :friends, Friends.Repo,
       database: "friends_repo",
       username: "user",
       password: "pass",
       hostname: "localhost"
   #+END_SRC
3) ~lib/friends/repo.ex~
   #+BEGIN_SRC elixir
     defmodule Friends.Repo do
       use Ecto.Repo,
         otp_app: :friends,
         adapter: Ecto.Adapters.Postgres
     end
   #+END_SRC
   + ~otp_app~ tells Ecto which Elixir application it can look for
     database configuration in
4) start the repo process in ~lib/friends/application.ex~
   #+BEGIN_SRC elixir
     def start(_type, _args) do
       children = [
         Friends.Repo,
       ]
   #+END_SRC
5) add this to ~config/config.exs~
   #+BEGIN_SRC elixir
   config :friends, ecto_repos: [Friends.Repo]
   #+END_SRC
   This tells our application about the repo, which will allow us to
   run commands such as ~mix ecto.create~

* Setting up the database
- create the database
  #+BEGIN_SRC
  mix ecto.create
  #+END_SRC
- create a migration
  #+BEGIN_SRC elixir
  mix ecto.gen.migration create_people
  #+END_SRC
  generates a new migration file in ~priv/repo/migrations~
  #+BEGIN_SRC elixir
    defmodule Friends.Repo.Migrations.CreatePeople do
      use Ecto.Migration

      def change do
        create table(:people) do
          add(:first_name, :string)
          add(:last_name, :string)
          add(:age, :integer)
        end
      end
    end
  #+END_SRC
  NOTE: The naming convention for tables in Ecto databases is to use a
  pluralized name.

- run the migration to create the table
  #+BEGIN_SRC
  mix ecto.migrate
  #+END_SRC
  if you you made any mistake you can run ~mix ecto.rollback~

* Creating the schema
- The schema is an Elixir representation of data from our database.
- Schemas are commonly associated with a database table, however they
  can be associated with a database view as well
  #+BEGIN_SRC elixir
    defmodule Friends.Person do
      use Ecto.Schema

      schema "people" do            # database name
        field :first_name, :string
        field :last_name, :string
        field :age, :integer
      end
    end
  #+END_SRC
  + we’re telling Ecto that the ~Friends.Person~ schema maps to the
    ~people~ table in the database
  + We’ve called this schema ~Person~ because the naming convention in
    Ecto for schemas is a singularized name.
  + in iex
    #+BEGIN_SRC elixir
      iex(1)> person = %Friends.Person{}
      %Friends.Person{
        __meta__: #Ecto.Schema.Metadata<:built, "people">,
        age: nil,
        first_name: nil,
        id: nil,
        last_name: nil
      }
    #+END_SRC

* Inserting data
- We can insert a new record into our ~people~ table with this code:
  #+BEGIN_SRC elixir
  person = %Friends.Person{}
  Friends.Repo.insert(person)
  {:ok,
    %Friends.Person{
      __meta__: #Ecto.Schema.Metadata<:loaded, "people">,
      age: nil, first_name: nil, id: 1, last_name: nil
    }
  }
  # or
  {:ok, person} = Friends.Repo.insert(person)
  #+END_SRC
* Validating changes
- For this, Ecto has [[https://hexdocs.pm/ecto/Ecto.Changeset.html][changesets]]
  + how to use it
    1. filter and cast input
       #+BEGIN_SRC elixir
         import Ecto.Changeset

         params = %{"title" => "So What", "index" => "1", "duration" => 180, "foo" => "LOL"}

         changeset =
           %Track{}
           |> cast(params, [:title, :index, :duration])
       #+END_SRC
    2. validate
       #+BEGIN_SRC elixir
         changeset =
           validate_required(changeset, [:title, :index])
           |> validate_number(:index, greater_than: 0)
       #+END_SRC
    3. capture errors
       #+BEGIN_SRC elixir
         # see if it works
         case Repo.insert(changeset) do
           {:ok, track} -> IO.puts "Track #{track.name} successfully added"
           {:error, changeset} -> IO.puts changeset.errors
         end
       #+END_SRC

- sample
  #+BEGIN_SRC elixir
    defmodule Friends.Person do
      use Ecto.Schema

      schema "people" do
        field(:first_name, :string)
        field(:last_name, :string)
        field(:age, :integer)
      end


      # This changeset takes a `person` and a set of `params`, which are to be
      # the changes to apply to this person
      def changeset(person, params \\ %{}) do
        person
        |> Ecto.Changeset.cast(params, [:first_name, :last_name, :age])
        |> Ecto.Changeset.validate_required([:first_name, :last_name])
      end
    end
  #+END_SRC
- ~Ecto.Changeset.cast(person, params, [:first_name, :last_name, :age])~
  + it's ~cast(data, params, permitted, opts \\ [])~
  + Casting tells the changeset what parameters are allowed to be
    passed through in this changeset, and anything not in the list
    will be ignored.
- ~Ecto.Changeset.validate_required([:first_name, :last_name])~
  + it's ~validate_required(changeset, fields, opts \\ [])~
  + says that, for this changeset, we expect ~first_name~ and ~last_name~
    to have values specified

    with error
    #+BEGIN_SRC elixir
      iex(9)> person = %Friends.Person{}
      %Friends.Person{
        __meta__: #Ecto.Schema.Metadata<:built, "people">,
        age: nil,
        first_name: nil,
        id: nil,
        last_name: nil
      }

      iex(10)> changeset = Friends.Person.changeset(person, %{})
      #Ecto.Changeset<
        action: nil,
        changes: %{},
        errors: [
        first_name: {"can't be blank", [validation: :required]},
        last_name: {"can't be blank", [validation: :required]}
        ],
        data: #Friends.Person<>,
        valid?: false
      >

      iex(11)> {:error, changeset} = Friends.Repo.insert(changeset)
      {:error,
       #Ecto.Changeset<
         action: :insert,
         changes: %{},
         errors: [
         first_name: {"can't be blank", [validation: :required]},
         last_name: {"can't be blank", [validation: :required]}
         ],
         data: #Friends.Person<>,
         valid?: false
       >
      }

      iex(14)> changeset.errors
      [
        first_name: {"can't be blank", [validation: :required]},
        last_name: {"can't be blank", [validation: :required]}
      ]
    #+END_SRC

    valid changeset
    #+BEGIN_SRC elixir
      iex> person = %Friends.Person{}
      %Friends.Person{
        __meta__: #Ecto.Schema.Metadata<:built, "people">,
        age: nil,
        first_name: nil,
        id: nil,
        last_name: nil
      }

      iex> changeset = Friends.Person.changeset(person, %{first_name: "Ryan", last_name: "Bigg"})
      #Ecto.Changeset<
        action: nil,
        changes: %{first_name: "Ryan", last_name: "Bigg"},
        errors: [],
        data: #Friends.Person<>,
        valid?: true
      >

      iex(17)> changeset.valid?
      true

      iex> Friends.Repo.insert(changeset)

      10:02:59.746 [debug] QUERY OK db=3.9ms queue=1.9ms
      INSERT INTO "people" ("first_name","last_name") VALUES ($1,$2) RETURNING "id" ["Ryan", "Bigg"]
      {:ok,
       %Friends.Person{
         __meta__: #Ecto.Schema.Metadata<:loaded, "people">,
         age: nil,
         first_name: "Ryan",
         id: 3,
         last_name: "Bigg"
       }}
    #+END_SRC

  + NOTE: ~changeset.valid?~ will not check constraints (such as
    ~uniqueness_constraint~). For that, you will need to attempt to do
    an insertion and check for errors from the database. It’s for this
    reason it’s best practice to try inserting data and validate the
    returned tuple from ~Friends.Repo.insert~ to get the correct errors,
    as prior to insertion the changeset will only contain validation
    errors from the application itself.
* queries
1. construct the query
2. execute that query against the database by passing the query to the
   repository
** Fetching a single record
- build the query
  ~Friends.Person |> Ecto.Query.first~
  will generate an ~Ecto.Query~
  #+BEGIN_SRC
  #Ecto.Query<from p in Friends.Person, order_by: [asc: p.id], limit: 1>
  #+END_SRC

  We could construct this query ourselves
  #+BEGIN_SRC elixir
  require Ecto.Query
  Ecto.Query.from p in Friends.Person, order_by: [asc: p.id], limit: 1
  #+END_SRC
- execute the query
  #+BEGIN_SRC elixir
  iex> Friends.Person |> Ecto.Query.first |> Friends.Repo.one

  %Friends.Person{__meta__: #Ecto.Schema.Metadata<:loaded>,
  age: 28, first_name: "Ryan", id: 1, last_name: "Bigg"}
  #+END_SRC
  or get the last one
  #+BEGIN_SRC elixir
  iex> Friends.Person |> Ecto.Query.last |> Friends.Repo.one

  %Friends.Person{__meta__: #Ecto.Schema.Metadata<:loaded>,
  age: 26, first_name: "Jane", id: 3, last_name: "Smith"}
  #+END_SRC
  The ~Ecto.Repo.one~ function will only return a struct if there is
  one record in the result from the database. If there is more than
  one record returned, an ~Ecto.MultipleResultsError~ exception will be
  thrown.

** Fetching all records
#+BEGIN_SRC elixir
iex> Friends.Person |> Friends.Repo.all
#+END_SRC
** Fetch a single record based on ID
#+BEGIN_SRC elixir
iex> Friends.Person |> Friends.Repo.get(1)
%Friends.Person{__meta__: #Ecto.Schema.Metadata<:loaded>,
 age: 28, first_name: "Ryan", id: 1, last_name: "Bigg"}
#+END_SRC
** Fetch a single record based on a specific attribute
- If we want to get a record based on something other than the ~id~
  attribute, we can use ~get_by~:
  #+BEGIN_SRC elixir
    iex> Friends.Person |> Friends.Repo.get_by(first_name: "Ryan")

    %Friends.Person{__meta__: #Ecto.Schema.Metadata<:loaded>,
                    age: 28, first_name: "Ryan", id: 1, last_name: "Bigg"}
  #+END_SRC
** Filtering results
- If we want to get multiple records matching a specific attribute, we
  can use ~where~:
  #+BEGIN_SRC elixir
  Friends.Person |> Ecto.Query.where(last_name: "Smith") |> Friends.Repo.all

  [%Friends.Person{__meta__: #Ecto.Schema.Metadata<:loaded>, age: 27,
  first_name: "John", id: 2, last_name: "Smith"},

  %Friends.Person{__meta__: #Ecto.Schema.Metadata<:loaded>, age: 26,
  first_name: "Jane", id: 3, last_name: "Smith"}]
  #+END_SRC
  the generated query is
  #+BEGIN_SRC
  #Ecto.Query<from p in Friends.Person, where: p.last_name == "Smith">
  #+END_SRC
  which means we can get the same result with
  #+BEGIN_SRC
  Ecto.Query.from(p in Friends.Person, where: p.last_name == "Smith") |> Friends.Repo.all
  #+END_SRC
  with both syntax we have to pin (^) the variables
  #+BEGIN_SRC elixir
    iex> last_name = "Smith"
    iex> Friends.Person |> Ecto.Query.where(last_name: ^last_name) |> Friends.Repo.all

    # Or:

    iex> last_name = "Smith"
    iex> Ecto.Query.from(p in Friends.Person, where: p.last_name == ^last_name) |> Friends.Repo.all
  #+END_SRC
  The pin operator instructs the query builder to use parameterised
  SQL queries protecting against SQL injection.

** Composing Ecto queries
   #+BEGIN_SRC elixir
     query = Friends.Person |> Ecto.Query.where(last_name: "Smith")

     query = query |> Ecto.Query.where(first_name: "Jane")

     #Ecto.Query<
                   from p in Friends.Person, where: p.last_name == "Smith", where: p.first_name == "Jane">
   #+END_SRC
** Updating records
- Updating records in Ecto requires us to first fetch a record from
  the database. We then create a changeset from that record and the
  changes we want to make to that record, and then call the
  ~Ecto.Repo.update~ function.
  + fetch
    #+BEGIN_SRC
    person = Friends.Person |> Ecto.Query.first |> Friends.Repo.one
    #+END_SRC
  + build a changeset
    #+BEGIN_SRC
    changeset = Friends.Person.changeset(person, %{age: 29})
    #+END_SRC
    We need to build a changeset because if we just create a new
    ~Friends.Person~ struct with the new age, Ecto wouldn’t be able to
    know that the age has changed without inspecting the database
  + update
    #+BEGIN_SRC
    iex> Friends.Repo.update(changeset)
    {:ok,
    %Friends.Person{__meta__: #Ecto.Schema.Metadata<:loaded>, age: 29,
    first_name: "Ryan", id: 1, last_name: "Bigg"}}
    #+END_SRC
** Deleting records
- Similar to updating, we must first fetch a record from the database
  and then call ~Friends.Repo.delete~ to delete that record:
  #+BEGIN_SRC elixir
  iex> person = Friends.Repo.get(Friends.Person, 1)
  iex> Friends.Repo.delete(person)
  #=> {:ok,
  %Friends.Person{__meta__: #Ecto.Schema.Metadata<:deleted>, age: 29,
  first_name: "Ryan", id: 2, last_name: "Bigg"}}

  #+END_SRC
===================
* Ecto
** Ecto.Repo
- repositories are wrappers around the data store. Via the repository,
  we can create, update, destroy and query existing entries. A
  repository needs an adapter and credentials to communicate to the
  databas

** Ecto.Schema
- schemas are used to map any data source into an Elixir struct. We
  will often use them to map tables into Elixir data but that’s one of
  their use cases and not a requirement for using Ecto

** Ecto.Changeset
- changesets provide a way for developers to filter and cast external
  parameters, as well as a mechanism to track and validate changes
  before they are applied to your data

** Ecto.Query
- written in Elixir syntax, queries are used to retrieve information
  from a given repository. Queries in Ecto are secure, avoiding common
  problems like SQL Injection, while still being composable, allowing
  developers to build queries piece by piece instead of all at once
  #+BEGIN_SRC elixir
    import Ecto.Query, only: [from: 2]

    query = from u in User,
      where: u.age > 18 or is_nil(u.email),
      select: u

    # Returns %User{} structs matching the query
    Repo.all(query)
  #+END_SRC
  In the example above we relied on our schema but queries can also be
  made directly against a table by giving the table name as a
  string. In such cases, the data to be fetched must be explicitly
  outlined:
  #+BEGIN_SRC elixir
    query = from u in "users",
              where: u.age > 18 or is_nil(u.email),
              select: %{name: u.name, age: u.age}

    # Returns maps as defined in select
    Repo.all(query)
  #+END_SRC

- Queries are defined and extended with the from macro. The supported
  keywords are:
  #+BEGIN_SRC
  :distinct
  :where
  :order_by
  :offset
  :limit
  :lock
  :group_by
  :having
  :join
  :select
  :preload
  #+END_SRC
- When writing a query, you are inside Ecto’s query syntax. In order
  to access params values or invoke Elixir functions, you need to use
  the ^ operator, which is overloaded by Ecto:
  #+BEGIN_SRC elixir
    def min_age(min) do
      from u in User, where: u.age > ^min
    end
  #+END_SRC

* Associations
- Ecto supports defining associations on schemas:

  create ~comments~ table
  #+BEGIN_SRC elixir
    defmodule Friends.Repo.Migrations.CreateComments do
      use Ecto.Migration

      def change do
        create table(:comments) do
          add(:post_id, references(:posts))
          add(:body, :text)
          timestamps()
        end
      end
    end
  #+END_SRC
  create ~posts~ table
  #+BEGIN_SRC elixir
    defmodule Friends.Repo.Migrations.CreatePosts do
      use Ecto.Migration

      def change do
        create table(:posts) do
          add(:title, :string)
          add(:body, :text)
          timestamps()
        end
      end
    end
  #+END_SRC
  create ~Post~ schema
  #+BEGIN_SRC elixir
    defmodule Friends.Post do
      use Ecto.Schema

      schema "posts" do
        field(:title)
        field(:body)
        has_many(:comments, Friends.Comment)

        timestamps()
      end
    end
  #+END_SRC
  create ~Comment~ schema
  #+BEGIN_SRC elixir
  defmodule Friends.Post do
    use Ecto.Schema

    schema "posts" do
      field(:title)
      field(:body)
      has_many(:comments, Friends.Comment)

      timestamps()
    end
  end
  #+END_SRC
- The difference between ~has_one/3~ and ~belongs_to/3~ is that the
  foreign key is always defined in the schema that invokes
  ~belongs_to/3~. You can think of the schema that calls ~has_*~ as
  the parent schema and the one that invokes ~belongs_to~ as the child
  one.

- When an association is defined, Ecto also defines a field in the
  schema with the association name. By default, associations are not
  loaded into this field:

  #+BEGIN_SRC
  iex> post = Repo.get(Post, 42)
  iex> post.comments
  #Ecto.Association.NotLoaded<...>
  #+END_SRC
  + but you can preload
    #+BEGIN_SRC elixir
    Repo.all(from(p in Post, preload: [:comments])) # it runs two queries
    #+END_SRC

  + Preloading can also be done with a pre-defined join value:
    #+BEGIN_SRC elixir
    Repo.all from p in Post,
            join: c in assoc(p, :comments),
            preload: [comments: c]
    #+END_SRC
    + performs a single query, finding all posts and the respective
      comments that match the criteria. Because this query performs a
      JOIN

  + for the simple cases, preloading can also be done after a
    collection was fetched:
    #+BEGIN_SRC
    posts = Repo.all(Post) |> Repo.preload(:comments)
    #+END_SRC
  + get all the comments
    #+BEGIN_SRC elixir
      import Ecto

      post = Repo.get(Post, 1)

      # Get all comments for the given post
      Repo.all assoc(post, :comments)

      # Or build a query on top of the associated comments
      query = from c in assoc(post, :comments), where: not is_nil(c.title)
      Repo.all(query)
    #+END_SRC
** Manipulating associations
-
  #+BEGIN_SRC elixir
    Repo.insert!(%Post{
      title: "Hello",
      body: "world",
      comments: [
        %Comment{body: "Excellent!"}
      ]
    })
  #+END_SRC
-
  #+BEGIN_SRC elixir
    post = Ecto.Changeset.change(%Post{}, title: "Hello", body: "world")
    comment = Ecto.Changeset.change(%Comment{}, body: "Excellent!")
    post_with_comments = Ecto.Changeset.put_assoc(post, :comments, [comment])
    Repo.insert!(post_with_comments)
  #+END_SRC
- handling each entry individually inside a transaction
  #+BEGIN_SRC elixir
    Repo.transaction fn ->
      post = Repo.insert!(%Post{title: "Hello", body: "world"})

      # Build a comment from the post struct
      comment = Ecto.build_assoc(post, :comments, body: "Excellent!")

      Repo.insert!(comment)
    end
  #+END_SRC
  + ~Ecto.build_assoc/3~ builds the comment using the id currently set
    in the post struct. It is equivalent to:
    #+BEGIN_SRC elixir
    %Comment{post_id: post.id, body: "Excellent!"}
    #+END_SRC
- ~Ecto.build_assoc/3~
  + The ~Ecto.build_assoc/3~ function is specially useful in Phoenix
    controllers. For example, when creating the post, one would do:
    #+BEGIN_SRC elixir
    Ecto.build_assoc(current_user, :post)
    #+END_SRC
    As we likely want to associate the post to the user currently
    signed in the application. In another controller, we could build a
    comment for an existing post with:
    #+BEGIN_SRC elixir
    Ecto.build_assoc(post, :comments)
    #+END_SRC
** Deleting associations
- When defining a ~has_many/3~, ~has_one/3~ and friends, you can also pass
  a ~:on_delete~ option that specifies which action should be performed
  on associations when the parent is deleted.
  #+BEGIN_SRC elixir
  has_many :comments, MyApp.Comment, on_delete: :delete_all
  #+END_SRC
  - Besides the value above, ~:nilify_all~ is also supported, with
    ~:nothing~ being the default.
* Embeds
- Ecto also supports embeds. While associations keep parent and child
  entries in different tables, embeds stores the child along side the
  parent.

- Databases like MongoDB have native support for embeds. Databases
  like PostgreSQL uses a mixture of JSONB (~embeds_one/3~) and ARRAY
  columns to provide this functionality.

* Ecto.Changeset module
- Changesets allow filtering, casting, validation and definition of
  constraints when manipulating structs.
- The functions ~cast/4~ and ~change/2~ are the usual entry points for
  creating changesets
  #+BEGIN_SRC elixir
  comment = Ecto.Changeset.change(%Comment{}, body: "Excellent!")
  #+END_SRC
** External vs internal data
- Changesets allow working with both kinds of data:
  + internal to the application - for example programmatically
    generated, or coming from other subsystems. This use case is
    primarily covered by the ~change/2~ and ~put_change/3~ functions.
  + external to the application - for example data provided by the
    user in a form that needs to be type-converted and properly
    validated. This use case is primarily covered by the ~cast/4~
    function.
** Validations and constraints
- The difference between validations and constraints
  + is that most validations can be executed without a need to
    interact with the database and, therefore, are always executed
    before attempting to insert or update the entry in the
    database. Some validations may happen against the database but
    they are inherently unsafe. Those validations start with a
    ~unsafe_~ prefix, such as ~unsafe_validate_unique/3~.
  + constraints rely on the database and are always safe
  + validations are always checked before constraints. Constraints
    won’t even be checked in case validations failed
- example
  create the table
  #+BEGIN_SRC elixir
    defmodule Friends.Repo.Migrations.CreateUsers do
      use Ecto.Migration

      def change do
        create table(:users) do
          add(:name, :string)
          add(:email, :string)
          add(:age, :integer)
          timestamps()
        end

        create(unique_index(:users, [:email]))
      end
    end

  #+END_SRC
  define the schema
  #+BEGIN_SRC elixir
    defmodule User do
      use Ecto.Schema
      import Ecto.Changeset

      schema "users" do
        field :name
        field :email
        field :age, :integer
      end

      def changeset(user, params \\ %{}) do
        user
        |> cast(params, [:name, :email, :age])
        |> validate_required([:name, :email])
        |> validate_format(:email, ~r/@/)
        |> validate_inclusion(:age, 18..100)
        |> unique_constraint(:email)
      end
    end

    changeset = User.changeset(%User{}, %{age: 0, email: "mary@example.com"})
    {:error, changeset} = Repo.insert(changeset)
    changeset.errors #=> [age: {"is invalid", []}, name: {"can't be blank", []}]
  #+END_SRC
** Associations, embeds and on replace
- There are two primary APIs:
  1. ~cast_assoc/3~ and ~cast_embed/3~
  2. ~put_assoc/4~ and ~put_embed/4~

- ~cast_assoc/3~ and ~cast_embed/3~ - those functions are used when
  working with external data. In particular, they allow you to
  change associations and embeds alongside the parent struct, all at
  once.

- ~put_assoc/4~ and ~put_embed/4~ - it allows you to replace the
  association or embed as a whole. This can be used to move
  associated data from one entry to another, to completely remove or
  replace existing entries.

- The same way we have used changesets to manipulate embeds, we can
  also use them to change child associations at the same time we are
  manipulating the parent.

- ~cast_assoc~ (or ~cast_embed~) is used when you want to manage
  associations or embeds based on external parameters, such as the
  data received through Phoenix forms. In such cases, Ecto will
  compare the data existing in the struct with the data sent through
  the form and generate the proper operations. On the other hand, we
  use ~put_assoc~ (or ~put_embed~) when we aleady have the associations
  (or embeds) as structs and changesets, and we simply want to tell
  Ecto to take those entries as is.

- ~cast_assoc~ is the pendant to ~cast~. aka casting external data
  like coming from a form, while ~put_assocs~ expects you to supply
  already validated and properly checked structs or changesets of the
  association.

- ~cast_assoc(changeset, name, opts \\ [])~
  + This function should be used when working with the entire
    association at once (and not a single element of a many-style
    association) and using data external to the application.
  + ~cast_assoc/3~ is used when you want to create the associated record
    along with your changeset.
    #+BEGIN_SRC elixir
      defmodule User do
        def changeset(user, params) do
          user
          |> cast(params, @allowed_params)
          |> validate_required(@required_params)
          # Account.changeset is inferred by default
          |> cast_assoc(:account, required: true, with: &Account.registration_changeset/2)
        end
      end

      account = %{plan: "free"}
      user = %{email: "coolio@example.com", password: "bananas", account: account}
      User.changeset(%User{}, user)
    #+END_SRC
    + By default ~cast_assoc/3~ will use ~changeset/2~ in your associated
      model, but you can specify a different by passing the ~:with~
      option.

- ~put_assoc/4~
  is used when you already have an associated struct and
  you want to assign the association in your changset.
  #+BEGIN_SRC elixir
    defmodule Comment do
      def changeset(comment, params) do
        comment
        |> cast(params, @allowed_params)
        |> validate_required([:text])
        |> put_assoc(:user, params.user)
      end
    end

    comment = %{text: "Hey, sup?", user: some_user}
    Comment.changeset(%Comment{}, comment)
  #+END_SRC




** Schemaless changesets
- Such functionality makes Ecto extremely useful to cast, validate and
  prune data even if it is not meant to be persisted to the database.
  #+BEGIN_SRC elixir
    data  = %{}
    types = %{name: :string}
    params = %{name: "Callum"}
    changeset =
      {data, types}
      |> Ecto.Changeset.cast(params, Map.keys(types))
      |> Ecto.Changeset.validate_required(...)
      |> Ecto.Changeset.validate_length(...)
  #+END_SRC
**  The Ecto.Changeset struct
- The public fields are:
  + ~valid?~ - Stores if the changeset is valid
  + ~data~ - The changeset source data, for example, a struct
  + ~params~ - The parameters as given on changeset creation
  + ~changes~ - The changes from parameters that were approved in
    casting
  + ~errors~ - All errors from validations
  + ~required~ - All required fields as a list of atoms
  + ~action~ - The action to be performed with the changeset
  + ~types~ - Cache of the data’s field types
  + ~empty~_values - A list of values to be considered empty
  + ~repo~ - The repository applying the changeset (only set after a
    Repo function is called)
  + ~repo_opts~ - A keyword list of options given to the underlying
    repository operation
- The following fields are private and must not be accessed directly.
  + ~validations~
  + ~constraints~
  + ~filters~
