- Mostly from ecto documentation

* add ecto
1) generate necessities
   #+BEGIN_SRC
   mix ecto.gen.repo -r Friends.Repo
   #+END_SRC
2) checkout configuration at ~config/config.exs~
   #+BEGIN_SRC elixir
     config :friends, Friends.Repo,
       database: "friends_repo",
       username: "user",
       password: "pass",
       hostname: "localhost"
   #+END_SRC
3) ~lib/friends/repo.ex~
   #+BEGIN_SRC elixir
     defmodule Friends.Repo do
       use Ecto.Repo,
         otp_app: :friends,
         adapter: Ecto.Adapters.Postgres
     end
   #+END_SRC
   + ~otp_app~ tells Ecto which Elixir application it can look for
     database configuration in
4) start the repo process in ~lib/friends/application.ex~
   #+BEGIN_SRC elixir
     def start(_type, _args) do
       children = [
         Friends.Repo,
       ]
   #+END_SRC
5) add this to ~config/config.exs~
   #+BEGIN_SRC elixir
   config :friends, ecto_repos: [Friends.Repo]
   #+END_SRC
   This tells our application about the repo, which will allow us to
   run commands such as ~mix ecto.create~

* Setting up the database
- create the database
  #+BEGIN_SRC
  mix ecto.create
  #+END_SRC
- create a migration
  #+BEGIN_SRC elixir
  mix ecto.gen.migration create_people
  #+END_SRC
  generates a new migration file in ~priv/repo/migrations~
  #+BEGIN_SRC elixir
    defmodule Friends.Repo.Migrations.CreatePeople do
      use Ecto.Migration

      def change do
        create table(:people) do
          add(:first_name, :string)
          add(:last_name, :string)
          add(:age, :integer)
        end
      end
    end
  #+END_SRC
  NOTE: The naming convention for tables in Ecto databases is to use a
  pluralized name.

- run the migration to create the table
  #+BEGIN_SRC
  mix ecto.migrate
  #+END_SRC
  if you you made any mistake you can run ~mix ecto.rollback~

* Creating the schema
- The schema is an Elixir representation of data from our database.
- Schemas are commonly associated with a database table, however they
  can be associated with a database view as well
  #+BEGIN_SRC elixir
    defmodule Friends.Person do
      use Ecto.Schema

      schema "people" do            # database name
        field :first_name, :string
        field :last_name, :string
        field :age, :integer
      end
    end
  #+END_SRC
  + we’re telling Ecto that the ~Friends.Person~ schema maps to the
    ~people~ table in the database
  + We’ve called this schema ~Person~ because the naming convention in
    Ecto for schemas is a singularized name.
  + in iex
    #+BEGIN_SRC elixir
      iex(1)> person = %Friends.Person{}
      %Friends.Person{
        __meta__: #Ecto.Schema.Metadata<:built, "people">,
        age: nil,
        first_name: nil,
        id: nil,
        last_name: nil
      }
    #+END_SRC

* Inserting data
- We can insert a new record into our ~people~ table with this code:
  #+BEGIN_SRC elixir
  person = %Friends.Person{}
  Friends.Repo.insert(person)
  {:ok,
    %Friends.Person{
      __meta__: #Ecto.Schema.Metadata<:loaded, "people">,
      age: nil, first_name: nil, id: 1, last_name: nil
    }
  }
  # or
  {:ok, person} = Friends.Repo.insert(person)
  #+END_SRC
* Validating changes
- For this, Ecto has [[https://hexdocs.pm/ecto/Ecto.Changeset.html][changesets]]
  + how to use it
    1. filter and cast input
       #+BEGIN_SRC elixir
         import Ecto.Changeset

         params = %{"title" => "So What", "index" => "1", "duration" => 180, "foo" => "LOL"}

         changeset =
           %Track{}
           |> cast(params, [:title, :index, :duration])
       #+END_SRC
    2. validate
       #+BEGIN_SRC elixir
         changeset =
           validate_required(changeset, [:title, :index])
           |> validate_number(:index, greater_than: 0)
       #+END_SRC
    3. capture errors
       #+BEGIN_SRC elixir
         # see if it works
         case Repo.insert(changeset) do
           {:ok, track} -> IO.puts "Track #{track.name} successfully added"
           {:error, changeset} -> IO.puts changeset.errors
         end
       #+END_SRC

- sample
  #+BEGIN_SRC elixir
    defmodule Friends.Person do
      use Ecto.Schema

      schema "people" do
        field(:first_name, :string)
        field(:last_name, :string)
        field(:age, :integer)
      end


      # This changeset takes a `person` and a set of `params`, which are to be
      # the changes to apply to this person
      def changeset(person, params \\ %{}) do
        person
        |> Ecto.Changeset.cast(params, [:first_name, :last_name, :age])
        |> Ecto.Changeset.validate_required([:first_name, :last_name])
      end
    end
  #+END_SRC
- ~Ecto.Changeset.cast(person, params, [:first_name, :last_name, :age])~
  + it's ~cast(data, params, permitted, opts \\ [])~
  + Casting tells the changeset what parameters are allowed to be
    passed through in this changeset, and anything not in the list
    will be ignored.
- ~Ecto.Changeset.validate_required([:first_name, :last_name])~
  + it's ~validate_required(changeset, fields, opts \\ [])~
  + says that, for this changeset, we expect ~first_name~ and ~last_name~
    to have values specified

    with error
    #+BEGIN_SRC elixir
      iex(9)> person = %Friends.Person{}
      %Friends.Person{
        __meta__: #Ecto.Schema.Metadata<:built, "people">,
        age: nil,
        first_name: nil,
        id: nil,
        last_name: nil
      }

      iex(10)> changeset = Friends.Person.changeset(person, %{})
      #Ecto.Changeset<
        action: nil,
        changes: %{},
        errors: [
        first_name: {"can't be blank", [validation: :required]},
        last_name: {"can't be blank", [validation: :required]}
        ],
        data: #Friends.Person<>,
        valid?: false
      >

      iex(11)> {:error, changeset} = Friends.Repo.insert(changeset)
      {:error,
       #Ecto.Changeset<
         action: :insert,
         changes: %{},
         errors: [
         first_name: {"can't be blank", [validation: :required]},
         last_name: {"can't be blank", [validation: :required]}
         ],
         data: #Friends.Person<>,
         valid?: false
       >
      }

      iex(14)> changeset.errors
      [
        first_name: {"can't be blank", [validation: :required]},
        last_name: {"can't be blank", [validation: :required]}
      ]
    #+END_SRC

    valid changeset
    #+BEGIN_SRC elixir
      iex> person = %Friends.Person{}
      %Friends.Person{
        __meta__: #Ecto.Schema.Metadata<:built, "people">,
        age: nil,
        first_name: nil,
        id: nil,
        last_name: nil
      }

      iex> changeset = Friends.Person.changeset(person, %{first_name: "Ryan", last_name: "Bigg"})
      #Ecto.Changeset<
        action: nil,
        changes: %{first_name: "Ryan", last_name: "Bigg"},
        errors: [],
        data: #Friends.Person<>,
        valid?: true
      >

      iex(17)> changeset.valid?
      true

      iex> Friends.Repo.insert(changeset)

      10:02:59.746 [debug] QUERY OK db=3.9ms queue=1.9ms
      INSERT INTO "people" ("first_name","last_name") VALUES ($1,$2) RETURNING "id" ["Ryan", "Bigg"]
      {:ok,
       %Friends.Person{
         __meta__: #Ecto.Schema.Metadata<:loaded, "people">,
         age: nil,
         first_name: "Ryan",
         id: 3,
         last_name: "Bigg"
       }}
    #+END_SRC

  + NOTE: ~changeset.valid?~ will not check constraints (such as
    ~uniqueness_constraint~). For that, you will need to attempt to do
    an insertion and check for errors from the database. It’s for this
    reason it’s best practice to try inserting data and validate the
    returned tuple from ~Friends.Repo.insert~ to get the correct errors,
    as prior to insertion the changeset will only contain validation
    errors from the application itself.
* queries
1. construct the query
2. execute that query against the database by passing the query to the
   repository
** Fetching a single record
- build the query
  ~Friends.Person |> Ecto.Query.first~
  will generate an ~Ecto.Query~
  #+BEGIN_SRC
  #Ecto.Query<from p in Friends.Person, order_by: [asc: p.id], limit: 1>
  #+END_SRC

  We could construct this query ourselves
  #+BEGIN_SRC elixir
  require Ecto.Query
  Ecto.Query.from p in Friends.Person, order_by: [asc: p.id], limit: 1
  #+END_SRC
- execute the query
  #+BEGIN_SRC elixir
  iex> Friends.Person |> Ecto.Query.first |> Friends.Repo.one

  %Friends.Person{__meta__: #Ecto.Schema.Metadata<:loaded>,
  age: 28, first_name: "Ryan", id: 1, last_name: "Bigg"}
  #+END_SRC
  or get the last one
  #+BEGIN_SRC elixir
  iex> Friends.Person |> Ecto.Query.last |> Friends.Repo.one

  %Friends.Person{__meta__: #Ecto.Schema.Metadata<:loaded>,
  age: 26, first_name: "Jane", id: 3, last_name: "Smith"}
  #+END_SRC
  The ~Ecto.Repo.one~ function will only return a struct if there is
  one record in the result from the database. If there is more than
  one record returned, an ~Ecto.MultipleResultsError~ exception will be
  thrown.

** Fetching all records
#+BEGIN_SRC elixir
iex> Friends.Person |> Friends.Repo.all
#+END_SRC
** Fetch a single record based on ID
#+BEGIN_SRC elixir
iex> Friends.Person |> Friends.Repo.get(1)
%Friends.Person{__meta__: #Ecto.Schema.Metadata<:loaded>,
 age: 28, first_name: "Ryan", id: 1, last_name: "Bigg"}
#+END_SRC
** Fetch a single record based on a specific attribute
- If we want to get a record based on something other than the ~id~
  attribute, we can use ~get_by~:
  #+BEGIN_SRC elixir
    iex> Friends.Person |> Friends.Repo.get_by(first_name: "Ryan")

    %Friends.Person{__meta__: #Ecto.Schema.Metadata<:loaded>,
                    age: 28, first_name: "Ryan", id: 1, last_name: "Bigg"}
  #+END_SRC
** Filtering results
- If we want to get multiple records matching a specific attribute, we
  can use ~where~:
  #+BEGIN_SRC elixir
  Friends.Person |> Ecto.Query.where(last_name: "Smith") |> Friends.Repo.all

  [%Friends.Person{__meta__: #Ecto.Schema.Metadata<:loaded>, age: 27,
  first_name: "John", id: 2, last_name: "Smith"},

  %Friends.Person{__meta__: #Ecto.Schema.Metadata<:loaded>, age: 26,
  first_name: "Jane", id: 3, last_name: "Smith"}]
  #+END_SRC
  the generated query is
  #+BEGIN_SRC
  #Ecto.Query<from p in Friends.Person, where: p.last_name == "Smith">
  #+END_SRC
  which means we can get the same result with
  #+BEGIN_SRC
  Ecto.Query.from(p in Friends.Person, where: p.last_name == "Smith") |> Friends.Repo.all
  #+END_SRC
  with both syntax we have to pin (^) the variables
  #+BEGIN_SRC elixir
    iex> last_name = "Smith"
    iex> Friends.Person |> Ecto.Query.where(last_name: ^last_name) |> Friends.Repo.all

    # Or:

    iex> last_name = "Smith"
    iex> Ecto.Query.from(p in Friends.Person, where: p.last_name == ^last_name) |> Friends.Repo.all
  #+END_SRC
  The pin operator instructs the query builder to use parameterised
  SQL queries protecting against SQL injection.

** Composing Ecto queries
   #+BEGIN_SRC elixir
     query = Friends.Person |> Ecto.Query.where(last_name: "Smith")

     query = query |> Ecto.Query.where(first_name: "Jane")

     #Ecto.Query<
                   from p in Friends.Person, where: p.last_name == "Smith", where: p.first_name == "Jane">
   #+END_SRC
** Updating records
- Updating records in Ecto requires us to first fetch a record from
  the database. We then create a changeset from that record and the
  changes we want to make to that record, and then call the
  ~Ecto.Repo.update~ function.
  + fetch
    #+BEGIN_SRC
    person = Friends.Person |> Ecto.Query.first |> Friends.Repo.one
    #+END_SRC
  + build a changeset
    #+BEGIN_SRC
    changeset = Friends.Person.changeset(person, %{age: 29})
    #+END_SRC
    We need to build a changeset because if we just create a new
    ~Friends.Person~ struct with the new age, Ecto wouldn’t be able to
    know that the age has changed without inspecting the database
  + update
    #+BEGIN_SRC
    iex> Friends.Repo.update(changeset)
    {:ok,
    %Friends.Person{__meta__: #Ecto.Schema.Metadata<:loaded>, age: 29,
    first_name: "Ryan", id: 1, last_name: "Bigg"}}
    #+END_SRC
** Deleting records
- Similar to updating, we must first fetch a record from the database
  and then call ~Friends.Repo.delete~ to delete that record:
  #+BEGIN_SRC elixir
  iex> person = Friends.Repo.get(Friends.Person, 1)
  iex> Friends.Repo.delete(person)
  #=> {:ok,
  %Friends.Person{__meta__: #Ecto.Schema.Metadata<:deleted>, age: 29,
  first_name: "Ryan", id: 2, last_name: "Bigg"}}

  #+END_SRC
===================
* Ecto
** Ecto.Repo
- repositories are wrappers around the data store. Via the repository,
  we can create, update, destroy and query existing entries. A
  repository needs an adapter and credentials to communicate to the
  databas

** Ecto.Schema
- schemas are used to map any data source into an Elixir struct. We
  will often use them to map tables into Elixir data but that’s one of
  their use cases and not a requirement for using Ecto

** Ecto.Changeset
- changesets provide a way for developers to filter and cast external
  parameters, as well as a mechanism to track and validate changes
  before they are applied to your data

** Ecto.Query
- written in Elixir syntax, queries are used to retrieve information
  from a given repository. Queries in Ecto are secure, avoiding common
  problems like SQL Injection, while still being composable, allowing
  developers to build queries piece by piece instead of all at once
  #+BEGIN_SRC elixir
    import Ecto.Query, only: [from: 2]

    query = from u in User,
      where: u.age > 18 or is_nil(u.email),
      select: u

    # Returns %User{} structs matching the query
    Repo.all(query)
  #+END_SRC
  In the example above we relied on our schema but queries can also be
  made directly against a table by giving the table name as a
  string. In such cases, the data to be fetched must be explicitly
  outlined:
  #+BEGIN_SRC elixir
    query = from u in "users",
              where: u.age > 18 or is_nil(u.email),
              select: %{name: u.name, age: u.age}

    # Returns maps as defined in select
    Repo.all(query)
  #+END_SRC

- Queries are defined and extended with the from macro. The supported
  keywords are:
  #+BEGIN_SRC
  :distinct
  :where
  :order_by
  :offset
  :limit
  :lock
  :group_by
  :having
  :join
  :select
  :preload
  #+END_SRC
- When writing a query, you are inside Ecto’s query syntax. In order
  to access params values or invoke Elixir functions, you need to use
  the ^ operator, which is overloaded by Ecto:
  #+BEGIN_SRC elixir
    def min_age(min) do
      from u in User, where: u.age > ^min
    end
  #+END_SRC

* Associations
- Ecto supports defining associations on schemas:

  create ~comments~ table
  #+BEGIN_SRC elixir
    defmodule Friends.Repo.Migrations.CreateComments do
      use Ecto.Migration

      def change do
        create table(:comments) do
          add(:post_id, references(:posts))
          add(:body, :text)
          timestamps()
        end
      end
    end
  #+END_SRC
  create ~posts~ table
  #+BEGIN_SRC elixir
    defmodule Friends.Repo.Migrations.CreatePosts do
      use Ecto.Migration

      def change do
        create table(:posts) do
          add(:title, :string)
          add(:body, :text)
          timestamps()
        end
      end
    end
  #+END_SRC
  create ~Post~ schema
  #+BEGIN_SRC elixir
    defmodule Friends.Post do
      use Ecto.Schema

      schema "posts" do
        field(:title)
        field(:body)
        has_many(:comments, Friends.Comment)

        timestamps()
      end
    end
  #+END_SRC
  create ~Comment~ schema
  #+BEGIN_SRC elixir
  defmodule Friends.Post do
    use Ecto.Schema

    schema "posts" do
      field(:title)
      field(:body)
      has_many(:comments, Friends.Comment)

      timestamps()
    end
  end
  #+END_SRC
- The difference between ~has_one/3~ and ~belongs_to/3~ is that the
  foreign key is always defined in the schema that invokes
  ~belongs_to/3~. You can think of the schema that calls ~has_*~ as
  the parent schema and the one that invokes ~belongs_to~ as the child
  one.

- When an association is defined, Ecto also defines a field in the
  schema with the association name. By default, associations are not
  loaded into this field:

  #+BEGIN_SRC
  iex> post = Repo.get(Post, 42)
  iex> post.comments
  #Ecto.Association.NotLoaded<...>
  #+END_SRC
  + but you can preload
    #+BEGIN_SRC elixir
    Repo.all(from(p in Post, preload: [:comments])) # it runs two queries
    #+END_SRC

  + Preloading can also be done with a pre-defined join value:
    #+BEGIN_SRC elixir
    Repo.all from p in Post,
            join: c in assoc(p, :comments),
            preload: [comments: c]
    #+END_SRC
    + performs a single query, finding all posts and the respective
      comments that match the criteria. Because this query performs a
      JOIN

  + for the simple cases, preloading can also be done after a
    collection was fetched:
    #+BEGIN_SRC
    posts = Repo.all(Post) |> Repo.preload(:comments)
    #+END_SRC
  + get all the comments
    #+BEGIN_SRC elixir
      import Ecto

      post = Repo.get(Post, 1)

      # Get all comments for the given post
      Repo.all assoc(post, :comments)

      # Or build a query on top of the associated comments
      query = from c in assoc(post, :comments), where: not is_nil(c.title)
      Repo.all(query)
    #+END_SRC
** Manipulating associations
-
  #+BEGIN_SRC elixir
    Repo.insert!(%Post{
      title: "Hello",
      body: "world",
      comments: [
        %Comment{body: "Excellent!"}
      ]
    })
  #+END_SRC
-
  #+BEGIN_SRC elixir
    post = Ecto.Changeset.change(%Post{}, title: "Hello", body: "world")
    comment = Ecto.Changeset.change(%Comment{}, body: "Excellent!")
    post_with_comments = Ecto.Changeset.put_assoc(post, :comments, [comment])
    Repo.insert!(post_with_comments)
  #+END_SRC
- handling each entry individually inside a transaction
  #+BEGIN_SRC elixir
    Repo.transaction fn ->
      post = Repo.insert!(%Post{title: "Hello", body: "world"})

      # Build a comment from the post struct
      comment = Ecto.build_assoc(post, :comments, body: "Excellent!")

      Repo.insert!(comment)
    end
  #+END_SRC
  + ~Ecto.build_assoc/3~ builds the comment using the id currently set
    in the post struct. It is equivalent to:
    #+BEGIN_SRC elixir
    %Comment{post_id: post.id, body: "Excellent!"}
    #+END_SRC
- ~Ecto.build_assoc/3~
  + The ~Ecto.build_assoc/3~ function is specially useful in Phoenix
    controllers. For example, when creating the post, one would do:
    #+BEGIN_SRC elixir
    Ecto.build_assoc(current_user, :post)
    #+END_SRC
    As we likely want to associate the post to the user currently
    signed in the application. In another controller, we could build a
    comment for an existing post with:
    #+BEGIN_SRC elixir
    Ecto.build_assoc(post, :comments)
    #+END_SRC
** Deleting associations
- When defining a ~has_many/3~, ~has_one/3~ and friends, you can also pass
  a ~:on_delete~ option that specifies which action should be performed
  on associations when the parent is deleted.
  #+BEGIN_SRC elixir
  has_many :comments, MyApp.Comment, on_delete: :delete_all
  #+END_SRC
  - Besides the value above, ~:nilify_all~ is also supported, with
    ~:nothing~ being the default.
* Embeds
- Ecto also supports embeds. While associations keep parent and child
  entries in different tables, embeds stores the child along side the
  parent.

- Databases like MongoDB have native support for embeds. Databases
  like PostgreSQL uses a mixture of JSONB (~embeds_one/3~) and ARRAY
  columns to provide this functionality.

* Ecto.Changeset module
- Changesets allow filtering, casting, validation and definition of
  constraints when manipulating structs.
- The functions ~cast/4~ and ~change/2~ are the usual entry points for
  creating changesets
  #+BEGIN_SRC elixir
  comment = Ecto.Changeset.change(%Comment{}, body: "Excellent!")
  #+END_SRC
** External vs internal data
- Changesets allow working with both kinds of data:
  + internal to the application - for example programmatically
    generated, or coming from other subsystems. This use case is
    primarily covered by the ~change/2~ and ~put_change/3~ functions.
  + external to the application - for example data provided by the
    user in a form that needs to be type-converted and properly
    validated. This use case is primarily covered by the ~cast/4~
    function.
** Validations and constraints
- The difference between validations and constraints
  + is that most validations can be executed without a need to
    interact with the database and, therefore, are always executed
    before attempting to insert or update the entry in the
    database. Some validations may happen against the database but
    they are inherently unsafe. Those validations start with a
    ~unsafe_~ prefix, such as ~unsafe_validate_unique/3~.
  + constraints rely on the database and are always safe
  + validations are always checked before constraints. Constraints
    won’t even be checked in case validations failed
- example
  create the table
  #+BEGIN_SRC elixir
    defmodule Friends.Repo.Migrations.CreateUsers do
      use Ecto.Migration

      def change do
        create table(:users) do
          add(:name, :string)
          add(:email, :string)
          add(:age, :integer)
          timestamps()
        end

        create(unique_index(:users, [:email]))
      end
    end

  #+END_SRC
  define the schema
  #+BEGIN_SRC elixir
    defmodule User do
      use Ecto.Schema
      import Ecto.Changeset

      schema "users" do
        field :name
        field :email
        field :age, :integer
      end

      def changeset(user, params \\ %{}) do
        user
        |> cast(params, [:name, :email, :age])
        |> validate_required([:name, :email])
        |> validate_format(:email, ~r/@/)
        |> validate_inclusion(:age, 18..100)
        |> unique_constraint(:email)
      end
    end

    changeset = User.changeset(%User{}, %{age: 0, email: "mary@example.com"})
    {:error, changeset} = Repo.insert(changeset)
    changeset.errors #=> [age: {"is invalid", []}, name: {"can't be blank", []}]
  #+END_SRC
** Associations, embeds and on replace
- There are two primary APIs:
  1. ~cast_assoc/3~ and ~cast_embed/3~
  2. ~put_assoc/4~ and ~put_embed/4~

- ~cast_assoc/3~ and ~cast_embed/3~ - those functions are used when
  working with external data. In particular, they allow you to
  change associations and embeds alongside the parent struct, all at
  once.

- ~put_assoc/4~ and ~put_embed/4~ - it allows you to replace the
  association or embed as a whole. This can be used to move
  associated data from one entry to another, to completely remove or
  replace existing entries.

- The same way we have used changesets to manipulate embeds, we can
  also use them to change child associations at the same time we are
  manipulating the parent.

- ~cast_assoc~ (or ~cast_embed~) is used when you want to manage
  associations or embeds based on external parameters, such as the
  data received through Phoenix forms. In such cases, Ecto will
  compare the data existing in the struct with the data sent through
  the form and generate the proper operations. On the other hand, we
  use ~put_assoc~ (or ~put_embed~) when we aleady have the associations
  (or embeds) as structs and changesets, and we simply want to tell
  Ecto to take those entries as is.

- ~cast_assoc~ is the pendant to ~cast~. aka casting external data
  like coming from a form, while ~put_assocs~ expects you to supply
  already validated and properly checked structs or changesets of the
  association.

- ~cast_assoc(changeset, name, opts \\ [])~
  + This function should be used when working with the entire
    association at once (and not a single element of a many-style
    association) and using data external to the application.
  + ~cast_assoc/3~ is used when you want to create the associated record
    along with your changeset.
    #+BEGIN_SRC elixir
      defmodule User do
        def changeset(user, params) do
          user
          |> cast(params, @allowed_params)
          |> validate_required(@required_params)
          # Account.changeset is inferred by default
          |> cast_assoc(:account, required: true, with: &Account.registration_changeset/2)
        end
      end

      account = %{plan: "free"}
      user = %{email: "coolio@example.com", password: "bananas", account: account}
      User.changeset(%User{}, user)
    #+END_SRC
    + By default ~cast_assoc/3~ will use ~changeset/2~ in your associated
      model, but you can specify a different by passing the ~:with~
      option.

- ~put_assoc/4~
  is used when you already have an associated struct and
  you want to assign the association in your changset.
  #+BEGIN_SRC elixir
    defmodule Comment do
      def changeset(comment, params) do
        comment
        |> cast(params, @allowed_params)
        |> validate_required([:text])
        |> put_assoc(:user, params.user)
      end
    end

    comment = %{text: "Hey, sup?", user: some_user}
    Comment.changeset(%Comment{}, comment)
  #+END_SRC




** Schemaless changesets
- Such functionality makes Ecto extremely useful to cast, validate and
  prune data even if it is not meant to be persisted to the database.
  #+BEGIN_SRC elixir
    data  = %{}
    types = %{name: :string}
    params = %{name: "Callum"}
    changeset =
      {data, types}
      |> Ecto.Changeset.cast(params, Map.keys(types))
      |> Ecto.Changeset.validate_required(...)
      |> Ecto.Changeset.validate_length(...)
  #+END_SRC
**  The Ecto.Changeset struct
- The public fields are:
  + ~valid?~ - Stores if the changeset is valid
  + ~data~ - The changeset source data, for example, a struct
  + ~params~ - The parameters as given on changeset creation
  + ~changes~ - The changes from parameters that were approved in
    casting
  + ~errors~ - All errors from validations
  + ~required~ - All required fields as a list of atoms
  + ~action~ - The action to be performed with the changeset
  + ~types~ - Cache of the data’s field types
  + ~empty~_values - A list of values to be considered empty
  + ~repo~ - The repository applying the changeset (only set after a
    Repo function is called)
  + ~repo_opts~ - A keyword list of options given to the underlying
    repository operation
- The following fields are private and must not be accessed directly.
  + ~validations~
  + ~constraints~
  + ~filters~
* Ecto.LogEntry
* Ecto.Multi
- ~Ecto.Multi~ is a data structure for grouping multiple Repo
  operations.
- ~Ecto.Multi~ makes it possible to pack operations that should be
  performed in a single database transaction and gives a way to
  introspect the queued operations without actually performing them.
- Each operation is given a name that is unique and will identify its
  result in case of success or failure.
- All operations will be executed in the order they were added.
- The ~Ecto.Multi~ structure should be considered opaque. You can use
  ~%Ecto.Multi{}~ to pattern match the type, but accessing fields or
  directly modifying them is not advised.
- ~Ecto.Multi.to_list/1~ returns a canonical representation of the
  structure that can be used for introspection.

- Example

  The use case we’ll be looking into is resetting a password. We
  need to update the account with proper information, log the
  request and remove all current sessions:
  #+BEGIN_SRC elixir
        defmodule PasswordManager do
          alias Ecto.Multi

          def reset(account, params) do
            Multi.new
            |> Multi.update(:account, Account.password_reset_changeset(account, params))
            |> Multi.insert(:log, Log.password_reset_changeset(account, params))
            |> Multi.delete_all(:sessions, Ecto.assoc(account, :sessions))
          end
        end

        result = Repo.transaction(PasswordManager.reset(account, params))

        case result do
          {:ok, %{account: account, log: log, sessions: sessions}} ->
            # Operation was successful, we can access results (exactly the same
            # we would get from running corresponding Repo functions) under keys
            # we used for naming the operations.
            {:error, failed_operation, failed_value, changes_so_far} ->
            # One of the operations failed. We can access the operation's failure
            # value (like changeset for operations on changesets) to prepare a
            # proper response. We also get access to the results of any operations
            # that succeeded before the indicated operation failed. However, any
            # successful operations would have been rolled back.
    end
  #+END_SRC
  + test it
    #+BEGIN_SRC elixir

      test "dry run password reset" do
        account = %Account{password: "letmein"}
        multi = PasswordManager.reset(account, params)

        assert [
          {:account, {:update, account_changeset, []}},
          {:log, {:insert, log_changeset, []}},
          {:sessions, {:delete_all, query, []}}
        ] = Ecto.Multi.to_list(multi)

        # We can introspect changesets and query to see if everything
        # is as expected, for example:
        assert account_changeset.valid?
        assert log_changeset.valid?
        assert inspect(query) == "#Ecto.Query<from a in Session>"
      end
    #+END_SRC
  + The name of each operation does not have to be an atom. This can
    be particularly useful when you wish to update a collection of
    changesets at once, and track their errors individually:
    #+BEGIN_SRC elixir
      accounts = [%Account{id: 1}, %Account{id: 2}]

      Enum.reduce(accounts, Multi.new(), fn account, multi ->
        Multi.update(
          multi,
          {:account, account.id},
          Account.password_reset_changeset(account, params)
        )
      end)
    #+END_SRC
* Ecto.Query
- Queries are used to retrieve and manipulate data from a repository
- Ecto queries come in two flavors: keyword-based and macro-based.
-
  #+BEGIN_SRC elixir
    # Imports only from/2 of Ecto.Query
    import Ecto.Query, only: [from: 2]

    # Create a query
    query = from u in "users",
              where: u.age > 18,
              select: u.name

    # Send the query to the repository
    Repo.all(query)
  #+END_SRC
** Query expressions
- Ecto allows a limited set of expressions inside queries. In the
  query below, for example, we use ~u.age~ to access a field, the ~>~
  comparison operator and the literal ~0~:
  #+BEGIN_SRC elixir
  query = from u in "users", where: u.age > 0, select: u.name
  #+END_SRC
  + Lists all functions allowed in the query API.
    * Comparison operators: ~==~, ~!=~, ~<=~, ~>=~, ~<~, ~>~
    * Arithmetic operators: ~+~, ~-~, ~*~, ~/~
    * Boolean operators: ~and~, ~or~, ~not~
    * Inclusion operator: ~in/2~
    * Search functions: ~like/2~ and ~ilike/2~
    * Null check functions: ~is_nil/1~
    * Aggregates: ~count/0~, ~count/1~, ~avg/1~, ~sum/1~, ~min/1~, ~max/1~
    * Date/time intervals: ~datetime_add/3~, ~date_add/3~, ~from_now/2~, ~ago/2~
    * Inside select: ~struct/2~, ~map/2~, ~merge/2~ and literals (map, tuples, lists, etc)
    * General: ~fragment/1~, ~field/2~ and ~type/2~
  + also following literals are supported in queries
    * Integers: ~1~, ~2~, ~3~
    * Floats: ~1.0~, ~2.0~, ~3.0~
    * Booleans: ~true~, ~false~
    * Binaries: ~<<1, 2, 3>>~
    * Strings: ~"foo bar"~, ~~s(this is a string)~
    * Arrays: ~[1, 2, 3]~, ~~w(interpolate words)~

** Interpolation and casting
- External values and Elixir expressions can be injected into a query
  expression with ~^~:
  #+BEGIN_SRC elixir
    def with_minimum(age, height_ft) do
      from u in "users",
        where: u.age > ^age and u.height > ^(height_ft * 3.28),
        select: u.name
    end

    with_minimum(18, 5.0)
  #+END_SRC
- explicitly tell Ecto what is the expected type of the value being
  interpolated
  #+BEGIN_SRC elixir
    age = "18"
    Repo.all(from u in "users",
              where: u.age > type(^age, :integer),
              select: u.name)
  #+END_SRC
** ~nil~ comparison
- nil comparison in filters, such as where and having, is forbidden
  and it will raise an error:
  #+BEGIN_SRC elixir
  # Raises if the variable age (in this case used with ^ operator) is nil
  from u in User, where: u.age == ^age
  #+END_SRC
- check that value is nil, use ~is_nil/1~
  #+BEGIN_SRC elixir
  from u in User, where: is_nil(u.age)
  #+END_SRC
** Composition
- Ecto queries are composable
  #+BEGIN_SRC elixir
    # Create a query
    query = from u in User, where: u.age > 18

    # Extend the query
    query = from u in query, select: u.name
  #+END_SRC
- Any value can be used on the right-side of ~in~ as long as it
  implements the [[https://hexdocs.pm/ecto/Ecto.Queryable.html][~Ecto.Queryable]]~ protocol.
** Positional bindings
- On the left side of ~in~ we specify the query bindings. This is done
  inside ~from~ and ~join~ clauses
- In the query below ~u~ is a binding and ~u.age~ is a field access using
  this binding
  #+BEGIN_SRC elixir
  query = from u in User, where: u.age > 18
  #+END_SRC
- When using joins, the bindings should be matched in the order they
  are specified:
  #+BEGIN_SRC elixir
    # Create a query
    query = from p in Post,
              join: c in Comment, where: c.post_id == p.id

    # Extend the query
    query = from [p, c] in query,
              select: {p.title, c.body}
  #+END_SRC
  + You are not required to specify all bindings when composing
  + if you are interested only on the last binding (or the last
    bindings) in a query, you can use ~...~ to specify “all bindings
    before” and match on the last one.
    #+BEGIN_SRC elixir
    from [p, ..., c] in posts_with_comments, select: {p.title, c.body}
    #+END_SRC
    * In other words, ~...~ will include all the binding between the
      first and the last, which may be no binding at all, one or many.
** Named bindings
- We can named the bindings. This approach lets us not worry about
  keeping track of the position of the bindings when composing the
  query.
  #+BEGIN_SRC elixir
    posts_with_comments =
      from p in query,
        join: c in Comment, as: :comment, where: c.post_id == p.id

    from [p, comment: c] in posts_with_comments, select: {p.title, c.body}
  #+END_SRC
  a name can be assigned to the first binding as well:
  #+BEGIN_SRC elixir
    from p in Post, as: :post
  #+END_SRC
  Only atoms are accepted for binding names. Named binding references
  are expected to be placed in the tail position of the bindings list

** Bindingless operations
- bindings are not necessary when the query has only the ~from~ clause.
  #+BEGIN_SRC elixir
    from Post,
      where: [category: "fresh and new"],
      order_by: [desc: :published_at],
      select: [:id, :title, :body]


    # It is equivalent to:
    from p in Post,
      where: p.category == "fresh and new",
      order_by: [desc: p.published_at],
      select: struct(p, [:id, :title, :body])


    # we can also dynamically build them
    where = [category: "fresh and new"]
    order_by = [desc: :published_at]
    select = [:id, :title, :body]
    from Post, where: ^where, order_by: ^order_by, select: ^select
  #+END_SRC
** Fragments
- It is not possible to represent all possible database queries using
  Ecto’s query syntax. When such is required, it is possible to use
  fragments to send any expression to the database
- Ecto provides fragments to inject SQL (and non-SQL) fragments into
  queries
  #+BEGIN_SRC elixir
    from p in Post,
      where: is_nil(p.published_at) and
             fragment("lower(?)", p.title) == ^title
  #+END_SRC
  we are using the ~lower~ procedure in the database to downcase the
  ~title~ column
- [[https://hexdocs.pm/ecto/Ecto.Query.API.html#fragment/1][doc]]

** Macro API
- keywords query syntax
  #+BEGIN_SRC elixir
    import Ecto.Query
    from u in "users", where: u.age > 18, select: u.name
  #+END_SRC
- Ecto also supports a pipe-based syntax:
  #+BEGIN_SRC elixir
    "users"
    |> where([u], u.age > 18)
    |> select([u], u.name)
  #+END_SRC
- The downside of using macros is that the binding must be specified
  for every operation. However, since keyword-based and pipe-based
  examples are equivalent, the bindingless syntax also works for
  macros:
  #+BEGIN_SRC elixir
    "users"
    |> where([u], u.age > 18)
    |> select([:name])
  #+END_SRC

** Query Prefix
- It is possible to set a prefix for the queries. For Postgres users,
  this will specify the schema where the table is located, while for
  MySQL users this will specify the database where the table is
  located. When no prefix is set, Postgres queries are assumed to be
  in the public schema, while MySQL queries are assumed to be in the
  database set in the config for the repo.
- The query prefix may be set either for the whole query or on each
  individual ~from~ and ~join~ expression. If a ~prefix~ is not given to a
  ~from~ or a ~join~, the prefix of the schema given to the from or join
  is used.
- examples
  #+BEGIN_SRC elixir
  results = Repo.all(query, prefix: "accounts")
  #+END_SRC
  #+BEGIN_SRC elixir
    results =
      query # May be User or an Ecto.Query itself
      |> Ecto.Queryable.to_query
      |> Map.put(:prefix, "accounts")
      |> Repo.all()
  #+END_SRC
  #+BEGIN_SRC elixir
    results =from u in User,
      prefix: "accounts",
      join: p in assoc(u, :posts),
      prefix: "public"
  #+END_SRC
- prefix lookup precedence:
  + The ~:prefix~ option given to ~from~ / ~join~ has the highest precedence
  + Then it falls back to the ~@schema_prefix~ attribute declared in the
    schema given to ~from~ / ~join~
  + Then it falls back to the query prefix

*** functions
- ~distinct(query, binding \\ [], expr)~
  #+BEGIN_SRC elixir
    # Returns the list of different categories in the Post schema
    from(p in Post, distinct: true, select: p.category)

    # If your database supports DISTINCT ON(),
    # you can pass expressions to distinct too
    from(p in Post,
       distinct: p.category,
       order_by: [p.date])

    # The DISTINCT ON() also supports ordering similar to ORDER BY.
    from(p in Post,
       distinct: [desc: p.category],
       order_by: [p.date])

    # Using atoms
    from(p in Post, distinct: :category, order_by: :date)


    # Expressions example
    Post
    |> distinct(true)
    |> order_by([p], [p.category, p.author])
  #+END_SRC
- ~exclude(query, field)~
  Resets a previously set field on a query.
  #+BEGIN_SRC elixir
  Ecto.Query.exclude(query, :join)
  Ecto.Query.exclude(query, :where)
  Ecto.Query.exclude(query, :order_by)
  Ecto.Query.exclude(query, :group_by)
  Ecto.Query.exclude(query, :having)
  Ecto.Query.exclude(query, :distinct)
  Ecto.Query.exclude(query, :select)
  Ecto.Query.exclude(query, :combinations)
  Ecto.Query.exclude(query, :limit)
  Ecto.Query.exclude(query, :offset)
  Ecto.Query.exclude(query, :lock)
  Ecto.Query.exclude(query, :preload)
  Ecto.Query.exclude(query, :inner_join)
  Ecto.Query.exclude(query, :cross_join)
  Ecto.Query.exclude(query, :left_join)
  Ecto.Query.exclude(query, :right_join)
  Ecto.Query.exclude(query, :full_join)
  Ecto.Query.exclude(query, :inner_lateral_join)
  Ecto.Query.exclude(query, :left_lateral_join)
  #+END_SRC
  keep in mind that if a join is removed and its bindings were
  referenced elsewhere, the bindings won’t be removed, leading to a
  query that won’t compile.
- ~group_by(query, binding \\ [], expr)~
  + Groups together rows from the schema that have the same values in
    the given fields.
    #+BEGIN_SRC elixir
      # Returns the number of posts in each category
      from(p in Post,
        group_by: p.category,
        select: {p.category, count(p.id)})

      # Using atoms
      from(p in Post, group_by: :category, select: {p.category, count(p.id)})

      # Using direct fields access
      from(p in Post,
        join: c in assoc(p, :category)
        group_by: [p.id, c.name])

      # Expressions example
      Post |> group_by([p], p.category) |> select([p], count(p.id))
    #+END_SRC
- ~having(query, binding \\ [], expr)~
  + Like ~where~, ~having~ filters rows from the schema, but after the
    grouping is performed giving it the same semantics as ~select~ for a
    grouped query. ~having~ groups the query even if
    the query has no ~group_by~ expression.
    #+BEGIN_SRC elixir
      # Returns the number of posts in each category where the
      # average number of comments is above ten
      from(p in Post,
        group_by: p.category,
        having: avg(p.num_comments) > 10,
        select: {p.category, count(p.id)})

      # Expressions example
      Post
      |> group_by([p], p.category)
      |> having([p], avg(p.num_comments) > 10)
      |> select([p], count(p.id))
    #+END_SRC
- ~preload(query, bindings \\ [], expr)~
  #+BEGIN_SRC elixir
  Repo.all from p in Post, preload: [:comments]
  #+END_SRC
  + The example above will fetch all posts from the database and then
    do a separate query returning all comments associated with the
    given posts.
  + you may want posts and comments to be selected and filtered in the
    same query:
    #+BEGIN_SRC elixir
      Repo.all from p in Post,
                 join: c in assoc(p, :comments),
                 where: c.published_at > p.updated_at,
                 preload: [comments: c]
    #+END_SRC
  + Note: keep in mind operations like limit and offset in the preload
    query will affect the whole result set and not each
    association. For example, the query below:
    #+BEGIN_SRC elixir
      comments_query = from c in Comment, order_by: c.popularity, limit: 5
      Repo.all from p in Post, preload: [comments: ^comments_query]
    #+END_SRC
    won’t bring the top of comments per post. Rather, it will only
    bring the 5 top comments across all posts.
* Ecto.Repo behaviour
- A repository maps to an underlying data store, controlled by the
  adapter. For example, Ecto ships with a Postgres adapter
- When used, the repository expects the ~:otp_app~ as option. The
  ~:otp_app~ should point to an OTP application that has the repository
  configuration.
  #+BEGIN_SRC elixir
    defmodule Repo do
      use Ecto.Repo,
        otp_app: :my_app,
        adapter: Ecto.Adapters.Postgres
    end
  #+END_SRC
  + Could be configured with:
    #+BEGIN_SRC elixir
      config :my_app, Repo,
        database: "ecto_simple",
        username: "postgres",
        password: "postgres",
        hostname: "localhost"
    #+END_SRC
  + Most of the configuration that goes into the config is specific to
    the adapter, so check ~Ecto.Adapters.Postgres~ documentation
- Almost all of the repository operations accept the following
  options:
  + ~:timeout~ - The time in milliseconds to wait for the query call
    to finish, ~:infinity~ will wait indefinitely (default: 15000);
  + ~:log~ - When false, does not log the query
  + ~:telemetry_event~ - The telemetry event name to dispatch the
    event under
- ~insert(struct_or_changeset, opts)~
  - In case a struct is given, the struct is converted into a
    changeset with all non-nil fields as part of the changeset.
  - In case a changeset is given, the changes in the changeset are
    merged with the struct fields, and all of them are sent to the
     database.
- ~load(module_or_map, data)~
  Loads ~data~ into a struct or a map.
  #+BEGIN_SRC elixir
    iex> result = Ecto.Adapters.SQL.query!(MyRepo, "SELECT * FROM users", [])
    iex> Enum.map(result.rows, &MyRepo.load(User, {result.columns, &1}))
    [%User{...}, ...]
  #+END_SRC
- ~preload(structs_or_struct_or_nil, preloads, opts)~
  + Preloads all associations on the given struct or structs.
  + This is similar to ~Ecto.Query.preload/3~ except it allows you to
    preload structs after they have been fetched from the database.
    #+BEGIN_SRC elixir
      # Use a single atom to preload an association
      posts = Repo.preload posts, :comments

      # Use a list of atoms to preload multiple associations
      posts = Repo.preload posts, [:comments, :authors]

      # Use a keyword list to preload nested associations as well
      posts = Repo.preload posts, [comments: [:replies, :likes], authors: []]

      # Use a keyword list to customize how associations are queried
      posts = Repo.preload posts, [comments: from(c in Comment, order_by: c.published_at)]

      # Use a two-element tuple for a custom query and nested association definition
      query = from c in Comment, order_by: c.published_at
      posts = Repo.preload posts, [comments: {query, [:replies, :likes]}]
    #+END_SRC
- ~transaction(fun_or_multi, opts)~
  + Runs the given function or ~Ecto.Multi~ inside a transaction.
    #+BEGIN_SRC elixir
      import Ecto.Changeset, only: [change: 2]

      MyRepo.transaction(fn ->
        MyRepo.update!(change(alice, balance: alice.balance - 10))
        MyRepo.update!(change(bob, balance: bob.balance + 10))
      end)

      # Roll back a transaction explicitly
      MyRepo.transaction(fn ->
        p = MyRepo.insert!(%Post{})
        if not Editor.post_allowed?(p) do
          MyRepo.rollback(:posting_not_allowed)
        end
      end)

      # With Ecto.Multi
      Ecto.Multi.new
      |> Ecto.Multi.insert(:post, %Post{})
      |> MyRepo.transaction
    #+END_SRC
- ~update_all(queryable, updates, opts)~
  #+BEGIN_SRC elixir
    MyRepo.update_all(Post, set: [title: "New title"])

    MyRepo.update_all(Post, inc: [visits: 1])

    from(p in Post, where: p.id < 10, select: p.visits)
    |> MyRepo.update_all(set: [title: "New title"])

    from(p in Post, where: p.id < 10, update: [set: [title: "New title"]])
    |> MyRepo.update_all([])

    from(p in Post, where: p.id < 10, update: [set: [title: ^new_title]])
    |> MyRepo.update_all([])

    from(p in Post, where: p.id < 10, update: [set: [title: fragment("upper(?)", ^new_title)]])
    |> MyRepo.update_all([])
  #+END_SRC
* Ecto.Schema
- An Ecto schema is used to map any data source into an Elixir struct
- The definition of the schema is possible through two main APIs:
  ~schema/2~ and ~embedded_schema/1~
  1) ~schema/2~
     + is typically used to map data from a persisted source,
       usually a database table, into Elixir structs and vice-versa.
     + lso contain a ~__meta__~ field with metadata holding the status
       of the struct, for example, if it has been built, loaded or
       deleted.
  2) ~embedded_schema/1~
     + is used for defining schemas that are embedded in other schemas
       or only exist in-memory.
     + For example, you can use such schemas to receive data from a
       command line interface and validate it, without ever persisting
       it elsewhere.
     + Such structs do not contain a ~__meta__~ field, as they are
       never persisted.
- Besides working as data mappers, ~embedded_schema/1~ and ~schema/2~ can
  also be used together to decouple how the data is represented in
  your applications from the database.
- Sample
  #+BEGIN_SRC elixir
    defmodule User do
      use Ecto.Schema

      schema "users" do
        field :name, :string
        field :age, :integer, default: 0
        has_many :posts, Post
      end
    end
  #+END_SRC
  #+BEGIN_SRC elixir
    iex> user = %User{name: "jane"}
    iex> %{user | age: 30}
  #+END_SRC
  + a schema will automatically generate a primary key which is named
    ~id~ and of type ~:integer~
- structs are cast, validated and manipulated with the ~Ecto.Changeset~
  module.
- you can use an embedded schema to represent your UI, mapping and
  validating its inputs, and then you convert such embedded schema to
  other schemas that are persisted to the database:
  #+BEGIN_SRC elixir
    defmodule SignUp do
      use Ecto.Schema

      embedded_schema do
        field :name, :string
        field :age, :integer
        field :email, :string
        field :accepts_conditions, :boolean
      end
    end

    defmodule Profile do
      use Ecto.Schema

      schema "profiles" do
        field :name
        field :age
        belongs_to :account, Account
      end
    end

    defmodule Account do
      use Ecto.Schema

      schema "accounts" do
        field :email
      end
    end
  #+END_SRC
  The ~SignUp~ schema can be cast and validated with the help of the
  ~Ecto.Changeset~ module, and afterwards, you can copy its data to the
  ~Profile~ and ~Account~ structs that will be persisted to the database
  with the help of ~Ecto.Repo~
** Schema attributes
- Supported attributes for configuring the defined schema. They must
  be set after the ~use Ecto.Schema~ call and before the ~schema/2~
  definition.
  + ~@primary_key~
    * Defaults to ~{:id, :id, autogenerate: true}~
  + ~@schema_prefix~
    * Defaults to ~nil~, which generates structs and queries without
      prefix.
    * When set, the prefix will be used by every built struct and on
      queries whenever the schema is used in a ~from~ or a ~join~
    * In PostgreSQL, the prefix is called “SCHEMA” (typically set via
      Postgres’ ~search_path~). In MySQL the prefix points to databases.
  + ~@foreign_key_type~
    * configures the default foreign key type used by ~belongs_to~
      associations. It must be set in the same module that defines the
      ~belongs_to~. Defaults to ~:id~
  + ~@timestamps_opts~
    * configures the default timestamps type used by
      ~timestamps~. Defaults to ~[type: :naive_datetime]~
  + ~@derive~
    * the same as ~@derive~ available in ~Kernel.defstruct/1~ as the
      schema defines a struct behind the scenes
  + ~@field_source_mapper~
    * a function that receives the current field name and returns the
      mapping of this field name in the underlying source. In other
      words, it is a mechanism to automatically generate the ~:source~
      option for the ~field~ macro. It defaults to ~fn x -> x~ end, where
      no field transformation is done;
- with a macro to configure application wide defaults:
  #+BEGIN_SRC elixir
    # Define a module to be used as base
    defmodule MyApp.Schema do
      defmacro __using__(_) do
        quote do
          use Ecto.Schema
          @primary_key {:id, :binary_id, autogenerate: true}
          @foreign_key_type :binary_id
        end
      end
    end

    # Now use MyApp.Schema to define new schemas
    defmodule MyApp.Comment do
      use MyApp.Schema

      schema "comments" do

        # will also define a :post_id field with :binary_id type that
        # references the :id field of the MyApp.Post schema.
        belongs_to :post, MyApp.Post
      end
    end
  #+END_SRC

** Primary keys
- Ecto supports two ID types, often used as the type for primary keys
  and associations:
  + ~:id~
    * used when the primary key is an integer
    *
  + ~:binary_id~
    * used for primary keys in particular binary formats, which may be
      ~Ecto.UUID~ for databases like PostgreSQL and MySQL, or some
      specific ObjectID or RecordID often imposed by NoSQL databases.
- Ecto also supports composite primary keys. This is achieved by
  declaring a ~@primary_key~, as usual, and then passing the
  ~primary_key: true~ option to any of the composite fields
** Types and casting
- Types are split into two categories
  1. primitive types
    | ECTO TYPE              | ELIXIR TYPE          | LITERAL SYNTAX IN QUERY |
    |------------------------+----------------------+-------------------------|
    | ~:id~                  | ~integer~            | 1,2,3                   |
    | ~:binary_id~           | ~binary~             | ~<<int,int,int,...>>~   |
    | ~:integer~             | ~integer~            | 1,2,3                   |
    | ~:float~               | ~float~              | 1.0, 2.0, 3.0           |
    | ~:boolean~             | ~boolean~            | true, false             |
    | ~:string~              | UTF-8 encoded string | "hello"                 |
    | ~:binary~              | ~binary~             | ~<<int,int,int,...>>~   |
    | ~{:array, inner_type}~ | ~list~               | ~[value, value, ...]~   |
    | ~:map~                 | ~map~                |                         |
    | ~{:map, inner_type}~   | ~map~                |                         |
    | ~:decimal~             | ~[[https://github.com/ericmj/decimal][Decimal]]~            |                         |
    | ~:date~                | ~[[https://hexdocs.pm/elixir/Date.html][Date]]~               |                         |
    | ~:time~                | ~[[https://hexdocs.pm/elixir/Time.html][Time]]~               |                         |
    | ~:naive_datetime~      | ~[[https://hexdocs.pm/elixir/NaiveDateTime.html][NaiveDateTime]]~      |                         |
    | ~:naive_datetime_usec~ | ~[[https://hexdocs.pm/elixir/NaiveDateTime.html][NaiveDateTime]]~      |                         |
    | ~:utc_datetime~        | ~[[https://hexdocs.pm/elixir/DateTime.html][DateTime]]~           |                         |
    | ~:utc_datetime_usec~   | ~[[https://hexdocs.pm/elixir/DateTime.html][DateTime]]~           |                         |

     * For the ~{:array, inner_type}~ and ~{:map, inner_type}~ type,
       replace ~inner_type~ with one of the valid types, such as ~:string~.

     * For the ~:decimal~ type, ~+Infinity~, ~-Infinity~, and ~NaN~ values are
       not supported, even though the ~[[https://github.com/ericmj/decimal][Decimal]]~ library handles them. To
       support them, you can create a custom type.

     * For calendar types with and without microseconds, the precision
       is enforced when persisting to the DB. For example, casting
       =~T[09:00:00]= as =:time_usec= will succeed and result in
       =~T[09:00:00.000000]=, but persisting a type without microseconds
       as ~:time_usec~ will fail. Similarly, casting =~T[09:00:00.000000]=
       as =:time= will succeed, but persisting will not. This is the
       same behaviour as seen in other types, where casting has to be
       done explicitly and is never performed implicitly when loading
       from or dumping to the database.
  2. custom types
     - Ecto allows custom types to be implemented by developers,
       allowing Ecto behaviour to be extended.
     - A custom type is a module that implements the ~[[https://hexdocs.pm/ecto/Ecto.Type.html][Ecto.Type]]~
       behaviour. By default, Ecto provides the following custom
       types:
       | CUSTOM TYPE	 | DATABASE TYPE | ELIXIR TYPE |
       |-----------------+---------------+-------------|
       | [[https://hexdocs.pm/ecto/Ecto.UUID.html][Ecto.UUID]]       | :uuid         | uuid-string |

- schemas can also have virtual fields by passing the ~virtual: true~
  option. These fields are not persisted to the database and can
  optionally not be type checked by declaring type ~:any~
*** The datetime types
- Four different datetime primitive types are available:
  1. ~naive_datetime~ - has a precision of *seconds* and casts values to
     Elixir’s ~NaiveDateTime~ struct which has no timezone information.
  2. ~naive_datetime_usec~ - has a default precision of *microseconds*
     and also casts values to ~NaiveDateTime~ with no timezone
     information.
  3. ~utc_datetime~ - has a precision of seconds and casts values to
     Elixir’s ~DateTime~ struct and expects the time zone to be set to
     UTC.
  4. ~utc_datetime_usec~ has a default precision of microseconds and
     also casts values to ~DateTime~ expecting the time zone be set to
     UTC.
- keep in mind that Elixir functions like ~NaiveDateTime.utc_now/0~ have
  a default precision of 6. Casting a value with a precision greater
  than 0 to a non-~usec~ type will truncate all microseconds and set the
  precision to 0.
*** The map type
- The map type allows developers to store an Elixir map directly in
  the database:
  #+BEGIN_SRC elixir
    # In your migration
    create table(:users) do
      add :data, :map
    end

    # In your schema
    field :data, :map

    # Now in your code
    user = Repo.insert! %User{data: %{"foo" => "bar"}}
  #+END_SRC
- In order to support maps, different databases may employ different
  techniques. For example, PostgreSQL will store those values in jsonb
  fields, allowing you to just query parts of it.
- For maps to work in such databases, Ecto will need a JSON
  library. By default Ecto will use ~Jason~ which needs to be added to
  your deps in ~mix.exs~:
  #+BEGIN_SRC elixir
  {:jason, "~> 1.0"}
  #+END_SRC
*** Casting
- When directly manipulating the struct, it is the responsibility of
  the developer to ensure the field values have the proper type. For
  example, you can create a user struct with an invalid value for ~age~:
  #+BEGIN_SRC elixir
    iex> user = %User{age: "0"}
    iex> user.age
    "0"
  #+END_SRC
- However, if you attempt to persist the struct above, an error will
  be raised since Ecto validates the types when sending them to the
  adapter/database.
- Therefore, when working with and manipulating external data, it is
  recommended to use ~Ecto.Changeset~'s that are able to filter and
  properly cast external data:
  #+BEGIN_SRC elixir
    changeset = Ecto.Changeset.cast(%User{}, %{"age" => "0"}, [:age])
    user = Repo.insert!(changeset)
  #+END_SRC
- You can use Ecto schemas and changesets to cast and validate any
  kind of data, regardless if the data will be persisted to an Ecto
  repository or not.
** Reflection
- Any schema module will generate the ~__schema__~ function that can be
  used for runtime introspection of the schema:

  + ~__schema__(:source)~ - Returns the source as given to ~schema/2~;

  + ~__schema__(:prefix)~ - Returns optional prefix for source
      provided by ~@schema_prefix~ schema attribute;

  + ~__schema__(:primary_key)~ - Returns a list of primary key fields
      (empty if there is none);

  + ~__schema__(:fields)~ - Returns a list of all non-virtual field
      names;

  + ~__schema__(:field_source, field)~ - Returns the alias of the
      given field;

  + ~__schema__(:type, field)~ - Returns the type of the given
      non-virtual field;

  + ~__schema__(:associations)~ - Returns a list of all association
      field names;

  + ~__schema__(:association, assoc)~ - Returns the association
      reflection of the given assoc;

  + ~__schema__(:embeds)~ - Returns a list of all embedded field
      names;

  + ~__schema__(:embed, embed)~ - Returns the embedding reflection of
      the given embed;

  + ~__schema__(:read_after_writes)~ - Non-virtual fields that must be
      read back from the database after every write (insert or update);

  + ~__schema__(:autogenerate_id)~ - Primary key that is auto
      generated on insert;

** Functions
- ~belongs_to(name, queryable, opts \\ [])~
  + Indicates a one-to-one or many-to-one association with another
    schema.
  + The current schema belongs to zero or one records of the other
    schema. The other schema often has a ~has_one~ or a ~has_many~ field
    with the reverse association.
  + You should use ~belongs_to~ in the table that contains the foreign
    key. Imagine a company <-> employee relationship. If the employee
    contains the ~company_id~ in the underlying database table, we say
    the employee belongs to company.
  + when you invoke this macro, a field with the name of foreign key
    is automatically defined in the schema for you.
  + ~opts~
    * ~:foreign_key~ - Sets the foreign key field name, defaults to
      the name of the association suffixed by ~_id~. For example,
      ~belongs_to :company~ will define foreign key of ~:company_id~
    * ~:references~ - Sets the key on the other schema to be used for
      the association, defaults to: ~:id~
    * ~:define_field~ - When ~false~, does not automatically define a
      ~:foreign_key~ field, implying the user is defining the field
      manually elsewhere
    * ~:type~ - Sets the type of automatically defined
      ~:foreign_key~. Defaults to: ~:integer~ and can be set per schema
      via ~@foreign_key_type~
    * ~:on_replace~ - The action taken on associations when the record
      is replaced when casting or manipulating parent changeset. May
      be ~:raise~ (default), ~:mark_as_invalid~, ~:nilify~, ~:update~, or
      ~:delete~. See ~[[Https://hexdocs.pm/ecto/Ecto.Changeset.html#module-the-on_replace-option][Ecto Changeset]]~
    * ~:defaults~ - Default values to use when building the
      association. This overrides any default set on the association
      schema. For example, imagine
      ~Post.has_many :comments, defaults: [public: true]~.
      Then when using ~Ecto.build_assoc(post, :comments)~
      that comment will have ~comment.public == true~.
    * ~:primary_key~ - If the underlying belongs_to field is a primary
      key
    * ~:source~ - The source for the underlying field
    * ~:where~ - A filter for the association.
  + example
    #+BEGIN_SRC elixir
      defmodule Comment do
        use Ecto.Schema

        schema "comments" do
          belongs_to :post, Post
        end
      end

      # The post can come preloaded on the comment record
      [comment] = Repo.all(from(c in Comment, where: c.id == 42, preload: :post))
      comment.post #=> %Post{...}
    #+END_SRC
    * If you need custom options on the underlying field, you can
      define the field explicitly and then pass ~define_field: false~ to
      ~belongs_to~:
      #+BEGIN_SRC elixir
        defmodule Comment do
          use Ecto.Schema

          schema "comments" do
            field :post_id, :integer, ... # custom options
            belongs_to :post, Post, define_field: false
          end
        end
      #+END_SRC
  + Polymorphic associations
    * magine you have defined a Comment schema and you wish to use it
      for commenting on both tasks and posts.
    * Some abstractions would force you to define some sort of
      polymorphic association with two fields in your database:
      #+BEGIN_SRC
      * commentable_type
      * commentable_id
      #+END_SRC
    * In Ecto, we have three ways to solve this issue.
      1. The simplest is to define multiple fields in the Comment
         schema, one for each association:
         #+BEGIN_SRC
         * task_id
         * post_id
         #+END_SRC

      2. because Ecto does not tie a schema to a given table, we can
         use separate tables for each association.
         #+BEGIN_SRC elixir
           defmodule Comment do
             use Ecto.Schema

             schema "abstract table: comments" do

               # This will be used by associations
               # on each "concrete" table
               field :assoc_id, :integer
             end
           end
         #+END_SRC
         Notice we have changed the table name to ~abstract table: comments~.
         You can choose whatever name you want, the point here is that
         this particular table will never exist.

         Now in your Post and Task schemas:
         #+BEGIN_SRC elixir
           defmodule Post do
             use Ecto.Schema

             schema "posts" do
               has_many :comments, {"posts_comments", Comment}, foreign_key: :assoc_id
             end
           end

           defmodule Task do
             use Ecto.Schema

             schema "tasks" do
               has_many :comments, {"tasks_comments", Comment}, foreign_key: :assoc_id
             end
           end
         #+END_SRC
         Now each association uses its own specific table,
         ~posts_comments~ and ~tasks_comments~, which must be created
         on migrations. The advantage of this approach is that we
         never store unrelated data together, also ensuring we keep
         database references fast and correct.

         When using this technique, the only limitation is that you
         cannot build comments directly. For example, the command
         below
         #+BEGIN_SRC elixir
         Repo.insert!(%Comment{})
         #+END_SRC
         will attempt to use the abstract table. Instead, one should
         use
         #+BEGIN_SRC elixir
         Repo.insert!(build_assoc(post, :comments))
         #+END_SRC
         leveraging the ~Ecto.build_assoc/3~ function. You can also use
         ~Ecto.assoc/2~ and ~Ecto.Query.assoc/2~ in the query syntax to
         easily retrieve associated comments to a given post or task:
         #+BEGIN_SRC elixir
           # Fetch all comments associated with the given task
           Repo.all(assoc(task, :comments))
         #+END_SRC
         Or all comments in a given table:
         #+BEGIN_SRC elixir
         Repo.all from(c in {"posts_comments", Comment}), ...)
         #+END_SRC

      3. The third and final option is to use ~many_to_many/3~ to define
         the relationships between the resources. In this case, the
         comments table won’t have the foreign key, instead there is a
         intermediary table responsible for associating the entries:
         #+BEGIN_SRC elixir
           defmodule Comment do
             use Ecto.Schema
             schema "comments" do
               # ...
             end
           end
         #+END_SRC
         In your posts and tasks:
         #+BEGIN_SRC elixir
           defmodule Post do
             use Ecto.Schema

             schema "posts" do
               many_to_many :comments, Comment, join_through: "posts_comments"
             end
           end

           defmodule Task do
             use Ecto.Schema

             schema "tasks" do
               many_to_many :comments, Comment, join_through: "tasks_comments"
             end
           end
         #+END_SRC
- ~embedded_schema(list)~
  + An embedded schema is either embedded into another schema or kept
    exclusively in memory. For this reason, an embedded schema does
    not require a source name and it does not include a metadata
    field.
- ~embeds_many(name, schema, opts \\ [])~
  + The current schema has zero or more records of the other schema
    embedded inside of it. Embeds have all the things regular schemas
    have.

  + It is recommended to declare your ~embeds_many/3~ field with type
    ~:map~ and a default of ~"[]"~ (although Ecto will also automatically
    translate ~nil~ values from the database into empty lists).

  + example
    #+BEGIN_SRC elixir
      defmodule Order do
        use Ecto.Schema

        schema "orders" do
          embeds_many :items, Item
        end
      end

      defmodule Item do
        use Ecto.Schema

        embedded_schema do
          field :title
        end
      end

      # The items are loaded with the order
      order = Repo.get!(Order, 42)
      order.items #=> [%Item{...}, ...]
    #+END_SRC
  + Adding and removal of embeds can only be done via the
    ~Ecto.Changeset~ API so Ecto can properly track the embed
    life-cycle:

    #+BEGIN_SRC elixir
      # Order has no items
      order = Repo.get!(Order, 42)
      order.items
      # => []

      items  = [%Item{title: "Soap"}]

      # Generate a changeset
      changeset = Ecto.Changeset.change(order)

      # Put a one or more new items
      # remember there's a :on_replace the you need to be aware of
      changeset = Ecto.Changeset.put_embed(changeset, :items, items)

      # Update the order and fetch items
      items = Repo.update!(changeset).items

      # Items are generated with a unique identification
      items
      # => [%Item{id: "20a97d94-f79b-4e63-a875-85deed7719b7", title: "Soap"}]
    #+END_SRC
  + Updating of embeds must be done using a changeset for each changed
    embed.
    #+BEGIN_SRC elixir
      # Order has an existing items
      order = Repo.get!(Order, 42)
      order.items
      # => [%Item{id: "20a97d94-f79b-4e63-a875-85deed7719b7", title: "Soap"}]

      # Generate a changeset
      changeset = Ecto.Changeset.change(order)

      # Put the updated item as a changeset
      current_item = List.first(order.items)
      item_changeset = Ecto.Changeset.change(current_item, title: "Mujju's Soap")
      order_changeset = Ecto.Changeset.put_embed(changeset, :items, [item_changeset])

      # Update the order and fetch items
      items = Repo.update!(order_changeset).items

      # Item has the updated title
      items
      # => [%Item{id: "20a97d94-f79b-4e63-a875-85deed7719b7", title: "Mujju's Soap"}]
    #+END_SRC
  + Inline embedded schema
    * The schema module can be defined inline in the parent schema in
      simple cases:
      #+BEGIN_SRC elixir
        defmodule Parent do
          use Ecto.Schema

          schema "parents" do
            field :name, :string

            embeds_many :children, Child do
              field :name, :string
              field :age,  :integer
            end
          end

          def changeset(schema, params) do
            schema
            |> cast(params, [:name])
            |> cast_embed(:children, with: &child_changeset/2)
          end

          defp child_changeset(schema, params) do
            schema
            |> cast(params, [:name, :age])
          end
          Link to this macro
        end
      #+END_SRC
    * Primary keys are automatically set up for embedded schemas as
      well, defaulting to ~{:id, :binary_id, autogenerate: true}~
- ~embeds_many(name, schema, opts, list)~
  + Indicates an embedding of many schemas.
- ~embeds_one(name, schema, opts \\ [])~
  + Indicates an embedding of a schema.

  + The current schema has zero or one records of the other schema
    embedded inside of it. It uses a field similar to the ~:map~ type
    for storage, but allows embeds to have all the things regular
    schema can.

  + You must declare your ~embeds_one/3~ field with type ~:map~ at the
    database level.

  + The embedded may or may not have a primary key. Ecto use the
    primary keys to detect if an embed is being updated or not. If a
    primary is not present, ~:on_replace~ should be set to either
    ~:update~ or ~:delete~ if there is a desire to either update or delete
    the current embed when a new one is set.

  + example
    #+BEGIN_SRC elixir
      defmodule Order do
        use Ecto.Schema

        schema "orders" do
          embeds_one :item, Item
        end
      end

      defmodule Item do
        use Ecto.Schema

        embedded_schema do
          field :title
        end
      end

      # The item is loaded with the order
      order = Repo.get!(Order, 42)
      order.item #=> %Item{...}
    #+END_SRC

  + Adding and removal of embeds can only be done via the
    ~Ecto.Changeset~ API so Ecto can properly track the embed
    life-cycle:
    #+BEGIN_SRC elixir
      order = Repo.get!(Order, 42)
      item  = %Item{title: "Soap"}

      # Generate a changeset
      changeset = Ecto.Changeset.change(order)

      # Put a new embed to the changeset
      changeset = Ecto.Changeset.put_embed(changeset, :item, item)

      # Update the order, and fetch the item
      item = Repo.update!(changeset).item

      # Item is generated with a unique identification
      item
      # => %Item{id: "20a97d94-f79b-4e63-a875-85deed7719b7", title: "Soap"}
    #+END_SRC

  + Inline embedded schema
    * The schema module can be defined inline in the parent schema in
      simple cases:
      #+BEGIN_SRC elixir
        defmodule Parent do
          use Ecto.Schema

          schema "parents" do
            field :name, :string

            embeds_one :child, Child do
              field :name, :string
              field :age,  :integer
            end
          end
        end
      #+END_SRC
    * Options should be passed before the do block like this:
      #+BEGIN_SRC elixir
        embeds_one :child, Child, on_replace: :delete do
          field :name, :string
          field :age,  :integer
        end
      #+END_SRC
    * Primary keys are automatically set up for embedded schemas as
      well, defaulting to ~{:id, :binary_id, autogenerate: true}~. You can
      customize it by passing a ~:primary_key~ option with the same
      arguments as ~@primary_key~
    * Defining embedded schema in such a way will define a
      ~Parent.Child~ module with the appropriate struct. In order to
      properly cast the embedded schema. When casting the
      inline-defined embedded schemas you need to use the ~:with~ option
      of ~Ecto.Changeset.cast_embed/3~ to provide the proper function to
      do the casting. For example:
      #+BEGIN_SRC elixir
        def changeset(schema, params) do
          schema
          |> cast(params, [:name])
          |> cast_embed(:child, with: &child_changeset/2)
        end

        defp child_changeset(schema, params) do
          schema
          |> cast(params, [:name, :age])
        end
      #+END_SRC
  + Encoding and decoding
    * Because many databases do not support direct encoding and
      decoding of embeds, it is often emulated by Ecto by using
      specific encoding and decoding rules.
    * For example, PostgreSQL will store embeds on top of JSONB
      columns, which means types in embedded schemas won’t go through
      the usual dump->DB->load cycle but rather
      encode->DB->decode->cast. This means that, when using embedded
      schemas with databases like PG or MySQL, make sure all of your
      types can be JSON encoded/decoded correctly. Ecto provides this
      guarantee for all built-in types.
- ~embeds_one(name, schema, opts, list)~
- ~field(name, type \\ :string, opts \\ [])~
  - The field name will be used as is to read and write to the
    database by all of the built-in adapters unless overridden with
    the ~:source~ option.
  - opts
    + ~:default~ - Sets the default value on the schema and the
      struct. The default value is calculated at compilation time, so
      don’t use expressions like ~DateTime.utc_now~ or
      ~Ecto.UUID.generate~ as they would then be the same for all
      records.

    + ~:source~ - Defines the name that is to be used in database for
      this field. This is useful when attaching to an existing
      database. The value should be an atom.

    + ~:autogenerate~ - a ~{module, function, args}~ tuple for a
      function to call to generate the field value before insertion if
      value is not set. A shorthand value of true is equivalent to
      ~{type, :autogenerate, []}~.

    + ~:read_after_writes~ - When true, the field is always read back
      from the database after insert and updates. For relational
      databases, this means the ~RETURNING~ option of those statements
      is used. For this reason, MySQL does not support this option and
      will raise an error if a schema is inserted/updated with read
      after writes fields.

    + ~:virtual~ - When true, the field is not persisted to the
      database. Notice virtual fields do not support ~:autogenerate~ nor
      ~:read_after_writes~.

    + ~:primary_key~ - When true, the field is used as part of the
      composite primary key
- ~has_many(name, queryable, opts \\ [])~
- ~has_many(name, queryable, opts \\ [])~
