* Ecto documentation
** add ecto
 1) generate necessities
    #+BEGIN_SRC
    mix ecto.gen.repo -r Friends.Repo
    #+END_SRC
 2) checkout configuration at ~config/config.exs~
    #+BEGIN_SRC elixir
      config :friends, Friends.Repo,
        database: "friends_repo",
        username: "user",
        password: "pass",
        hostname: "localhost"
    #+END_SRC
 3) ~lib/friends/repo.ex~
    #+BEGIN_SRC elixir
      defmodule Friends.Repo do
        use Ecto.Repo,
          otp_app: :friends,
          adapter: Ecto.Adapters.Postgres
      end
    #+END_SRC
    + ~otp_app~ tells Ecto which Elixir application it can look for
      database configuration in
 4) start the repo process in ~lib/friends/application.ex~
    #+BEGIN_SRC elixir
      def start(_type, _args) do
        children = [
          Friends.Repo,
        ]
    #+END_SRC
 5) add this to ~config/config.exs~
    #+BEGIN_SRC elixir
    config :friends, ecto_repos: [Friends.Repo]
    #+END_SRC
    This tells our application about the repo, which will allow us to
    run commands such as ~mix ecto.create~

** Setting up the database
 - create the database
   #+BEGIN_SRC
   mix ecto.create
   #+END_SRC
 - create a migration
   #+BEGIN_SRC elixir
   mix ecto.gen.migration create_people
   #+END_SRC
   generates a new migration file in ~priv/repo/migrations~
   #+BEGIN_SRC elixir
     defmodule Friends.Repo.Migrations.CreatePeople do
       use Ecto.Migration

       def change do
         create table(:people) do
           add(:first_name, :string)
           add(:last_name, :string)
           add(:age, :integer)
         end
       end
     end
   #+END_SRC
   NOTE: The naming convention for tables in Ecto databases is to use a
   pluralized name.

 - run the migration to create the table
   #+BEGIN_SRC
   mix ecto.migrate
   #+END_SRC
   if you you made any mistake you can run ~mix ecto.rollback~

** Creating the schema
 - The schema is an Elixir representation of data from our database.
 - Schemas are commonly associated with a database table, however they
   can be associated with a database view as well
   #+BEGIN_SRC elixir
     defmodule Friends.Person do
       use Ecto.Schema

       schema "people" do            # database name
         field :first_name, :string
         field :last_name, :string
         field :age, :integer
       end
     end
   #+END_SRC
   + we’re telling Ecto that the ~Friends.Person~ schema maps to the
     ~people~ table in the database
   + We’ve called this schema ~Person~ because the naming convention in
     Ecto for schemas is a singularized name.
   + in iex
     #+BEGIN_SRC elixir
       iex(1)> person = %Friends.Person{}
       %Friends.Person{
         __meta__: #Ecto.Schema.Metadata<:built, "people">,
         age: nil,
         first_name: nil,
         id: nil,
         last_name: nil
       }
     #+END_SRC

** Inserting data
 - We can insert a new record into our ~people~ table with this code:
   #+BEGIN_SRC elixir
   person = %Friends.Person{}
   Friends.Repo.insert(person)
   {:ok,
     %Friends.Person{
       __meta__: #Ecto.Schema.Metadata<:loaded, "people">,
       age: nil, first_name: nil, id: 1, last_name: nil
     }
   }
   # or
   {:ok, person} = Friends.Repo.insert(person)
   #+END_SRC
** Validating changes
 - For this, Ecto has [[https://hexdocs.pm/ecto/Ecto.Changeset.html][changesets]]
   + how to use it
     1. filter and cast input
        #+BEGIN_SRC elixir
          import Ecto.Changeset

          params = %{"title" => "So What", "index" => "1", "duration" => 180, "foo" => "LOL"}

          changeset =
            %Track{}
            |> cast(params, [:title, :index, :duration])
        #+END_SRC
     2. validate
        #+BEGIN_SRC elixir
          changeset =
            validate_required(changeset, [:title, :index])
            |> validate_number(:index, greater_than: 0)
        #+END_SRC
     3. capture errors
        #+BEGIN_SRC elixir
          # see if it works
          case Repo.insert(changeset) do
            {:ok, track} -> IO.puts "Track #{track.name} successfully added"
            {:error, changeset} -> IO.puts changeset.errors
          end
        #+END_SRC

 - sample
   #+BEGIN_SRC elixir
     defmodule Friends.Person do
       use Ecto.Schema

       schema "people" do
         field(:first_name, :string)
         field(:last_name, :string)
         field(:age, :integer)
       end


       # This changeset takes a `person` and a set of `params`, which are to be
       # the changes to apply to this person
       def changeset(person, params \\ %{}) do
         person
         |> Ecto.Changeset.cast(params, [:first_name, :last_name, :age])
         |> Ecto.Changeset.validate_required([:first_name, :last_name])
       end
     end
   #+END_SRC
 - ~Ecto.Changeset.cast(person, params, [:first_name, :last_name, :age])~
   + it's ~cast(data, params, permitted, opts \\ [])~
   + Casting tells the changeset what parameters are allowed to be
     passed through in this changeset, and anything not in the list
     will be ignored.
 - ~Ecto.Changeset.validate_required([:first_name, :last_name])~
   + it's ~validate_required(changeset, fields, opts \\ [])~
   + says that, for this changeset, we expect ~first_name~ and ~last_name~
     to have values specified

     with error
     #+BEGIN_SRC elixir
       iex(9)> person = %Friends.Person{}
       %Friends.Person{
         __meta__: #Ecto.Schema.Metadata<:built, "people">,
         age: nil,
         first_name: nil,
         id: nil,
         last_name: nil
       }

       iex(10)> changeset = Friends.Person.changeset(person, %{})
       #Ecto.Changeset<
         action: nil,
         changes: %{},
         errors: [
         first_name: {"can't be blank", [validation: :required]},
         last_name: {"can't be blank", [validation: :required]}
         ],
         data: #Friends.Person<>,
         valid?: false
       >

       iex(11)> {:error, changeset} = Friends.Repo.insert(changeset)
       {:error,
        #Ecto.Changeset<
          action: :insert,
          changes: %{},
          errors: [
          first_name: {"can't be blank", [validation: :required]},
          last_name: {"can't be blank", [validation: :required]}
          ],
          data: #Friends.Person<>,
          valid?: false
        >
       }

       iex(14)> changeset.errors
       [
         first_name: {"can't be blank", [validation: :required]},
         last_name: {"can't be blank", [validation: :required]}
       ]
     #+END_SRC

     valid changeset
     #+BEGIN_SRC elixir
       iex> person = %Friends.Person{}
       %Friends.Person{
         __meta__: #Ecto.Schema.Metadata<:built, "people">,
         age: nil,
         first_name: nil,
         id: nil,
         last_name: nil
       }

       iex> changeset = Friends.Person.changeset(person, %{first_name: "Ryan", last_name: "Bigg"})
       #Ecto.Changeset<
         action: nil,
         changes: %{first_name: "Ryan", last_name: "Bigg"},
         errors: [],
         data: #Friends.Person<>,
         valid?: true
       >

       iex(17)> changeset.valid?
       true

       iex> Friends.Repo.insert(changeset)

       10:02:59.746 [debug] QUERY OK db=3.9ms queue=1.9ms
       INSERT INTO "people" ("first_name","last_name") VALUES ($1,$2) RETURNING "id" ["Ryan", "Bigg"]
       {:ok,
        %Friends.Person{
          __meta__: #Ecto.Schema.Metadata<:loaded, "people">,
          age: nil,
          first_name: "Ryan",
          id: 3,
          last_name: "Bigg"
        }}
     #+END_SRC

   + NOTE: ~changeset.valid?~ will not check constraints (such as
     ~uniqueness_constraint~). For that, you will need to attempt to do
     an insertion and check for errors from the database. It’s for this
     reason it’s best practice to try inserting data and validate the
     returned tuple from ~Friends.Repo.insert~ to get the correct errors,
     as prior to insertion the changeset will only contain validation
     errors from the application itself.
** queries
 1. construct the query
 2. execute that query against the database by passing the query to the
    repository
*** Fetching a single record
 - build the query
   ~Friends.Person |> Ecto.Query.first~
   will generate an ~Ecto.Query~
   #+BEGIN_SRC
   #Ecto.Query<from p in Friends.Person, order_by: [asc: p.id], limit: 1>
   #+END_SRC

   We could construct this query ourselves
   #+BEGIN_SRC elixir
   require Ecto.Query
   Ecto.Query.from p in Friends.Person, order_by: [asc: p.id], limit: 1
   #+END_SRC
 - execute the query
   #+BEGIN_SRC elixir
   iex> Friends.Person |> Ecto.Query.first |> Friends.Repo.one

   %Friends.Person{__meta__: #Ecto.Schema.Metadata<:loaded>,
   age: 28, first_name: "Ryan", id: 1, last_name: "Bigg"}
   #+END_SRC
   or get the last one
   #+BEGIN_SRC elixir
   iex> Friends.Person |> Ecto.Query.last |> Friends.Repo.one

   %Friends.Person{__meta__: #Ecto.Schema.Metadata<:loaded>,
   age: 26, first_name: "Jane", id: 3, last_name: "Smith"}
   #+END_SRC
   The ~Ecto.Repo.one~ function will only return a struct if there is
   one record in the result from the database. If there is more than
   one record returned, an ~Ecto.MultipleResultsError~ exception will be
   thrown.

*** Fetching all records
 #+BEGIN_SRC elixir
 iex> Friends.Person |> Friends.Repo.all
 #+END_SRC
*** Fetch a single record based on ID
 #+BEGIN_SRC elixir
 iex> Friends.Person |> Friends.Repo.get(1)
 %Friends.Person{__meta__: #Ecto.Schema.Metadata<:loaded>,
  age: 28, first_name: "Ryan", id: 1, last_name: "Bigg"}
 #+END_SRC
*** Fetch a single record based on a specific attribute
 - If we want to get a record based on something other than the ~id~
   attribute, we can use ~get_by~:
   #+BEGIN_SRC elixir
     iex> Friends.Person |> Friends.Repo.get_by(first_name: "Ryan")

     %Friends.Person{__meta__: #Ecto.Schema.Metadata<:loaded>,
                     age: 28, first_name: "Ryan", id: 1, last_name: "Bigg"}
   #+END_SRC
*** Filtering results
 - If we want to get multiple records matching a specific attribute, we
   can use ~where~:
   #+BEGIN_SRC elixir
   Friends.Person |> Ecto.Query.where(last_name: "Smith") |> Friends.Repo.all

   [%Friends.Person{__meta__: #Ecto.Schema.Metadata<:loaded>, age: 27,
   first_name: "John", id: 2, last_name: "Smith"},

   %Friends.Person{__meta__: #Ecto.Schema.Metadata<:loaded>, age: 26,
   first_name: "Jane", id: 3, last_name: "Smith"}]
   #+END_SRC
   the generated query is
   #+BEGIN_SRC
   #Ecto.Query<from p in Friends.Person, where: p.last_name == "Smith">
   #+END_SRC
   which means we can get the same result with
   #+BEGIN_SRC
   Ecto.Query.from(p in Friends.Person, where: p.last_name == "Smith") |> Friends.Repo.all
   #+END_SRC
   with both syntax we have to pin (^) the variables
   #+BEGIN_SRC elixir
     iex> last_name = "Smith"
     iex> Friends.Person |> Ecto.Query.where(last_name: ^last_name) |> Friends.Repo.all

     # Or:

     iex> last_name = "Smith"
     iex> Ecto.Query.from(p in Friends.Person, where: p.last_name == ^last_name) |> Friends.Repo.all
   #+END_SRC
   The pin operator instructs the query builder to use parameterised
   SQL queries protecting against SQL injection.

*** Composing Ecto queries
    #+BEGIN_SRC elixir
      query = Friends.Person |> Ecto.Query.where(last_name: "Smith")

      query = query |> Ecto.Query.where(first_name: "Jane")

      #Ecto.Query<
                    from p in Friends.Person, where: p.last_name == "Smith", where: p.first_name == "Jane">
    #+END_SRC
*** Updating records
 - Updating records in Ecto requires us to first fetch a record from
   the database. We then create a changeset from that record and the
   changes we want to make to that record, and then call the
   ~Ecto.Repo.update~ function.
   + fetch
     #+BEGIN_SRC
     person = Friends.Person |> Ecto.Query.first |> Friends.Repo.one
     #+END_SRC
   + build a changeset
     #+BEGIN_SRC
     changeset = Friends.Person.changeset(person, %{age: 29})
     #+END_SRC
     We need to build a changeset because if we just create a new
     ~Friends.Person~ struct with the new age, Ecto wouldn’t be able to
     know that the age has changed without inspecting the database
   + update
     #+BEGIN_SRC
     iex> Friends.Repo.update(changeset)
     {:ok,
     %Friends.Person{__meta__: #Ecto.Schema.Metadata<:loaded>, age: 29,
     first_name: "Ryan", id: 1, last_name: "Bigg"}}
     #+END_SRC
*** Deleting records
 - Similar to updating, we must first fetch a record from the database
   and then call ~Friends.Repo.delete~ to delete that record:
   #+BEGIN_SRC elixir
   iex> person = Friends.Repo.get(Friends.Person, 1)
   iex> Friends.Repo.delete(person)
   #=> {:ok,
   %Friends.Person{__meta__: #Ecto.Schema.Metadata<:deleted>, age: 29,
   first_name: "Ryan", id: 2, last_name: "Bigg"}}

   #+END_SRC
 ===================
** Ecto
*** Ecto.Repo
 - repositories are wrappers around the data store. Via the repository,
   we can create, update, destroy and query existing entries. A
   repository needs an adapter and credentials to communicate to the
   databas

*** Ecto.Schema
 - schemas are used to map any data source into an Elixir struct. We
   will often use them to map tables into Elixir data but that’s one of
   their use cases and not a requirement for using Ecto

*** Ecto.Changeset
 - changesets provide a way for developers to filter and cast external
   parameters, as well as a mechanism to track and validate changes
   before they are applied to your data

*** Ecto.Query
 - written in Elixir syntax, queries are used to retrieve information
   from a given repository. Queries in Ecto are secure, avoiding common
   problems like SQL Injection, while still being composable, allowing
   developers to build queries piece by piece instead of all at once
   #+BEGIN_SRC elixir
     import Ecto.Query, only: [from: 2]

     query = from u in User,
       where: u.age > 18 or is_nil(u.email),
       select: u

     # Returns %User{} structs matching the query
     Repo.all(query)
   #+END_SRC
   In the example above we relied on our schema but queries can also be
   made directly against a table by giving the table name as a
   string. In such cases, the data to be fetched must be explicitly
   outlined:
   #+BEGIN_SRC elixir
     query = from u in "users",
               where: u.age > 18 or is_nil(u.email),
               select: %{name: u.name, age: u.age}

     # Returns maps as defined in select
     Repo.all(query)
   #+END_SRC

 - Queries are defined and extended with the from macro. The supported
   keywords are:
   #+BEGIN_SRC
   :distinct
   :where
   :order_by
   :offset
   :limit
   :lock
   :group_by
   :having
   :join
   :select
   :preload
   #+END_SRC
 - When writing a query, you are inside Ecto’s query syntax. In order
   to access params values or invoke Elixir functions, you need to use
   the ^ operator, which is overloaded by Ecto:
   #+BEGIN_SRC elixir
     def min_age(min) do
       from u in User, where: u.age > ^min
     end
   #+END_SRC

** Associations
 - Ecto supports defining associations on schemas:

   create ~comments~ table
   #+BEGIN_SRC elixir
     defmodule Friends.Repo.Migrations.CreateComments do
       use Ecto.Migration

       def change do
         create table(:comments) do
           add(:post_id, references(:posts))
           add(:body, :text)
           timestamps()
         end
       end
     end
   #+END_SRC
   create ~posts~ table
   #+BEGIN_SRC elixir
     defmodule Friends.Repo.Migrations.CreatePosts do
       use Ecto.Migration

       def change do
         create table(:posts) do
           add(:title, :string)
           add(:body, :text)
           timestamps()
         end
       end
     end
   #+END_SRC
   create ~Post~ schema
   #+BEGIN_SRC elixir
     defmodule Friends.Post do
       use Ecto.Schema

       schema "posts" do
         field(:title)
         field(:body)
         has_many(:comments, Friends.Comment)

         timestamps()
       end
     end
   #+END_SRC
   create ~Comment~ schema
   #+BEGIN_SRC elixir
   defmodule Friends.Post do
     use Ecto.Schema

     schema "posts" do
       field(:title)
       field(:body)
       has_many(:comments, Friends.Comment)

       timestamps()
     end
   end
   #+END_SRC
 - The difference between ~has_one/3~ and ~belongs_to/3~ is that the
   foreign key is always defined in the schema that invokes
   ~belongs_to/3~. You can think of the schema that calls ~has_*~ as
   the parent schema and the one that invokes ~belongs_to~ as the child
   one.

 - When an association is defined, Ecto also defines a field in the
   schema with the association name. By default, associations are not
   loaded into this field:

   #+BEGIN_SRC
   iex> post = Repo.get(Post, 42)
   iex> post.comments
   #Ecto.Association.NotLoaded<...>
   #+END_SRC
   + but you can preload
     #+BEGIN_SRC elixir
     Repo.all(from(p in Post, preload: [:comments])) # it runs two queries
     #+END_SRC

   + Preloading can also be done with a pre-defined join value:
     #+BEGIN_SRC elixir
     Repo.all from p in Post,
             join: c in assoc(p, :comments),
             preload: [comments: c]
     #+END_SRC
     + performs a single query, finding all posts and the respective
       comments that match the criteria. Because this query performs a
       JOIN

   + for the simple cases, preloading can also be done after a
     collection was fetched:
     #+BEGIN_SRC
     posts = Repo.all(Post) |> Repo.preload(:comments)
     #+END_SRC
   + get all the comments
     #+BEGIN_SRC elixir
       import Ecto

       post = Repo.get(Post, 1)

       # Get all comments for the given post
       Repo.all assoc(post, :comments)

       # Or build a query on top of the associated comments
       query = from c in assoc(post, :comments), where: not is_nil(c.title)
       Repo.all(query)
     #+END_SRC
*** Manipulating associations
 -
   #+BEGIN_SRC elixir
     Repo.insert!(%Post{
       title: "Hello",
       body: "world",
       comments: [
         %Comment{body: "Excellent!"}
       ]
     })
   #+END_SRC
 -
   #+BEGIN_SRC elixir
     post = Ecto.Changeset.change(%Post{}, title: "Hello", body: "world")
     comment = Ecto.Changeset.change(%Comment{}, body: "Excellent!")
     post_with_comments = Ecto.Changeset.put_assoc(post, :comments, [comment])
     Repo.insert!(post_with_comments)
   #+END_SRC
 - handling each entry individually inside a transaction
   #+BEGIN_SRC elixir
     Repo.transaction fn ->
       post = Repo.insert!(%Post{title: "Hello", body: "world"})

       # Build a comment from the post struct
       comment = Ecto.build_assoc(post, :comments, body: "Excellent!")

       Repo.insert!(comment)
     end
   #+END_SRC
   + ~Ecto.build_assoc/3~ builds the comment using the id currently set
     in the post struct. It is equivalent to:
     #+BEGIN_SRC elixir
     %Comment{post_id: post.id, body: "Excellent!"}
     #+END_SRC
 - ~Ecto.build_assoc/3~
   + The ~Ecto.build_assoc/3~ function is specially useful in Phoenix
     controllers. For example, when creating the post, one would do:
     #+BEGIN_SRC elixir
     Ecto.build_assoc(current_user, :post)
     #+END_SRC
     As we likely want to associate the post to the user currently
     signed in the application. In another controller, we could build a
     comment for an existing post with:
     #+BEGIN_SRC elixir
     Ecto.build_assoc(post, :comments)
     #+END_SRC
*** Deleting associations
 - When defining a ~has_many/3~, ~has_one/3~ and friends, you can also pass
   a ~:on_delete~ option that specifies which action should be performed
   on associations when the parent is deleted.
   #+BEGIN_SRC elixir
   has_many :comments, MyApp.Comment, on_delete: :delete_all
   #+END_SRC
   - Besides the value above, ~:nilify_all~ is also supported, with
     ~:nothing~ being the default.
** Embeds
 - Ecto also supports embeds. While associations keep parent and child
   entries in different tables, embeds stores the child along side the
   parent.

 - Databases like MongoDB have native support for embeds. Databases
   like PostgreSQL uses a mixture of JSONB (~embeds_one/3~) and ARRAY
   columns to provide this functionality.

** Ecto.Changeset module
 - Changesets allow filtering, casting, validation and definition of
   constraints when manipulating structs.
 - The functions ~cast/4~ and ~change/2~ are the usual entry points for
   creating changesets
   #+BEGIN_SRC elixir
   comment = Ecto.Changeset.change(%Comment{}, body: "Excellent!")
   #+END_SRC
*** External vs internal data
 - Changesets allow working with both kinds of data:
   + internal to the application - for example programmatically
     generated, or coming from other subsystems. This use case is
     primarily covered by the ~change/2~ and ~put_change/3~ functions.
   + external to the application - for example data provided by the
     user in a form that needs to be type-converted and properly
     validated. This use case is primarily covered by the ~cast/4~
     function.
*** Validations and constraints
 - The difference between validations and constraints
   + is that most validations can be executed without a need to
     interact with the database and, therefore, are always executed
     before attempting to insert or update the entry in the
     database. Some validations may happen against the database but
     they are inherently unsafe. Those validations start with a
     ~unsafe_~ prefix, such as ~unsafe_validate_unique/3~.
   + constraints rely on the database and are always safe
   + validations are always checked before constraints. Constraints
     won’t even be checked in case validations failed
 - example
   create the table
   #+BEGIN_SRC elixir
     defmodule Friends.Repo.Migrations.CreateUsers do
       use Ecto.Migration

       def change do
         create table(:users) do
           add(:name, :string)
           add(:email, :string)
           add(:age, :integer)
           timestamps()
         end

         create(unique_index(:users, [:email]))
       end
     end

   #+END_SRC
   define the schema
   #+BEGIN_SRC elixir
     defmodule User do
       use Ecto.Schema
       import Ecto.Changeset

       schema "users" do
         field :name
         field :email
         field :age, :integer
       end

       def changeset(user, params \\ %{}) do
         user
         |> cast(params, [:name, :email, :age])
         |> validate_required([:name, :email])
         |> validate_format(:email, ~r/@/)
         |> validate_inclusion(:age, 18..100)
         |> unique_constraint(:email)
       end
     end

     changeset = User.changeset(%User{}, %{age: 0, email: "mary@example.com"})
     {:error, changeset} = Repo.insert(changeset)
     changeset.errors #=> [age: {"is invalid", []}, name: {"can't be blank", []}]
   #+END_SRC
*** Associations, embeds and on replace
 - There are two primary APIs:
   1. ~cast_assoc/3~ and ~cast_embed/3~
   2. ~put_assoc/4~ and ~put_embed/4~

 - ~cast_assoc/3~ and ~cast_embed/3~ - those functions are used when
   working with external data. In particular, they allow you to
   change associations and embeds alongside the parent struct, all at
   once.

 - ~put_assoc/4~ and ~put_embed/4~ - it allows you to replace the
   association or embed as a whole. This can be used to move
   associated data from one entry to another, to completely remove or
   replace existing entries.

 - The same way we have used changesets to manipulate embeds, we can
   also use them to change child associations at the same time we are
   manipulating the parent.

 - ~cast_assoc~ (or ~cast_embed~) is used when you want to manage
   associations or embeds based on external parameters, such as the
   data received through Phoenix forms. In such cases, Ecto will
   compare the data existing in the struct with the data sent through
   the form and generate the proper operations. On the other hand, we
   use ~put_assoc~ (or ~put_embed~) when we aleady have the associations
   (or embeds) as structs and changesets, and we simply want to tell
   Ecto to take those entries as is.

 - ~cast_assoc~ is the pendant to ~cast~. aka casting external data
   like coming from a form, while ~put_assocs~ expects you to supply
   already validated and properly checked structs or changesets of the
   association.

 - ~cast_assoc(changeset, name, opts \\ [])~
   + This function should be used when working with the entire
     association at once (and not a single element of a many-style
     association) and using data external to the application.
   + ~cast_assoc/3~ is used when you want to create the associated record
     along with your changeset.
     #+BEGIN_SRC elixir
       defmodule User do
         def changeset(user, params) do
           user
           |> cast(params, @allowed_params)
           |> validate_required(@required_params)
           # Account.changeset is inferred by default
           |> cast_assoc(:account, required: true, with: &Account.registration_changeset/2)
         end
       end

       account = %{plan: "free"}
       user = %{email: "coolio@example.com", password: "bananas", account: account}
       User.changeset(%User{}, user)
     #+END_SRC
     + By default ~cast_assoc/3~ will use ~changeset/2~ in your associated
       model, but you can specify a different by passing the ~:with~
       option.

 - ~put_assoc/4~
   is used when you already have an associated struct and
   you want to assign the association in your changset.
   #+BEGIN_SRC elixir
     defmodule Comment do
       def changeset(comment, params) do
         comment
         |> cast(params, @allowed_params)
         |> validate_required([:text])
         |> put_assoc(:user, params.user)
       end
     end

     comment = %{text: "Hey, sup?", user: some_user}
     Comment.changeset(%Comment{}, comment)
   #+END_SRC




*** Schemaless changesets
 - Such functionality makes Ecto extremely useful to cast, validate and
   prune data even if it is not meant to be persisted to the database.
   #+BEGIN_SRC elixir
     data  = %{}
     types = %{name: :string}
     params = %{name: "Callum"}
     changeset =
       {data, types}
       |> Ecto.Changeset.cast(params, Map.keys(types))
       |> Ecto.Changeset.validate_required(...)
       |> Ecto.Changeset.validate_length(...)
   #+END_SRC
***  The Ecto.Changeset struct
 - The public fields are:
   + ~valid?~ - Stores if the changeset is valid
   + ~data~ - The changeset source data, for example, a struct
   + ~params~ - The parameters as given on changeset creation
   + ~changes~ - The changes from parameters that were approved in
     casting
   + ~errors~ - All errors from validations
   + ~required~ - All required fields as a list of atoms
   + ~action~ - The action to be performed with the changeset
   + ~types~ - Cache of the data’s field types
   + ~empty~_values - A list of values to be considered empty
   + ~repo~ - The repository applying the changeset (only set after a
     Repo function is called)
   + ~repo_opts~ - A keyword list of options given to the underlying
     repository operation
 - The following fields are private and must not be accessed directly.
   + ~validations~
   + ~constraints~
   + ~filters~
** Ecto.LogEntry
** Ecto.Multi
 - ~Ecto.Multi~ is a data structure for grouping multiple Repo
   operations.
 - ~Ecto.Multi~ makes it possible to pack operations that should be
   performed in a single database transaction and gives a way to
   introspect the queued operations without actually performing them.
 - Each operation is given a name that is unique and will identify its
   result in case of success or failure.
 - All operations will be executed in the order they were added.
 - The ~Ecto.Multi~ structure should be considered opaque. You can use
   ~%Ecto.Multi{}~ to pattern match the type, but accessing fields or
   directly modifying them is not advised.
 - ~Ecto.Multi.to_list/1~ returns a canonical representation of the
   structure that can be used for introspection.

 - Example

   The use case we’ll be looking into is resetting a password. We
   need to update the account with proper information, log the
   request and remove all current sessions:
   #+BEGIN_SRC elixir
         defmodule PasswordManager do
           alias Ecto.Multi

           def reset(account, params) do
             Multi.new
             |> Multi.update(:account, Account.password_reset_changeset(account, params))
             |> Multi.insert(:log, Log.password_reset_changeset(account, params))
             |> Multi.delete_all(:sessions, Ecto.assoc(account, :sessions))
           end
         end

         result = Repo.transaction(PasswordManager.reset(account, params))

         case result do
           {:ok, %{account: account, log: log, sessions: sessions}} ->
             # Operation was successful, we can access results (exactly the same
             # we would get from running corresponding Repo functions) under keys
             # we used for naming the operations.
             {:error, failed_operation, failed_value, changes_so_far} ->
             # One of the operations failed. We can access the operation's failure
             # value (like changeset for operations on changesets) to prepare a
             # proper response. We also get access to the results of any operations
             # that succeeded before the indicated operation failed. However, any
             # successful operations would have been rolled back.
     end
   #+END_SRC
   + test it
     #+BEGIN_SRC elixir

       test "dry run password reset" do
         account = %Account{password: "letmein"}
         multi = PasswordManager.reset(account, params)

         assert [
           {:account, {:update, account_changeset, []}},
           {:log, {:insert, log_changeset, []}},
           {:sessions, {:delete_all, query, []}}
         ] = Ecto.Multi.to_list(multi)

         # We can introspect changesets and query to see if everything
         # is as expected, for example:
         assert account_changeset.valid?
         assert log_changeset.valid?
         assert inspect(query) == "#Ecto.Query<from a in Session>"
       end
     #+END_SRC
   + The name of each operation does not have to be an atom. This can
     be particularly useful when you wish to update a collection of
     changesets at once, and track their errors individually:
     #+BEGIN_SRC elixir
       accounts = [%Account{id: 1}, %Account{id: 2}]

       Enum.reduce(accounts, Multi.new(), fn account, multi ->
         Multi.update(
           multi,
           {:account, account.id},
           Account.password_reset_changeset(account, params)
         )
       end)
     #+END_SRC
** Ecto.Query
 - Queries are used to retrieve and manipulate data from a repository
 - Ecto queries come in two flavors: keyword-based and macro-based.
 -
   #+BEGIN_SRC elixir
     # Imports only from/2 of Ecto.Query
     import Ecto.Query, only: [from: 2]

     # Create a query
     query = from u in "users",
               where: u.age > 18,
               select: u.name

     # Send the query to the repository
     Repo.all(query)
   #+END_SRC
*** Query expressions
 - Ecto allows a limited set of expressions inside queries. In the
   query below, for example, we use ~u.age~ to access a field, the ~>~
   comparison operator and the literal ~0~:
   #+BEGIN_SRC elixir
   query = from u in "users", where: u.age > 0, select: u.name
   #+END_SRC
   + Lists all functions allowed in the query API.
     * Comparison operators: ~==~, ~!=~, ~<=~, ~>=~, ~<~, ~>~
     * Arithmetic operators: ~+~, ~-~, ~*~, ~/~
     * Boolean operators: ~and~, ~or~, ~not~
     * Inclusion operator: ~in/2~
     * Search functions: ~like/2~ and ~ilike/2~
     * Null check functions: ~is_nil/1~
     * Aggregates: ~count/0~, ~count/1~, ~avg/1~, ~sum/1~, ~min/1~, ~max/1~
     * Date/time intervals: ~datetime_add/3~, ~date_add/3~, ~from_now/2~, ~ago/2~
     * Inside select: ~struct/2~, ~map/2~, ~merge/2~ and literals (map, tuples, lists, etc)
     * General: ~fragment/1~, ~field/2~ and ~type/2~
   + also following literals are supported in queries
     * Integers: ~1~, ~2~, ~3~
     * Floats: ~1.0~, ~2.0~, ~3.0~
     * Booleans: ~true~, ~false~
     * Binaries: ~<<1, 2, 3>>~
     * Strings: ~"foo bar"~, ~~s(this is a string)~
     * Arrays: ~[1, 2, 3]~, ~~w(interpolate words)~

*** Interpolation and casting
 - External values and Elixir expressions can be injected into a query
   expression with ~^~:
   #+BEGIN_SRC elixir
     def with_minimum(age, height_ft) do
       from u in "users",
         where: u.age > ^age and u.height > ^(height_ft * 3.28),
         select: u.name
     end

     with_minimum(18, 5.0)
   #+END_SRC
 - explicitly tell Ecto what is the expected type of the value being
   interpolated
   #+BEGIN_SRC elixir
     age = "18"
     Repo.all(from u in "users",
               where: u.age > type(^age, :integer),
               select: u.name)
   #+END_SRC
*** ~nil~ comparison
 - nil comparison in filters, such as where and having, is forbidden
   and it will raise an error:
   #+BEGIN_SRC elixir
   # Raises if the variable age (in this case used with ^ operator) is nil
   from u in User, where: u.age == ^age
   #+END_SRC
 - check that value is nil, use ~is_nil/1~
   #+BEGIN_SRC elixir
   from u in User, where: is_nil(u.age)
   #+END_SRC
*** Composition
 - Ecto queries are composable
   #+BEGIN_SRC elixir
     # Create a query
     query = from u in User, where: u.age > 18

     # Extend the query
     query = from u in query, select: u.name
   #+END_SRC
 - Any value can be used on the right-side of ~in~ as long as it
   implements the [[https://hexdocs.pm/ecto/Ecto.Queryable.html][~Ecto.Queryable]]~ protocol.
*** Positional bindings
 - On the left side of ~in~ we specify the query bindings. This is done
   inside ~from~ and ~join~ clauses
 - In the query below ~u~ is a binding and ~u.age~ is a field access using
   this binding
   #+BEGIN_SRC elixir
   query = from u in User, where: u.age > 18
   #+END_SRC
 - When using joins, the bindings should be matched in the order they
   are specified:
   #+BEGIN_SRC elixir
     # Create a query
     query = from p in Post,
               join: c in Comment, where: c.post_id == p.id

     # Extend the query
     query = from [p, c] in query,
               select: {p.title, c.body}
   #+END_SRC
   + You are not required to specify all bindings when composing
   + if you are interested only on the last binding (or the last
     bindings) in a query, you can use ~...~ to specify “all bindings
     before” and match on the last one.
     #+BEGIN_SRC elixir
     from [p, ..., c] in posts_with_comments, select: {p.title, c.body}
     #+END_SRC
     * In other words, ~...~ will include all the binding between the
       first and the last, which may be no binding at all, one or many.
*** Named bindings
 - We can named the bindings. This approach lets us not worry about
   keeping track of the position of the bindings when composing the
   query.
   #+BEGIN_SRC elixir
     posts_with_comments =
       from p in query,
         join: c in Comment, as: :comment, where: c.post_id == p.id

     from [p, comment: c] in posts_with_comments, select: {p.title, c.body}
   #+END_SRC
   a name can be assigned to the first binding as well:
   #+BEGIN_SRC elixir
     from p in Post, as: :post
   #+END_SRC
   Only atoms are accepted for binding names. Named binding references
   are expected to be placed in the tail position of the bindings list

*** Bindingless operations
 - bindings are not necessary when the query has only the ~from~ clause.
   #+BEGIN_SRC elixir
     from Post,
       where: [category: "fresh and new"],
       order_by: [desc: :published_at],
       select: [:id, :title, :body]


     # It is equivalent to:
     from p in Post,
       where: p.category == "fresh and new",
       order_by: [desc: p.published_at],
       select: struct(p, [:id, :title, :body])


     # we can also dynamically build them
     where = [category: "fresh and new"]
     order_by = [desc: :published_at]
     select = [:id, :title, :body]
     from Post, where: ^where, order_by: ^order_by, select: ^select
   #+END_SRC
*** Fragments
 - It is not possible to represent all possible database queries using
   Ecto’s query syntax. When such is required, it is possible to use
   fragments to send any expression to the database
 - Ecto provides fragments to inject SQL (and non-SQL) fragments into
   queries
   #+BEGIN_SRC elixir
     from p in Post,
       where: is_nil(p.published_at) and
              fragment("lower(?)", p.title) == ^title
   #+END_SRC
   we are using the ~lower~ procedure in the database to downcase the
   ~title~ column
 - [[https://hexdocs.pm/ecto/Ecto.Query.API.html#fragment/1][doc]]

*** Macro API
 - keywords query syntax
   #+BEGIN_SRC elixir
     import Ecto.Query
     from u in "users", where: u.age > 18, select: u.name
   #+END_SRC
 - Ecto also supports a pipe-based syntax:
   #+BEGIN_SRC elixir
     "users"
     |> where([u], u.age > 18)
     |> select([u], u.name)
   #+END_SRC
 - The downside of using macros is that the binding must be specified
   for every operation. However, since keyword-based and pipe-based
   examples are equivalent, the bindingless syntax also works for
   macros:
   #+BEGIN_SRC elixir
     "users"
     |> where([u], u.age > 18)
     |> select([:name])
   #+END_SRC

*** Query Prefix
 - It is possible to set a prefix for the queries. For Postgres users,
   this will specify the schema where the table is located, while for
   MySQL users this will specify the database where the table is
   located. When no prefix is set, Postgres queries are assumed to be
   in the public schema, while MySQL queries are assumed to be in the
   database set in the config for the repo.
 - The query prefix may be set either for the whole query or on each
   individual ~from~ and ~join~ expression. If a ~prefix~ is not given to a
   ~from~ or a ~join~, the prefix of the schema given to the from or join
   is used.
 - examples
   #+BEGIN_SRC elixir
   results = Repo.all(query, prefix: "accounts")
   #+END_SRC
   #+BEGIN_SRC elixir
     results =
       query # May be User or an Ecto.Query itself
       |> Ecto.Queryable.to_query
       |> Map.put(:prefix, "accounts")
       |> Repo.all()
   #+END_SRC
   #+BEGIN_SRC elixir
     results =from u in User,
       prefix: "accounts",
       join: p in assoc(u, :posts),
       prefix: "public"
   #+END_SRC
 - prefix lookup precedence:
   + The ~:prefix~ option given to ~from~ / ~join~ has the highest precedence
   + Then it falls back to the ~@schema_prefix~ attribute declared in the
     schema given to ~from~ / ~join~
   + Then it falls back to the query prefix

**** functions
 - ~distinct(query, binding \\ [], expr)~
   #+BEGIN_SRC elixir
     # Returns the list of different categories in the Post schema
     from(p in Post, distinct: true, select: p.category)

     # If your database supports DISTINCT ON(),
     # you can pass expressions to distinct too
     from(p in Post,
        distinct: p.category,
        order_by: [p.date])

     # The DISTINCT ON() also supports ordering similar to ORDER BY.
     from(p in Post,
        distinct: [desc: p.category],
        order_by: [p.date])

     # Using atoms
     from(p in Post, distinct: :category, order_by: :date)


     # Expressions example
     Post
     |> distinct(true)
     |> order_by([p], [p.category, p.author])
   #+END_SRC
 - ~exclude(query, field)~
   Resets a previously set field on a query.
   #+BEGIN_SRC elixir
   Ecto.Query.exclude(query, :join)
   Ecto.Query.exclude(query, :where)
   Ecto.Query.exclude(query, :order_by)
   Ecto.Query.exclude(query, :group_by)
   Ecto.Query.exclude(query, :having)
   Ecto.Query.exclude(query, :distinct)
   Ecto.Query.exclude(query, :select)
   Ecto.Query.exclude(query, :combinations)
   Ecto.Query.exclude(query, :limit)
   Ecto.Query.exclude(query, :offset)
   Ecto.Query.exclude(query, :lock)
   Ecto.Query.exclude(query, :preload)
   Ecto.Query.exclude(query, :inner_join)
   Ecto.Query.exclude(query, :cross_join)
   Ecto.Query.exclude(query, :left_join)
   Ecto.Query.exclude(query, :right_join)
   Ecto.Query.exclude(query, :full_join)
   Ecto.Query.exclude(query, :inner_lateral_join)
   Ecto.Query.exclude(query, :left_lateral_join)
   #+END_SRC
   keep in mind that if a join is removed and its bindings were
   referenced elsewhere, the bindings won’t be removed, leading to a
   query that won’t compile.
 - ~group_by(query, binding \\ [], expr)~
   + Groups together rows from the schema that have the same values in
     the given fields.
     #+BEGIN_SRC elixir
       # Returns the number of posts in each category
       from(p in Post,
         group_by: p.category,
         select: {p.category, count(p.id)})

       # Using atoms
       from(p in Post, group_by: :category, select: {p.category, count(p.id)})

       # Using direct fields access
       from(p in Post,
         join: c in assoc(p, :category)
         group_by: [p.id, c.name])

       # Expressions example
       Post |> group_by([p], p.category) |> select([p], count(p.id))
     #+END_SRC
 - ~having(query, binding \\ [], expr)~
   + Like ~where~, ~having~ filters rows from the schema, but after the
     grouping is performed giving it the same semantics as ~select~ for a
     grouped query. ~having~ groups the query even if
     the query has no ~group_by~ expression.
     #+BEGIN_SRC elixir
       # Returns the number of posts in each category where the
       # average number of comments is above ten
       from(p in Post,
         group_by: p.category,
         having: avg(p.num_comments) > 10,
         select: {p.category, count(p.id)})

       # Expressions example
       Post
       |> group_by([p], p.category)
       |> having([p], avg(p.num_comments) > 10)
       |> select([p], count(p.id))
     #+END_SRC
 - ~preload(query, bindings \\ [], expr)~
   #+BEGIN_SRC elixir
   Repo.all from p in Post, preload: [:comments]
   #+END_SRC
   + The example above will fetch all posts from the database and then
     do a separate query returning all comments associated with the
     given posts.
   + you may want posts and comments to be selected and filtered in the
     same query:
     #+BEGIN_SRC elixir
       Repo.all from p in Post,
                  join: c in assoc(p, :comments),
                  where: c.published_at > p.updated_at,
                  preload: [comments: c]
     #+END_SRC
   + Note: keep in mind operations like limit and offset in the preload
     query will affect the whole result set and not each
     association. For example, the query below:
     #+BEGIN_SRC elixir
       comments_query = from c in Comment, order_by: c.popularity, limit: 5
       Repo.all from p in Post, preload: [comments: ^comments_query]
     #+END_SRC
     won’t bring the top of comments per post. Rather, it will only
     bring the 5 top comments across all posts.
** Ecto.Repo behaviour
 - A repository maps to an underlying data store, controlled by the
   adapter. For example, Ecto ships with a Postgres adapter
 - When used, the repository expects the ~:otp_app~ as option. The
   ~:otp_app~ should point to an OTP application that has the repository
   configuration.
   #+BEGIN_SRC elixir
     defmodule Repo do
       use Ecto.Repo,
         otp_app: :my_app,
         adapter: Ecto.Adapters.Postgres
     end
   #+END_SRC
   + Could be configured with:
     #+BEGIN_SRC elixir
       config :my_app, Repo,
         database: "ecto_simple",
         username: "postgres",
         password: "postgres",
         hostname: "localhost"
     #+END_SRC
   + Most of the configuration that goes into the config is specific to
     the adapter, so check ~Ecto.Adapters.Postgres~ documentation
 - Almost all of the repository operations accept the following
   options:
   + ~:timeout~ - The time in milliseconds to wait for the query call
     to finish, ~:infinity~ will wait indefinitely (default: 15000);
   + ~:log~ - When false, does not log the query
   + ~:telemetry_event~ - The telemetry event name to dispatch the
     event under
 - ~insert(struct_or_changeset, opts)~
   - In case a struct is given, the struct is converted into a
     changeset with all non-nil fields as part of the changeset.
   - In case a changeset is given, the changes in the changeset are
     merged with the struct fields, and all of them are sent to the
      database.
 - ~load(module_or_map, data)~
   Loads ~data~ into a struct or a map.
   #+BEGIN_SRC elixir
     iex> result = Ecto.Adapters.SQL.query!(MyRepo, "SELECT * FROM users", [])
     iex> Enum.map(result.rows, &MyRepo.load(User, {result.columns, &1}))
     [%User{...}, ...]
   #+END_SRC
 - ~preload(structs_or_struct_or_nil, preloads, opts)~
   + Preloads all associations on the given struct or structs.
   + This is similar to ~Ecto.Query.preload/3~ except it allows you to
     preload structs after they have been fetched from the database.
     #+BEGIN_SRC elixir
       # Use a single atom to preload an association
       posts = Repo.preload posts, :comments

       # Use a list of atoms to preload multiple associations
       posts = Repo.preload posts, [:comments, :authors]

       # Use a keyword list to preload nested associations as well
       posts = Repo.preload posts, [comments: [:replies, :likes], authors: []]

       # Use a keyword list to customize how associations are queried
       posts = Repo.preload posts, [comments: from(c in Comment, order_by: c.published_at)]

       # Use a two-element tuple for a custom query and nested association definition
       query = from c in Comment, order_by: c.published_at
       posts = Repo.preload posts, [comments: {query, [:replies, :likes]}]
     #+END_SRC
 - ~transaction(fun_or_multi, opts)~
   + Runs the given function or ~Ecto.Multi~ inside a transaction.
     #+BEGIN_SRC elixir
       import Ecto.Changeset, only: [change: 2]

       MyRepo.transaction(fn ->
         MyRepo.update!(change(alice, balance: alice.balance - 10))
         MyRepo.update!(change(bob, balance: bob.balance + 10))
       end)

       # Roll back a transaction explicitly
       MyRepo.transaction(fn ->
         p = MyRepo.insert!(%Post{})
         if not Editor.post_allowed?(p) do
           MyRepo.rollback(:posting_not_allowed)
         end
       end)

       # With Ecto.Multi
       Ecto.Multi.new
       |> Ecto.Multi.insert(:post, %Post{})
       |> MyRepo.transaction
     #+END_SRC
 - ~update_all(queryable, updates, opts)~
   #+BEGIN_SRC elixir
     MyRepo.update_all(Post, set: [title: "New title"])

     MyRepo.update_all(Post, inc: [visits: 1])

     from(p in Post, where: p.id < 10, select: p.visits)
     |> MyRepo.update_all(set: [title: "New title"])

     from(p in Post, where: p.id < 10, update: [set: [title: "New title"]])
     |> MyRepo.update_all([])

     from(p in Post, where: p.id < 10, update: [set: [title: ^new_title]])
     |> MyRepo.update_all([])

     from(p in Post, where: p.id < 10, update: [set: [title: fragment("upper(?)", ^new_title)]])
     |> MyRepo.update_all([])
   #+END_SRC
** Ecto.Schema
 - An Ecto schema is used to map any data source into an Elixir struct
 - The definition of the schema is possible through two main APIs:
   ~schema/2~ and ~embedded_schema/1~
   1) ~schema/2~
      + is typically used to map data from a persisted source,
        usually a database table, into Elixir structs and vice-versa.
      + lso contain a ~__meta__~ field with metadata holding the status
        of the struct, for example, if it has been built, loaded or
        deleted.
   2) ~embedded_schema/1~
      + is used for defining schemas that are embedded in other schemas
        or only exist in-memory.
      + For example, you can use such schemas to receive data from a
        command line interface and validate it, without ever persisting
        it elsewhere.
      + Such structs do not contain a ~__meta__~ field, as they are
        never persisted.
 - Besides working as data mappers, ~embedded_schema/1~ and ~schema/2~ can
   also be used together to decouple how the data is represented in
   your applications from the database.
 - Sample
   #+BEGIN_SRC elixir
     defmodule User do
       use Ecto.Schema

       schema "users" do
         field :name, :string
         field :age, :integer, default: 0
         has_many :posts, Post
       end
     end
   #+END_SRC
   #+BEGIN_SRC elixir
     iex> user = %User{name: "jane"}
     iex> %{user | age: 30}
   #+END_SRC
   + a schema will automatically generate a primary key which is named
     ~id~ and of type ~:integer~
 - structs are cast, validated and manipulated with the ~Ecto.Changeset~
   module.
 - you can use an embedded schema to represent your UI, mapping and
   validating its inputs, and then you convert such embedded schema to
   other schemas that are persisted to the database:
   #+BEGIN_SRC elixir
     defmodule SignUp do
       use Ecto.Schema

       embedded_schema do
         field :name, :string
         field :age, :integer
         field :email, :string
         field :accepts_conditions, :boolean
       end
     end

     defmodule Profile do
       use Ecto.Schema

       schema "profiles" do
         field :name
         field :age
         belongs_to :account, Account
       end
     end

     defmodule Account do
       use Ecto.Schema

       schema "accounts" do
         field :email
       end
     end
   #+END_SRC
   The ~SignUp~ schema can be cast and validated with the help of the
   ~Ecto.Changeset~ module, and afterwards, you can copy its data to the
   ~Profile~ and ~Account~ structs that will be persisted to the database
   with the help of ~Ecto.Repo~
*** Schema attributes
 - Supported attributes for configuring the defined schema. They must
   be set after the ~use Ecto.Schema~ call and before the ~schema/2~
   definition.
   + ~@primary_key~
     * Defaults to ~{:id, :id, autogenerate: true}~
   + ~@schema_prefix~
     * Defaults to ~nil~, which generates structs and queries without
       prefix.
     * When set, the prefix will be used by every built struct and on
       queries whenever the schema is used in a ~from~ or a ~join~
     * In PostgreSQL, the prefix is called “SCHEMA” (typically set via
       Postgres’ ~search_path~). In MySQL the prefix points to databases.
   + ~@foreign_key_type~
     * configures the default foreign key type used by ~belongs_to~
       associations. It must be set in the same module that defines the
       ~belongs_to~. Defaults to ~:id~
   + ~@timestamps_opts~
     * configures the default timestamps type used by
       ~timestamps~. Defaults to ~[type: :naive_datetime]~
   + ~@derive~
     * the same as ~@derive~ available in ~Kernel.defstruct/1~ as the
       schema defines a struct behind the scenes
   + ~@field_source_mapper~
     * a function that receives the current field name and returns the
       mapping of this field name in the underlying source. In other
       words, it is a mechanism to automatically generate the ~:source~
       option for the ~field~ macro. It defaults to ~fn x -> x~ end, where
       no field transformation is done;
 - with a macro to configure application wide defaults:
   #+BEGIN_SRC elixir
     # Define a module to be used as base
     defmodule MyApp.Schema do
       defmacro __using__(_) do
         quote do
           use Ecto.Schema
           @primary_key {:id, :binary_id, autogenerate: true}
           @foreign_key_type :binary_id
         end
       end
     end

     # Now use MyApp.Schema to define new schemas
     defmodule MyApp.Comment do
       use MyApp.Schema

       schema "comments" do

         # will also define a :post_id field with :binary_id type that
         # references the :id field of the MyApp.Post schema.
         belongs_to :post, MyApp.Post
       end
     end
   #+END_SRC

*** Primary keys
 - Ecto supports two ID types, often used as the type for primary keys
   and associations:
   + ~:id~
     * used when the primary key is an integer
     *
   + ~:binary_id~
     * used for primary keys in particular binary formats, which may be
       ~Ecto.UUID~ for databases like PostgreSQL and MySQL, or some
       specific ObjectID or RecordID often imposed by NoSQL databases.
 - Ecto also supports composite primary keys. This is achieved by
   declaring a ~@primary_key~, as usual, and then passing the
   ~primary_key: true~ option to any of the composite fields
*** Types and casting
 - Types are split into two categories
   1. primitive types
     | ECTO TYPE              | ELIXIR TYPE          | LITERAL SYNTAX IN QUERY |
     |------------------------+----------------------+-------------------------|
     | ~:id~                  | ~integer~            | 1,2,3                   |
     | ~:binary_id~           | ~binary~             | ~<<int,int,int,...>>~   |
     | ~:integer~             | ~integer~            | 1,2,3                   |
     | ~:float~               | ~float~              | 1.0, 2.0, 3.0           |
     | ~:boolean~             | ~boolean~            | true, false             |
     | ~:string~              | UTF-8 encoded string | "hello"                 |
     | ~:binary~              | ~binary~             | ~<<int,int,int,...>>~   |
     | ~{:array, inner_type}~ | ~list~               | ~[value, value, ...]~   |
     | ~:map~                 | ~map~                |                         |
     | ~{:map, inner_type}~   | ~map~                |                         |
     | ~:decimal~             | ~[[https://github.com/ericmj/decimal][Decimal]]~            |                         |
     | ~:date~                | ~[[https://hexdocs.pm/elixir/Date.html][Date]]~               |                         |
     | ~:time~                | ~[[https://hexdocs.pm/elixir/Time.html][Time]]~               |                         |
     | ~:naive_datetime~      | ~[[https://hexdocs.pm/elixir/NaiveDateTime.html][NaiveDateTime]]~      |                         |
     | ~:naive_datetime_usec~ | ~[[https://hexdocs.pm/elixir/NaiveDateTime.html][NaiveDateTime]]~      |                         |
     | ~:utc_datetime~        | ~[[https://hexdocs.pm/elixir/DateTime.html][DateTime]]~           |                         |
     | ~:utc_datetime_usec~   | ~[[https://hexdocs.pm/elixir/DateTime.html][DateTime]]~           |                         |

      * For the ~{:array, inner_type}~ and ~{:map, inner_type}~ type,
        replace ~inner_type~ with one of the valid types, such as ~:string~.

      * For the ~:decimal~ type, ~+Infinity~, ~-Infinity~, and ~NaN~ values are
        not supported, even though the ~[[https://github.com/ericmj/decimal][Decimal]]~ library handles them. To
        support them, you can create a custom type.

      * For calendar types with and without microseconds, the precision
        is enforced when persisting to the DB. For example, casting
        =~T[09:00:00]= as =:time_usec= will succeed and result in
        =~T[09:00:00.000000]=, but persisting a type without microseconds
        as ~:time_usec~ will fail. Similarly, casting =~T[09:00:00.000000]=
        as =:time= will succeed, but persisting will not. This is the
        same behaviour as seen in other types, where casting has to be
        done explicitly and is never performed implicitly when loading
        from or dumping to the database.
   2. custom types
      - Ecto allows custom types to be implemented by developers,
        allowing Ecto behaviour to be extended.
      - A custom type is a module that implements the ~[[https://hexdocs.pm/ecto/Ecto.Type.html][Ecto.Type]]~
        behaviour. By default, Ecto provides the following custom
        types:
        | CUSTOM TYPE	 | DATABASE TYPE | ELIXIR TYPE |
        |-----------------+---------------+-------------|
        | [[https://hexdocs.pm/ecto/Ecto.UUID.html][Ecto.UUID]]       | :uuid         | uuid-string |

 - schemas can also have virtual fields by passing the ~virtual: true~
   option. These fields are not persisted to the database and can
   optionally not be type checked by declaring type ~:any~
**** The datetime types
 - Four different datetime primitive types are available:
   1. ~naive_datetime~ - has a precision of *seconds* and casts values to
      Elixir’s ~NaiveDateTime~ struct which has no timezone information.
   2. ~naive_datetime_usec~ - has a default precision of *microseconds*
      and also casts values to ~NaiveDateTime~ with no timezone
      information.
   3. ~utc_datetime~ - has a precision of seconds and casts values to
      Elixir’s ~DateTime~ struct and expects the time zone to be set to
      UTC.
   4. ~utc_datetime_usec~ has a default precision of microseconds and
      also casts values to ~DateTime~ expecting the time zone be set to
      UTC.
 - keep in mind that Elixir functions like ~NaiveDateTime.utc_now/0~ have
   a default precision of 6. Casting a value with a precision greater
   than 0 to a non-~usec~ type will truncate all microseconds and set the
   precision to 0.
**** The map type
 - The map type allows developers to store an Elixir map directly in
   the database:
   #+BEGIN_SRC elixir
     # In your migration
     create table(:users) do
       add :data, :map
     end

     # In your schema
     field :data, :map

     # Now in your code
     user = Repo.insert! %User{data: %{"foo" => "bar"}}
   #+END_SRC
 - In order to support maps, different databases may employ different
   techniques. For example, PostgreSQL will store those values in jsonb
   fields, allowing you to just query parts of it.
 - For maps to work in such databases, Ecto will need a JSON
   library. By default Ecto will use ~Jason~ which needs to be added to
   your deps in ~mix.exs~:
   #+BEGIN_SRC elixir
   {:jason, "~> 1.0"}
   #+END_SRC
**** Casting
 - When directly manipulating the struct, it is the responsibility of
   the developer to ensure the field values have the proper type. For
   example, you can create a user struct with an invalid value for ~age~:
   #+BEGIN_SRC elixir
     iex> user = %User{age: "0"}
     iex> user.age
     "0"
   #+END_SRC
 - However, if you attempt to persist the struct above, an error will
   be raised since Ecto validates the types when sending them to the
   adapter/database.
 - Therefore, when working with and manipulating external data, it is
   recommended to use ~Ecto.Changeset~'s that are able to filter and
   properly cast external data:
   #+BEGIN_SRC elixir
     changeset = Ecto.Changeset.cast(%User{}, %{"age" => "0"}, [:age])
     user = Repo.insert!(changeset)
   #+END_SRC
 - You can use Ecto schemas and changesets to cast and validate any
   kind of data, regardless if the data will be persisted to an Ecto
   repository or not.
*** Reflection
 - Any schema module will generate the ~__schema__~ function that can be
   used for runtime introspection of the schema:

   + ~__schema__(:source)~ - Returns the source as given to ~schema/2~;

   + ~__schema__(:prefix)~ - Returns optional prefix for source
       provided by ~@schema_prefix~ schema attribute;

   + ~__schema__(:primary_key)~ - Returns a list of primary key fields
       (empty if there is none);

   + ~__schema__(:fields)~ - Returns a list of all non-virtual field
       names;

   + ~__schema__(:field_source, field)~ - Returns the alias of the
       given field;

   + ~__schema__(:type, field)~ - Returns the type of the given
       non-virtual field;

   + ~__schema__(:associations)~ - Returns a list of all association
       field names;

   + ~__schema__(:association, assoc)~ - Returns the association
       reflection of the given assoc;

   + ~__schema__(:embeds)~ - Returns a list of all embedded field
       names;

   + ~__schema__(:embed, embed)~ - Returns the embedding reflection of
       the given embed;

   + ~__schema__(:read_after_writes)~ - Non-virtual fields that must be
       read back from the database after every write (insert or update);

   + ~__schema__(:autogenerate_id)~ - Primary key that is auto
       generated on insert;

*** Functions
 - ~belongs_to(name, queryable, opts \\ [])~
   + Indicates a one-to-one or many-to-one association with another
     schema.
   + The current schema belongs to zero or one records of the other
     schema. The other schema often has a ~has_one~ or a ~has_many~ field
     with the reverse association.
   + You should use ~belongs_to~ in the table that contains the foreign
     key. Imagine a company <-> employee relationship. If the employee
     contains the ~company_id~ in the underlying database table, we say
     the employee belongs to company.
   + when you invoke this macro, a field with the name of foreign key
     is automatically defined in the schema for you.
   + ~opts~
     * ~:foreign_key~ - Sets the foreign key field name, defaults to
       the name of the association suffixed by ~_id~. For example,
       ~belongs_to :company~ will define foreign key of ~:company_id~
     * ~:references~ - Sets the key on the other schema to be used for
       the association, defaults to: ~:id~
     * ~:define_field~ - When ~false~, does not automatically define a
       ~:foreign_key~ field, implying the user is defining the field
       manually elsewhere
     * ~:type~ - Sets the type of automatically defined
       ~:foreign_key~. Defaults to: ~:integer~ and can be set per schema
       via ~@foreign_key_type~
     * ~:on_replace~ - The action taken on associations when the record
       is replaced when casting or manipulating parent changeset. May
       be ~:raise~ (default), ~:mark_as_invalid~, ~:nilify~, ~:update~, or
       ~:delete~. See ~[[Https://hexdocs.pm/ecto/Ecto.Changeset.html#module-the-on_replace-option][Ecto Changeset]]~
     * ~:defaults~ - Default values to use when building the
       association. This overrides any default set on the association
       schema. For example, imagine
       ~Post.has_many :comments, defaults: [public: true]~.
       Then when using ~Ecto.build_assoc(post, :comments)~
       that comment will have ~comment.public == true~.
     * ~:primary_key~ - If the underlying belongs_to field is a primary
       key
     * ~:source~ - The source for the underlying field
     * ~:where~ - A filter for the association.
   + example
     #+BEGIN_SRC elixir
       defmodule Comment do
         use Ecto.Schema

         schema "comments" do
           belongs_to :post, Post
         end
       end

       # The post can come preloaded on the comment record
       [comment] = Repo.all(from(c in Comment, where: c.id == 42, preload: :post))
       comment.post #=> %Post{...}
     #+END_SRC
     * If you need custom options on the underlying field, you can
       define the field explicitly and then pass ~define_field: false~ to
       ~belongs_to~:
       #+BEGIN_SRC elixir
         defmodule Comment do
           use Ecto.Schema

           schema "comments" do
             field :post_id, :integer, ... # custom options
             belongs_to :post, Post, define_field: false
           end
         end
       #+END_SRC
   + Polymorphic associations
     * magine you have defined a Comment schema and you wish to use it
       for commenting on both tasks and posts.
     * Some abstractions would force you to define some sort of
       polymorphic association with two fields in your database:
       #+BEGIN_SRC
       * commentable_type
       * commentable_id
       #+END_SRC
     * In Ecto, we have three ways to solve this issue.
       1. The simplest is to define multiple fields in the Comment
          schema, one for each association:
          #+BEGIN_SRC
          * task_id
          * post_id
          #+END_SRC

       2. because Ecto does not tie a schema to a given table, we can
          use separate tables for each association.
          #+BEGIN_SRC elixir
            defmodule Comment do
              use Ecto.Schema

              schema "abstract table: comments" do

                # This will be used by associations
                # on each "concrete" table
                field :assoc_id, :integer
              end
            end
          #+END_SRC
          Notice we have changed the table name to ~abstract table: comments~.
          You can choose whatever name you want, the point here is that
          this particular table will never exist.

          Now in your Post and Task schemas:
          #+BEGIN_SRC elixir
            defmodule Post do
              use Ecto.Schema

              schema "posts" do
                has_many :comments, {"posts_comments", Comment}, foreign_key: :assoc_id
              end
            end

            defmodule Task do
              use Ecto.Schema

              schema "tasks" do
                has_many :comments, {"tasks_comments", Comment}, foreign_key: :assoc_id
              end
            end
          #+END_SRC
          Now each association uses its own specific table,
          ~posts_comments~ and ~tasks_comments~, which must be created
          on migrations. The advantage of this approach is that we
          never store unrelated data together, also ensuring we keep
          database references fast and correct.

          When using this technique, the only limitation is that you
          cannot build comments directly. For example, the command
          below
          #+BEGIN_SRC elixir
          Repo.insert!(%Comment{})
          #+END_SRC
          will attempt to use the abstract table. Instead, one should
          use
          #+BEGIN_SRC elixir
          Repo.insert!(build_assoc(post, :comments))
          #+END_SRC
          leveraging the ~Ecto.build_assoc/3~ function. You can also use
          ~Ecto.assoc/2~ and ~Ecto.Query.assoc/2~ in the query syntax to
          easily retrieve associated comments to a given post or task:
          #+BEGIN_SRC elixir
            # Fetch all comments associated with the given task
            Repo.all(assoc(task, :comments))
          #+END_SRC
          Or all comments in a given table:
          #+BEGIN_SRC elixir
          Repo.all from(c in {"posts_comments", Comment}), ...)
          #+END_SRC

       3. The third and final option is to use ~many_to_many/3~ to define
          the relationships between the resources. In this case, the
          comments table won’t have the foreign key, instead there is a
          intermediary table responsible for associating the entries:
          #+BEGIN_SRC elixir
            defmodule Comment do
              use Ecto.Schema
              schema "comments" do
                # ...
              end
            end
          #+END_SRC
          In your posts and tasks:
          #+BEGIN_SRC elixir
            defmodule Post do
              use Ecto.Schema

              schema "posts" do
                many_to_many :comments, Comment, join_through: "posts_comments"
              end
            end

            defmodule Task do
              use Ecto.Schema

              schema "tasks" do
                many_to_many :comments, Comment, join_through: "tasks_comments"
              end
            end
          #+END_SRC
 - ~embedded_schema(list)~
   + An embedded schema is either embedded into another schema or kept
     exclusively in memory. For this reason, an embedded schema does
     not require a source name and it does not include a metadata
     field.
 - ~embeds_many(name, schema, opts \\ [])~
   + The current schema has zero or more records of the other schema
     embedded inside of it. Embeds have all the things regular schemas
     have.

   + It is recommended to declare your ~embeds_many/3~ field with type
     ~:map~ and a default of ~"[]"~ (although Ecto will also automatically
     translate ~nil~ values from the database into empty lists).

   + example
     #+BEGIN_SRC elixir
       defmodule Order do
         use Ecto.Schema

         schema "orders" do
           embeds_many :items, Item
         end
       end

       defmodule Item do
         use Ecto.Schema

         embedded_schema do
           field :title
         end
       end

       # The items are loaded with the order
       order = Repo.get!(Order, 42)
       order.items #=> [%Item{...}, ...]
     #+END_SRC
   + Adding and removal of embeds can only be done via the
     ~Ecto.Changeset~ API so Ecto can properly track the embed
     life-cycle:

     #+BEGIN_SRC elixir
       # Order has no items
       order = Repo.get!(Order, 42)
       order.items
       # => []

       items  = [%Item{title: "Soap"}]

       # Generate a changeset
       changeset = Ecto.Changeset.change(order)

       # Put a one or more new items
       # remember there's a :on_replace the you need to be aware of
       changeset = Ecto.Changeset.put_embed(changeset, :items, items)

       # Update the order and fetch items
       items = Repo.update!(changeset).items

       # Items are generated with a unique identification
       items
       # => [%Item{id: "20a97d94-f79b-4e63-a875-85deed7719b7", title: "Soap"}]
     #+END_SRC
   + Updating of embeds must be done using a changeset for each changed
     embed.
     #+BEGIN_SRC elixir
       # Order has an existing items
       order = Repo.get!(Order, 42)
       order.items
       # => [%Item{id: "20a97d94-f79b-4e63-a875-85deed7719b7", title: "Soap"}]

       # Generate a changeset
       changeset = Ecto.Changeset.change(order)

       # Put the updated item as a changeset
       current_item = List.first(order.items)
       item_changeset = Ecto.Changeset.change(current_item, title: "Mujju's Soap")
       order_changeset = Ecto.Changeset.put_embed(changeset, :items, [item_changeset])

       # Update the order and fetch items
       items = Repo.update!(order_changeset).items

       # Item has the updated title
       items
       # => [%Item{id: "20a97d94-f79b-4e63-a875-85deed7719b7", title: "Mujju's Soap"}]
     #+END_SRC
   + Inline embedded schema
     * The schema module can be defined inline in the parent schema in
       simple cases:
       #+BEGIN_SRC elixir
         defmodule Parent do
           use Ecto.Schema

           schema "parents" do
             field :name, :string

             embeds_many :children, Child do
               field :name, :string
               field :age,  :integer
             end
           end

           def changeset(schema, params) do
             schema
             |> cast(params, [:name])
             |> cast_embed(:children, with: &child_changeset/2)
           end

           defp child_changeset(schema, params) do
             schema
             |> cast(params, [:name, :age])
           end
           Link to this macro
         end
       #+END_SRC
     * Primary keys are automatically set up for embedded schemas as
       well, defaulting to ~{:id, :binary_id, autogenerate: true}~
 - ~embeds_many(name, schema, opts, list)~
   + Indicates an embedding of many schemas.
 - ~embeds_one(name, schema, opts \\ [])~
   + Indicates an embedding of a schema.

   + The current schema has zero or one records of the other schema
     embedded inside of it. It uses a field similar to the ~:map~ type
     for storage, but allows embeds to have all the things regular
     schema can.

   + You must declare your ~embeds_one/3~ field with type ~:map~ at the
     database level.

   + The embedded may or may not have a primary key. Ecto use the
     primary keys to detect if an embed is being updated or not. If a
     primary is not present, ~:on_replace~ should be set to either
     ~:update~ or ~:delete~ if there is a desire to either update or delete
     the current embed when a new one is set.

   + example
     #+BEGIN_SRC elixir
       defmodule Order do
         use Ecto.Schema

         schema "orders" do
           embeds_one :item, Item
         end
       end

       defmodule Item do
         use Ecto.Schema

         embedded_schema do
           field :title
         end
       end

       # The item is loaded with the order
       order = Repo.get!(Order, 42)
       order.item #=> %Item{...}
     #+END_SRC

   + Adding and removal of embeds can only be done via the
     ~Ecto.Changeset~ API so Ecto can properly track the embed
     life-cycle:
     #+BEGIN_SRC elixir
       order = Repo.get!(Order, 42)
       item  = %Item{title: "Soap"}

       # Generate a changeset
       changeset = Ecto.Changeset.change(order)

       # Put a new embed to the changeset
       changeset = Ecto.Changeset.put_embed(changeset, :item, item)

       # Update the order, and fetch the item
       item = Repo.update!(changeset).item

       # Item is generated with a unique identification
       item
       # => %Item{id: "20a97d94-f79b-4e63-a875-85deed7719b7", title: "Soap"}
     #+END_SRC

   + Inline embedded schema
     * The schema module can be defined inline in the parent schema in
       simple cases:
       #+BEGIN_SRC elixir
         defmodule Parent do
           use Ecto.Schema

           schema "parents" do
             field :name, :string

             embeds_one :child, Child do
               field :name, :string
               field :age,  :integer
             end
           end
         end
       #+END_SRC
     * Options should be passed before the do block like this:
       #+BEGIN_SRC elixir
         embeds_one :child, Child, on_replace: :delete do
           field :name, :string
           field :age,  :integer
         end
       #+END_SRC
     * Primary keys are automatically set up for embedded schemas as
       well, defaulting to ~{:id, :binary_id, autogenerate: true}~. You can
       customize it by passing a ~:primary_key~ option with the same
       arguments as ~@primary_key~
     * Defining embedded schema in such a way will define a
       ~Parent.Child~ module with the appropriate struct. In order to
       properly cast the embedded schema. When casting the
       inline-defined embedded schemas you need to use the ~:with~ option
       of ~Ecto.Changeset.cast_embed/3~ to provide the proper function to
       do the casting. For example:
       #+BEGIN_SRC elixir
         def changeset(schema, params) do
           schema
           |> cast(params, [:name])
           |> cast_embed(:child, with: &child_changeset/2)
         end

         defp child_changeset(schema, params) do
           schema
           |> cast(params, [:name, :age])
         end
       #+END_SRC
   + Encoding and decoding
     * Because many databases do not support direct encoding and
       decoding of embeds, it is often emulated by Ecto by using
       specific encoding and decoding rules.
     * For example, PostgreSQL will store embeds on top of JSONB
       columns, which means types in embedded schemas won’t go through
       the usual dump->DB->load cycle but rather
       encode->DB->decode->cast. This means that, when using embedded
       schemas with databases like PG or MySQL, make sure all of your
       types can be JSON encoded/decoded correctly. Ecto provides this
       guarantee for all built-in types.
 - ~embeds_one(name, schema, opts, list)~
 - ~field(name, type \\ :string, opts \\ [])~
   - The field name will be used as is to read and write to the
     database by all of the built-in adapters unless overridden with
     the ~:source~ option.
   - opts
     + ~:default~ - Sets the default value on the schema and the
       struct. The default value is calculated at compilation time, so
       don’t use expressions like ~DateTime.utc_now~ or
       ~Ecto.UUID.generate~ as they would then be the same for all
       records.

     + ~:source~ - Defines the name that is to be used in database for
       this field. This is useful when attaching to an existing
       database. The value should be an atom.

     + ~:autogenerate~ - a ~{module, function, args}~ tuple for a
       function to call to generate the field value before insertion if
       value is not set. A shorthand value of true is equivalent to
       ~{type, :autogenerate, []}~.

     + ~:read_after_writes~ - When true, the field is always read back
       from the database after insert and updates. For relational
       databases, this means the ~RETURNING~ option of those statements
       is used. For this reason, MySQL does not support this option and
       will raise an error if a schema is inserted/updated with read
       after writes fields.

     + ~:virtual~ - When true, the field is not persisted to the
       database. Notice virtual fields do not support ~:autogenerate~ nor
       ~:read_after_writes~.

     + ~:primary_key~ - When true, the field is used as part of the
       composite primary key
 - ~has_many(name, queryable, opts \\ [])~
 - ~has_many(name, queryable, opts \\ [])~
   + Indicates a one-to-many association with another schema.
   + The current schema has zero or more records of the other
     schema. The other schema often has a belongs_to field with the
     reverse association.
   + ~opts~
     * ~:foreign_key~ - Sets the foreign key, this should map to a field
       on the other schema, defaults to the underscored name of the
       current schema suffixed by ~_id~
     * ~:references~ - Sets the key on the current schema to be used for
       the association, defaults to the primary key on the schema
     * ~:through~ - Allow this association to be defined in terms of
       existing associations.
     * ~:on_delete~
       - The action taken on associations when parent record is deleted.
       - May be ~:nothing~ (default), ~:nilify_all~ and ~:delete_all~
       - Using this option is *DISCOURAGED* for most relational
         databases. Instead, in your migration, set
         ~references(:parent_id, on_delete: :delete_all)~.
     * ~:on_replace~
       - The action taken on associations when the record is replaced
         when casting or manipulating parent changeset.
       - May be ~:raise~ (default), ~:mark_as_invalid~, ~:nilify~, or
         ~:delete~
     * ~:defaults~
       - Default values to use when building the association. This
         overrides any default set on the association schema.
       - For example, imagine ~Post.has_many :comments, defaults: [public: true]~.
         Then when using ~Ecto.build_assoc(post, :comments)~ that comment will have ~comment.public == true~.
     * ~:where~
       - A filter for the association. It does not apply to ~:through~
         associations.

   + example
     #+BEGIN_SRC elixir
       defmodule Post do
         use Ecto.Schema
         schema "posts" do
           has_many :comments, Comment
         end
       end

       # Get all comments for a given post
       post = Repo.get(Post, 42)
       comments = Repo.all assoc(post, :comments)

       # The comments can come preloaded on the post struct
       [post] = Repo.all(from(p in Post, where: p.id == 42, preload: :comments))
       post.comments #=> [%Comment{...}, ...]
     #+END_SRC
     ~has_many~ can be used to define hierarchical relationships within a
     single schema, for example threaded comments.
     #+BEGIN_SRC elixir
       defmodule Comment do
         use Ecto.Schema
         schema "comments" do
           field :content, :string
           field :parent_id, :integer
           belongs_to :parent, Comment, foreign_key: :id, references: :parent_id, define_field: false
           has_many :children, Comment, foreign_key: :parent_id, references: :id
         end
       end
     #+END_SRC
   + Filtering associations
     * It is possible to specify a ~:where~ option that will filter the
       records returned by the association. Querying, joining or
       preloading the association will use the given conditions
       #+BEGIN_SRC elixir
         defmodule Post do
           use Ecto.Schema

           schema "posts" do
             has_many :public_comments, Comment,
               where: [public: true]
           end
         end
       #+END_SRC
     * The ~:where~ option expects a keyword list where the key is an
       atom representing the field and the value is either:
       - ~nil~ - which specifies the field must be nil
       - ~{:not, nil}~ - which specifies the field must not be ~nil~
       - ~{:in, list}~ - which specifies the field must be one of the values in a list
       - or any other value which the field is compared directly against
   + has_many/has_one :through
     * defining associations in terms of other associations via the ~:through~ option.
     * example
       #+BEGIN_SRC elixir
         defmodule Post do
           use Ecto.Schema

           schema "posts" do
             has_many :comments, Comment
             has_one :permalink, Permalink

             # In the has_many :through example below, the `:comments`
             # in the list [:comments, :author] refers to the
             # `has_many :comments` in the Post own schema and the
             # `:author` refers to the `belongs_to :author` of the
             # Comment's schema (the module below).
             # (see the description below for more details)
             has_many :comments_authors, through: [:comments, :author]

             # Specify the association with custom source
             has_many :tags, {"posts_tags", Tag}
           end
         end

         defmodule Comment do
           use Ecto.Schema

           schema "comments" do
             belongs_to :author, Author
             belongs_to :post, Post
             has_one :post_permalink, through: [:post, :permalink]
           end
         end
       #+END_SRC
       - we have defined a ~has_many~ ~:through~ association named
         ~:comments_authors~. A ~:through~ association always expects a
         list and the first element of the list must be a previously
         defined association in the current module. For example,
         ~:comments_authors~ first points to ~:comments~ in the same module
         (~Post~), which then points to ~:author~ in the next schema,
         ~Comment~.

       - This ~:through~ association will return all authors for all
         comments that belongs to that post:
         #+BEGIN_SRC elixir
           # Get all comments authors for a given post
           post = Repo.get(Post, 42)
           authors = Repo.all assoc(post, :comments_authors)
         #+END_SRC
       - Although we used the ~:through~ association in the example
         above, Ecto also allows developers to dynamically build the
         through associations using the ~Ecto.assoc/2~ function:
         #+BEGIN_SRC elixir
         Ecto.assoc(post, [:comments, :author])
         #+END_SRC
         * In fact, given ~:through~ associations are read-only, using
           the ~Ecto.assoc/2~ format is the preferred mechanism for
           working with through associations.
       - ~:through~ associations can also be preloaded. In such cases,
         not only the ~:through~ association is preloaded but all
         intermediate steps are preloaded too:
         #+BEGIN_SRC elixir
           [post] = Repo.all(from(p in Post, where: p.id == 42, preload: :comments_authors))
           post.comments_authors #=> [%Author{...}, ...]

           # The comments for each post will be preloaded too
           post.comments #=> [%Comment{...}, ...]

           # And the author for each comment too
           hd(post.comments).author #=> %Author{...}
         #+END_SRC
       - When the ~:through~ association is expected to return one or
         zero items, ~has_one :through~ should be used instead
         #+BEGIN_SRC elixir
           # How we defined the association above
           has_one :post_permalink, through: [:post, :permalink]

           # Get a preloaded comment
           [comment] = Repo.all(Comment) |> Repo.preload(:post_permalink)
           comment.post_permalink #=> %Permalink{...}
         #+END_SRC
 - ~has_one(name, queryable, opts \\ [])~
   + Indicates a one-to-one association with another schema.
   + The current schema has zero or one records of the other
     schema. The other schema often has a belongs_to field with the
     reverse association.
   + ~opts~
     * ~:foreign_key~
       - Sets the foreign key, this should map to a field on the other
         schema, defaults to the underscored name of the current module
         suffixed by ~_id~
     * ~:references~
       - Sets the key on the current schema to be used for the
         association, defaults to the primary key on the schema
     * ~:through~
       - If this association must be defined in terms of existing associations.
     * ~:on_delete~
       - The action taken on associations when parent record is deleted
       - May be ~:nothing~ (default), ~:nilify_all~ and ~:delete_all~.
       - Using this option is *DISCOURAGED* for most relational
         databases. Instead, in your migration, set
         ~references(:parent_id, on_delete: :delete_all)~.
       - Opposite to the migration option, this option cannot guarantee
         integrity and it is only triggered for ~Ecto.Repo.delete/~ (and
         not on ~Ecto.Repo.delete_all/2~) and it never cascades.
     * ~:on_replace~
       - The action taken on associations when the record is replaced
         when casting or manipulating parent changeset.
       - May be ~:raise~ (default), ~:mark_as_invalid~, ~:nilify~,
         ~:update~, or ~:delete~
     * ~:defaults~
       - Default values to use when building the association.
       - This overrides any default set on the association schema. For
         example, imagine ~Post.has_many :comments, defaults: [public: true]~.
         Then when using ~Ecto.build_assoc(post, :comments)~ that
         comment will have ~comment.public == true~.
     * ~:where~ - A filter for the association
   + example
     #+BEGIN_SRC elixir
       defmodule Post do
         use Ecto.Schema

         schema "posts" do
           has_one :permalink, Permalink

           # Specify the association with custom source
           has_one :category, {"posts_categories", Category}
         end
       end

       # The permalink can come preloaded on the post struct
       [post] = Repo.all(from(p in Post, where: p.id == 42, preload: :permalink))
       post.permalink #=> %Permalink{...}
     #+END_SRC
 - ~many_to_many(name, queryable, opts \\ [])~
   + Indicates a many-to-many association with another schema.
   + The association happens through a join schema or source,
     containing foreign keys to the associated schemas.
     #+BEGIN_SRC elixir
       # from MyApp.Post
       many_to_many :tags, MyApp.Tag, join_through: "posts_tags"
     #+END_SRC
     is backed by relational databases through a join table as follows:
     #+BEGIN_SRC
       [Post] <-> [posts_tags] <-> [Tag]
         id   <--   post_id
                     tag_id    -->  id
     #+END_SRC
   + Options
     * ~:join_through~
       - specifies the source of the associated data.
       - It may be a string, like “posts_tags”, representing the
         underlying storage table or an atom, like ~MyApp.PostTag~,
         representing a schema. This option is required.
     * ~:join_keys~
       - specifies how the schemas are associated.
       - It expects a keyword list with two entries, the first being
         how the join table should reach the current schema and the
         second how the join table should reach the associated
         schema.
       - In the example above, it defaults to: ~[post_id: :id, tag_id: :id]~.
       - The keys are inflected from the schema names.
     * ~:on_delete~
       - The action taken on associations when parent record is deleted
       - May be ~:nothing~ (default) or ~:delete_all~.
       - Using this option is *DISCOURAGED* for most relational
         databases. Instead, in your migration, set
         ~references(:parent_id, on_delete: :delete_all)~.
       - Opposite to the migration option, this option cannot guarantee
         integrity and it is only triggered for ~Ecto.Repo.delete/2~ (and
         not on ~Ecto.Repo.delete_all/2~).
       - This option can only remove data from the join source, never
         the associated records, and it never cascades.
     * ~:on_replace~
       - The action taken on associations when the record is replaced
         when casting or manipulating parent changeset.
       - May be ~:raise~ (default), ~:mark_as_invalid~, or ~:delete~.
         + ~:delete~ will only remove data from the join source, never
           the associated records. See Ecto.Changeset’s section on
           related data for more info.
     * ~:defaults~
       - Default values to use when building the association.
       - This overrides any default set on the association schema
       - For example, imagine ~Post.has_many :comments, defaults: [public: true]~.
         Then when using ~Ecto.build_assoc(post, :comments)~ that comment will have ~comment.public == true~.
     * ~:unique~
       - When true, checks if the associated entries are unique.
       - This is done by checking the primary key of the associated
         entries during repository operations
       - Keep in mind this does not guarantee uniqueness at the
         database level. For such it is preferred to set a unique index
         in the database. For example: ~create unique_index(:posts_tags, [:post_id, :tag_id])~
     * ~:where~ - A filter for the association.
   + Removing data
     * If you attempt to remove associated ~many_to_many~ data, Ecto will
       always remove data from the join schema and never from the
       target associations be it by setting ~:on_replace~ to ~:delete~,
       ~:on_delete~ to ~:delete_all~ or by using changeset functions such
       as ~Ecto.Changeset.put_assoc/3~.
     * For example, if a ~Post~ has a many to many relationship with ~Tag~,
       setting ~:on_delete~ to ~:delete_all~ will only delete entries from
       the “posts_tags” table in case ~Post~ is deleted.
   + Migration
     * How your migration should be structured depends on the value you
       pass in ~:join_through~
     * If ~:join_through~ is simply a string, representing a table, you
       may define a table without primary keys and you must not include
       any further columns, as those values won’t be set by Ecto:
       #+BEGIN_SRC elixir
         create table(:posts_tags, primary_key: false) do
           add :post_id, references(:posts)
           add :tag_id, references(:tags)
         end
       #+END_SRC
     * However, if your ~:join_through~ is a schema, like ~MyApp.PostTag~,
       your join table may be structured as any other table in your
       codebase, including timestamps:
       #+BEGIN_SRC elixir
         create table(:posts_tags) do
           add :post_id, references(:posts)
           add :tag_id, references(:tags)
           timestamps()
         end
       #+END_SRC
       Because ~:join_through~ contains a schema, in such cases,
       autogenerated values and primary keys will be automatically
       handled by Ecto.
   + example
     #+BEGIN_SRC elixir
       defmodule Post do
         use Ecto.Schema
         schema "posts" do
           many_to_many :tags, Tag, join_through: "posts_tags"
         end
       end

       # Let's create a post and a tag
       post = Repo.insert!(%Post{})
       tag = Repo.insert!(%Tag{name: "introduction"})

       # We can associate at any time post and tags together using changesets
       post
       |> Repo.preload(:tags) # Load existing data
       |> Ecto.Changeset.change() # Build the changeset
       |> Ecto.Changeset.put_assoc(:tags, [tag]) # Set the association
       |> Repo.update!

       # In a later moment, we may get all tags for a given post
       post = Repo.get(Post, 42)
       tags = Repo.all(assoc(post, :tags))

       # The tags may also be preloaded on the post struct for reading
       [post] = Repo.all(from(p in Post, where: p.id == 42, preload: :tags))
       post.tags #=> [%Tag{...}, ...]
     #+END_SRC
   + Join Schema Example
     * You may prefer to use a join schema to handle many_to_many
       associations. The decoupled nature of Ecto allows us to create a
       “join” struct which belongs_to both sides of the many to many
       association.
       #+BEGIN_SRC elixir
         defmodule MyApp.Repo.Migrations.CreateUserOrganization do
           use Ecto.Migration

           def change do
             create table(:users_organizations) do
               add :user_id, references(:users)
               add :organization_id, references(:organizations)

               timestamps()
             end
           end
         end

         defmodule UserOrganization do
           use Ecto.Schema

           @primary_key false
           schema "users_organizations" do
             belongs_to :user, User
             belongs_to :organization, Organization
             timestamps() # Added bonus, a join schema will also allow you to set timestamps
           end

           def changeset(struct, params \\ %{}) do
             struct
             |> Ecto.Changeset.cast(params, [:user_id, :organization_id])
             |> Ecto.Changeset.validate_required([:user_id, :organization_id])
             # Maybe do some counter caching here!
           end
         end

         defmodule User do
           use Ecto.Schema

           schema "users" do
             many_to_many :organizations, Organization, join_through: UserOrganization
           end
         end

         defmodule Organization do
           use Ecto.Schema

           schema "organizations" do
             many_to_many :users, User, join_through: UserOrganization
           end
         end

         # Then to create the association, pass in the ID's of an existing
         # User and Organization to UserOrganization.changeset
         changeset = UserOrganization.changeset(%UserOrganization{}, %{user_id: id, organization_id: id})

         case Repo.insert(changeset) do
           {:ok, assoc} -> # Assoc was created!
           {:error, changeset} -> # Handle the error
         end
       #+END_SRC
 - ~schema(source, list)~
   + Defines a schema struct with a source name and field definitions.
   + An additional field called ~__meta__~ is added to the struct for
     storing internal Ecto state. This field always has a
     ~Ecto.Schema.Metadata~ struct as value and can be manipulated with
     the ~Ecto.put_meta/2~ function.
 - ~timestamps(opts \\ [])~
   + Generates ~:inserted_at~ and ~:updated_at~ timestamp fields.
   + The fields generated by this macro will automatically be set to
     the current time when inserting and updating values in a
     repository.
   + ~opts~
     * ~:type~ - the timestamps type, defaults to ~:naive_datetime~.
     * ~:inserted_at~ - the name of the column for insertion times or ~false~
     * ~:updated_at~ - the name of the column for update times or ~false~
     * ~:autogenerate~ - a MFA tuple used for generating both
       ~inserted_at~ and ~updated_at~ timestamps
     * All options can be pre-configured by setting ~@timestamps_opts~.
** Ecto.Schema.Metadata
 - Stores metadata of a struct.
*** State
 - The state of the schema is stored in the ~:state~ field and allows
   following values:
   + ~:built~ - the struct was constructed in memory and is not
     persisted to database yet;
   + ~:loaded~ - the struct was loaded from database and represents
     persisted data;
   + ~:deleted~ - the struct was deleted and no longer represents
     persisted data.
*** Source
 - The ~:source~ tracks the (table or collection) where the struct is
   or should be persisted to.
*** Prefix
 - Tracks the source prefix in the data storage
*** Context
 - The ~:context~ field represents additional state some databases
   require for proper updates of data. It is not used by the built-in
   adapters of ~Ecto.Adapters.Postres~ and ~Ecto.Adapters.MySQL~.
*** Schema
 - The ~:schema~ field refers the module name for the schema this
   metadata belongs to.
** Ecto.Type behaviour
 - Defines functions and the ~Ecto.Type~ behaviour for implementing
   custom types.
 - A custom type expects 4 functions to be implemented
   1. ~type~
      + Returns the underlying schema type for the custom type
      + For example, if you want to provide your own date structures,
        the type function should return ~:date~.
   2. ~cast(term)~
      + Casts the given input to the custom type
      + This callback is called on external input and can return any
        type, as long as the ~dump/1~ function is able to convert the
        returned value into an Ecto native type.
      + There are two situations where this callback is called:
        1. When casting values by ~Ecto.Changeset~
        2. When passing arguments to ~Ecto.Query~
      + When returning ~{:error, keyword()}~, the returned keyword list
        will be preserved in the changeset errors, similar to
        ~Changeset.add_error/4~. Passing a ~:message~ key, will override
        the default message. It is not possible to override the ~:type~
        key.
      + For ~{:array, CustomType}~ or ~{:map, CustomType}~ the returned
        keyword list will be erased and the default error will be
        shown.

   3. ~load(term)~
      + Loads the given term into a custom type
      + This callback is called when loading data from the database and
        receive an Ecto native type. It can return any type, as long as
        the ~dump/1~ function is able to convert the returned value back
        into an Ecto native type.

   4. ~dump(term)~
      + Dumps the given term into an Ecto native type
      + This callback is called with any term that was stored in the
        struct and it needs to validate them and convert it to an Ecto
        native type.

 - Note: ~nil~ values are always bypassed and cannot be handled by
   custom types.
*** Example
 - url-shortening service.
   #+BEGIN_SRC elixir
     defmodule EctoURI do
       @behaviour Ecto.Type
       def type, do: :map

       # Provide custom casting rules.
       # Cast strings into the URI struct to be used at runtime
       def cast(uri) when is_binary(uri) do
         {:ok, URI.parse(uri)}
       end

       # Accept casting of URI structs as well
       def cast(%URI{} = uri), do: {:ok, uri}

       # Everything else is a failure though
       def cast(_), do: :error

       # When loading data from the database, we are guaranteed to
       # receive a map (as databases are strict) and we will
       # just put the data back into an URI struct to be stored
       # in the loaded schema struct.
       def load(data) when is_map(data) do
         data =
           for {key, val} <- data do
             {String.to_existing_atom(key), val}
           end
         {:ok, struct!(URI, data)}
       end

       # When dumping data to the database, we *expect* an URI struct
       # but any value could be inserted into the schema struct at runtime,
       # so we need to guard against them.
       def dump(%URI{} = uri), do: {:ok, Map.from_struct(uri)}
       def dump(_), do: :error
     end
   #+END_SRC
   Now we can use our new field type above in our schemas:
   #+BEGIN_SRC elixir
     defmodule ShortUrl do
       use Ecto.Schema

       schema "posts" do
         field :original_url, EctoURI
       end
     end
   #+END_SRC
** Ecto.UUID
** Mix.Ecto
 - Conveniences for writing Ecto related Mix tasks.

** QUERY APIS
 - Lists all functions allowed in the query API.
   + Comparison operators: ~==~, ~!=~, ~<=~, ~>=~, ~<~, ~>~
   + Arithmetic operators: ~+~, ~-~, ~*~, ~/~
   + Boolean operators: ~and~, ~or~, ~not~
   + Inclusion operator: ~in/2~
   + Search functions: ~like/2~ and ~ilike/2~
   + Null check functions: ~is_nil/1~
   + Aggregates: ~count/0~, ~count/1~, ~avg/1~, ~sum/1~, ~min/1~, ~max/1~
   + Date/time intervals: ~datetime_add/3~, ~date_add/3~, ~from_now/2~, ~ago/2~
   + Inside select: ~struct/2~, ~map/2~, ~merge/2~ and literals (map, tuples, lists, etc)
   + General: ~fragment/1~, ~field/2~ and ~type/2~
 - ~ago(count, interval)~
   #+BEGIN_SRC elixir
   from p in Post, where: p.published_at > ago(3, "month")
   #+END_SRC
 - ~avg(value)~
   + Calculates the average for the given entry.
     #+BEGIN_SRC elixir
     from p in Payment, select: avg(p.value)
     #+END_SRC
 - ~coalesce(value, expr)~
   + Takes whichever value is not null, or null if they both are.
   + In SQL, COALESCE takes any number of arguments, but in ecto it
     only takes two, so it must be chained to achieve the same effect.
   #+BEGIN_SRC elixir
   from p in Payment, select: p.value |> coalesce(p.backup_value) |> coalesce(0)
   #+END_SRC
 - ~count()~
   #+BEGIN_SRC elixir
   from p in Post, select: count()
   #+END_SRC
 - ~count(value)~
   + Counts the given entry.
     #+BEGIN_SRC elixir
     from p in Post, select: count(p.id)
     #+END_SRC
 - ~count(value, atom)~
   + Counts the distinct values in given entry.
     #+BEGIN_SRC elixir
     from p in Post, select: count(p.id, :distinct)
     #+END_SRC
 - ~date_add(date, count, interval)~
   + Adds a given interval to a date.
 - ~datetime_add(datetime, count, interval)~
   + Adds a given interval to a datetime.
   + The first argument is a ~datetime~, the second one is the count for
     the interval, which may be either positive or negative and the
     interval value:
     #+BEGIN_SRC elixir
       # Get all items published since the last month
       from p in Post, where: p.published_at >
                              datetime_add(^NaiveDateTime.utc_now, -1, "month")
     #+END_SRC
     we used ~datetime_add/3~ to subtract one month from the current
     datetime and compared it with the ~p.published_at~. If you want to
     perform operations on date, ~date_add/3~ could be used.
   + The following intervals are supported: year, month, week, day,
     hour, minute, second, millisecond and microsecond.
 - ~field(source, field)~
   + Allows a field to be dynamically accessed.
     #+BEGIN_SRC elixir
       def at_least_four(doors_or_tires) do
           from c in Car,
         where: field(c, ^doors_or_tires) >= 4
       end
     #+END_SRC
   + In the example above, ~both at_least_four(:doors)~ and
     ~at_least_four(:tires)~ would be valid calls as the field is
     dynamically generated.
 - ~filter(value, filter)~
   + Applies the given expression as a ~FILTER~ clause against an
     aggregate. This is currently only supported by Postgres.
     #+BEGIN_SRC elixir
       from p in Payment, select: filter(avg(p.value), p.value > 0 and p.value < 100)

       from p in Payment, select: avg(p.value) |> filter(p.value < 0)
     #+END_SRC
 - ~fragment(fragments)~
   + Send fragments directly to the database.
   + It is not possible to represent all possible database queries
     using Ecto’s query syntax. When such is required, it is possible
     to use fragments to send any expression to the database:
     #+BEGIN_SRC elixir
       def unpublished_by_title(title) do
         from p in Post,
           where: is_nil(p.published_at) and
                  fragment("lower(?)", p.title) == ^title
       end
     #+END_SRC
   + Ecto is unable to do any type casting described above when
     fragments are used. You can however use the ~type/2~ function to
     give Ecto some hints:
     #+BEGIN_SRC elixir
     fragment("lower(?)", p.title) == type(^title, :string)
     #+END_SRC
     Or even say the right side is of the same type as ~p.title~:
     #+BEGIN_SRC elixir
     fragment("lower(?)", p.title) == type(^title, p.title)
     #+END_SRC
   + It is possible to make use of PostgreSQL’s JSON/JSONB data type
     with fragments, as well:
     #+BEGIN_SRC elixir
     fragment("?->>? ILIKE ?", p.map, "key_name", ^some_value)
     #+END_SRC
   + Keyword fragments
     * In order to support databases that do not have string-based
       queries, like MongoDB, fragments also allow keywords to be
       given:
       #+BEGIN_SRC elixir
         from p in Post,
             where: fragment(title: ["$eq": ^some_value])
       #+END_SRC
   + Defining custom functions using macros and fragment
     * You can add a custom Ecto query function using macros. For
       example to expose SQL’s coalesce function you can define this
       macro:
       #+BEGIN_SRC elixir
         defmodule CustomFunctions do
           defmacro coalesce(left, right) do
             quote do
               fragment("coalesce(?, ?)", unquote(left), unquote(right))
             end
           end
         end
       #+END_SRC
       To have ~coalesce/2~ available, just import the module that defines it.
       #+BEGIN_SRC elixir
         import CustomFunctions
       #+END_SRC
       The only downside is that it will show up as a fragment when
       inspecting the Elixir query. Other than that, it should be
       equivalent to a built-in Ecto query function.
 - ~from_now(count, interval)~
   + Adds the given interval to the current time in UTC.
   + The current time in UTC is retrieved from Elixir and not from the
     database.
     #+BEGIN_SRC elixir
     from a in Account, where: a.expires_at < from_now(3, "month")
     #+END_SRC
 - ~ilike(string, search)~
   + Searches for ~search~ in ~string~ in a case insensitive fashion.
     #+BEGIN_SRC elixir
       from p in Post, where: ilike(p.body, "Chapter%")
     #+END_SRC
 - ~left in right~
   + The right side may either be a list, a literal list or even a
     column in the database with array type:
   #+BEGIN_SRC elixir
     from p in Post, where: p.id in [1, 2, 3]

     from p in Post, where: "elixir" in p.tags
   #+END_SRC
 - ~is_nil(value)~
   Checks if the given value is nil.
   #+BEGIN_SRC elixir
     from p in Post, where: is_nil(p.published_at)
   #+END_SRC

   To check if a given value is not nil use:
   #+BEGIN_SRC elixir
     from p in Post, where: not is_nil(p.published_at)
   #+END_SRC
 - ~like(string, search)~
   + You should be very careful when allowing user sent data to be used
     as part of LIKE query, since they allow to perform
     [[https://githubengineering.com/like-injection/][LIKE-injections]].
 - ~map(source, fields)~
   + Used in ~select~ to specify which fields should be returned as a
     map.
   + For example, if you don’t need all fields to be returned or
     neither need a struct, you can use ~map/2~ to achieve both:
     #+BEGIN_SRC elixir
       from p in Post,
         select: map(p, [:title, :body])
     #+END_SRC
   + ~map/2~ can also be used to dynamically select fields:
     #+BEGIN_SRC elixir
       fields = [:title, :body]
       from p in Post, select: map(p, ^fields)
     #+END_SRC
   + If the same source is selected multiple times with a ~map~, the
     fields are merged in order to avoid fetching multiple copies from
     the database. In other words, the expression below:
     #+BEGIN_SRC elixir
     from(city in City, preload: :country,
      select: {map(city, [:country_id]), map(city, [:name])}
     #+END_SRC
     is expanded to:
     #+BEGIN_SRC elixir
       from(city in City, preload: :country,
            select: {map(city, [:country_id, :name]), map(city, [:country_id, :name])}
     #+END_SRC
   + For preloads, the selected fields may be specified from the parent:
     #+BEGIN_SRC elixir
       from(city in City, preload: :country,
            select: map(city, [:country_id, :name, country: [:id, :population]]))
     #+END_SRC
     *IMPORTANT*: When filtering fields for associations, you *MUST*
     include the foreign keys used in the relationship, otherwise Ecto
     will be unable to find associated records.
 - ~max(value)~
   + Calculates the maximum for the given entry.
     #+BEGIN_SRC elixir
       from p in Payment, select: max(p.value)
     #+END_SRC
 - ~merge(left_map, right_map)~
   + Merges the map on the right over the map on the left.
   + If the map on the left side is a struct, Ecto will check all of
     the field on the right previously exist on the left before
     merging.
   #+BEGIN_SRC
   from(city in City, select: merge(city, %{virtual_field: "some_value"}))
   #+END_SRC
   This function is primarily used by ~Ecto.Query.select_merge/3~ to
   merge different select clauses.
 - ~min(value)~
   + Calculates the minimum for the given entry.
     #+BEGIN_SRC elixir
     from p in Payment, select: min(p.value)
     #+END_SRC
 - ~struct(source, fields)~
   + Used in select to specify which struct fields should be returned.
   + For example, if you don’t need all fields to be returned as part
     of a struct, you can filter it to include only certain fields by
     using ~struct/2~:
     #+BEGIN_SRC elixir
       from p in Post,
         select: struct(p, [:title, :body])
     #+END_SRC
   + ~struct/2~ can also be used to dynamically select fields:
     #+BEGIN_SRC elixir
       fields = [:title, :body]
       from p in Post, select: struct(p, ^fields)
     #+END_SRC
   + As a convenience, ~select~ allows developers to take fields without
     an explicit call to ~struct/2~:
     #+BEGIN_SRC elixir
     from p in Post, select: [:title, :body]
     #+END_SRC
     or even dynamically:
     #+BEGIN_SRC elixir
     fields = [:title, :body]
     from p in Post, select: ^fields
     #+END_SRC
   + For preloads, the selected fields may be specified from the
     parent:
     #+BEGIN_SRC elixir
       from(city in City, preload: :country,
            select: struct(city, [:country_id, :name, country: [:id, :population]]))
     #+END_SRC
   + If the same source is selected multiple times with a struct, the
     fields are merged in order to avoid fetching multiple copies from
     the database. In other words, the expression below:
     #+BEGIN_SRC elixir
     from(city in City, preload: :country,
      select: {struct(city, [:country_id]), struct(city, [:name])}
     #+END_SRC
     is expanded to:
     #+BEGIN_SRC elixir
     from(city in City, preload: :country,
      select: {struct(city, [:country_id, :name]), struct(city, [:country_id, :name])}
     #+END_SRC
     *IMPORTANT*: When filtering fields for associations, you *MUST*
     include the foreign keys used in the relationship, otherwise Ecto
     will be unable to find associated records.
 - ~sum(value)~
   + Calculates the sum for the given entry.
     #+BEGIN_SRC elixir
     from p in Payment, select: sum(p.value)
     #+END_SRC

 - ~type(interpolated_value, type)~
   + Casts the given value to the given type at the database level.
   + Most of the times, Ecto is able to proper cast interpolated values
     due to its type checking mechanism. In some situations though, you
     may want to tell Ecto that a parameter has some particular type:
     #+BEGIN_SRC elixir
       type(^title, :string)
     #+END_SRC
     It is also possible to say the type must match the same of a column:
     #+BEGIN_SRC elixir
       type(^title, p.title)
     #+END_SRC
   + Ecto will ensure ~^title~ is cast to the given type and enforce such
     type at the database level. If the value is returned in a ~select~,
     Ecto will also enforce the proper type throughout.
   + When performing arithmetic operations, ~type/2~ can be used to cast
     all the parameters in the operation to the same type:
     #+BEGIN_SRC elixir
       from p in Post,
         select: type(p.visits + ^a_float + ^a_integer, :decimal)
     #+END_SRC
   + Inside ~select~, ~type/2~ can also be used to cast fragments:
     #+BEGIN_SRC elixir
       type(fragment("NOW"), :naive_datetime)

       # another example
       from Comment, select: type(fragment("inserted_at"), :naive_datetime)
       # [~N[2019-02-26 10:01:57], ~N[2019-02-26 10:02:08]]
     #+END_SRC
   + Or to type fields from schemaless queries:
     #+BEGIN_SRC elixir
       from p in "posts", select: type(p.cost, :decimal)
     #+END_SRC
   + Or to type aggregation results:
     #+BEGIN_SRC elixir
     from p in Post, select: type(avg(p.cost), :integer)
     #+END_SRC
** Ecto.Query.WindowAPI
 - [[file:sql.org::*window%20functions][Read notes on window functions]]
 - Windows functions must always be used as the first argument of
   ~over/2~ where the second argument is the name of a window:
   #+BEGIN_SRC elixir
     from e in Employee,
       select: {e.depname, e.empno, e.salary, over(avg(e.salary), :department)},
       windows: [department: [partition_by: e.depname]]
   #+END_SRC
   + In the example above, we get the average salary per
     department. ~:department~ is the window name, partitioned by
     ~e.depname~ and ~avg/1~ is the window function.
   + defining a window is not necessary, as the window definition can be
     given as the second argument to over:
     #+BEGIN_SRC elixir
       from e in Employee,
         select: {e.depname, e.empno, e.salary, over(avg(e.salary), partition_by: e.depname)}
     #+END_SRC

*** functions
 - ~cume_dist()~
   + Returns relative rank of the current row: (number of rows preceding or peer with current row) / (total rows).
     #+BEGIN_SRC
     from p in Post,
        select: cume_dist() |> over(partition_by: p.category_id, order_by: p.date)
     #+END_SRC
   + example
     #+BEGIN_SRC elixir
       iex> (from u in User,
             select: {u.gender, u.age, over(cume_dist(), :age)},
             windows: [age: [partition_by: u.gender, order_by: u.age]]) |>
             Repo.all
             # executes
             # SELECT u0."gender", u0."age", cume_dist() OVER "age"
             # FROM "users" AS u0
             # WINDOW "age" AS (PARTITION BY u0."gender" ORDER BY u0."age")

             # gender | age | cume_dist
             # --------+-----+-----------
             # f      |  10 |       0.5
             # f      |  30 |         1
             # m      |  12 |       0.5
             # m      |  12 |       0.5
             # m      |  20 |      0.75
             # m      |  35 |         1
       [
        {"f", 10, 0.5},
        {"f", 30, 1.0},
        {"m", 12, 0.5},
        {"m", 12, 0.5},
        {"m", 20, 0.75},
        {"m", 35, 1.0}
       ]
     #+END_SRC
 - ~dense_rank()~
   + Returns rank of the current row without gaps; this function counts peer groups.
     #+BEGIN_SRC elixir
       from p in Post,
            select: dense_rank() |> over(partition_by: p.category_id, order_by: p.date)
     #+END_SRC
   + example
     #+BEGIN_SRC elixir
       iex> (from u in User,
             select: {u.gender, u.age, over(dense_rank(), :age)},
             windows: [age: [partition_by: u.gender, order_by: u.age]]) |> Repo.all

       # 11:30:27.645 [debug] QUERY OK source="users" db=2.1ms queue=3.2ms
       # SELECT u0."gender", u0."age", dense_rank() OVER "age" FROM "users" AS u0 WINDOW "age" AS (PARTITION BY u0."gender" ORDER BY u0."age") []

       [
          {"f", 10, 1},
          {"f", 30, 2},
          {"m", 12, 1},
          {"m", 12, 1},
          {"m", 20, 2},
          {"m", 35, 3}
       ]
     #+END_SRC
 - ~first_value(value)~
   + Returns value evaluated at the row that is the first row of the window frame.
     #+BEGIN_SRC elixir
       from p in Post,
            select: first_value(p.id) |> over(partition_by: p.category_id, order_by: p.date)
     #+END_SRC
   + example
     #+BEGIN_SRC elixir
       iex> (from u in User,
         select: %{sex: u.gender, age: u.age, id: u.id, first: over(first_value(u.id), :age)},
         windows: [age: [partition_by: u.gender, order_by: u.age]]) |> Repo.all

       # 11:35:11.793 [debug] QUERY OK source="users" db=1.1ms queue=1.2ms
       # SELECT u0."gender", u0."age", u0."id", first_value(u0."id") OVER "age" FROM "users" AS u0 WINDOW "age" AS (PARTITION BY u0."gender" ORDER BY u0."age") []

       [
         %{age: 10, first: 1, id: 1, sex: "f"},
         %{age: 30, first: 1, id: 3, sex: "f"},
         %{age: 12, first: 5, id: 5, sex: "m"},
         %{age: 12, first: 5, id: 6, sex: "m"},
         %{age: 20, first: 5, id: 2, sex: "m"},
         %{age: 35, first: 5, id: 4, sex: "m"}
       ]
     #+END_SRC
 - ~lag(value, offset \\ 1, default \\ nil)~
   - Returns value evaluated at the row that is offset-rows before the
     current row within the partition.

   - If there is no such row, instead return default (which must be of
     the same type as value). Both offset and default are evaluated
     with respect to the current row. If omitted, offset defaults to 1
     and default to nil.
     #+BEGIN_SRC elixir
     from e in Events,
      windows: [w: [partition_by: e.name, order_by: e.tick]],
      select: {
        e.tick,
        e.action,
        e.name,
        lag(e.action) |> over(:w), # previous_action
        lead(e.action) |> over(:w) # next_action
      }
     #+END_SRC
   - example
     #+BEGIN_SRC elixir
       iex> (from u in User,
             select: %{sex: u.gender, age: u.age, id: u.id, prev: over(lag(u.id), :age)},
             windows: [age: [partition_by: u.gender, order_by: u.age]]) |> Repo.all

       13:55:12.154 [debug] QUERY OK source="users" db=1.1ms queue=1.3ms
       SELECT u0."gender", u0."age", u0."id", lag(u0."id") OVER "age" FROM "users" AS u0 WINDOW "age" AS (PARTITION BY u0."gender" ORDER BY u0."age") []

       [
           %{age: 10, id: 1, prev: nil, sex: "f"},
           %{age: 30, id: 3, prev: 1, sex: "f"},
           %{age: 12, id: 5, prev: nil, sex: "m"},
           %{age: 12, id: 6, prev: 5, sex: "m"},
           %{age: 20, id: 2, prev: 6, sex: "m"},
           %{age: 35, id: 4, prev: 2, sex: "m"}
       ]
     #+END_SRC
 - ~last_value(value)~
   - Returns value evaluated at the row that is the last row of the
     window frame.
     #+BEGIN_SRC elixir
       from p in Post,
            select: last_value(p.id) |> over(partition_by: p.category_id, order_by: p.date)
     #+END_SRC
   - example
     #+BEGIN_SRC sql
       SELECT
        product_name,
        group_name,
        price,
        LAST_VALUE (price) OVER (
        PARTITION BY group_name
        ORDER BY
        price RANGE BETWEEN UNBOUNDED PRECEDING
        AND UNBOUNDED FOLLOWING
        ) AS highest_price_per_group
       FROM
        products
       INNER JOIN product_groups USING (group_id);
     #+END_SRC
     uses the ~LAST_VALUE()~ function to return the highest price per product group.
 - ~lead(value, offset \\ 1, default \\ nil)~
   + Returns value evaluated at the row that is offset-rows after the
     current row within the partition.
   + If there is no such row, instead return default (which must be of
     the same type as value). Both offset and default are evaluated
     with respect to the current row. If omitted, offset defaults to 1
     and default to ~nil~.
     #+BEGIN_SRC elixir
       from e in Events,
            windows: [w: [partition_by: e.name, order_by: e.tick]],
            select: {
              e.tick,
              e.action,
              e.name,
              lag(e.action) |> over(:w), # previous_action
              lead(e.action) |> over(:w) # next_action
            }
     #+END_SRC
   + example
     #+BEGIN_SRC elixir
       iex> (from u in User, select: %{sex: u.gender, age: u.age, next_same_gender_person_age: over(lead(u.age), :age)}, windows: [age: [partition_by: u.gender, order_by: u.age]]) |> Repo.all

       14:45:55.086 [debug] QUERY OK source="users" db=1.1ms queue=0.9ms
       SELECT u0."gender", u0."age", lead(u0."age") OVER "age" FROM "users" AS u0 WINDOW "age" AS (PARTITION BY u0."gender" ORDER BY u0."age") []

       [
         %{age: 10, next_same_gender_person_age: 30, sex: "f"},
         %{age: 30, next_same_gender_person_age: nil, sex: "f"},
         %{age: 12, next_same_gender_person_age: 12, sex: "m"},
         %{age: 12, next_same_gender_person_age: 20, sex: "m"},
         %{age: 20, next_same_gender_person_age: 35, sex: "m"},
         %{age: 35, next_same_gender_person_age: nil, sex: "m"}
       ]
     #+END_SRC
 - ~max(value)~
   + Calculates the maximum for the given entry.
     #+BEGIN_SRC elixir
     from p in Payment, select: max(p.value)
     #+END_SRC
   + example
     #+BEGIN_SRC elixir
       iex(59)> (from u in User,
         select: %{sex: u.gender, age: u.age, oldest_same_gender_person_age: over(max(u.age), :age)},
         windows: [age: [partition_by: u.gender, order_by: [desc: u.age]]]) |> Repo.all

       14:48:16.837 [debug] QUERY OK source="users" db=1.1ms queue=1.4ms
       SELECT u0."gender", u0."age", max(u0."age") OVER "age" FROM "users" AS u0 WINDOW "age" AS (PARTITION BY u0."gender" ORDER BY u0."age" DESC) []

       [
         %{age: 30, oldest_same_gender_person_age: 30, sex: "f"},
         %{age: 10, oldest_same_gender_person_age: 30, sex: "f"},
         %{age: 35, oldest_same_gender_person_age: 35, sex: "m"},
         %{age: 20, oldest_same_gender_person_age: 35, sex: "m"},
         %{age: 12, oldest_same_gender_person_age: 35, sex: "m"},
         %{age: 12, oldest_same_gender_person_age: 35, sex: "m"}
       ]
     #+END_SRC
 - ~min(value)~
   + Calculates the minimum for the given entry.
     #+BEGIN_SRC
     from p in Payment, select: min(p.value)
     #+END_SRC
 - ~nth_value(value, nth)~
   + Returns value evaluated at the row that is the nth row of the
     window frame (counting from 1); ~nil~ if no such row.
     #+BEGIN_SRC elixir
       from p in Post,
            select: nth_value(p.id, 4) |> over(partition_by: p.category_id, order_by: p.date)
     #+END_SRC
   + example
     #+BEGIN_SRC elixir
       iex> (from u in User,
         select: %{sex: u.gender, age: u.age, foo: over(nth_value(u.age, 2), :age)},
         windows: [age: [partition_by: u.gender, order_by: [desc: u.age]]]) |> Repo.all

       14:57:24.009 [debug] QUERY OK source="users" db=2.0ms
       SELECT u0."gender", u0."age", nth_value(u0."age", 2) OVER "age" FROM "users" AS u0 WINDOW "age" AS (PARTITION BYu0."gender" ORDER BY u0."age" DESC) []

       [
           %{age: 30, foo: nil, sex: "f"},
           %{age: 10, foo: 10, sex: "f"},
           %{age: 35, foo: nil, sex: "m"},
           %{age: 20, foo: 20, sex: "m"},
           %{age: 12, foo: 20, sex: "m"},
           %{age: 12, foo: 20, sex: "m"}
       ]
     #+END_SRC
 - ~ntile(num_buckets)~
   + Returns integer ranging from 1 to the argument value, dividing the
     partition as equally as possible.
     #+BEGIN_SRC elixir
       from p in Post,
            select: ntile(10) |> over(partition_by: p.category_id, order_by: p.date)
     #+END_SRC
   + example
     #+BEGIN_SRC elixir
       iex> (from u in User,
         select: %{sex: u.gender, age: u.age, foo: over(ntile(3), :age)},
         windows: [age: [partition_by: u.gender, order_by: [desc: u.age]]]) |> Repo.all

       15:08:08.605 [debug] QUERY OK source="users" db=0.9ms queue=1.0ms
       SELECT u0."gender", u0."age", ntile(3) OVER "age" FROM "users" AS u0 WINDOW "age" AS (PARTITION BY u0."gender" ORDER BY u0."age" DESC) []

       [
         %{age: 30, foo: 1, sex: "f"},
         %{age: 10, foo: 2, sex: "f"},
         %{age: 35, foo: 1, sex: "m"},
         %{age: 20, foo: 1, sex: "m"},
         %{age: 12, foo: 2, sex: "m"},
         %{age: 12, foo: 3, sex: "m"}
       ]
     #+END_SRC
 - ~percent_rank()~
   + Returns relative rank of the current row: (rank - 1) / (total rows - 1).
     #+BEGIN_SRC elixir
       from p in Post,
            select: percent_rank() |> over(partition_by: p.category_id, order_by: p.date)
     #+END_SRC
   + example
     #+BEGIN_SRC elixir
       iex(69)> (from u in User,
         select: %{sex: u.gender, age: u.age, foo: over(percent_rank(), :age)},
         windows: [age: [partition_by: u.gender, order_by: [desc: u.age]]]) |> Repo.all

       15:16:56.154 [debug] QUERY OK source="users" db=1.0ms queue=0.9ms
       SELECT u0."gender", u0."age", percent_rank() OVER "age" FROM "users" AS u0 WINDOW "age" AS (PARTITION BY u0."gender" ORDER BY u0."age" DESC) []

       [
         %{age: 30, foo: 0.0, sex: "f"},
         %{age: 10, foo: 1.0, sex: "f"},
         %{age: 35, foo: 0.0, sex: "m"},
         %{age: 20, foo: 0.3333333333333333, sex: "m"},
         %{age: 12, foo: 0.6666666666666666, sex: "m"},
         %{age: 12, foo: 0.6666666666666666, sex: "m"}
       ]
     #+END_SRC
 - ~rank()~
   + Returns rank of the current row with gaps; same as ~row_number/0~ of
     its first peer.
     #+BEGIN_SRC elixir
       from p in Post,
            select: rank() |> over(partition_by: p.category_id, order_by: p.date)
     #+END_SRC
   + example
     #+BEGIN_SRC elixir
       iex> (from u in User,
         select: %{sex: u.gender, age: u.age, foo: over(rank(), :age)},
         windows: [age: [partition_by: u.gender, order_by: [desc: u.age]]]) |> Repo.all

       15:18:41.985 [debug] QUERY OK source="users" db=1.0ms queue=0.9ms
       SELECT u0."gender", u0."age", rank() OVER "age" FROM "users" AS u0 WINDOW "age" AS (PARTITION BY u0."gender" ORDER BY u0."age" DESC) []

       [
           %{age: 30, foo: 1, sex: "f"},
           %{age: 10, foo: 2, sex: "f"},
           %{age: 35, foo: 1, sex: "m"},
           %{age: 20, foo: 2, sex: "m"},
           %{age: 12, foo: 3, sex: "m"},
           %{age: 12, foo: 3, sex: "m"}
       ]
     #+END_SRC
 - ~row_number()~
   + Returns number of the current row within its partition, counting
     from 1.
     #+BEGIN_SRC elixir
       from p in Post,
            select: row_number() |> over(partition_by: p.category_id, order_by: p.date)
     #+END_SRC
   + example
     #+BEGIN_SRC elixir
       iex> (from u in User,
         select: %{sex: u.gender, age: u.age, foo: over(row_number(), :age)},
         windows: [age: [partition_by: u.gender, order_by: [desc: u.age]]]) |> Repo.all

       15:21:09.304 [debug] QUERY OK source="users" db=1.0ms queue=1.0ms
       SELECT u0."gender", u0."age", row_number() OVER "age" FROM "users" AS u0 WINDOW "age" AS (PARTITION BY u0."gender" ORDER BY u0."age" DESC) []

       [
         %{age: 30, foo: 1, sex: "f"},
         %{age: 10, foo: 2, sex: "f"},
         %{age: 35, foo: 1, sex: "m"},
         %{age: 20, foo: 2, sex: "m"},
         %{age: 12, foo: 3, sex: "m"},
         %{age: 12, foo: 4, sex: "m"}
       ]
     #+END_SRC
 - ~sum(value)~
   + Calculates the sum for the given entry.
     #+BEGIN_SRC elixir
       from p in Payment, select: sum(p.value)
     #+END_SRC
   + example
     #+BEGIN_SRC elixir
       iex> (from u in User, select: %{sex: u.gender, age: u.age, foo: over(sum(u.age), :age)}, windows: [age: [partition_by: u.gender, order_by: [desc: u.age]]]) |> Repo.all

       15:22:39.592 [debug] QUERY OK source="users" db=1.0ms queue=1.1ms
       SELECT u0."gender", u0."age", sum(u0."age") OVER "age" FROM "users" AS u0 WINDOW "age" AS (PARTITION BY u0."gender" ORDER BY u0."age" DESC) []

       [
         %{age: 30, foo: 30, sex: "f"},
         %{age: 10, foo: 40, sex: "f"},
         %{age: 35, foo: 35, sex: "m"},
         %{age: 20, foo: 55, sex: "m"},
         %{age: 12, foo: 79, sex: "m"},
         %{age: 12, foo: 79, sex: "m"}
       ]
     #+END_SRC
** Ecto.Adapters.Postgres
** ecto_sql
 - To interface with migrations, developers typically use mix tasks:
   + ~mix ecto.migrations~ - lists all available migrations and their status
   + ~mix ecto.migrate~ - runs a migration
   + ~mix ecto.rollback~ - rolls back a previously run migration
 - SQL sandbox
   + ~ecto_sql~ provides a sandbox for testing. The sandbox wraps each
     test in a transaction, making sure the tests are isolated and can
     run concurrently

 - Structure load and dumping
   + If you have an existing database, you may want to dump its
     existing structure and make it reproducible from within Ecto. This
     can be achieved with two Mix tasks:
     * ~mix ecto.load~ - loads an existing structure into the database
     * ~mix ecto.dump~ - dumps the existing database structure to the filesystem
   + For creating and dropping databases,
     * ~mix ecto.create~
     * ~mix ecto.drop~
*** Ecto.Adapters.SQL
 - ~query(repo, sql, params \\ [], opts \\ [])~
   + Runs custom SQL query on given repo.
   + Examples
     #+BEGIN_SRC elixir
       iex> Ecto.Adapters.SQL.query(MyRepo, "SELECT $1::integer + $2", [40, 2])
       {:ok, %{rows: [[42]], num_rows: 1}}
     #+END_SRC
     For convenience, this function is also available under the repository:
     #+BEGIN_SRC elixir
       iex> MyRepo.query("SELECT $1::integer + $2", [40, 2])
       {:ok, %{rows: [[42]], num_rows: 1}}
     #+END_SRC
 - ~stream(repo, sql, params \\ [], opts \\ [])~
   + Returns a stream that runs a custom SQL query on given repo when
     reduced.
   + Example
     #+BEGIN_SRC elixir
     iex> Ecto.Adapters.SQL.stream(MyRepo, "SELECT $1::integer + $2", [40, 2]) |> Enum.to_list()
     [%{rows: [[42]], num_rows: 1}]
    #+END_SRC
 - ~to_sql(kind, repo, queryable)~
   + Converts the given query to SQL according to its kind and the
     adapter in the given repository.
   + example
     #+BEGIN_SRC elixir
       iex> Ecto.Adapters.SQL.to_sql(:all, repo, Post)
       {"SELECT p.id, p.title, p.inserted_at, p.created_at FROM posts as p", []}

       iex> Ecto.Adapters.SQL.to_sql(:update_all, repo, from(p in Post, update: [set: [title: ^"hello"]]))
       {"UPDATE posts AS p SET title = $1", ["hello"]}
     #+END_SRC
     This function is also available under the repository with name ~to_sql~:
*** Ecto.Adapters.SQL.Sandbox
 - A pool for concurrent transactional tests.
 - The sandbox pool is implemented on top of an ownership
   mechanism. When started, the pool is in automatic mode, which means
   the repository will automatically check connections out as with any
   other pool.
 - The ~mode/2~ function can be used to change the pool mode to *manual*
   or *shared*.
   + In both modes, the connection must be explicitly checked out
     before use.
   + When explicit checkouts are made, the sandbox will wrap the
    connection in a transaction by default and control who has access
    to it.
   + This means developers have a safe mechanism for running concurrent
     tests against the database.
**** Example
 - The first step is to configure your database to use the
   ~Ecto.Adapters.SQL.Sandbox~ pool. You set those options in your
   ~config/config.exs~ (or preferably ~config/test.exs~) if you haven’t
   yet:
   #+BEGIN_SRC elixir
     config :my_app, Repo,
       pool: Ecto.Adapters.SQL.Sandbox
   #+END_SRC
   Now you can write transactional tests:
   #+BEGIN_SRC elixir
     # At the end of your test_helper.exs
     # Set the pool mode to manual for explicit checkouts
     Ecto.Adapters.SQL.Sandbox.mode(Repo, :manual)

     defmodule PostTest do
       # Once the mode is manual, tests can also be async
       use ExUnit.Case, async: true

       setup do
         # Explicitly get a connection before each test
         :ok = Ecto.Adapters.SQL.Sandbox.checkout(Repo)
       end

       test "create post" do
         # Use the repository as usual
         assert %Post{} = Repo.insert!(%Post{})
       end
     end
   #+END_SRC

**** Collaborating processes
 - Sometimes a test may need to interact with multiple processes, all
   using the same connection so they all belong to the same
   transaction.
 - problem
   #+BEGIN_SRC elixir
     setup do
       # Explicitly get a connection before each test
       :ok = Ecto.Adapters.SQL.Sandbox.checkout(Repo)
     end

     test "create two posts, one sync, another async" do
       task = Task.async(fn ->
         Repo.insert!(%Post{title: "async"})
       end)
       assert %Post{} = Repo.insert!(%Post{title: "sync"})
       assert %Post{} = Task.await(task)
     end
   #+END_SRC
   The test above will fail with an error similar to:
   #+BEGIN_SRC
   ** (DBConnection.OwnershipError) cannot find ownership process for #PID<0.35.0>
   #+END_SRC
   That’s because the setup block is checking out the connection only
   for the test process. Once we spawn a Task, there is no connection
   assigned to it and it will fail.

 - The sandbox module provides two ways of doing so, via *allowances* or
   by running in *shared mode*.

 - Allowances
   + you can explicitly tell a process which checked out connection it
     should use, allowing multiple processes to collaborate over the
     same connection.
     #+BEGIN_SRC elixir
       test "create two posts, one sync, another async" do
         parent = self()
         task = Task.async(fn ->
           Ecto.Adapters.SQL.Sandbox.allow(Repo, parent, self())
           Repo.insert!(%Post{title: "async"})
         end)
         assert %Post{} = Repo.insert!(%Post{title: "sync"})
         assert %Post{} = Task.await(task)
       end
     #+END_SRC
   + the advantage is that you can still run your tests in async mode.
 - Shared mode
   + Shared mode allows a process to share its connection with any
     other process automatically, without relying on explicit
     allowances.
     #+BEGIN_SRC elixir
       setup do
         # Explicitly get a connection before each test
         :ok = Ecto.Adapters.SQL.Sandbox.checkout(Repo)
         # Setting the shared mode must be done only after checkout
         Ecto.Adapters.SQL.Sandbox.mode(Repo, {:shared, self()})
       end

       test "create two posts, one sync, another async" do
         task = Task.async(fn ->
           Repo.insert!(%Post{title: "async"})
         end)
         assert %Post{} = Repo.insert!(%Post{title: "sync"})
         assert %Post{} = Task.await(task)
       end
     #+END_SRC
     By calling ~mode({:shared, self()})~, any process that needs to
     talk to the database will now use the same connection as the one
     checked out by the test process during the setup block.
   + The downside is that tests can no longer run concurrently in shared mode.
***** issues with running the sandbox mode concurrently
 - “owner exited while client is still running”
   #+BEGIN_SRC
     21:57:43.910 [error] Postgrex.Protocol (#PID<0.284.0>) disconnected:
         ,** (DBConnection.Error) owner #PID<> exited while client #PID<> is still running
   #+END_SRC
   + the error happens because the test process (owner) has finished, either
     because the test succeeded or because it failed, while the client
     process was trying to get information from the database
 - “owner timed out because it owned the connection for longer than
   Nms”
   #+BEGIN_SRC
     09:56:43.081 [error] Postgrex.Protocol (#PID<>) disconnected:
         ,** (DBConnection.ConnectionError) owner #PID<> timed out
         because it owned the connection for longer than 60000ms
   #+END_SRC
   + If you have a long running test (or you’re debugging with
     ~IEx.pry~), the timeout for the connection ownership may be too
     short. You can increase the timeout by setting the
     ~:ownership_timeout~ options for your repo config in
     ~config/config.exs~ (or preferably in ~config/test.exs~):
     #+BEGIN_SRC elixir
       config :my_app, MyApp.Repo,
         ownership_timeout: NEW_TIMEOUT_IN_MILLISECONDS
     #+END_SRC
     The ~:ownership_timeout~ option is part of ~DBConnection.Ownership~ and
     defaults to 60000ms. Timeouts are given as integers in milliseconds.
   + Alternately, if this is an issue for only a handful of
     long-running tests, you can pass an ~:ownership_timeout~ option when
     calling ~Ecto.Adapters.SQL.Sandbox.checkout/2~ instead of setting a
     longer timeout globally in your config.
***** Deferred constraints
 - Some databases allow to defer constraint validation to the
   transaction commit time, instead of the particular statement
   execution time.
 - Since the SQL Sandbox mode rolls back transactions, tests might
   report false positives because deferred constraints are never
   checked by the database.
 - To manually force deferred constraints validation when using
   PostgreSQL use the following line right at the end of your test
   case:
   #+BEGIN_SRC elixir
   Repo.query!("SET CONSTRAINTS ALL IMMEDIATE")
   #+END_SRC
***** Database locks and deadlocks
 - Since the sandbox relies on concurrent transactional tests, there is
   a chance your tests may trigger deadlocks in your database.
 - even on databases like PostgreSQL, performance degradations or
   deadlocks may still occur. For example, imagine multiple tests are
   trying to insert the same user to the database. They will attempt to
   retrieve the same database lock, causing only one test to succeed
   and run while all other tests wait for the lock.
 - In other situations, two different tests may proceed in a way that
   each test retrieves locks desired by the other, leading to a
   situation that cannot be resolved, a deadlock. For instance:
   #+BEGIN_SRC text
     Transaction 1:                Transaction 2:
     begin
                                   begin
     update posts where id = 1
                                   update posts where id = 2
                                   update posts where id = 1
     update posts where id = 2
                           ,**deadlock**
   #+END_SRC
   + There are different ways to avoid such problems. One of them is to
     make sure your tests work on distinct data. Regardless of your
     choice between using fixtures or factories for test data, make
     sure you get a new set of data per test. This is specially
     important for data that is meant to be unique like user emails.
     For example, instead of:
     #+BEGIN_SRC elixir
       def insert_user do
         Repo.insert! %User{email: "sample@example.com"}
       end
     #+END_SRC
     prefer:
     #+BEGIN_SRC elixir
       def insert_user do
         Repo.insert! %User{email: "sample-#{counter()}@example.com"}
       end

       defp counter do
         System.unique_integer [:positive]
       end
     #+END_SRC
**** Functions
*** Ecto.Migration behaviour
 - Example
   #+BEGIN_SRC elixir
     defmodule MyRepo.Migrations.AddWeatherTable do
       use Ecto.Migration

       def up do
         create table("weather") do
           add :city,    :string, size: 40
           add :temp_lo, :integer
           add :temp_hi, :integer
           add :prcp,    :float

           timestamps()
         end
       end

       def down do
         drop table("weather")
       end
     end
   #+END_SRC

 - Ecto creates a table (can be configured via ~:migration_source~ configuration
   option) in the database in order to keep track of migrations and
   will add an entry to this table for each migration.

**** Change
 - ~change/0~ is an abstraction that wraps both ~up/0~ and ~down/0~ for
   automatically-reversible migrations
   #+BEGIN_SRC elixir
     defmodule MyRepo.Migrations.AddWeatherTable do
       use Ecto.Migration

       def change do
         create table("weather") do
           add :city,    :string, size: 40
           add :temp_lo, :integer
           add :temp_hi, :integer
           add :prcp,    :float

           timestamps()
         end
       end
     end
   #+END_SRC
 - not all commands are reversible. Trying to rollback a non-reversible
   command will raise an ~Ecto.MigrationError~.
 - ~execute/2~ is reversible in ~change/0~ by accepting a pair of
   plain SQL strings. The first is run on forward migrations (~up/0~) and
   the second when rolling back (~down/0~)

**** Field Types
 - The Ecto primitive types are mapped to the appropriate database type
   by the various database adapters. For example, ~:string~ is converted
   to ~:varchar~, ~:binary~ to ~:bits~ or ~:blob~, and so on.
 - you can pass any field type supported by your database as long as it
   maps to an Ecto type. For instance, you can use ~:text~, ~:varchar~, or
   ~:char~ in your migrations as ~add(:field_name, :text)~. In your Ecto
   schema, they will all map to the same ~:string~ type.
 - if you want to use a field type with database-specific options, you
   can pass atoms containing these options like ~:"int unsigned"~,
   ~:"time without time zone"~
**** Prefixes
 - Migrations support specifying a table prefix or index prefix which
   will target either a schema (if using PostgreSQL) or a different
   database (if using MySQL). If no prefix is provided, the default
   schema or database is used.
 - Any reference declared in the table migration refers by default to
   the table with the same declared prefix.
   #+BEGIN_SRC elixir
     def up do
       create table("weather", prefix: "north_america") do
         add :city,    :string, size: 40
         add :temp_lo, :integer
         add :temp_hi, :integer
         add :prcp,    :float
         add :group_id, references(:groups)

         timestamps()
       end

       create index("weather", [:city], prefix: "north_america")
     end
   #+END_SRC
 - When using a prefixed table with either MySQL or PostgreSQL, you
   must use the same prefix for the index field to ensure that you
   index the prefix-qualified table.

**** Transactions
 - For PostgreSQL, Ecto always runs migrations inside a transaction,
   but that’s not always desired: for example, you cannot create/drop
   indexes concurrently inside a transaction. Migrations can be forced
   to run outside a transaction by setting the ~@disable_ddl_transaction~
   module attribute to ~true~.
**** Transaction Callbacks
 - There are use cases that dictate adding some common behavior after
   beginning a migration transaction, or before commiting that
   transaction. For instance, one might desire to set a ~lock_timeout~
   for each lock in the transaction.
 - Another way these might be leveraged is by defining a custom
   migration module so that these callbacks will run for all of your
   migrations, if you have special requirements.
   #+BEGIN_SRC elixir
     defmodule MyApp.Migration do
       defmacro __using__(_) do
         use Ecto.Migration

         def after_begin() do
           repo().query! "SET lock_timeout TO '5s'", "SET lock_timeout TO '10s'"
         end

         # There's also a `before_commit()` to run immediately before the transaction is closed
       end
     end
   #+END_SRC
   Then in your migrations you can use MyApp.Migration to share this
   behavior among all your migrations.
**** Comments
 - Migrations where you create or alter a table support specifying
   table and column comments. The same can be done when creating
   constraints and indexes. Not all databases support this feature.
   #+BEGIN_SRC elixir
     def up do
       create index("posts", [:name], comment: "Index Comment")

       create constraint("products", "price_must_be_positive", check: "price > 0", comment: "Constraint Comment")

       create table("weather", prefix: "north_america", comment: "Table Comment") do
         add :city, :string, size: 40, comment: "Column Comment"
         timestamps()
       end
     end
   #+END_SRC
**** Repo configuration
 - The following migration configuration options are available for a
   given repository:
   + ~:migration_source~ - Version numbers of migrations will be saved
     in a table named schema_migrations by default. You can configure
     the name of the table via:
     #+BEGIN_SRC elixir
     config :app, App.Repo, migration_source: "my_migrations"
     #+END_SRC
   + ~:migration_primary_key~ - By default, Ecto uses the ~:id~ column
     with type ~:bigserial~, but you can configure it via:
     #+BEGIN_SRC elixir
     config :app, App.Repo, migration_primary_key: [name: :uuid, type: :binary_id]
     #+END_SRC
   + ~:migration_timestamps~ - By default, Ecto uses the ~:naive_datetime~
     type, but you can configure it via:
     #+BEGIN_SRC elixir
     config :app, App.Repo, migration_timestamps: [type: :utc_datetime]
     #+END_SRC
   + ~:migration_lock~ - By default, Ecto will lock the migration
     table. This allows multiple nodes to attempt to run migrations at
     the same time but only one will succeed. However, this does not
     play well with other features, such as the ~:concurrently~ option in
     PostgreSQL indexes. You can disable the ~migration_lock~ by setting
     it to ~nil~:
     #+BEGIN_SRC elixir
     config :app, App.Repo, migration_lock: nil
     #+END_SRC
   + ~:migration_default_prefix~ - Ecto defaults to ~nil~ for the database
     prefix for migrations, but you can configure it via:
     #+BEGIN_SRC elixir
     config :app, App.Repo, migration_default_prefix: "my_prefix"
     #+END_SRC
**** functions
 - ~add(column, type, opts \\ [])~
   + Adds a column when creating or altering a table.
   + also accepts Ecto primitive types as column types that are
     normalized by the database adapter. For example, ~:string~ is
     converted to ~:varchar~, ~:binary~ to ~:bits~ or ~:blob~, and so
     on.
   + the column type is not always the same as the type used in your
     schema. For example, a schema that has a ~:string~ field can be
     supported by columns of type ~:char~, ~:varchar~, ~:text~, and
     others. For this reason, this function also accepts ~:text~ and
     other type annotations that are native to the database. These are
     passed to the database as-is.
   + the column type may be either an Ecto primitive type,
     which is normalized in cases where the database does not
     understand it, such as ~:string~ or ~:binary~, or a database type
     which is passed as-is.
   + Custom Ecto types like ~Ecto.UUID~ are not supported because they
     are application-level concerns and may not always map to the
     database.
   + Example
     #+BEGIN_SRC elixir
       create table("posts") do
         add :title, :string, default: "Untitled"
       end

       alter table("posts") do
         add :summary, :text # Database type
         add :object,  :map  # Elixir type which is handled by the database
       end
     #+END_SRC
   + ~opts~
     * ~:primary_key~ - when true, marks this field as the primary
       key. If multiple fields are marked, a composite primary key will
       be created.
     * ~:default~ - the column’s default value. It can be a string,
       number, empty list, list of strings, list of numbers, or a
       fragment generated by ~fragment/1~.
     * ~:null~ - when false, the column does not allow null values.
     * ~:size~ - the size of the type (for example, the number of
       characters). The default is no size, except for ~:string~, which
       defaults to 255.
     * ~:precision~ - the precision for a numeric type. Required when
       ~:scale~ is specified.
     * ~:scale~ - the scale of a numeric type. Defaults to 0.
 - ~add_if_not_exists(column, type, opts \\ [])~
   + Adds a column if it not exists yet when altering a table.
   + If the ~type~ value is a ~%Reference{}~, it is used to remove the
     constraint.
   + ~type~ and ~opts~ are exactly the same as in ~add/3~, and they are
     used when the command is reversed.
   + Example
     #+BEGIN_SRC elixir
       alter table("posts") do
         add_if_not_exists :title, :string, default: ""
       end
     #+END_SRC
 - ~alter(object, list)~
   + Alters a table.
   + Examples
     #+BEGIN_SRC elixir
       alter table("posts") do
         add :summary, :text
         modify :title, :text
         remove :views
       end
     #+END_SRC
 - ~constraint(table, name, opts \\ [])~
   + Defines a constraint (either a check constraint or an exclusion
     constraint) to be evaluated by the database when a row is inserted
     or updated.
   + Example
     #+BEGIN_SRC elixir
       create constraint("users", :price_must_be_positive, check: "price > 0")
       create constraint("size_ranges", :no_overlap, exclude: ~s|gist (int4range("from", "to", '[]') WITH &&)|)
       drop   constraint("products", "price_must_be_positive")
     #+END_SRC
   + ~opts~
     * ~:check~ - A check constraint expression. Required when creating
       a check constraint.
     * ~:exclude~ - An exclusion constraint expression. Required when
       creating an exclusion constraint.
     * ~:prefix~ - The prefix for the table.
 - ~create(index)~
   + Creates one of the following:
     * an index
     * a table with only an ~:id~ field
     * a constraint
   + When reversing (in a ~change/0~ running backwards), indexes are only
     dropped if they exist, and no errors are raised. To enforce
     dropping an index, use ~drop/1~.
   + Example
     #+BEGIN_SRC elixir
       create index("posts", [:name])
       create table("version")
       create constraint("products", "price_must_be_positive", check: "price > 0")
     #+END_SRC
 - ~create(object, list)~
   + Creates a table.
   + By default, the table will also include an ~:id~ primary key field
     that has a type of ~:bigserial~.
   + Example
     #+BEGIN_SRC elixir
       create table(:posts) do
         add :title, :string, default: "Untitled"
         add :body,  :text

         timestamps()
       end
     #+END_SRC
 - ~create_if_not_exists(index)~
   + Creates an index or a table with only ~:id~ field if one does not
     yet exist.
   + Example
     #+BEGIN_SRC elixir
     create_if_not_exists index("posts", [:name])

     create_if_not_exists table("version")
     #+END_SRC
 - ~create_if_not_exists(object, list)~
   + Creates a table if it does not exist.
   + Works just like ~create/2~ but does not raise an error when the
     table already exists.
 - ~direction()~
   + Gets the migrator direction.
 - ~drop(index_or_table_or_constraint)~
   + Drops one of the following:
     * an index
     * a table
     * a constraint
   + Example
     #+BEGIN_SRC elixir
       drop index("posts", [:name])
       drop table("posts")
       drop constraint("products", "price_must_be_positive")
     #+END_SRC
 - ~drop_if_exists(index_or_table)~
   + Drops a table or index if it exists.
   + Does not raise an error if the specified table or index does not
     exist.
   + Examples
     #+BEGIN_SRC elixir
     drop_if_exists index("posts", [:name])
     drop_if_exists table("posts")
     #+END_SRC
 - ~execute(command)~
   + Executes arbitrary SQL or a keyword command.
   + Reversible commands can be defined by calling ~execute/2~.
   + Examples
     #+BEGIN_SRC elixir
     execute "CREATE EXTENSION postgres_fdw"

     execute create: "posts", capped: true, size: 1024
     #+END_SRC
 - ~execute(up, down)~
   + Executes reversible SQL commands.
   + This is useful for database-specific functionality that does not
     warrant special support in Ecto, for example, creating and
     dropping a PostgreSQL extension. The ~execute/2~ form avoids having
     to define separate ~up/0~ and ~down/0~ blocks that each contain an
     ~execute/1~ expression.
   + Examples
     #+BEGIN_SRC elixir
     execute "CREATE EXTENSION postgres_fdw", "DROP EXTENSION postgres_fdw"
     #+END_SRC
 - ~flush()~
   + (someone from Slack:) it explicitly flushes any pending migrations prior to your
     ~change/0~, ~up/0~, or ~down/0~ migration functions
     complete. Essentially you should need to call ~flush()~ if you
     wanted to perform any subsequent data migration tasks in the same
     migration.
     #+BEGIN_SRC elixir
       def change do
         alter table(:deployments) do
           add :status, :text
         end

         flush()

         Repo.update_all(Deployment, [set: [status: "completed"]], prefix: prefix())
       end
     #+END_SRC
 - ~fragment(expr)~
   + Generates a fragment to be used as a default value.
   + Examples
     #+BEGIN_SRC elixir
       create table("posts") do
         add :inserted_at, :naive_datetime, default: fragment("now()")
       end
     #+END_SRC
 - ~index(table, columns, opts \\ [])~
   + Returns an index struct that can be given to ~create/1~, ~drop/1~,
     etc.
   + Expects the table name as the first argument and the index
     field(s) as the second. The fields can be atoms, representing
     columns, or strings, representing expressions that are sent as-is
     to the database.
   + ~opts~
     * ~:name~ - the name of the index. Defaults to "~#{table}_#{column}_index~".
     * ~:unique~ - indicates whether the index should be
       unique. Defaults to ~false~.
     * ~:concurrently~ - indicates whether the index should be
       created/dropped concurrently.
     * ~:using~ - configures the index type.
     * ~:prefix~ - specify an optional prefix for the index.
     * ~:where~ - specify conditions for a partial index.
   + Adding/dropping indexes concurrently
     * PostgreSQL supports adding/dropping indexes
       concurrently. However, this feature does not work well with the
       transactions used by Ecto to guarantee integrity during
       migrations.
     * to migrate indexes concurrently, you need to set
       ~@disable_ddl_transaction~ in the migration to ~true~, disabling the
       guarantee that all of the changes in the migration will happen
       at once:
       #+BEGIN_SRC elixir
         defmodule MyRepo.Migrations.CreateIndexes do
           use Ecto.Migration
           @disable_ddl_transaction true

           def change do
             create index("posts", [:slug], concurrently: true)
           end
         end
       #+END_SRC
     * And you also need to disable the migration lock for that repository:
       #+BEGIN_SRC
       config :my_app, MyApp.Repo, migration_lock: nil
       #+END_SRC
       - The migration lock is used to guarantee that only one node in
         a cluster can run migrations. Two nodes may attempt to race
         each other.
       - Since running migrations outside a transaction can be
         dangerous, consider performing very few operations in
         migrations that add concurrent indexes. We recommend to run
         migrations with concurrent indexes in isolation and disable
         those features only temporarily.
   + Index types
     * When creating an index, the index type can be specified with the
       ~:using~ option. The ~:using~ option can be an atom or a string, and
       its value is passed to the generated ~USING~ clause as-is.
     * For example, PostgreSQL supports several index types like B-tree
       (the default), Hash, GIN, and GiST.
   + Partial indexes
     * Databases like PostgreSQL and MSSQL support partial indexes.
     * A partial index is an index built over a subset of a table. The
       subset is defined by a conditional expression using the ~:where~
       option. The ~:where~ option can be an atom or a string; its value
       is passed to the generated ~WHERE~ clause as-is.
   + Examples
     #+BEGIN_SRC elixir
       # With no name provided, the name of the below index defaults to
       # products_category_id_sku_index
       create index("products", [:category_id, :sku], unique: true)

       # The name can also be set explicitly
       drop index("products", [:category_id, :sku], name: :my_special_name)

       # Indexes can be added concurrently
       create index("products", [:category_id, :sku], concurrently: true)

       # The index type can be specified
       create index("products", [:name], using: :hash)

       # Partial indexes are created by specifying a :where option
       create index("products", [:user_id], where: "price = 0", name: :free_products_index)
     #+END_SRC
   + Indexes also support custom expressions. Some databases may
     require the index expression to be written between parentheses:
     #+BEGIN_SRC elixir
       # Create an index on a custom expression
       create index("products", ["(lower(name))"], name: :products_lower_name_index)

       # Create a tsvector GIN index on PostgreSQL
       create index("products", ["(to_tsvector('english', name))"],
                    name: :products_name_vector, using: "GIN")
     #+END_SRC
 - ~modify(column, type, opts \\ [])~
   + Modifies the type of a column when altering a table.
   + This command is not reversible unless the ~:from~ option is
     provided. If the ~:from~ value is a ~%Reference{}~, the adapter will
     try to drop the corresponding foreign key constraints before
     modifying the type.
   + Example
     #+BEGIN_SRC elixir
       alter table("posts") do
         modify :title, :text
       end
     #+END_SRC
   + ~opts~
     * ~:null~ - determines whether the column accepts null values.
     * ~:default~ - changes the default value of the column.
     * ~:from~ - specifies the current type of the column.
     * ~:size~ - specifies the size of the type (for example, the
       number of characters). The default is no size.
     * ~:precision~ - the precision for a numeric type. Required when
       ~:scale~ is specified.
     * ~:scale~ - the scale of a numeric type. Defaults to 0.
 - ~prefix()~
   + Gets the migrator prefix.
 - ~references(table, opts \\ [])~
   + Defines a foreign key.
   + Example
     #+BEGIN_SRC elixir
       create table("products") do
         add :group_id, references("groups")
       end
     #+END_SRC
   + ~opts~
     * ~:name~ - The name of the underlying reference, which defaults
       to "~#{table}_#{column}_fkey~".
     * ~:column~ - The foreign key column name, which defaults to ~:id~.
     * ~:prefix~ - The prefix for the reference. Defaults to the
       reference of the table if present, or ~nil~.
     * ~:type~ - The foreign key type, which defaults to ~:bigserial~.
     * ~:on_delete~ - What to do if the referenced entry is deleted. May
       be ~:nothing~ (default), ~:delete_all~, ~:nilify_all~, or ~:restrict~.
     * ~:on_update~ - What to do if the referenced entry is
       updated. May be ~:nothing~ (default), ~:update_all~, ~:nilify_all~, or
       ~:restrict~.
 - ~remove(column)~
   + Removes a column when altering a table.
   + This command is not reversible as Ecto does not know what type it
     should add the column back as. Use ~remove/3~ as a reversible
     alternative.
   + Example
     #+BEGIN_SRC elixir
       alter table("posts") do
         remove :title
       end
     #+END_SRC
 - ~remove(column, type, opts \\ [])~
   + Removes a column in a reversible way when altering a table.
   + ~type~ and ~opts~ are exactly the same as in ~add/3~, and they are
     used when the command is reversed.
   + If the type value is a ~%Reference{}~, it is used to remove the
     constraint.
   + Examples
     #+BEGIN_SRC elixir
       alter table("posts") do
         remove :title, :string, default: ""
       end
     #+END_SRC
 - ~remove_if_exists(column, type)~
   + Removes a column only if the column exists when altering the
     constraint if the reference type is passed once it only has the
     constraint name on reference structure.
   + This command is not reversible as Ecto does not know about column
     existense before the removal attempt.
   + Examples
     #+BEGIN_SRC elixir
       alter table("posts") do
         remove_if_exists :title, :string
       end
     #+END_SRC
 - ~rename(table_current, list)~
   + Renames a table.
   + Examples
     #+BEGIN_SRC elixir
     rename table("posts"), to: table("new_posts")
     #+END_SRC
 - ~rename(table, current_column, list)~
   + Renames a column outside of the ~alter~ statement.
   + Example
     #+BEGIN_SRC
      rename table("posts"), :title, to: :summary
     #+END_SRC
 - ~repo()~
   + Gets the migrator repo.
 - ~table(name, opts \\ [])~
   + Returns a table struct that can be given to ~create/2~, ~alter/2~,
     ~drop/1~, etc.
   + Examples
     #+BEGIN_SRC elixir
       create table("products") do
         add :name, :string
         add :price, :decimal
       end

       drop table("products")

       create table("products", primary_key: false) do
         add :name, :string
         add :price, :decimal
       end
     #+END_SRC
   + ~opts~
     * ~:primary_key~ - when ~false~, a primary key field is not generated
       on table creation.
     * ~:engine~ - customizes the table storage for supported
       databases. For MySQL, the default is InnoDB.
     * ~:prefix~ - the prefix for the table.
     * :options - provide custom options that will be appended after
       the generated statement. For example, “WITH”, “INHERITS”, or “ON
       COMMIT” clauses.
 - ~timestamps(opts \\ [])~
   + Adds ~:inserted_at~ and ~:updated_at~ timestamp columns.
   + Those columns are of ~:naive_datetime~ type and by default cannot
     be null. A list of opts can be given to customize the generated
     fields.
   + ~opts~
     * ~:inserted_at~ - the name of the column for storing insertion
       times. Setting it to ~false~ disables the column.
     * ~:updated_at~ - the name of the column for storing
       last-updated-at times. Setting it to ~false~ disables the column.
     * ~:type~ - the type of the ~:inserted_at~ and ~:updated_at~
       columns. Defaults to ~:naive_datetime~.
 - ~unique_index(table, columns, opts \\ [])~
   + Shortcut for creating a unique index.
*** Ecto.Adapters.Postgres
 - All options can be given via the repository configuration:
   #+BEGIN_SRC elixir
     config :your_app, YourApp.Repo,
       ...
   #+END_SRC

   Connection options
   ~:hostname~
   ~:socket_dir~
   ~:socket~
   ~:username~
   ~:password~
   ~:port~
   ~:database~
   ~:maintenance_database~
   ~:pool~
   ~:timeout~
   ~:ssl~
   ~:ssl_opts~
   ~:parameters~
   ~:connect_timeout~
   ~:prepare~
   ~:socket_options~
   Storage options
   ~:encoding~
   ~:template~
   ~:lc_collate~
   ~:lc_ctype~
   ~:dump_path~
   After connect callback
   ~after_connect~
   Extensions
   ~types~

* Programming Ecto Book

- ~Repo~ is the heart of Ecto and acts as a kind of proxy for your
  database. All communication to and from the database goes through
  ~Repo~.

- The ~Query~ module contains Ecto’s powerful but elegant API for
  writing queries. Here you’ll find everything you need to pull the
  data you want out of your database, and make precise changes

- A schema is a kind of map, from database tables to your code. The
  ~Schema~ module contains tools to help you create these maps with
  ease. The best part is Ecto schemas are very flexible—you’re not
  locked into a simple one-to-one relationship between your tables and
  your structs.

- Ecto understands that one size does not fit all, so it provides the
  ~changeset~: a data structure that captures all aspects of making a
  change to your data. The ~Changeset~ module provides functions for
  creating and manipulating changesets, allowing you to structure your
  changes in a way that is safe, flexible, and easy to test.

- You often need to coordinate several database changes
  simultaneously, where they must all succeed or fail together. The
  ~transaction~ function works great for simple cases, but the ~Multi~
  module can handle even very complex cases while still keeping your
  code clean and testable.

- Changing the structure of a database can be tricky, particularly
  when multiple developers are involved, but ~Migration~ helps you
  coordinate these changes so that everyone stays in sync.
** Repo
- delete_all
- insert_all
- update_all
  #+BEGIN_SRC elixir
  Repo.update_all("artists", set: [updated_at: DateTime.utc_now()])
  #+END_SRC
  + set
  + inc
  + push
  + pull
- e.g.
  #+BEGIN_SRC elixir
  Repo.insert_all("artists",
                 [%{name: "Max Roach"}, %{name: "Art Blakey"}],
                 returning: [:id, :name])
  #=> {2, [%{id: 12, name: "Max Roach"}, %{id: 13, name: "Art Blakey"}]}
  #+END_SRC
*** Executing raw queries
- e.g.
  #+BEGIN_SRC elixir
    # or better yet Repo.query
    iex(7)> Ecto.Adapters.SQL.query(Repo, "select * from artists where id = 1")

    15:17:32.127 [debug] QUERY OK db=1.4ms queue=1.5ms
    select * from artists where id = 1 []
    {:ok,
     %Postgrex.Result{
       columns: ["id", "name", "birth_date", "death_date", "inserted_at",
        "updated_at"],
       command: :select,
       connection_id: 18530,
       messages: [],
       num_rows: 1,
       rows: [
         [1, "Miles Davis", nil, nil, ~N[2019-04-25 08:11:42.000000],
          ~N[2019-04-25 10:25:29.000000]]
       ]
     }}
  #+END_SRC

*** Customizing Your Repo
- e.g.
  #+BEGIN_SRC elixir
    defmodule MusicDB.Repo do
      use Ecto.Repo,
        otp_app: :music_db,
        adapter: Ecto.Adapters.Postgres

      def using_postgres? do
        MusicDB.Repo.__adapter__() == Ecto.Adapters.Postgres
      end

      def count(table) do
        aggregate(table, :count, :id)
      end
    end
  #+END_SRC
** Querying Your Database
- look at the docs for the ~Ecto.Query~ module to see all the keywords
  available to you
- and look at ~Ecto.Query.API~ to see all the utility functions that
  you can use within queries.
- e.g
  #+BEGIN_SRC elixir
  query =
      from(t in "tracks",
        join: a in "albums",
        on: t.album_id == a.id,
        where: t.duration > 900,
        select: [t.id, t.title, a.title]
      )
  #+END_SRC
  Here’s the same query written using the macro syntax:
  #+BEGIN_SRC elixir
  query =
    "tracks"
    |> join(:inner, [t], a in "albums", on: t.album_id == a.id)
    |> where([t, a], t.duration > 900)
    |> select([t, a], [t.id, t.title, a.title])
  #+END_SRC
- We can see the statement it’ll generate with the ~Ecto.Adapters.SQL.to_sql~ function:
  #+BEGIN_SRC elixir
    query = from "artists", select: [:name]

    Ecto.Adapters.SQL.to_sql(:all, Repo, query)
    #=> {"SELECT a0.\"name\" FROM \"artists\" AS a0", []}

    # or better yet
    query = from "artists", select: [:name]
    Repo.to_sql(:all, query)
    #=> {"SELECT a0.\"name\" FROM \"artists\" AS a0", []}
  #+END_SRC
- ~type~ conversion
  #+BEGIN_SRC elixir
    artist_id = "1"

    q = from "artists", where: [id: type(^artist_id, :integer)], select: [:name]

    Repo.all(q)
    #=> [%{name: "Miles Davis"}]
  #+END_SRC
*** Query Bindings
- You create a query binding by using ~in~ along with the usual ~from~.
  #+BEGIN_SRC elixir
  q = from a in "artists", where: a.name == "Bill Evans", select: [:id, :name]
  #+END_SRC
  ~a~ becomes the binding for the ~artists~ table

*** Query Expressions
- read ~Ecto.Query.API~ module
- e.g.
  #+BEGIN_SRC elixir
    # like statements
    q = from a in "artists", where: like(a.name, "Miles%"), select: [:id, :name]

    # checking for null
    q = from a in "artists", where: is_nil(a.name), select: [:id, :name]

    # checking for not null
    q = from a in "artists", where: not is_nil(a.name), select: [:id, :name]

    # date comparison - this finds artists added more than 1 year ago
    q = from a in "artists", where: a.inserted_at < ago(1, "year"), select: [:id, :name]
  #+END_SRC
*** Inserting Raw SQL
- The ~fragment~ function gives you an escape hatch for writing bits
  of raw SQL that get inserted verba- tim into the query
  #+BEGIN_SRC elixir
    q = from a in "artists",
        where: fragment("lower(?)", a.name) == "miles davis",
        select: [:id, :name]
  #+END_SRC
  If this is something you think you’ll be using a lot, you can extend
  Ecto’s query API by adding your own macro and importing it into your
  module:
  #+BEGIN_SRC elixir
    defmacro lower(arg) do
      quote do: fragment("lower(?)", unquote(arg))
    end
  #+END_SRC
  Then the query could be rewritten like this:
  #+BEGIN_SRC elixir
    q = from a in "artists", where: lower(a.name) == "miles davis", select: [:id, :name]
  #+END_SRC

*** Combining Results with ~union~ and ~union_all~
- To combine results of different queries, SQL provides the ~UNION~
  operator.
  #+BEGIN_SRC elixir
    tracks_query = from t in "tracks", select: t.title
    union_query = from a in "albums", select: a.title,
      union: ^tracks_query

    Repo.all(union_query)
    #=> ["Without a Song", "Gary's Theme", "Miles", "Kind Of Blue", ...]
  #+END_SRC
  For this to work, the two queries need to have result sets with the
  same column names and data type.
- With ~union~ the database will filter the results so that they only
  contain *unique* rows. This can add quite a bit of overhead. If you’re
  certain that your results won’t contain duplicates (or you don’t
  care if they do), you can use ~union_all~ to generate a more efficient
  query:
  #+BEGIN_SRC elixir
    tracks_query = from t in "tracks", select: t.title
    union_query = from a in "albums", select: a.title,
      union_all: ^tracks_query

    Repo.all(union_query)
    #=> ["Without a Song", "Gary's Theme", "Miles", "Kind Of Blue", ...]
  #+END_SRC
**** intersect
- e.g.
  #+BEGIN_SRC elixir
    tracks_query = from t in "tracks", select: t.title
    intersect_query = from a in "albums", select: a.title,
      intersect: ^tracks_query
  #+END_SRC
**** except
- e.g.
  #+BEGIN_SRC elixir
    tracks_query = from t in "tracks", select: t.title
    except_query = from a in "albums", select: a.title,
      except: ^tracks_query
  #+END_SRC

- As with ~union:~ and ~union_all:~ , Ecto provides ~intersect_all:~ and
  ~except_all:~ when you’re not concerned about potential duplicates.
*** order_by and group_by
**** order_by
- If we wanted a list of all of artists in alphabetical order, we can
  use ~order_by~
  #+BEGIN_SRC elixir
  q = from a in "artists", select: [a.name], order_by: a.name
  Repo.all(q)
  #=> [["Bill Evans"], ["Bobby Hutcherson"], ["Miles Davis"]]
  #+END_SRC
- to get the results in ~desc~ order (~asc~ is the default):
  #+BEGIN_SRC elixir
    q = from a in "artists", select: [a.name], order_by: [desc: a.name]
    Repo.all(q)
    #=> [["Miles Davis"], ["Bobby Hutcherson"], ["Bill Evans"]]
  #+END_SRC
- order by multiple columns

  the results will be sorted by the first column provided to
  ~order_by~ then by the second, and so on.
  #+BEGIN_SRC elixir
    q = from t in "tracks", select: [t.album_id, t.title, t.index],
    order_by: [t.album_id, t.index]
    Repo.all(q)
    #=> [[1, "So What", 1], [1, "Freddie Freloader", 2], [1, "Blue In Green", 3],
    #=> [1, "All Blues", 4], [1, "Flamenco Sketches", 5],
    #=> [2, "If I Were A Bell", 1], [2, "Stella By Starlight", 2],
    #=> [2, "Walkin'", 3], [2, "Miles", 4], [2, "No Blues", 5], ... ]
  #+END_SRC

- When using order, you should give some thought to columns that
  might contain ~NULL~
  + if you want to control where they appear, you can specify the
    ordering using ~:asc_nulls_last~, ~:asc_nulls_first~,
    ~:desc_nulls_last~, or ~:desc_nulls_first~ (note that MySQL
    currently does not support these options):
  #+BEGIN_SRC elixir
    q = from t in "tracks", select: [t.album_id, t.title, t.index], order_by: [desc: t.album_id, asc_nulls_first: t.index]

    Repo.all(q)
    #=> [[5, "Anton's Ball", 1], [5, "The Moontrane", 2], [5, "Farallone", 3],
    #=> [5, "Song Of Songs", 4], [4, "Come Rain Or Come Shine", 1], ... ]
  #+END_SRC

**** group_by
- Let’s say we wanted to get the total length of each album. We’re
  going to need to look at the duration column of each track, but we
  don’t actually want to see each individual track: we just want to
  see a single result for each album. When you want to collapse rows
  together like this, the ~group_by~ keyword is your friend. Here’s how
  you can do it:
  #+BEGIN_SRC elixir
    q = from t in "tracks", select: [t.album_id, sum(t.duration)], group_by: t.album_id
  #+END_SRC
  + The ~group_by~ value tells Ecto that even though we’re selecting
    across the tracks table, we only want one row for each album. In
    our select, we’re grabbing the ~album_id~ (which we have to have if
    we want to include it in our ~group_by~ ), and we use the ~sum~
    function from ~Ecto.Query.API~ to add all the ~duration~ values
    together. The result looks like this:
**** having
- Let’s say we wanted to refine this further and only return the
  albums whose total length is longer than one hour (3600 seconds). A
  ~where~ clause won’t help us here: that would only limit the records
  that get included in the duration counts. What we want is something
  like a ~where~ clause we can apply /after/ we’ve totaled up the track
  lengths. And that’s exactly what the /having/ clause is for.
  #+BEGIN_SRC elixir
        q =
          from(t in "tracks",
            select: [t.album_id, sum(t.duration)],
            group_by: t.album_id,
            having: sum(t.duration) > 3600
          )

        Repo.all(q)
  #+END_SRC
*** Working with Joins
- sample
  #+BEGIN_SRC elixir
        q =
          from(
            t in "tracks",
            join: a in "albums",
            on: t.album_id == a.id,
            where: t.duration > 900,
            join: ar in "artists",
            on: a.artist_id == ar.id,
            select: %{artist: ar.name, album: a.title, track: t.title}
          )

        Repo.all(q)
  #+END_SRC
*** Composing Queries
- we’ve always been using strings on the right side of the ~in~
  expression (for example, ~from a in "albums"~). That string has
  always represented the name of a table in our database. But the ~in~
  expression is actually looking for something broader than that:
  it’s looking for any data type that has implemented the
  ~Ecto.Queryable~ protocol
- The ~Ecto.Queryable~ protocol specifies only one function that needs
  to be implemented: ~to_query~. So you can think of Queryable as "a
  thing that can be queried."
- As we’ve seen, Ecto provides an implementation for the String type,
  which is what we’ve been using so far. But it also provides an
  implementation for the ~Ecto.Query~ struct.

- Sample
  #+BEGIN_SRC elixir
    albums_by_miles =
      from(al in "albums",
        join: ar in "artists",
        on: al.artist_id == ar.id,
        where: ar.name == "Miles Davis"
      )

    track_query =
      from([al, ar] in albums_by_miles,
        join: tr in "tracks",
        on: tr.album_id == al.id,
        select: tr.title
      )

    Repo.all(
      from [alb, _arti] in albums_by_miles, select: alb.title
    )
  #+END_SRC
  As you can see The query bindings are still available, but they must
  be referred to in the same order that they first appeared.

**** Working with Named Bindings
- Ecto allows you to assign specific names to bindings that it saves
  throughout the life of the query.

- To create a named binding, you use the ~as:~ keyword. You can add
  this to the ~from~ call, or to any of the ~join~ options.
  #+BEGIN_SRC elixir
    albums_by_miles =
      from a in "albums",
      as: :albums,
      join: ar in "artists",
      as: :artists,
      on: a.artist_id == ar.id,
      where: ar.name == "Miles Davis"
  #+END_SRC
  To use the named binding in another query, you add the name to the
  beginning of the ~from~ call:
  #+BEGIN_SRC elixir
  album_query = from [albums: a] in albums_by_miles, select: a.title
  #+END_SRC

  Order doesn't matter. Here we listed the artists binding first, even
  though it appears second in our original.
  #+BEGIN_SRC elixir
    album_query =
      from [artists: ar, albums: a] in albums_by_miles,
      select: [a.title, ar.name]
  #+END_SRC
- If you need to find out if a given query has a named binding, you
  can use the ~has_named_binding?~ function:
  #+BEGIN_SRC elixir
    albums_by_miles = from a in "albums", as: :albums,
      join: ar in "artists",
      as: :artists,
      on: a.artist_id == ar.id,
      where: ar.name == "Miles Davis"

    has_named_binding?(albums_by_miles, :albums)
    #=> true
  #+END_SRC

**** Combining Queries with ~or_where~
- By default, Ecto combines ~where~ clauses with ~AND~
  #+BEGIN_SRC elixir
    albums_by_miles =
      from(al in "albums",
        join: ar in "artists",
        on: ar.id == al.artist_id,
        where: ar.name == "Miles Davis"
      )

    q =
      from([al, ar] in albums_by_miles,
        where: ar.name == "Bobby Hutcherson",
        select: al.title
      )

    Repo.to_sql(:all, q)
    #=> {"SELECT a0.\"title\" FROM \"albums\" AS a0
    #=> INNER JOIN \"artists\" AS a1
    #=> ON a0.\"artist_id\" = a1.\"id\"
    #=> WHERE (a1.\"name\" = 'Miles Davis')
    #=> AND (a1.\"name\" = 'Bobby Hutcherson')", []}
  #+END_SRC
- ~or_where~
  #+BEGIN_SRC elixir
    q =
      from [a,ar] in albums_by_miles,
      or_where: ar.name == "Bobby Hutcherson",
      select: %{artist: ar.name, album: a.title}
  #+END_SRC
**** Other Ways to Use Queries
- sample
  #+BEGIN_SRC elixir
    q = from t in "tracks", where: t.title == "Autum Leaves"
    Repo.update_all(q, set: [title: "Autumn Leaves"])
  #+END_SRC
** Connecting Your Tables to Elixir Structs with Schemas
- sample
  #+BEGIN_SRC elixir
    defmodule MusicDB.Track do
      use Ecto.Schema
      alias MusicDB.Album

      schema "tracks" do
        field(:title, :string)
        field(:duration, :integer)
        field(:duration_string, :string, virtual: true)
        field(:index, :integer)
        field(:number_of_plays, :integer)
        timestamps()

        belongs_to(:album, Album)
      end
    end
  #+END_SRC
*** Data Types
- Ecto supports a number of different data types out of the box
  | Ecto Type             | Elixir Type   |
  |-----------------------+---------------|
  | :id                   | integer       |
  | :binary_id            | binary        |
  | :integer              | integer       |
  | :float                | float         |
  | :boolean              | boolean       |
  | :string UTF-8 encoded | string        |
  | :binary               | binary        |
  | {:array, inner_type}  | list          |
  | :map                  | map           |
  | {:map, inner_type}    | map           |
  | :decimal              | Decimal       |
  | :date                 | Date          |
  | :time                 | Time          |
  | :naive_datetime       | NaiveDateTime |
  | :utc_datetime         | DateTime      |

- The ~:naive_datetime~ type is a datetime value that has no associated
  time zone information. If you use ~utc_datetime~ the value must be a
  ~DateTime~ struct with its time zone set to UTC. Ecto will raise an
  error if you attempt to use a value with a different time zone.
- The ~time~, ~naive_datetime~, and ~utc_datetime~ types used to store
  microsecond information in the columns that use them, but this is
  no longer the case. If you do need microsecond precision, you should
  use one of the corresponding types: ~time_usec~, ~naive_datetime_usec~,
  or ~utc_datetime_usec~.

- The ~:map~ type allows you to store Elixir maps into the database. The
  storage strategy differs depending on the database. In MySQL, maps
  are stored as text fields, but Postgres has first-class support for
  maps via its jsonb type and these fields are actually queryable. As
  of this writing, the Ecto team strongly recommends that your maps
  use string keys, rather than atoms. In some cases, storing a map
  with atom keys will work correctly but when retrieving, Ecto will
  always return maps with string keys
