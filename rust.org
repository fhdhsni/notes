Notes from /The Rust Book/

* ownership
- Memory is managed through a system of ownership with a set of rules
  that the compiler checks at compile time. No run-time costs are
  incurred for any of the ownership features.
- Another property that makes the stack fast is that all data on the
  stack must take up a known, fixed size.

- Ownership
  1. Each value in Rust has a variable that’s called its owner.
  2. There can only be one owner at a time.
  3. When the owner goes out of scope, the value will be dropped.

- When a variable goes out of scope, Rust calls a special function for
  us. This function is called =drop=, and it’s where the author of String
  can put the code to return the memory. Rust calls =drop= automatically
  at the closing =}=

- Note: In C++, this pattern of deallocating resources at the end of
  an item’s lifetime is sometimes called Resource Acquisition Is
  Initialization (RAII). The drop function in Rust will be familiar to
  you if you’ve used RAII patterns.

- A String is made up of three parts, shown on the left: a pointer to
  the memory that holds the contents of the string, a length, and a
  capacity. This group of data is stored on the stack. The memory on
  the heap holds the contents. The length is how much memory, in bytes,
  the contents of the String is currently using. The capacity is the
  total amount of memory, in bytes, that the String has received from
  the operating system. The

  #+BEGIN_SRC rust
  let s1 = String::from("hello");
  let s2 = s1;
  #+END_SRC
  When we assign s1 to s2, the String data is copied, meaning we copy
  the pointer, the length, and the capacity that are on the stack. We do
  not copy the data on the heap that the pointer refers to.

  This is a problem: when s2 and s1 go out of scope, they will both try
  to free the same memory. This is known as a double free error and is
  one of the memory safety bugs we mentioned previously. Freeing memory
  twice can lead to memory corruption, which can potentially lead to
  security vulnerabilities.

- Ownership and Functions
  The semantics for passing a value to a function are similar to
  assigning a value to a variable. Passing a variable to a function will
  move or copy, just like assignment.

- A data race is a particular type of race condition in which these three behaviors occur:
    1. Two or more pointers access the same data at the same time.
    2. At least one of the pointers is being used to write to the data.
    3. There’s no mechanism being used to synchronize access to the data.

-  /dangling pointer/, a pointer that references a location in memory
  that may have been given to someone else, by freeing some memory
  while preserving a pointer to that memory.


-
  + At any given time, you can have /either/ but not both of:
    * One mutable reference.
    * Any number of immutable references.
  + References must always be valid.

*** slices
- String Literals Are Slices

#+BEGIN_SRC rust
let s = "Hello, world!";
#+END_SRC
The type of =s= here is =&str=: it’s a slice pointing to that specific
point of the binary. This is also why string literals are immutable;
=&str= is an immutable reference.

instead of
#+BEGIN_SRC rust
fn first_word(s: &String) -> &str {
#+END_SRC

A more experienced Rustacean would write the following line instead
because it allows us to use the same function on both Strings and
&strs:

#+BEGIN_SRC rust
fn first_word(s: &str) -> &str {
#+END_SRC

If we have a string slice, we can pass that directly. If we have a
String, we can pass a slice of the entire String. Defining a function
to take a string slice instead of a reference to a String makes our
API more general and useful without losing any functionality:

#+BEGIN_SRC rust
fn main() {
    let my_string = String::from("hello world");

    // first_word works on slices of `String`s
    let word = first_word(&my_string[..]);

    let my_string_literal = "hello world";

    // first_word works on slices of string literals
    let word = first_word(&my_string_literal[..]);

    // since string literals *are* string slices already,
    // this works too, without the slice syntax!
    let word = first_word(my_string_literal);
}

fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' && i != 0 {
            return &s[..i];
        }
    }

    &s[..]
}

#+END_SRC

* Struct
#+BEGIN_SRC rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!(
        "The area of the rectangle is {} square pixels.",
        area(&rect1)
    );
}

fn area(rectangle: &Rectangle) -> u32 {
    rectangle.width * rectangle.height
}
#+END_SRC

Our =area= function is defined with one parameter, which we’ve named
rectangle, whose type is an immutable borrow of a =struct Rectangle=
instance. We want to borrow the struct rather than take ownership of
it. This way, main retains its ownership and can continue using =rect1=,
which is the reason we use the =&= in the function signature and where
we call the function.

** Method Syntax
#+BEGIN_SRC rust

#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}
#+END_SRC

    Where’s the =->= Operator?

    In languages like C++, two different operators are used for
    calling methods: you use =.= if you’re calling a method on the
    object directly and =->= if you’re calling the method on a pointer
    to the object and need to dereference the pointer first. In other
    words, if object is a pointer, =object->something()= is similar to
    =(*object).something()=.

    Rust doesn’t have an equivalent to the =->= operator; instead, Rust
    has a feature called =automatic referencing and dereferencing=.
    Calling methods is one of the few places in Rust
    that has this behavior.

    Here’s how it works: when you call a method with
    =object.something()=, Rust automatically adds in =&=, =&mut=, or =*= so
    *object matches the signature of the method*. In other words, the
    following are the same:

    #+BEGIN_SRC rust
      p1.distance(&p2);
      (&p1).distance(&p2);
    #+END_SRC

    The first one looks much cleaner. This automatic referencing
    behavior works because methods have a clear receiver—the type of
    self. Given the receiver and name of a method, Rust can figure out
    definitively whether the method is reading (=&self=), mutating (=&mut self=),
    or consuming (=self=). The fact that Rust makes borrowing
    implicit for method receivers is a big part of making ownership
    ergonomic in practice.

**  Associated Functions


Another useful feature of =impl= blocks is that we’re allowed to define
functions within =impl= blocks that don’t take =self= as a
parameter. These are called associated functions because they’re
associated with the =struct=. They’re still functions, not methods,
because they don’t have an instance of the struct to work with. You’ve
already used the =String::from= associated function.

Associated functions are often used for constructors that will return
a new instance of the struct.

#+BEGIN_SRC rust
impl Rectangle {
    fn square(size: u32) -> Rectangle {
        Rectangle { width: size, height: size }
    }
}
let sq = Rectangle::square(3);
#+END_SRC

Methods let us specify the behavior that instances of our structs
have, and associated functions let us namespace functionality that is
particular to our struct without having an instance available.
