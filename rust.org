Notes from /The Rust Book/

* ownership
- Memory is managed through a system of ownership with a set of rules
  that the compiler checks at compile time. No run-time costs are
  incurred for any of the ownership features.
- Another property that makes the stack fast is that all data on the
  stack must take up a known, fixed size.

- Ownership
  1. Each value in Rust has a variable that’s called its owner.
  2. There can only be one owner at a time.
  3. When the owner goes out of scope, the value will be dropped.

- When a variable goes out of scope, Rust calls a special function for
  us. This function is called =drop=, and it’s where the author of String
  can put the code to return the memory. Rust calls =drop= automatically
  at the closing =}=

- Note: In C++, this pattern of deallocating resources at the end of
  an item’s lifetime is sometimes called Resource Acquisition Is
  Initialization (RAII). The drop function in Rust will be familiar to
  you if you’ve used RAII patterns.

- A String is made up of three parts, shown on the left: a pointer to
  the memory that holds the contents of the string, a length, and a
  capacity. This group of data is stored on the stack. The memory on
  the heap holds the contents. The length is how much memory, in bytes,
  the contents of the String is currently using. The capacity is the
  total amount of memory, in bytes, that the String has received from
  the operating system. The

  #+BEGIN_SRC rust
  let s1 = String::from("hello");
  let s2 = s1;
  #+END_SRC
  When we assign s1 to s2, the String data is copied, meaning we copy
  the pointer, the length, and the capacity that are on the stack. We do
  not copy the data on the heap that the pointer refers to.

  This is a problem: when s2 and s1 go out of scope, they will both try
  to free the same memory. This is known as a double free error and is
  one of the memory safety bugs we mentioned previously. Freeing memory
  twice can lead to memory corruption, which can potentially lead to
  security vulnerabilities.

- Ownership and Functions
  The semantics for passing a value to a function are similar to
  assigning a value to a variable. Passing a variable to a function will
  move or copy, just like assignment.

- A data race is a particular type of race condition in which these three behaviors occur:
    1. Two or more pointers access the same data at the same time.
    2. At least one of the pointers is being used to write to the data.
    3. There’s no mechanism being used to synchronize access to the data.

-  /dangling pointer/, a pointer that references a location in memory
  that may have been given to someone else, by freeing some memory
  while preserving a pointer to that memory.


-
  + At any given time, you can have /either/ but not both of:
    * One mutable reference.
    * Any number of immutable references.
  + References must always be valid.

*** slices
- String Literals Are Slices

#+BEGIN_SRC rust
let s = "Hello, world!";
#+END_SRC
The type of =s= here is =&str=: it’s a slice pointing to that specific
point of the binary. This is also why string literals are immutable;
=&str= is an immutable reference.

instead of
#+BEGIN_SRC rust
fn first_word(s: &String) -> &str {
#+END_SRC

A more experienced Rustacean would write the following line instead
because it allows us to use the same function on both Strings and
&strs:

#+BEGIN_SRC rust
fn first_word(s: &str) -> &str {
#+END_SRC

If we have a string slice, we can pass that directly. If we have a
String, we can pass a slice of the entire String. Defining a function
to take a string slice instead of a reference to a String makes our
API more general and useful without losing any functionality:

#+BEGIN_SRC rust
fn main() {
    let my_string = String::from("hello world");

    // first_word works on slices of `String`s
    let word = first_word(&my_string[..]);

    let my_string_literal = "hello world";

    // first_word works on slices of string literals
    let word = first_word(&my_string_literal[..]);

    // since string literals *are* string slices already,
    // this works too, without the slice syntax!
    let word = first_word(my_string_literal);
}

fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' && i != 0 {
            return &s[..i];
        }
    }

    &s[..]
}

#+END_SRC

* Struct
