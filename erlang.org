My Erlang notes, From [[https://learnyousomeerlang.com/][Learn You Some Erlang for Great Good]] book, official doc and my own clarifications.

* Miscellaneous
- to get the documentation on lists =erl -man lists=
- [[http://www.erlang.se/doc/programming_rules.shtml][Programming Rules and Conventions]]
- Erlang functions and expressions must always return something.
- command line
  #+BEGIN_SRC sh
   $ erlc road.erl
   $ erl -noshell -run road main road.txt  # `main` is the main function, road.txt is the passing arg, road is the name file/module
  #+END_SRC
* Basics
** Numbers
If you want to express integers in other bases than base 10, just
enter the number as Base#Value (given Base is in the range 2..36):
#+BEGIN_SRC erlang
> 2#101010.
42
#+END_SRC
** Atoms
An atom is referred to in an "atom table" which consumes memory (4
bytes/atom in a 32-bit system, 8 bytes/atom in a 64-bit system). The
atom table is not garbage collected, and so atoms will accumulate
until the system tips over, either from memory usage or because
1048577 atoms were declared.
#+BEGIN_SRC erlang
> atom = 'atom'.
atom
#+END_SRC
** Boolean Algebra & Comparison operators
the boolean operators =and= and =or= will always evaluate arguments on
both sides of the operator. If you want to have the short-circuit
operators (which will only evaluate the right-side argument if it
needs to), use =andalso= and =orelse=.

#+BEGIN_SRC
erl> 5 =:= 5.
true

erl> 1 =:= 0.
false

erl> 1 =/= 0.
true

erl> 5 =:= 5.0.
false

erl> 5 == 5.0.
true

erl> 5 /= 5.0.
false

erl> 1 >= 1.
true

erl> 1 =< 1.
true

erl> 0 == false.
false

erl> 1 < false.
true
#+END_SRC

Note: The correct ordering of each element in a comparison is the following:
=number < atom < reference < fun < port < pid < tuple < list < bit string=

Erlang has no such things as boolean true and false. The terms =true=
and =false= are atoms,
** Tuples
A tuple which contains an atom with one element following it is called
a 'tagged tuple'
** Lists
Strings are lists and the notation is the same!
#+BEGIN_SRC
erl> [97, 98, 99].
"abc"
#+END_SRC

Both =++= and =--= are right-associative. This means the elements of
many =--= or =++= operations will be done from right to left, as in the
following examples:
#+BEGIN_SRC
erl> [1,2,3] -- [1,2] -- [3].
[3]

erl> [1,2,3] -- [1,2] -- [2].
[2,3]
#+END_SRC
*** cons
These are all equivalent:
#+BEGIN_SRC
[a, b, c, d]
[a, b, c, d | []]
[a, b | [c, d]]
[a, b | [c | [d]]]
[a | [b | [c | [d]]]]
[a | [b | [c | [d | [] ]]]]
#+END_SRC
*** List Comprehensions
Set notation basically tells you how to build a set by specifying
properties its members must satisfy.

#+BEGIN_SRC
erl> [2*N || N <- [1,2,3,4]].
[2,4,6,8]

elr> [X*2 || X <- [1,2,3,4,5,6,7,8,9,10], X >= 4, X < 8].
[8,10,12,14]
#+END_SRC

#+BEGIN_SRC
NewList = [Expression || GeneratorExp1, GeneratorExp2, ..., GeneratorExpN, Condition1, Condition2, ... ConditionM]
#+END_SRC
** bit syntax
#+BEGIN_SRC  erlang
erl> Pixels = <<213,45,132,64,76,32,76,0,0,234,32,15>>. % declare 4 pixels of RGB colors in binary
<<213,45,132,64,76,32,76,0,0,234,32,15>>

erl> <<Pix1,Pix2,Pix3,Pix4>> = Pixels. %  we have more than 4 segments
  exception error: no match of right hand side value <<213,45,132,64,76,32,76, 0,0,234,32,15>>

erl> 19> <<Foo,_,_,_,_,_,_,_,_,_,_,_>> = Pixels.
<<213,45,132,64,76,32,76,0,0,234,32,15>>

erl> Foo.
213

% We tell Erlang that each variable on the left side will hold 24 bits of data. That's what Var:24 means
erl> <<Pix1:24, Pix2:24, Pix3:24, Pix4:24>> = Pixels.
<<213,45,132,64,76,32,76,0,0,234,32,15>>

erl> <<R:8, G:8, B:8>> = <<Pix1:24>>.
<<213,45,132>>

7> R.
213

8> <<R:8, Rest/binary>> = Pixels.
<<213,45,132,64,76,32,76,0,0,234,32,15>>

9> R.
213
#+END_SRC

 Erlang accepts more than one way to describe a binary segment. Those are all valid:

    Value
    Value:Size
    Value/TypeSpecifierList
    Value:Size/TypeSpecifierList

where /Size/ is going to represent bits or bytes (depending on /Type/ and
/Unit/ below), and /TypeSpecifierList/ represents one or more of the
following:

- *Type*
    + Possible values: =integer= | =float= | =binary= | =bytes= |
      =bitstring= | =bits= | =utf8= | =utf16= | =utf32=
    + This represents the kind of binary data used. Note that 'bytes'
      is shorthand for 'binary' and 'bits' is shorthand for
      'bitstring'. When no type is specified, Erlang assumes an
      'integer' type.

- *Signedness*
  + Possible values: =signed= | =unsigned=
  + Only matters for matching when the type is integer. The default is
  'unsigned'.

- *Endianness*
  + Possible values: =big= | =little= | =native=

  + Endianness only matters when the Type is either integer, utf16,
  utf32, or float. This has to do with how the system reads binary
  data. As an example, the BMP image header format holds the size of
  its file as an integer stored on 4 bytes. For a file that has a size
  of 72 bytes, a little-endian system would represent this as
  <<72,0,0,0>> and a big-endian one as <<0,0,0,72>>. One will be read
  as '72' while the other will be read as '1207959552', so make sure
  you use the right endianness. There is also the option to use
  'native', which will choose at run-time if the CPU uses
  little-endianness or big-endianness natively. By default, endianness
  is set to 'big'.

- *Unit*
    + written unit:Integer

    + This is the size of each segment, in bits. The allowed range is
      1..256 and is set by default to 1 for integers, floats and bit
      strings and to 8 for binary. The utf8, utf16 and utf32 types
      require no unit to be defined. The multiplication of Size by
      Unit is equal to the number of bits the segment will take and
      must be evenly divisible by 8. The unit size is usually used to
      ensure byte-alignment.

The /TypeSpecifierList/ is built by separating attributes by a '-'.

#+BEGIN_SRC
erl> <<X1/unsigned>> =  <<-44>>.
<<"Ô">>

erl> X1.
212

erl> <<X2/signed>> =  <<-44>>.
<<"Ô">>

erl> X2.
-44

erl> <<X2/integer-signed-little>> =  <<-44>>.
<<"Ô">>

erl> X2.
-44

erl> <<N:8/unit:1>> = <<72>>.
<<"H">>

erl> N.
72

erl> <<N/integer>> = <<72>>.
<<"H">>

erl> <<Y:4/little-unit:8>> = <<72,0,0,0>>.
<<72,0,0,0>>

erl> Y.
72
#+END_SRC



The standard binary operations (shifting bits to left and right,
binary 'and', 'or', 'xor', or 'not') also exist in Erlang. Just use
the functions =bsl= (Bit Shift Left), =bsr= (Bit Shift Right), =band=, =bor=,
=bxor=, and =bnot=.

#+BEGIN_SRC
2#00100 = 2#00010 bsl 1.
2#00001 = 2#00010 bsr 1.
2#10101 = 2#10001 bor 2#00101.
#+END_SRC

Example: parse TCP segments
#+BEGIN_SRC
<<SourcePort:16, DestinationPort:16,
AckNumber:32,
DataOffset:4, _Reserved:4, Flags:8, WindowSize:16,
CheckSum: 16, UrgentPointer:16,
Payload/binary>> = SomeBinary.
#+END_SRC

*** bit strings
#+BEGIN_SRC
<<"this is a bit string!">>
#+END_SRC

** Binary Comprehensions
#+BEGIN_SRC
erl> [ X || <<X>> <= <<1,2,3,4,5>>, X rem 2 == 0].
[2,4]

2> Pixels = <<213,45,132,64,76,32,76,0,0,234,32,15>>.
<<213,45,132,64,76,32,76,0,0,234,32,15>>

3> RGB = [ {R,G,B} || <<R:8,G:8,B:8>> <= Pixels ].
[{213,45,132},{64,76,32},{76,0,0},{234,32,15}]

erl> RGB.
[{213,45,132},{64,76,32},{76,0,0},{234,32,15}]

erl> << <<R:8, G:8, B:8>> ||  {R,G,B} <- RGB >>.
<<213,45,132,64,76,32,76,0,0,234,32,15>>

erl> << <<(X+1)/integer>> || <<X>> <= <<3,7,5,4,7>> >>.
<<4,8,6,5,8>>
#+END_SRC
* Modules
- All functions in Erlang must be defined in modules.
- module attributes are metadata describing the module itself. They can be found via =module_info/0=, like =mymod.module_info().=
- =-module(Name).=  This is always the first attribute (and statement) of
  a file, and for good reason: it's the name of the current module,
  where Name is an atom. This is the name you'll use to call
  functions from other modules. The calls are made with the =M:F(A)=
  form, where =M= is the module name, =F= the function, and A the
  arguments.
- =-export([Function1/Arity, Function2/Arity, ..., FunctionN/Arity]).=
- =-import(Module, [Function1/Arity, ..., FunctionN/Arity]).=
  Importing a function is not much more than a shortcut
- =-define(MACRO, some_value).=
  e.g =-define(foo, 88).= and to use it =?foo=
  e.g =-define(sub(X,Y), X-Y).= and to use it =?sub(23,47)=

* Compiling the code
  - =erlc flags file.erl= when in the command line
  - =compile:file(FileName)= when in the shell or in a module
  - =c()= when in the shell
*** flags
    - =-debug_info=
    - =-{outdir,Dir}=
    - =-export_all=: Will ignore the =-export= module attribute
   - =-{d,Macro}= or ={d,Macro,Value}= Defines a macro to be used in
     the module, where Macro is an atom. This is more frequently used
     when dealing when unit-testing, ensuring that a module will only
     have its testing functions created and exported when they are
     explicitly wanted. By default, Value is 'true' if it's not
     defined as the third element of the tuple.

e.g.
#+BEGIN_SRC
erl> compile:file(useless, [debug_info, export_all]).
{ok,useless}

erl> c(useless, [debug_info, export_all]).
{ok,useless}
#+END_SRC

Compiler flags can also be defined from within a module, with a module
attribute.
#+BEGIN_SRC erlang
-compile(export_all).
#+END_SRC

You could also use =c(Module,[native])=.
* Pattern Matching
Get the second element of a list
#+BEGIN_SRC erlang
second([_, X|_]) ->
    X.

same(X,X) ->
    true;
same(_,_) ->
    false.

foo({First = {X,Y,Z}, Second = {H, S, M}}) ->
    io:format("X:~p, Y: ~p, Z: ~p, H: ~p, S: ~p, M: ~p~n", [X,Y,Z, H, S, M]),
    io:format("First: ~p, second: ~p~n", [First, Second]).
#+END_SRC
* Guards, Guards!
#+BEGIN_SRC erlang
old_enough(X) when X >= 16 -> true;
old_enough(_) -> false.

right_age(X) when X >= 16, X =< 104 -> %% The comma (,) acts in a similar manner to the operator `andalso`
    true;
right_age(_) ->
    false.

wrong_age(X) when X < 16; X > 104 -> %% the semicolon (;) acts a bit like `orelse`
    true;
wrong_age(_) ->
    false.
#+END_SRC

Note: I've compared =,= and =;= in guards to the operators =andalso= and
=orelse=. They're not exactly the same, though. The former pair will
catch exceptions as they happen while the latter won't. What this
means is that if there is an error thrown in the first part of the
guard `X >= N; N >= 0`, the second part can still be evaluated and the
guard might succeed; if an error was thrown in the first part of `X >= N orelse N >= 0`,
the second part will also be skipped and the whole
guard will fail.

However, only =andalso= and =orelse= can be
nested inside guards. This means =(A orelse B) andalso C= is a valid
guard, while =(A; B), C= is not.



Note: type test BIFs constitute more than half of the functions
allowed in guard expressions. The rest are also BIFs, but do not
represent type tests. These are:

#+BEGIN_SRC erlang
 abs(Number), bit_size(Bitstring), byte_size(Bitstring), element(N, Tuple),
 float(Term), hd(List), length(List), node(),
 node(Pid|Ref|Port), round(Number), self(), size(Tuple|Bitstring),
 tl(List), trunc(Number), tuple_size(Tuple)
#+END_SRC

e.g
#+BEGIN_SRC erlang
zip(Xs, Ys) when length(Xs) == length(Ys) ->
    lists:reverse(zip(Xs, Ys, [])).

zip([], [], Result) ->
    Result;
zip([X|Xs], [Y|Ys], Result) ->
    zip(Xs, Ys, [{X, Y} | Result]).
#+END_SRC

* if
The =if= clauses are called Guard Patterns.

#+BEGIN_SRC erlang
  oh_god(N) ->
      if N =:= 2 -> might_succeed;
         true -> always_does  %% this is Erlang's if's 'else!', we can't omit this, or else we get an error
      end.

  help_me(Animal) ->
      Talk = if Animal == cat ->
                     "meow";
                Animal == beef ->
                     "moo";
                Animal == dog ->
                     "bark";
                true ->
                     "fdlkajfj"
             end,
      {Animal, "says " ++ Talk ++ "!"}.
#+END_SRC
* In Case ... of
a =case ... of= expression is like the whole function head: you can
have the complex pattern matching you can use with each argument, and
you can have guards on top of it!

#+BEGIN_SRC erlang
  insert(X, []) ->
      [X];
  insert(X, Set) ->
      case lists:member(X, Set) of
          true -> Set;
          false -> [X | Set]
      end.

  beach(Temperature) ->
      case Temperature of
          {celsius, N} when N >= 20, N =< 45 ->
              'favorable';
          {kelvin, N} when N >= 293, N =< 318 ->
              'scientifically favorable';
          {fahrenheit, N} when N >= 68, N =< 113 ->
              'favorable in the US';
          _ ->
              'avoid beach'
      end.
#+END_SRC

* Type conversions
Each of these functions take the form =<type>_to_<type>= and are
implemented in the =erlang= module.
#+BEGIN_SRC
1> erlang:list_to_integer("54").
54

2> erlang:integer_to_list(54).
"54"

3> erlang:list_to_integer("54.32").
   exception error: bad argument
in function  list_to_integer/1
called as list_to_integer("54.32")

4> erlang:list_to_float("54.32").
54.32

5> erlang:atom_to_list(true).
"true"

6> erlang:list_to_bitstring("hi there").
<<"hi there">>

7> erlang:bitstring_to_list(<<"hi there">>).
"hi there"
#+END_SRC

All of them:
#+BEGIN_SRC
atom_to_binary/2, atom_to_list/1, binary_to_atom/2,
binary_to_existing_atom/2, binary_to_list/1, bitstring_to_list/1,
binary_to_term/1, float_to_list/1, fun_to_list/1, integer_to_list/1,
integer_to_list/2, iolist_to_binary/1, iolist_to_atom/1,
list_to_atom/1, list_to_binary/1, list_to_bitstring/1,
list_to_existing_atom/1, list_to_float/1, list_to_integer/2,
list_to_pid/1, list_to_tuple/1, pid_to_list/1, port_to_list/1,
ref_to_list/1, term_to_binary/1, term_to_binary/2, tuple_to_list/1.
#+END_SRC
* To Guard a Data Type
type test BIFs:
#+BEGIN_SRC
is_atom/1           is_binary/1
is_bitstring/1      is_boolean/1        is_builtin/3
is_float/1          is_function/1       is_function/2
is_integer/1        is_list/1           is_number/1
is_pid/1            is_port/1           is_record/2
is_record/3         is_reference/1      is_tuple/1
#+END_SRC
* types
** =dialyzer=
** =typer=

* Recursion
#+BEGIN_SRC erlang
tail_fac(N) ->
    tail_fac(N, 1).

tail_fac(0, Acc) ->
    Acc;
tail_fac(N, Acc) when N > 0 ->
    tail_fac(N - 1, Acc * N).

zip([],_) -> [];
zip(_,[]) -> [];
zip([X|Xs],[Y|Ys]) -> [{X,Y}|zip(Xs,Ys)].


qSort([]) ->
    [];
qSort(L) when is_list(L) ->
    qSort(L, []).

qSort([], Acc) ->
    Acc;
qSort([Pivot|Rest], Acc) ->
    partition(Pivot, Rest, {[], [Pivot], []}, Acc).

partition(_Pivot, [], {Smaller, Equal, Bigger}, Acc) ->
    qSort(Smaller, Equal ++ qSort(Bigger, Acc));

partition(Pivot, [H | T], {Smaller, Equal, Bigger}, Acc) ->
    if H > Pivot -> partition(Pivot, T, {Smaller, Equal, [H | Bigger]}, Acc);
       H < Pivot -> partition(Pivot, T, {[H | Smaller], Equal, Bigger}, Acc);
       H =:= Pivot -> partition(Pivot, T, {Smaller, [H | Equal], Bigger}, Acc)
    end.
#+END_SRC

Note: tail recursion as seen here is not making the memory grow
because when the virtual machine sees a function calling itself in a
tail position (the last expression to be evaluated in a function), it
eliminates the current stack frame. This is called tail-call
optimisation (TCO) and it is a special case of a more general
optimisation named Last Call Optimisation (LCO).

LCO is done whenever the last expression to be evaluated in a function
body is another function call. When that happens, as with TCO, the
Erlang VM avoids storing the stack frame. As such tail recursion is
also possible between multiple functions. As an example, the chain of
functions =a() -> b(). b() -> c(). c() -> a().= will effectively create
an infinite loop that won't go out of memory as LCO avoids overflowing
the stack. This principle, combined with our use of accumulators is
what makes tail recursion useful.

* Higher Order Functions

#+BEGIN_SRC erlang
-module(hhfuns).
-compile(export_all).

one() ->
    1.
two() ->
    2.

add(X, Y) ->
    X() + Y().

%% to call it `hhfuns:add(fun hhfuns:one/0, fun hhfuns:two/0).`
#+END_SRC

* Anonymous functions
- syntax
    #+BEGIN_SRC erlang
fun(Args1) ->
        Expression1, Exp2, ..., ExpN;
   (Args2) ->
        Expression1, Exp2, ..., ExpN;
   (Args3) ->
        Expression1, Exp2, ..., ExpN
end
#+END_SRC
    e.g
    #+BEGIN_SRC erlang
fun(A,B) when A > B -> A; (_,B) -> B end
#+END_SRC
- You're most likely to use anonymous functions to carry state around
- define and call immediately
  #+BEGIN_SRC erlang
  (fun(X) -> io:format("It's ~p~n", [X]) end)(42).
  #+END_SRC
- name 'em
    the name is visible only within the function's scope
    #+BEGIN_SRC erlang
     fun Loop() ->
        io:format("I'm loop~n"),
        timer:sleep(500),
         Loop()  %% <------- calling itself
     end
    #+END_SRC
- look at =fold= beauty
  #+BEGIN_SRC erlang
    fold(_, Start, []) -> Start;
    fold(F, Start, [H|T]) -> fold(F, F(H,Start), T).


    reverse(L) ->
        fold(fun(X,Acc) -> [X|Acc] end, [], L).

    map(F,L) ->
        reverse(fold(fun(X,Acc) -> [F(X)|Acc] end, [], L)).

    filter(Pred, L) ->
        F = fun(X,Acc) ->
                    case Pred(X) of
                        true  -> [X|Acc];
                        false -> Acc
                    end
            end,
        reverse(fold(F, [], L)).
  #+END_SRC
* Errors
By default, Erlang's search path is set to be in the current
directory. You can add paths by using =code:add_patha/1= or
=code:add_pathz/1=.

Calling =erlang:error(Reason)= will end the execution in the current process.
#+BEGIN_SRC
1> erlang:error(badarith).
 exception error: bad argument in an arithmetic expression

2> erlang:error(custom_error).
 exception error: custom_error
#+END_SRC
* Exits
- There are two kinds of exits: 'internal' exits and 'external' exits.
- Internal exits are triggered by calling the function =exit/1= and
  make the current process stop its execution.
- External exits are called with =exit/2=
- =erlang:error/1= returns a stack trace and =exit/1= doesn't
* Throws
A throw is a class of exceptions used for cases that the programmer
can be expected to handle.

In comparison with exits and errors, they don't really carry any
'crash that process!' intent behind them, but rather control flow.

#+BEGIN_SRC
1> throw(permission_denied).
 exception throw: permission_denied
#+END_SRC

Usecase: An example could be the array module, where there is a
lookup function that can return a user-supplied default value if it
can't find the element needed. When the element can't be found, the
value default is thrown as an exception, and the top-level function
handles that and substitutes it with the user-supplied default
value. This keeps the programmer of the module from needing to pass
the default value as a parameter of every function of the lookup
algorithm, again focusing only on the successful cases.

e.g
#+BEGIN_SRC erlang
  %% looks for a given value 'Val' in the tree.
  has_value(_, {node, 'nil'}) ->
      false;
  has_value(Val, {node, {_, Val, _, _}}) ->
      true;
  has_value(Val, {node, {_, _, Left, Right}}) ->
      case has_value(Val, Left) of
          true -> true;
          false -> has_value(Val, Right)
      end.

  %% -------------------- using throw --------------------
  has_value(Val, Tree) ->
      try has_value1(Val, Tree) of
          false -> false
      catch
          true -> true
      end.

  has_value1(_, {node, 'nil'}) ->
      false;
  has_value1(Val, {node, {_, Val, _, _}}) ->
      throw(true);
  has_value1(Val, {node, {_, _, Left, Right}}) ->
      has_value1(Val, Left),
      has_value1(Val, Right).
#+END_SRC

* Dealing with Exceptions
- The Expression in between try and of is said to be protected.
- Note: It is important to know that the protected part of an
  exception can't be tail recursive. The VM must always keep a
  reference there in case there's an exception popping up.
- Because the =try ... catch= construct without the =of= part has nothing
  but a protected part, calling a recursive function from there might
  be dangerous for programs supposed to run for a long time (which is
  Erlang's niche). After enough iterations, you'll go out of memory or
  your program will get slower without really knowing why. By putting
  your recursive calls between the =of= and =catch=, you are not in a
  protected part and you will benefit from Last Call Optimisation.

You can replace =TypeOfError= by either =error=, =throw= or =exit=.
#+BEGIN_SRC erlang
  try Expression of
      SuccessfulPattern1 [Guards] ->
          Expression1;
      SuccessfulPattern2 [Guards] ->
          Expression2
  catch
      TypeOfError:ExceptionPattern1 ->
          Expression3;
      TypeOfError:ExceptionPattern2 ->
          Expression4
  end.
#+END_SRC
#+BEGIN_SRC erlang
-module(errors).
-compile(export_all).

%% foo() -> exit(foobar).
foo() -> erlang:error(badarith).

bar() ->
    try foo() of
        _ -> io:format("all good")
    catch
        error:badarith -> io:format("you DON'T know math.~n");
        error:Shit -> io:format("error -> ~p~n", [Shit]);
        throw:Shit -> io:format("throw -> ~p~n", [Shit]);
        exit:Shit -> io:format("exit -> ~p~n", [Shit])
    end.
#+END_SRC

- it's possible to have more than one expression between the =try= and the =of=
    #+BEGIN_SRC erlang
      whoa() ->
          try
              talk(),
              _Knight = "None shall Pass!",
              _Doubles = [N*2 || N <- lists:seq(1,100)],
              throw(up),
              _WillReturnThis = tequila
          of
              tequila -> "hey this worked!"
          catch
              Exception:Reason -> {caught, Exception, Reason}
          end.
    #+END_SRC
- it's possible to omit =of= part
    #+BEGIN_SRC erlang
      im_impressed() ->
          try
              talk(),
              _Knight = "None shall Pass!",
              _Doubles = [N*2 || N <- lists:seq(1,100)],
              throw(up),
              _WillReturnThis = tequila
          catch
              Exception:Reason -> {caught, Exception, Reason}
          end.
    #+END_SRC

** after
#+BEGIN_SRC erlang
  try Expr of
      Pattern -> Expr1
  catch
      Type:Exception -> Expr2
  after % this always gets executed
      Expr3
  end
#+END_SRC
 You can NOT get any return value out of the =after=
 construct. Therefore, =after= is mostly used to run code with side
 effects. The canonical use of this is when you want to make sure a
 file you were reading gets closed whether exceptions are raised or
 not.
** catch
#+BEGIN_SRC
erl> catch throw(whoa).
whoa

erl> catch exit(die).
{'EXIT',die}

erl> catch 1/0.
{'EXIT',{badarith,[{erlang,'/',[1,0]},
                   {erl_eval,do_apply,5},
                   {erl_eval,expr,5},
                   {shell,exprs,6},
                   {shell,eval_exprs,6},
                   {shell,eval_loop,3}]}}

erl> catch 2+2.
4
#+END_SRC

#+BEGIN_SRC erlang
  catcher(X,Y) ->
      case catch X/Y of
          {'EXIT', {badarith,_}} -> "uh oh";
          N -> N
      end.
#+END_SRC
* Records
Records are, first of all, a hack. Erlang records are just syntactic
sugar on top of tuples.

#+BEGIN_SRC erlang
  -module(records).
  -compile(export_all).

  -record(robot, {name,
                  type=industrial,
                  hobbies,
                  details=[]}).

  first_robot() ->
      #robot{name="Mechatron",
             type=handmade,
            details=["Moved by a small man inside"]}. %% hobbies will be undefined
#+END_SRC
#+BEGIN_SRC
1> c(records).
{ok,records}

2> records:first_robot().
{robot,"Mechatron",handmade,undefined,
["Moved by a small man inside"]}

3> rr(records).
[robot]

4> records:first_robot().
#robot{name = "Mechatron",type = handmade,
hobbies = undefined,
details = ["Moved by a small man inside"]}

5> Crusher = #robot{name="Crusher", hobbies=["Crushing people","petting cats"]}.
#robot{name = "Crusher",type = industrial,
hobbies = ["Crushing people","petting cats"],
details = []}

6> Crusher#robot.hobbies.
["Crushing people","petting cats"]


erl> Fuck = #robot{details=#robot{type="shitty"}}.
#robot{name = undefined,type = industrial,
       hobbies = undefined,
       details = #robot{name = undefined,type = "shitty",
                        hobbies = undefined,details = []}}

erl> Fuck#robot.details#robot.type.
"shitty"

erl> #robot.type. %% What this outputs is which element of the underlying tuple it is.
3
#+END_SRC

- Pattern Matching
  #+BEGIN_SRC erlang
    -record(user, {id, name, group, age}).

    admin_panel(#user{name=Name, group=admin}) ->
        Name ++ " is allowed!";
    admin_panel(#user{name=Name}) ->
        Name ++ " is not allowed".

    adult_section(U = #user{}) when U#user.age >= 18 ->
        allowed;

    adult_section(_) ->
        forbidden.
  #+END_SRC
- Update a record
  #+BEGIN_SRC
    erl> Me = #user{age=26}.
    #user{id = undefined,name = undefined,group = undefined, age = 26}
                                                                age = 27}
    erl> MeOlder = #user{age=Me#user.age + 1}.
    #user{id = undefined,name = undefined,group = undefined, age = 27}

    erl> MeOlder#user.age.
    27
  #+END_SRC

- share records across modules with the help of header files.
  Erlang header files are pretty similar to their C counter-part:
  they're nothing but a snippet of code that gets added to the module
  as if it were written there in the first place.
  #+BEGIN_SRC erlang
    %% this is a .hrl (header) file.
    -record(included, {some_field,
                       some_default = "yeah!",
                       unimaginative_name}).
  #+END_SRC
  To include it in a module, just add the following line to the module:
  #+BEGIN_SRC erlang
    -include("records.hrl").

    %% use it as usual
    included() -> #included{some_field="Some value"}.
  #+END_SRC

* Data Structures
** proplist
A proplist is any list of tuples of the form =[{Key,Value}]=.
To work with proplists, you can use the =proplists= module.

** orddict
If you do want a more complete key-value store for small amounts of
data, the =orddict= module is what you need. Orddicts (ordered
dictionaries) are proplists with a taste for formality. Each key can
be there once, the whole list is sorted for faster average lookup,
etc.

Orddicts are a generally good compromise between complexity and
efficiency up to about 75 elements. After that amount, you should
switch to different key-value stores.

** =dicts=, =gb_trees= and =maps=
These are basically key-value structures/modules to deal with
larger amounts of data.

** =arrays=
Erlang arrays, at the opposite of their imperative counterparts, are
not able to have such things as constant-time insertion or
lookup. Because they're usually slower than those in languages which
support destructive assignment and that the style of programming done
with Erlang doesn't necessary lend itself too well to arrays and
matrices, they are rarely used in practice.  Generally, Erlang
programmers who need to do matrix manipulations and other uses
requiring arrays tend to use concepts called Ports to let other
languages do the heavy lifting, or C-Nodes, Linked in drivers and NIFs
(Experimental, R13B03+).

** Sets
There are 4 main modules to deal with sets in Erlang. This is a bit
weird at first, but it makes more sense once you realize that it's
because it was agreed by implementers that there was no 'best' way to
build a set. The four modules are =ordsets=, =sets=, =gb_sets= and =sofs=
(sets of sets):

- =ordsets=: Ordsets are implemented as a sorted list. They're mainly
  useful for small sets, are the slowest kind of set, but they have
  the simplest and most readable representation of all sets. There are
  standard functions for them such as =ordsets:new/0=,
  =ordsets:is_element/2=, =ordsets:add_element/2=, =ordsets:del_element/2=,
  =ordsets:union/1=, =ordsets:intersection/1=, and a bunch more.

- =sets=: Sets (the module) is implemented on top of a structure really
  similar to the one used in dict. They implement the same interface
  as ordsets, but they're going to scale much better. Like
  dictionaries, they're especially good for read-intensive
  manipulations, like checking whether some element is part of the set
  or not.

- =gb_sets=: =Gb_sets= themselves are constructed above a General
  Balanced Tree structure similar to the one used in the =gb_trees=
  module. =gb_sets= are to =sets= what =gb_tree= is to =dict=; an
  implementation that is faster when considering operations different
  than reading, leaving you with more control. While =gb_sets= implement
  the same interface as =sets= and =ordsets=, they also add more
  functions. Like =gb_trees=, you have smart vs. naive functions,
  iterators, quick access to the smallest and largest values, etc.

- =sofs= Sets of sets (sofs) are implemented with sorted lists, stuck
  inside a tuple with some metadata. They're the module to use if you
  want to have full control over relationships between sets, families,
  enforce set types, etc. They're really what you want if you need
  mathematics concept rather than 'just' groups of unique elements.

  :NOTE:
  Björn Gustavsson, from the Erlang/OTP team and programmer of Wings3D
  mainly suggests using gb_sets in most circumstances, using ordset when
  you need a clear representation that you want to process with your own
  code and 'sets' when you need the \=:= operator (source.)
  :END:

** directed graphs (=digraph= and =digraph_utils=)

*** =digraph=
basically allows the construction and modification of a directed
graph: manipulating edges and vertices, finding paths and cycles

*** =digraph_utils=
allows you to navigate a graph (postorder, preorder), testing for
 cycles, arborescences or trees, finding neighbors, and so on.

** Queues
* concurrency
- the main sources of downtime in large scale software systems are
  intermittent or transient bugs. [[http://dslab.epfl.ch/pubs/crashonly.pdf][Source]]
- Erlang's processes take about 300 words of memory each (in a 32-bit
  processor 4 byte and 8 byte in a 64-bit implementation. [[http://erlang.org/doc/efficiency_guide/advanced.html#id2265856][Memory]]) and
  can be created in a matter of microseconds.
- The VM starts one thread per core which acts as a scheduler. Each of
  these schedulers has a run queue, or a list of Erlang processes on
  which to spend a slice of time. When one of the schedulers has too
  many tasks in its run queue, some are migrated to another one. This
  is to say each Erlang VM takes care of doing all the load-balancing.
- About linear scaling:
  Amdahl's Law: It indicates how much of a speedup you can expect your
  system to have whenever you add parallelism to it, and in what
  proportion. According to Amdahl's law, code that is 50% parallel can
  never get faster than twice what it was before, and code that is 95%
  parallel can theoretically be expected to be about 20 times faster
  if you add enough processors.
- disabling symmetric multiprocessing =$ erl -smp disable= or =erl +S 1=
  in erl =[smp:2:2]= means there are two cores available, with two schedulers.

** =spawn=
#+BEGIN_SRC erlang
Pid_1 = spawn(fun() -> ... end)
Pid_2 = spawn(module, fun, [args])
#+END_SRC

** =!=
#+BEGIN_SRC
9> self() ! hello.
hello

10> self() ! self() ! double.
double
#+END_SRC
** =receive=
#+BEGIN_SRC erlang
receive
  Pattern1 when Guard1 -> Expr1;
  Pattern2 when Guard2 -> Expr2;
  Pattern3 -> Expr3
  after Delay -> Expression2
end
#+END_SRC
** =after=
two interesting use-case
#+BEGIN_SRC erlang
  sleep(T) ->
      receive
      after T -> ok
      end.

  flush() ->
      receive
          _ -> flush()
      after 0 ->
              ok
      end.
#+END_SRC
** Selective Receives
#+BEGIN_SRC erlang
  important() ->
      receive
          {Priority, Message} when Priority > 10 ->
              [Message | important()]
      after 0 ->                                  % every message will be obtained until none is left
              normal()
      end.

  normal() ->
      receive
          {_, Message} ->
              [Message | normal()]
      after 0 ->                                  % every message will be obtained until none is left
              []
      end.
#+END_SRC
- be aware that is is sometimes unsafe due to the way selective
  receives work in Erlang.
- When messages are sent to a process, they're stored in the mailbox
  until the process reads them and they match a pattern there. As said
  in the previous chapter, the messages are stored in the order they
  were received. This means every time you match a message, it begins
  by the oldest one.

- That oldest message is then tried against every pattern of the
  receive until one of them matches. When it does, the message is
  removed from the mailbox and the code for the process executes
  normally until the next receive. When this next receive is
  evaluated, the VM will look for the oldest message currently in the
  mailbox (the one after the one we removed), and so on.

- When there is no way to match a given message, it is put in a save
  queue and the next message is tried. If the second message matches,
  the first message is put back on top of the mailbox to be retried
  later.
- This lets you only care about the messages that are useful. Ignoring
  some messages to handle them later. While they're useful, the
  problem with them is that if your process has a lot of messages you
  never care about, reading useful messages will actually take longer
  and longer (and the processes will grow in size too).

- =make_ref=
  #+BEGIN_SRC erlang
  optimized(Pid) ->
    Ref = make_ref(),
    Pid ! {self(), Ref, hello},
    receive
        {Pid, Ref, Msg} ->
            io:format("~p~n", [Msg])
    end.
  #+END_SRC
  Since R14A, a new optimization has been added to Erlang's
  compiler. It simplifies selective receives in very specific cases of
  back-and-forth communications between processes. To make it work, a
  reference (=make_ref()=) has to be created in a function and then sent
  in a message. In the same function, a selective receive is then
  made. If no message can match unless it contains the same reference,
  the compiler automatically makes sure the VM will skip messages
  received before the creation of that reference.
* Links
- A link is a specific kind of relationship that can be created
  between two processes. When that relationship is set up and one of
  the processes dies from an unexpected =throw=, =error= or =exit=,
  the other linked process also dies.

- This function will take an integer N, start N processes linked one
  to the other.
  #+BEGIN_SRC erlang
    chain(0) ->
        receive
            _ -> ok
        after 2000 ->
                exit("chain dies here")
        end;
    chain(N) ->
        Pid = spawn(fun() -> chain(N-1) end),
        link(Pid),
        receive
            _ -> ok
        end.
  #+END_SRC

- links are bidirectional
- To get rid of a =link=, use [[erldocs.com/18.0/erts/erlang.html#unlink/1][unlink/1]]
- Links can not be stacked. If you call =link/1= 15 times for the
  same two processes, only one link will still exist between them and
  a single call to =unlink/1= will be enough to tear it down.
- unlike =link(spawn(Function))= or =link(spawn(M,F,A))=,
  =spawn_link/1-3= is atomic.

* System processes
- System processes are basically normal processes, except they can
  convert exit signals to regular messages. This is done by calling
  =process_flag(trap_exit, true)= in a running process.
  #+BEGIN_SRC erlang
    erl> spawn_link(fun() -> exit("I'm dying already.") end).
     exception exit: "I'm dying already."

    erl> process_flag(trap_exit, true).
    false

    erl> spawn_link(fun() -> exit("I'm dying already.") end).
    <0.90.0>

    erl> flush().
    Shell got {'EXIT',<0.90.0>,"I'm dying already."}
    ok
  #+END_SRC
- By writing programs using system processes, it is easy to create a
  process whose only role is to check if something dies and then
  restart it whenever it fails.
- =exit/2=
* Monitors
- Monitors are a special type of link with two differences:
  1. they are unidirectional.
  2. they can be stacked.

- Monitors are what you want when a process wants to know what's going
  on with a second process, but neither of them really are vital to
  each other.

- =erlang:monitor/2=
  #+BEGIN_SRC erlang
    erl> Pid = spawn(fun() -> timer:sleep(5000) end).
    <0.90.0>

    erl>  erlang:monitor(process, Pid).
    #Ref<0.2327554241.1187774465.188331>

    erl>  erlang:monitor(process, Pid).
    #Ref<0.2327554241.1187774465.188336>

    erl> flush().
    Shell got {'DOWN',#Ref<0.2327554241.1187774465.188331>,process,<0.90.0>,
                      normal}
    Shell got {'DOWN',#Ref<0.2327554241.1187774465.188336>,process,<0.90.0>,
                      normal}
    ok
  #+END_SRC
- Every time a process you monitor goes down, you will receive such a
  message. The message is ={'DOWN', MonitorReference, process, Pid, Reason}=
- The /reference/ is there to allow you to demonitor the
  process. Remember, monitors are stackable, so it's possible to take
  more than one down. References allow you to track each of them in a
  unique manner.
- There is an atomic function to spawn a process while monitoring it,
  =spawn_monitor/1-3=

- =demonitor/1=
  #+BEGIN_SRC erlang
    erl> {Pid, Ref} = spawn_monitor(fun() -> receive _ -> exit(boom) end end).
    {<0.73.0>,#Ref<0.0.0.100>}

    erl> erlang:demonitor(Ref).
    true

    erl> Pid ! die.
    die

    erl> flush().
    ok
  #+END_SRC

* Naming Processes
- To give a process a name, the function =erlang:register/2= is used.
- If the process dies, it will automatically lose its name or you can
  also use =unregister/1= to do it manually.
- You can get a list of all registered processes with =registered/0= or
  a more detailed one with the shell command =regs()=.
- =whereis(foo)= is used to find the foo's process identifier
  #+BEGIN_SRC erlang
    -module(linkmon).
    -compile(export_all).

    start_critic() ->
        spawn(?MODULE, restarter, []).

    restarter() ->
        process_flag(trap_exit, true),
        Pid = spawn_link(?MODULE, critic, []),
        register(critic, Pid),
        receive
            {'EXIT', Pid, normal} ->
                ok;
            {'EXIT', Pid, _} ->
                restarter()
        end.


    judge(Band, Album) ->
        Ref = make_ref(),
        critic ! {self(), Ref, {Band, Album}},
        receive
            {Ref, Criticism} ->
                Criticism
        after 2000 ->
                timeout
        end.

    critic() ->
        receive
            {From, Ref, {"Johnny Crash", "The Token Ring of Fire"}} ->
                From ! {Ref, "Simply incredible."};
            {From, Ref, {_Band, _Album}} ->
                From ! {Ref, "They are terrible!"}
        end,
        critic().
  #+END_SRC
  #+BEGIN_SRC erlang
    erl> linkmon:start_critic().
    <0.85.0>

    erl> linkmon:judge("foo", "bar").
    "They are terrible!"

    erl> linkmon:judge("Johnny Crash", "The Token Ring of Fire").
    "Simply incredible."
  #+END_SRC

- You shouldn't ever create dynamic atoms. atoms can be used in a
  limited (though high) number.
* Designing a Concurrent Application
- If we monitor a process that doesn't exist (we won't notice that by
  just monitoring), then we send it a message we'll receive a message,
  something like
  ={'DOWN',#Ref<0.2588815752.2474377217.6021>,process,<0.134.9>,noproc}=.
  That's the reason for the second clause of the following receive. In
  case the process associated with Pid doesn't exist we get there.
  #+BEGIN_SRC erlang
    cancel(Pid) ->
        %% Monitor in case the process is already dead
        Ref = erlang:monitor(process, Pid),
        Pid ! {self(), Ref, cancel},
        receive
            {Ref, ok} ->
                erlang:demonitor(Ref, [flush]),
                ok;
            {'DOWN', Ref, process, Pid, _Reason} ->
                ok
        end.
  #+END_SRC

- Most messages will be wrapped under the form ={Pid, Ref, Message}=,
  where =Pid= is the sender and =Ref= is a unique message identifier to
  help know what reply came from who. If we were to send many messages
  before looking for replies, we would not know what reply went with
  what message without a reference.
* Hot Code Loving
- In order to do hot code loading, Erlang has a thing called the *code server*.
  The code server is basically a VM process in charge of an
  ETS table (in-memory database table, native to the VM.) The code
  server can hold two versions of a single module in memory, and both
  versions can run at once. A new version of a module is automatically
  loaded when compiling it with =c(Module)=, loading with =l(Module)= or
  loading it with one of the many functions of the [[http://erldocs.com/18.0/kernel/code.html][code module]].
- local calls: function calls you can make with functions that might
  not be exported. They're just of the format =Atom(Args)=.
- external call: can only be done with exported functions and has the
  form =Module:Function(Args)=

- When there are two versions of a module loaded in the VM, all local
  calls are done through the currently running version in a
  process. However, external calls are always done on the newest
  version of the code available in the code server. Then, if local
  calls are made from within the external one, they are in the new
  version of the code.
  #+BEGIN_SRC erlang
    -module(hotload).
    -export([server/1, upgrade/1]).

    server(State) ->
        receive
            update ->
                NewState = ?MODULE:upgrade(State),
                ?MODULE:server(NewState);  %% loop in the new version of the module
            SomeMessage ->
                %% do something here
                server(State)  %% stay in the same version no matter what.
        end.

    upgrade(OldState) ->
        %% transform and return the state here.
  #+END_SRC
* Namespaces
- Erlang has a flat module structure
- You can test for any clashes with the function =code:clash/0=.
* OTP
  a naive demonstration of core OTP

  kitty_server
  #+BEGIN_SRC erlang
    -module(kitty_server).
    -compile(export_all).
    -record(cat, {name,color=green, description}).

    %% ################################################################
    %% CLIENT API
    start_link() ->
        my_server:start_link(?MODULE, []).

    %% Synchronous call
    order_cat(Pid, Name, Color, Description) ->
        my_server:call(Pid, {order, Name, Color, Description}).

    %% Synchronous call
    close_shop(Pid) ->
        my_server:call(Pid, terminate).

    %% Asynchronous
    return_cat(Pid, Cat = #cat{}) ->
        my_server:cast(Pid, {return, Cat}).

    %% ################################################################
    %% called by server

    init(InitialState) ->
        InitialState.

    handle_call({order, Name, Color, Description}, From, []) ->
        my_server:reply(From, make_cat(Name, Color, Description)),
        [];

    handle_call({order, _Name, _Color, _Description}, From, Cats) ->
        my_server:reply(From, {hd(Cats)}),
        tl(Cats);

    handle_call(terminate, From, Cats) ->
        my_server:reply(From, ok),
        terminate(Cats).

    handle_cast({return, Cat}, Cats) ->
        [Cat | Cats].

    %% ################################################################
    %% private helpers
    make_cat(Name, Col, Desc) ->
        #cat{name=Name, color=Col, description=Desc}.

    terminate(Cats) ->
        [io:format("~p was set free.~n", [C#cat.name]) || C <- Cats],
        exit(normal).
  #+END_SRC

  my_server
  #+BEGIN_SRC erlang
    -module(my_server).
    -compile(export_all).

    %% Public API
    start(Module, InitialState) ->
        spawn(fun() -> init(Module, InitialState) end).

    start_link(Module, InitialState) ->
        spawn_link(fun() -> init(Module, InitialState) end).

    call(LoopPid, Msg) ->
        Ref = erlang:monitor(process, LoopPid),
        LoopPid ! {sync, self(), Ref, Msg},
        receive
            {Ref, Reply} ->
                erlang:demonitor(Ref, [flush]),
                Reply;
            {'DOWN', Ref, process, LoopPid, Reason} ->
                erlang:error(Reason)
        after 5000 ->
                erlang:error(timeout)
        end.

    cast(LoopPid, Msg) ->
        LoopPid ! {async, Msg},
        ok.

    reply({ClientPid, Ref}, Reply) ->
        ClientPid ! {Ref, Reply}.

    %% Private
    loop(Module, State) ->
        receive
            {async, Msg} ->
                loop(Module, Module:handle_cast(Msg, State));
            {sync, ClientPid, Ref, Msg} ->
                loop(Module, Module:handle_call(Msg, {ClientPid, Ref}, State))
        end.

    init(Module, InitialState) ->
        loop(Module, Module:init(InitialState)).
  #+END_SRC

  1. To fire up the server: We call kitty's =start_link=
     =kitty_server:start_link= -> =my_server:start_link= -> =my_server:init= -> =kitty_server:init=
     and we get the Pid of our server(that is the Pid of the loop in my_server).
  2. Let's order a cat by calling =order_cat=
     =kitty_server:order_cat= ->
     =my_server:call=, (sends a messeage the the loop and waits for a message) ~>
     =my_server:loop= ->
     =kitty_server:handle_call=, (sends a message to =my_server:call= which is waiting) ~>
     =my_server:call=

* =gen_server=
| gen_server     | YourModule    |
|----------------+---------------|
| start/3-4      | init/1        |
| start_link/3-4 | init/1        |
| call/2-3       | handle_call/3 |
| cast/2         | handle_cast/2 |

And then you have the other callbacks, those that are more about
special cases:
 + =handle_info/2=
 + =terminate/2=
 + =code_change/3=

** =init/1=
- used to initialize the server's state and do all of these one-time
  tasks that it will depend on
- The function can return:
  ={ok, State}=, ={ok, State, TimeOut}=, ={ok, State, hibernate}=, ={stop, Reason}= or =ignore=.
- =TimeOut=: a deadline before which you expect the server to receive
  a message. If no message is received before the deadline, the atom
  =timeout= is sent to the server, which should be handled with
  =handle_info/2=
- =hibernate=:
- On the other hand, if you do expect the process to take a long time
  before getting a reply and are worried about memory, you can add the
  =hibernate= atom to the tuple. Hibernation basically reduces the size
  of the process' state until it gets a message, at the cost of some
  processing power. If you are in doubt about using hibernation, you
  probably don't need it. Search for =erlang:hibernate=
- ={stop, Reduces}=, should be done when something went wrong during
  the initialization.

- While =init/1= is running, execution is blocked in the process that
  spawned the server. This is because it is waiting for a '=ready='
  message sent automatically by the =gen_server= module to make sure
  everything went fine.
** =handle_call/3=
- is used to work with synchronous messages
- There are 8 different return values possible, taking the form of
  tuples:
  1. ={reply, Reply, NewState}=
  2. ={reply, Reply, NewState, Timeout}=
  3. ={reply, Reply, NewState, hibernate}=

  4. ={noreply, NewState}=
  5. ={noreply, NewState, Timeout}=
  6. ={noreply, NewState, hibernate}=

  7. ={stop, Reason, Reply, NewState}=
  8. ={stop, Reason, NewState}=

- When you use =noreply=, the generic part of the server will assume
  you're taking care of sending the reply back yourself. This can be
  done with =gen_server:reply/2=
** =handle_cast/2=
- is used to handle asynchronous calls
- return values
  1. ={noreply, NewState}=
  2. ={noreply, NewState, Timeout}=
  3. ={noreply, NewState, hibernate}=
  4. ={stop, Reason, NewState}=

** =handle_info/2=
- it returns the same tuples as =handle_cast=
- But the difference is that this callback is only there for messages that
  were sent directly with the =!= operator and special ones like
  i=nit/1='s =timeout=, monitors' notifications and '=EXIT=' signals.
** =terminate/2=
- is called whenever one of the three =handle_Something= functions
  returns a tuple of the form ={stop, Reason, NewState}= or ={stop, Reason, Reply, NewState}=.
  It takes two parameters, =Reason= and =State=,
- will also be called when its parent (the process that spawned it)
  dies, if and only if the =gen_server= is trapping exits
- return value of this function doesn't really matter

** =code_change/3=
- is there to let you upgrade code
- takes the form =code_change(PreviousVersion, State, Extra)=
- the variable =PreviousVersion= is either the version term itself in
  the case of an upgrade (=myModule:module_info=), or ={down,
  Version}= in the case of a downgrade (just reloading older
  code). The =State= variable holds all of the current's server state so
  you can convert it.

* behaviour
- A behaviour is basically a way for a module to specify functions it
  expects another module to have. The behaviour is the contract
  sealing the deal between the well-behaved generic part of the code
  and the specific, error-prone part of the code
- For defining your own behaviours you need to export a function
  called =behaviour_info/1= implemented as follows:
  #+BEGIN_SRC erlang
    -module(my_behaviour).
    -export([behaviour_info/1]).

    %% init/1, some_fun/0 and other/3 are now expected callbacks
    behaviour_info(callbacks) -> [{init,1}, {some_fun, 0}, {other, 3}];
    behaviour_info(_) -> undefined.
  #+END_SRC
  use it like =-behaviour(my_behaviour)=.

* Generic Finite-State Machines, =gen_fsm=
- Somewhat similar to =gen_server= in that it is a specialised version
  of it. The biggest difference is that rather than handling calls and
  casts, we're handling synchronous and asynchronous events.

|-----------------------------------+----------------------------|
| *gen_fsm module*                  | *Callback module*          |
|-----------------------------------+----------------------------|
| gen_fsm:start_link                | Module:init/1              |
|-----------------------------------+----------------------------|
| gen_fsm:send_event                | Module:StateName/2         |
|-----------------------------------+----------------------------|
| gen_fsm:send_all_state_event      | Module:handle_event/3      |
|-----------------------------------+----------------------------|
| gen_fsm:sync_send_event           | Module:StateName/3         |
|-----------------------------------+----------------------------|
| gen_fsm:sync_send_all_state_event | Module:handle_sync_event/4 |
|-----------------------------------+----------------------------|
| -                                 | Module:handle_info/3       |
| -                                 | Module:terminate/3         |
| -                                 | Module:code_change/4       |

** =Module:init/1=
- the return values accepted are:
  + ={ok, StateName, Data}=
  + ={ok, StateName, Data, Timeout}=
  + ={ok, StateName, Data, hibernate}=
  + ={stop, Reason}=

- =StateName= is an atom and represents the next callback function to be called

** =Module:StateName/2-3=
- The functions =StateName/2= and =StateName/3= are placeholder names
  and you are to decide what they will be.

- suppose the =init/1= function returns the tuple ={ok, sitting, dog}=.
  This means the finite state machine will be in a =sitting=
  state. This is not the same kind of state as we had seen with
  =gen_server=; These states dictate a context in which you handle a
  given event. Now whenever the =gen_fsm= process receives an event, either
  the function =sitting/2= or =sitting/3= will be called. The =sitting/2=
  function is called for *asynchronous* events and =sitting/3= for
  *synchronous* ones.

- *=StateName(Event, StateData)=*
  + is called for *asynchronous* events
  + Asynchronous events aimed at any =StateName/2= function are sent
    with =gen_fsm:send_event/2=
  + =Event= is the actual message sent as an event, and
    =StateData= is the data that was carried over the calls
  + can return:
    * ={next_state, NextStateName, NewStateData}=
    * ={next_state, NextStateName, NewStateData, Timeout}=
    * ={next_state, NextStateName, NewStateData, hibernate}=
    * ={stop, Reason, NewStateData}=

- *=StateName(Event, From, StateData)=*
  + is called for *synchronous* events
  + synchronous events to be picked up by =StateName/3= are to be sent
    with =gen_fsm:sync_send_event/2-3=
  + can return:
    * ={reply, Reply, NextStateName, NewStateData}=
    * ={reply, Reply, NextStateName, NewStateData, Timeout}=
    * ={reply, Reply, NextStateName, NewStateData, hibernate}=

    * ={next_state, NextStateName, NewStateData}=
    * ={next_state, NextStateName, NewStateData, Timeout}=
    * ={next_state, NextStateName, NewStateData, hibernate}=

    * ={stop, Reason, Reply, NewStateData}=
    * ={stop, Reason, NewStateData}=

** =Module:handle_event(Event, StateName, Data)=
- is used for asynchronous global events that would trigger a specific
  reaction no matter what state we're in
- =StateName= in parameters shows what the state was when the =Event=
  was received
- returns the same values as =StateName/2=.
- =Event= is sent by =gen_fsm:send_all_state_event=

** =Module:handle_sync_event(Event, From, StateName, Data)=
- It handles synchronous global events, and returns the same kind of
  tuples as =StateName/3=.
- =Event= is sent by =gen_fsm:sync_send_all_state_event=
** =Module:code_change/4=
- like =gen_servers= except that it takes an extra state parameter
  when called like =code_change(OldVersion, StateName, Data, Extra)=,
  and returns a tuple of the form ={ok, NextStateName, NewStateData}=.
** =Module:terminate/3=
- like generic servers, =terminate/3= should do the opposite of =init/1=

** =gen_fsm:send_event(FsmRef, Event)=
- Asynchronous events aimed at any =StateName/2= function
- its equivalent function for global events is  =send_all_state_event/2=

** =gen_fsm:sync_send_event(FsmRef, Event, [Timeout])=
- Synchronous events to be picked up by =StateName/3= are to be sent
  with =sync_send_event/2-3=.
- its equivalent function for global events is  =sync_send_all_state_event/2-3=
** =gen_fsm:send_all_state_event(FsmRef, Event)=
- for sending global asynchronous events, picked up by
  =handle_event(Event, StateName, Data)=
** =gen_fsm:sync_send_all_state_event(FsmRef, Event, [Timeout])=
- for sending global synchronous events, picked up b
  =handle_sync_event(Event, From, StateName, Data)=
** =gen_fsm:reply(Caller, Reply)=
* Generic Event Handlers =gen_event=
:NOTE:
    - Remember that event handlers run in the same process as their manager.
:END:

This behavior module provides event handling functionality. It
consists of a generic event manager process with any number of event
handlers that are added and deleted dynamically.

| gen_event module           | Callback module       |
|----------------------------+-----------------------|
| gen_event:start            |                       |
| gen_event:start_link       | -                     |
|                            |                       |
| gen_event:add_handler      |                       |
| gen_event:add_sup_handler  | Module:init/1         |
|                            |                       |
| gen_event:notify           |                       |
| gen_event:sync_notify      | Module:handle_event/2 |
|                            |                       |
| gen_event:call             | Module:handle_call/2  |
|                            |                       |
| -                          | Module:handle_info/2  |
|                            |                       |
| gen_event:delete_handler   | Module:terminate/2    |
|                            |                       |
| gen_event:swap_handler     |                       |
| gen_event:swap_sup_handler | Module1:terminate/2   |
|                            | Module2:init/1        |
|                            |                       |
| gen_event:which_handlers   | -                     |
|                            |                       |
| gen_event:stop             | Module:terminate/2    |
|                            |                       |
| -                          | Module:code_change/3  |

** =Module:init/1= and =Module:terminate/2=
- init/1 takes a list of arguments and returns ={ok, State}=.
- Whatever happens in =init/1= should have its counterpart in =terminate/2=.
** =Module:handle_event(Event, State)=
- it works asynchronously, it means event manager doesn't block the
  calling process for the event handler to fnish (don't get confused
  by this. It does block event manager [event manager queues new
  events] and other event handlers have to to get their event. If you
  have more than one event handler, they are all running in one
  process and that is process of event man anger)
- can return:
  + ={ok, NewState}=
  + ={ok, NewState, hibernate}=, which puts the event manager itself into hibernation until the next event
  + =remove_handler=
  + ={ swap_handler, Args1, NewState, NewHandler, Args2}=

- All incoming events can come from =gen_event:notify/2= which is
  asynchronous like =gen_server:cast/2= is. There is also
  =gen_event:sync_notify/2= which is synchronous. This is a bit funny to
  say, because =handle_event/2= remains asynchronous. The idea here is
  that the function call only returns once all event handlers have
  seen and treated the new message. Until then, the event manager will
  keep blocking the calling process by not replying.
** =Module:handle_call(Event, State)=
- This is similar to a =gen_server='s =handle_call= callback
- can return
  + ={ok, Reply, NewState}=
  + ={ok, Reply, NewState, hibernate}=
  + ={remove_handler, Reply}=
  + ={swap_handler, Reply, Args1, NewState, Handler2, Args2}=
- The =gen_event:call/3-4= function is used to make the call
  + =gen_event:call(EventMgrRef, Handler, Request)=

** =Module:handle_info(Event, State)=
   The =handle_info/2= callback is pretty much the same as =handle_event=
   (same return values and everything), with the exception that it
   only treats out of band messages, such as exit signals, messages
   sent directly to the event manager with the ! operator, etc.
** =Module:code_change(OldVsn, State, Extra)=
** example of callback module
   #+BEGIN_SRC erlang
     -module(mymodule).
     -behaviour(gen_event).

     -export([init/1, handle_event/2, handle_call/2, handle_info/2, code_change/3, terminate/2]).

     init([]) ->
     {ok, []}.

     handle_event(_, State) ->
     {ok, State}.

     handle_call(_, State) ->
     {ok, ok, State}.

     handle_info(_, State) ->
     {ok, State}.

     code_change(_OldVsn, State, _Extra) ->
     {ok, State}.

     terminate(_Reason, _State) ->
     ok.
   #+END_SRC
** =gen_event:start_link()=
** =gen_event:add_handler(EventMgrRef, Handler, Args)=
- Also possible =gen_event:add_handler(Pid, {Module, Ref}, Args)=
  which is usefull If you want to call, add or delete a specific
  handler when there's more than one instance of it.
** =gen_event:add_sup_handler(EventMgrRef, Handler, Args)=
- Adds a new event handler in the same way as =add_handler/3=, but also
  supervises the connection between the event handler and the calling
  process.
** =gen_event:notify(EventMgrRef, Event)=
** =gen_event:sync_notify(EventMgrRef, Event)=
** =gen_event:delete_handler(EventMgrRef, Handler, Args)=
- The event manager calls =Module:terminate/2= to terminate the event
  handler.
- The return value is the return value of =Module:terminate/2=.
** =gen_event:call(EventMgrRef, Handler, Request)=
- Makes a synchronous call to event handler =Handler= installed in event
  manager =EventMgrRef= by sending a request and waiting until a reply
  arrives or a time-out occurs. The event manager calls
  =Module:handle_call/2= to handle the request.
* supervisor
