- XSF: XMPP Standards Foundation
- JSF: Jabber Software Foundation
- XEPs, previously known as JEPs: XMPP Extension Protocols
  + https://xmpp.org/extensions/
- JEPs: Jabber Extension Proposals
- JID: jabber identifier
- BOSH: Bidirectional streams Over Synchronous HTTP
- PEP: Personal Eventing Protocol

* Getting to Know XMPP (The eXtensible Messaging and Presence Protocol)

- Like HTTP, XMPP is a client-server protocol, but it differs from
  HTTP by allowing either side to send data to the other
  asynchronously. XMPP connections are long lived, and data is pushed
  instead of pulled.

** WhAt is XMPP?
- XMPP, like all protocols, defines a format for moving data between
  two or more communicating entities
- XML is known primarily as a document format, but in XMPP, XML data
  is organized as a pair of streams, one stream for each direction of
  communication. Each XML stream consists of an opening element,
  followed by XMPP stanzas and other top-level elements, and then a
  closing element. Each XMPP stanza is a first-level child element
  of the stream with all its descendent elements and attributes. At
  the end of an XMPP connection, the two streams form a pair of valid
  XML documents.


** XMPP Network
- Any XMPP network is composed of a number of actors. These actors can
  be categorized as servers, clients, components, and server
  plug-ins. An XMPP developer will write code to create or modify one
  of these types of actors. Each actor has its place on the XMPP
  network’s stage.

*** Servers
- XMPP servers, or more accurately, XMPP entities speaking the
  server-to-server protocol or the server end of the client-to-server
  protocol, are the circulatory system of any XMPP network. A server’s
  job is to route stanzas, whether they are internal from one user to
  another or from a local user to a user on a remote server.
- The set of XMPP servers that can mutually communicate forms an XMPP
  network.
- The set of public XMPP servers forms the global, federated XMPP
  network. If a server does not speak the server-to-server protocol,
  it becomes an island, unable to communicate with external servers.

*** Clients
*** Components
*** Plug-ins
*** XMPP Addressing
- JIDs are divided into two categories, bare JIDs and full JIDs. The
  full JID is always the most specific address for a particular
  entity, and the bare JID is simply the full JID with any resource
  part removed.
- For example, if a client’s full JID is ~darcy@pemberley.lit/library~,
  its bare JID would be ~darcy@pemberley.lit~. In some cases, the bare
  JID and the full JID are the same, such as when addressing a server
  or a specific multi-user chat room.

- JID: ~darcy@pemberley.lit/library~
  + the local part: ~darcy~
  + the domain: ~pemberley.lit~
  + the resource: ~library~


*** XMPP Stanzas
- Work is accomplished in XMPP by the sending and receiving of XMPP
  stanzas over an XMPP stream
- Three basic stanzas make up the core XMPP toolset. These stanzas are
  ~<presence>~, ~<message>~, and ~<iq>~
- XMPP stream is a set of two XML documents, one for each direction
  of communication. These documents have a root ~<stream:stream>~
  element. The children of this ~<stream:stream>~ element consist of
  routable stanzas and stream related top-level children.
- Each stanza is an XML element, including its children. The end
  points of XMPP communication process input and generate output on a
  stanza-by-stanza basis.
- The following example shows a simplified and short XMPP session:
  #+BEGIN_SRC xml
    <stream:stream>

      <iq type="get">
        <query xmlns="jabber:iq:roster"/>
      </iq>

      <presence/>

      <message to="darcy@pemberley.lit" from="elizabaeth@longbourn.lit/ballroom" type="chat">
        <body>I cannot talk of books in a ball-room; my head is always full of something else.</body>
      </message>

      <presence type="unavailable"/>

    </stream:stream>
  #+END_SRC
  + In this example, Elizabeth created an XMPP stream by sending the
    opening ~<stream:stream>~ tag. With the stream open, she sent her
    first stanza, an ~<iq>~ element. This ~<iq>~ element requested
    Elizabeth’s roster, the list of all her stored contacts. Next, she
    notified the server that she was online and available with a
    ~<presence>~ stanza. After noticing that Mr. Darcy was online, she
    sent him a short ~<message>~ stanza, thwarting his attempt at
    small talk. Finally, Elizabeth sent another ~<presence>~ stanza to
    inform the server she was unavailable and closed the
    ~<stream:stream>~ element, ending the session.

**** Common Attributes
- All three stanzas support a set of common attributes. Whether they
  are attributes of ~<presence>~, ~<message>~, or ~<iq>~ elements, the
  following attributes all mean the same thing.
  + ~from~
    * This attribute identifies the JID of the stanza’s origin.
    * Setting the from attribute on outgoing stanzas is not
      recommended; the server adds the correct from attribute to all
      stanzas as they pass through, and if you set the from attribute
      incorrectly, the server may reject your stanza altogether.
    * If the from attribute is missing on a received stanza in a
      client-to-server stream, this is interpreted to mean that the
      stanza originated from the server itself.
    * In the server-to-server protocol, a missing from attribute is an
      error.
  + ~to~
    * XMPP servers route your stanzas to the JID supplied in the to
      attribute. Similarly to the ~from~ attribute, if the ~to~
      attribute is missing in a client-to-server stream, the server
      assumes it is a message intended for the server itself. It is
      recommended that you omit the to attribute when you address the
      server itself.
    * If the JID specified in the ~to~ attribute is a user, the server
      potentially handles the stanza on the user’s behalf. If the
      destination is a bare JID, the server handles the stanza. This
      behavior is different for the three stanza types. If a full JID
      is specified as the destination, the server routes the stanza
      directly to the user.
  + ~type~
    * The type attribute specifies the specific kind of ~<presence>~,
      ~<message>~, or ~<iq>~ stanza. Each of the three basic stanzas has
      several possible values for the type attribute, and these are
      explained when each stanza is covered in detail. All three
      stanzas may have their type attribute set to a value of
      ~error~. This indicates that the stanza is an error response to a
      received stanza of the same kind. You must not respond to a
      stanza with an error type, to avoid feedback loops on the
      network.
  + ~id~
    * Stanzas may be given an id attribute to aid in identifying
      responses.
    * For ~<iq>~ stanzas, this attribute is required, but for the other
      two it is optional.
    * If a stanza is generated in reply to a stanza with an ~id~
      attribute, the reply stanza must contain an ~id~ attribute with
      the same value.
    * The ~id~ attribute needs to be unique enough that the stanza’s
      sender can use it to disambiguate responses.
    * Reply stanzas for ~<message>~ and ~<presence>~ stanzas are
      generally limited to reporting errors. Reply stanzas for ~<iq>~
      can signal successful operations, acknowledge a command, or
      return requested data. In all these cases, the client uses the
      id attribute of the reply stanza to identify which request
      stanza it is associated with.

**** Presence stanzas
- The ~<presence>~ stanza controls and reports the availability of an
  entity. This availability can range from simple online and offline
  to the more complex away and do not disturb. In addition, ~<presence>~
  stanzas are used to establish and terminate presence subscriptions
  to other entities.
- e.g.
  #+BEGIN_SRC javascript
  $pres().c(‘show’).t(“away”).up().c(‘status’).t(“reading”);
  #+END_SRC
**** Message stanzas
- A ~<message>~ stanza is fire and forget

**** IQ stanzas
- The ~<iq>~ stanza stands for Info/Query and provides a request and
  response mechanism for XMPP communication. It is very similar to the
  basic workings of the HTTP protocol, allowing both ~get~ and ~set~
  queries, similar to the GET and POST actions of HTTP.
- Each ~<iq>~ stanza is required to have a response, and, as mentioned
  previously, the stanza’s required id attribute is used to associate
  a response with the request that caused it.
- The ~<iq>~ stanza comes in four flavors differentiated by the stanza’s
  type attribute. There are two types of ~<iq>~ stanza requests, ~get~ and
  ~set~, and two types of responses, ~result~ and ~error~.

** the connection life cycle
*** Connection
- Before any stanzas are sent, an XMPP stream is necessary. Before an XMPP stream can exist, a con- nection must be made to an XMPP server.
- The first thing an XMPP client or server does when connecting to
  another XMPP server is to query the appropriate SRV record at the
  server’s domain. The response may include multiple SRV records,
  which can be used to load balance connections across multiple
  servers.
-
- If an appropriate SRV record cannot be found, the application tries
  to connect to the given domain directly as a fallback. Most
  libraries also allow you to specify a server to connect to
  explicitly.

*** Stream set up
- Once a connection is established to a given XMPP server, an XMPP
  stream is started. An XMPP stream is opened by sending the opening
  ~<stream:stream>~ element to the server. The server responds by
  sending the response stream’s opening ~<stream:stream>~ tag.
- Once XMPP streams are open in both directions, elements can be sent
  back and forth. At this stage of the connection life cycle, these
  elements will be related to the stream and the stream’s features.
- The server first sends a ~<stream:features>~ element, which details
  all the supported features on the XMPP stream. These mostly relate
  to encryption and authentication options that are available. For
  example, the server will specify if encryption (TLS) is available
  and whether or not anonymous logins are allowed.
- example
  1. First, the client sends the opening element to the server:
     #+BEGIN_SRC xml
       <?xml version='1.0'?>
       <stream:stream xmlns='jabber:client'
                      xmlns:stream='http://etherx.jabber.org/streams' version='1.0'
                      to='pemberley.lit'>
     #+END_SRC
  2. The server replies:
     #+BEGIN_SRC xml
       <?xml version='1.0'?>
       <stream:stream
           xmlns='jabber:client'
           xmlns:stream='http://etherx.jabber.org/streams'
           version='1.0'
           from='pemberley.lit' id='893ca401f5ff2ec29499984e9b7e8afc'
           xml:lang='en'>
         <stream:features>
           <stream:features>
             <starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'/>
             <compression xmlns='http://jabber.org/features/compress'>
               <method>zlib</method>
             </compression>
             <mechanisms xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>
               <mechanism>DIGEST-MD5</mechanism>
               <mechanism>PLAIN</mechanism>
             </mechanisms>
           </stream:features>
     #+END_SRC
     The XMPP streams set up between two servers look identical except
     that the top-level namespace is ~jabber:server~ instead of
     ~jabber:client~.
*** Authentication
- XMPP allows for Transport Layer Security (TLS) encryption, and most
  clients use this by default. Once TLS support is advertised by the
  server, the client starts the TLS connection and upgrades the
  current socket to an encrypted one without disconnecting. Once TLS
  encryption is established, a new pair of XMPP streams is created.
- Authentication in XMPP uses the Simple Authentication and Security
  Layers (SASL) protocol
- Disconnection
  + A polite disconfnection would look like this:
    #+BEGIN_SRC xml
      <presence type='unavailable'/>
    </stream:stream>
    #+END_SRC
* Designing XMPP Applications
- XMPP’s sweet spot is real-time communication, collaboration, and
  data exchange. *Where other protocols pull data, XMPP pushes it*

** XMPP versus HTTP
*** advantages of XMPP
- XMPP has the following advantages over HTTP, each of which are
  explored in detail:
  + Enables pushing data, not just pulling
    * HTTP clients can only request data from a server. Unless the
      server is responding to a client request, it cannot send data to
      the client. XMPP connections, on the other hand, are
      bidirectional. Either party can send data to the other at any
      time, as long as the connection is open.
  + Firewall friendly
  + Strong authentication and security
  + Provides many out-of-the-box tools for solving a wide range of problems
*** disadvantages of XMPP
- Stateful protocol
- Community and deployments are not as broad as HTTP
- More overhead than HTTP for simple chores
- Specialized implementations still needed
** Bridging XMPP and the web
- Even though several browsers are experimenting with features that
  use XMPP, none of the major browsers currently provides built-in
  support for the XMPP protocol. However, by using some clever
  programming and a little server-side help, you can tunnel XMPP
  sessions over HTTP connections efficiently and effectively.
- The technology that enables this efficient tunneling is called HTTP
  long polling. Coupled with a simple HTTP-based management protocol
  and an XMPP connection manager
*** Long polling
- If there is new data ready on the server, the server
  answers immediately. If there is not new data, the server keeps the
  connection open, holding any reply. Once new data arrives, it
  finally responds to the request. If no new data arrives after some
  period of time, the server can send back an empty reply, so as not
  to hold too many open connections at once. Once a request is
  returned, the client immediately sends a new one, and the whole
  process starts over.
- Multiple libraries and protocols have been designed to take
  advantage of long polling, but XMPP’s is one of the oldest
  implementations. In XMPP, this bridge is called *BOSH*, for
  Bidirectional streams Over Synchronous HTTP. You may also have heard
  of Comet or reverse HTTP, which are protocols built on the same
  technique.
*** managing the connection
- XMPP connections live for arbitrarily long periods of time, but HTTP
  requests are quite short lived. A connection manager maintains an
  XMPP connection for a third party and provides access to the
  connection via the HTTP long polling technique.
- The browser and the connection manager communicate over HTTP using a
  simple protocol called BOSH. Essentially, BOSH helps an HTTP client
  establish a new XMPP session, then transports stanzas back and forth
  over HTTP wrapped in a special ~<body>~ element. It also provides some
  security features to make sure that XMPP sessions can’t be easily
  hijacked. The connection manager communicates with an XMPP server as
  if it were a normal client.
*** making JS speak XMPP
- With HTTP long polling, you have the technology for low-latency data
  updates from a server. Combining this with a connection manager
  gives you a way to send and receive XMPP data over a series of HTTP
  requests.
*** making XMPP applications
-
* Saying hello
** The Connection life Cycle
- XMPP connections are created, destroyed, and go through a number of
  phases during their lifetimes,
- When you ask Strophe to connect to a server, you also provide it a
  callback function, which Strophe invokes every time the connection
  phase changes.
- Strophe Connection Statuses
  |----------------+----------------------------------------------------------------------------------------------------------|
  | CONNECTING     | Strophe has started its attempt to make a connection to the XMPP server.                                 |
  | AUTHENTICATING | The connection has been established, and Strophe is now attempting to authenticate and create a session. |
  | CONNECTED      | A session has been established, and user data may now flow freely.                                       |
  | DISCONNECTING  | Termination of the connection has started.                                                               |
  | DISCONNECTED   | The connection is fully terminated.                                                                      |
  | CONNFAIL       | Strophe encountered a problem trying to establish the connection.                                        |
  | AUTHFAIL       | An error occurred during the authentication process.                                                     |

  + ATTACHED: 8
  + AUTHENTICATING: 3
  + AUTHFAIL: 4
  + CONNECTED: 5
  + CONNECTING: 1
  + CONNFAIL: 2
  + CONNTIMEOUT: 10
  + DISCONNECTED: 6
  + DISCONNECTING: 7
  + ERROR: 0
  + REDIRECT: 9

** Creating a Connection
- XMPP connections are managed through the ~Strophe.Connection~ object.
  #+BEGIN_SRC js
    import O, { Strophe } from "strophe.js";

    const conn = new Strophe.Connection("https://conversejs.org/http-bind/");

    conn.connect(username, password, function(evt: any) {
      console.log(evt);
    });
  #+END_SRC
** Creating Stanzas
*** Strophe builders
    #+BEGIN_SRC js
      const pres = new Strophe.Builder("presence", {
        to: "example.com",
      });
    #+END_SRC
- Because building stanzas is such a common operation and typing ~new Strophe.Builder~
  is rather long, Strophe provides four global
  aliases for stanza creation: ~$build()~, ~$msg()~, ~$pres()~, and
  ~$iq()~. The code for these functions just creates ~Strophe.Builder~
  objects exactly like the examples shown. The function ~$build()~ takes
  the same two arguments as the constructor for ~Strophe.Builder~. The
  other three functions create ~<message/>~, ~<presence/>~, and ~<iq/>~
  stanzas, respectively, and take an optional argument of the desired
  attributes.
  #+BEGIN_SRC javascript
    import { Strophe, $build, $iq, $msg, $pres } from "strophe.js";

    const pres1 = $build(“presence”);
    const pres2 = $build(“presence”, {to: “example.com”});
    const pres3 = $pres();
    const pres4 = $pres({to: “example.com”});
  #+END_SRC
  #+BEGIN_SRC js

  #+END_SRC

  #+BEGIN_SRC js
    var message = $msg({to: 'darcy@pemberley.lit', type: 'chat'})
        .c('body').t('How do you do?');
    // produces:
    //
    //  <message to='darcy@pemberley.lit' type='chat'>
    //    <body>How do you do?</body>
    //  </message>
    //

    var iq = $iq({to: 'pemberley.lit', type: 'get', id: 'disco1'})
                .c('query', {xmlns: 'http://jabber.org/protocol/disco#info'});
    // produces:
    //
    // <iq to='pemberley.lit' type='get' id='disco1'>
    //   <query xmlns='http://jabber.org/protocol/disco#info'/>
    // </iq>

    var presence = $pres().c('show').t('away').up().c('status').t('Off to Meryton');
    // produces
    //
    // <presence>
    //   <show>away</show>
    //   <status>Off to Meryton</status>
    // </presence>
  #+END_SRC

*** sending
- e.g
  #+BEGIN_SRC javascript
    const [conn, set_conn] = useState(
      new Strophe.Connection("https://conversejs.org/http-bind/"),
      /* new Strophe.Connection("ws://localhost:5443/ws"), */
    );

    conn.connect(fhdhsni, token, function(evt) {
              set_status(evt);
            });

    useEffect(
      function() {
        if (status === Strophe.Status.CONNECTED) {
          const domain = Strophe.getDomainFromJid(conn.jid);
          const ping = $iq({ to: domain, type: "get", id: "ping1" }).c("ping", {
            xmln: "urn:xmpp:ping",
          });

          conn.send(ping);
        }
      },
      [status],
    );

  #+END_SRC

*** Adding and removing handlers
-
   #+BEGIN_SRC javascript
     conn.addHandler(
                handler: (stanza: Element) => any,
                ns: string,
                name: string,
                type: string,
                id: string,
                from: string,
                options?: { matchBare: boolean }
                ): any;
   #+END_SRC
  +
    #+BEGIN_SRC js
    conn.addHandler(
      function(res) {
        const msg = {
          id: res.getAttribute("id")!,
          name: res.getAttribute("from")!.replace(/@.*$/, ""),
          body: res.querySelector("body")!.textContent!,
        };

        set_msgs([...msgs, msg]);
      },
      undefined,
      "message",
      "chat",
      undefined,
      undefined,
    );
    #+END_SRC

  + The last four criteria — ~name~, ~type~, ~id~, and ~from~ —
    specify filters on the stanza’s element ~name~ and the ~type~,
    ~id~, and ~from~ attributes. These four criteria are checked only
    on the top-level element, not on any of the element’s descendants.
  + The first criterion, ~ns~, is slightly different, and it is checked
    for the top-level element as well as its immediate children
    * Matching on the ~ns~ (for namespace) criterion is mostly done with
      IQ stanzas. IQ stanzas generally contain a single child element
      that is namespaced according to the type of function it
      serves. For example, the ping stanza you sent earlier was an
      IQ-get stanza with a ~<ping/>~ child under the ~urn:xmpp:ping~
      namespace. Setting up a handler to catch all incoming ping
      requests could be done with the following code:
      #+BEGIN_SRC javascript
      conn.addHandler(my_ping_handler, “urn:xmpp:ping”, “iq”)
      #+END_SRC
      The function ~my_ping_handler()~ would be called anytime the
      connection received an IQ stanza with a child under the
      ~urn:xmpp:ping~ namespace. It would get all of these stanzas,
      regardless of their ~type~, ~id~, or ~fro~ attributes, because those
      criteria were left unspecified.

  + The name criterion will almost always be ~null~, to match any
    stanza, or one of ~message~, ~presence~, or ~iq~.
  + You should use ~from~ with care, because you may not always know
    which resource another user or service will use to communicate
    with you. A bare JID supplied as a ~from~ criterion will not match
    any full JID; the match must be exact.
  +
- Whenever a matching stanza is found for a handler, the handler
  function is invoked and passed the stanza as its argument. Unless
  the function returns true or some expression that evaluates to true,
  the handler function will be removed once it finishes.
* peek
-
  #+BEGIN_SRC javascript
    const [conn] = useState(new Strophe.Connection("wss://chat.fhdhsni.me:5443/ws"));

    conn.xmlInput = function(body) {
      console.log("<<<<<<<<<<<<<<<<");
      console.log(body);
      console.log("<<<<<<<<<<<<<<<<");
    };

    conn.xmlOutput = function(body) {
      console.log(">>>>>>>>>>>>>>>>");
      console.log(body);
      console.log(">>>>>>>>>>>>>>>>");
    };
  #+END_SRC

* One‑on‑One Chat
** Presence
- XMPP’s designers were quite sensitive to privacy issues, so presence
  information is controlled through subscriptions. In order for
  Elizabeth to receive presence updates from Wickham, she must first
  subscribe to those updates. Furthermore, Wickham must approve her
  subscription request.
- Presence subscriptions are asymmetric. If Elizabeth has a
  subscription to Wickham’s presence, it does not necessarily mean
  that Wickham is subscribed to Elizabeth’s. In most cases, a user
  will send a subscription request to someone, and automatically
  approve the subscription request coming from that same person.
** Messages
- a message can be addressed to a contact’s bare JID
  (~elizabeth@longbourn.lit~) or to a full JID
  (~elizabeth@longbourn.lit/library~).
** building the roster
- XMPP chat clients generally perform the following actions when they
  start:
    1. Connect and authenticate to the server.
    2. Request the roster.
    3. Send initial presence.
       + This step causes the server to send presence probes to
         contacts for whom the user has a presence subscription. These
         probes will result in a ~<presence>~ stanza being sent back to
         the user for each contact that is online.
*** requesting rosters
- Rosters are manipulated with IQ-get and IQ-set stanzas that contain
  a ~<query>~ element under the ~jabber:iq:roster~ namespace. Rosters can
  be retrieved and contacts modified and deleted using these simple
  stanzas.

- The following stanza requests Elizabeth’s roster from her server:
  #+BEGIN_SRC xml
    <iq from='elizabeth@longbourn.lit/library'
        type='get'
        id='roster1'>
      <query xmlns='jabber:iq:roster'/>
    </iq>
  #+END_SRC
  which in JS
  #+BEGIN_SRC javascript
    function() {
      const iq = $iq({ type: "get" }).c("query", {
        xmlns: "jabber:iq:roster",
      });

      conn.sendIQ(iq, function(resp) {
        console.log(resp);
      });
    }
  #+END_SRC
  + Her server will reply with something similar to the following
    #+BEGIN_SRC xml
      <iq to='elizabeth@longbourn.lit/library'
          type='result'
          id='roster1'>
          <query xmlns='jabber:iq:roster'>
            <item jid='darcy@pemberley.lit' name='Mr. Darcy' subscription='both'/>
            <item jid='jane@longbourn.lit' name='Jane' subscription='both'/>
          </query>
      </iq>
    #+END_SRC
    * The ~subscription~ attribute is set based on the *presence*
      subscription status of the contact:
      - ~both~: if there is a subscription in each direction
      - ~to~: if Elizabeth has a subscription but the other party does not
      - ~from~: if Elizabeth is not subscribed to the contact’s presence but the other user has a subscription to her presence.
    * Generally, the user will only want to see contacts in the roster
      for which the subscription value is ~both~ or ~to~.
- ~sendIQ~
  #+BEGIN_SRC javascript
    Connection.sendIQ(iq_stanza, success_callback?, error_callback?, timeout?);
  #+END_SRC
*** Adding new contacts
- e.g.
  #+BEGIN_SRC js
    const data = {jid: jid, name: name};

    /* add to roster */
    conn.sendIQ(
      $iq({ type: "set" })
        .c("query", {
          xmlns: "jabber:iq:roster",
        })
        .c("item", data),


        function on_success() {
        /* subscribe to the added jid */
        conn.send(
          $pres({ to: data.jid, type: "subscribe" }),
        );
      },
    );
    },
  #+END_SRC

*** presence subscription request
- e.g.
  #+BEGIN_SRC js
    conn.send($pres({ to: data.jid, type: "subscribe" }),);
  #+END_SRC
  the other side can respond with ~subscribed~ or ~unsubscribed~
  #+BEGIN_SRC js
    conn.send($pres({to: jid, type: "subscribed"}));
  #+END_SRC
* Service Discovery
- ~disco#info~
  + returns basic identity information and supported features for an entity
  + Most XMPP entities you will interact with will respond to
    ~disco#info~ queries. Generally, these queries are concerned with
    two kinds of information: identity and features. Identity
    information contains the entity’s name and purpose, and some
    services may have multiple identities. Feature information is
    useful to discover which particular features a service
    supports. For example, a publish-subscribe service may report that
    it supports all the required and some of the optional features
    defined in the Publish-Subscribe specification (XEP-0060) and that
    it also supports several other extensions.
- ~disco#items~
  + enumerate an entity’s children.
  + Service discovery information is organized in the form of a
    tree. The disco#items query requests the list of children for an
    entity. Some of these children will be other entities and some
    will be internal nodes. By continuing to do disco#items queries on
    each child, the entire service tree can be expanded
  + e.g.
    #+BEGIN_SRC js
      /* Disco#items Queries */
      conn.sendIQ(
        $iq({
          type: "get",
          to: "chat.fhdhsni.me",
        }).c("query", {
          xmlns: "http://jabber.org/protocol/disco#items",
        }),
        function(res) {
          console.log(res);
        },
      );
    #+END_SRC
    result:
    #+BEGIN_SRC xml
      <iq xmlns="jabber:client"
          xml:lang="en"
          to="farhad@chat.fhdhsni.me/1724753382249485781820162"
          from="chat.fhdhsni.me"
          type="result"
          id="4d667938-5243-42ff-9e3c-e48151b8f244:sendIQ">
        <query xmlns="http://jabber.org/protocol/disco#items">
          <item jid="conference.chat.fhdhsni.me"/>
          <item jid="proxy.chat.fhdhsni.me"/>
          <item jid="pubsub.chat.fhdhsni.me"/>
          <item jid="upload.chat.fhdhsni.me"/>
        </query>
      </iq>
    #+END_SRC
    which can be continued with further discovering
    #+BEGIN_SRC js
      conn.sendIQ(
        $iq({
          type: "get",
          to: "conference.chat.fhdhsni.me",
        }).c("query", {
          xmlns: "http://jabber.org/protocol/disco#items",
        }),
        function(res) {
          console.log(res);
        },
      );
    #+END_SRC

    result:
    #+BEGIN_SRC xml
      <iq xmlns="jabber:client"
          xml:lang="en"
          to="farhad@chat.fhdhsni.me/494140291225571480820210"
          from="conference.chat.fhdhsni.me"
          type="result"
          id="bb23b24f-2924-4f25-952e-ea21fb43c0be:sendIQ">
        <query xmlns="http://jabber.org/protocol/disco#items">
          <item name="foo (private, 1)" jid="otime@conference.chat.fhdhsni.me"/>
          <item name="Foobar (private, 1)" jid="peral@conference.chat.fhdhsni.me"/>
        </query>
      </iq>
    #+END_SRC
* MUC
- MUC is also a form of message broadcast. A single message sent to a
  room gets rebroadcast out to all the participants
  automatically. This makes it similar to Publish-Subscribe, which you
  see in the next chapter. Unlike Publish-Subscribe, MUC provides a
  lot of advanced management features typical of group chat services,
  such as room moderation, and each participant is often allowed to
  broadcast messages to the room as well.
** Group chat services
- Group chat is provided as a service, usually alongside a regular
  XMPP server. The group chat service has its own domain; for example,
  the jabber.org server runs a group chat service at
  conference.jabber.org.
- Each room on the group chat service gets its own address, which
  looks just like a user’s JID. The XMPP developer’s chat room on the
  conference.jabber.org service is at jdev@conference.jabber.org, and
  general XMPP-related chat takes place in
  jabber@conference.jabber.org.
** entering and leaving a room
- Users can join a group chat room simply by sending available
  presence to the room, along with a note that they understand the
  multi-user chat protocol. Sending presence directly to a JID instead
  of to the user’s server is called directed presence. Similarly, to
  leave, unavailable presence is sent to the room.
- Every participant in a group chat room gets their own address as
  well. Each participant picks a nickname for the room, and their JID
  within the room is the room’s JID with a resource added containing
  their nickname. For example, Darcy’s nickname in the Meryton ball
  chat room is darcy, so his group chat JID is
  ball@chat.meryton.lit/darcy.
-
