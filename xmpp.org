- XMPP Standards Foundation (XSF)
- Jabber Software Foundation (JSF)
- XMPP Extension Protocols (XEPs, previously known as JEPs)
- Jabber Extension Proposals (JEPs)
- JID (jabber identifier)

* Getting to Know XMPP (The eXtensible Messaging and Presence Protocol)

- Like HTTP, XMPP is a client-server protocol, but it differs from
  HTTP by allowing either side to send data to the other
  asynchronously. XMPP connections are long lived, and data is pushed
  instead of pulled.

** WhAt is XMPP?
- XMPP, like all protocols, defines a format for moving data between
  two or more communicating entities
- XML is known primarily as a document format, but in XMPP, XML data
  is organized as a pair of streams, one stream for each direction of
  communication. Each XML stream consists of an opening element,
  followed by XMPP stanzas and other top-level elements, and then a
  closing element. Each XMPP stanza is a first-level child element
  of the stream with all its descendent elements and attributes. At
  the end of an XMPP connection, the two streams form a pair of valid
  XML documents.


** XMPP Network
- Any XMPP network is composed of a number of actors. These actors can
  be categorized as servers, clients, components, and server
  plug-ins. An XMPP developer will write code to create or modify one
  of these types of actors. Each actor has its place on the XMPP
  network’s stage.

*** Servers
- XMPP servers, or more accurately, XMPP entities speaking the
  server-to-server protocol or the server end of the client-to-server
  protocol, are the circulatory system of any XMPP network. A server’s
  job is to route stanzas, whether they are internal from one user to
  another or from a local user to a user on a remote server.
- The set of XMPP servers that can mutually communicate forms an XMPP
  network.
- The set of public XMPP servers forms the global, federated XMPP
  network. If a server does not speak the server-to-server protocol,
  it becomes an island, unable to communicate with external servers.

*** Clients
*** Components
*** Plug-ins
*** XMPP Addressing
- JIDs are divided into two categories, bare JIDs and full JIDs. The
  full JID is always the most specific address for a particular
  entity, and the bare JID is simply the full JID with any resource
  part removed.
- For example, if a client’s full JID is ~darcy@pemberley.lit/library~,
  its bare JID would be ~darcy@pemberley.lit~. In some cases, the bare
  JID and the full JID are the same, such as when addressing a server
  or a specific multi-user chat room.

- JID: ~darcy@pemberley.lit/library~
  + the local part: ~darcy~
  + the domain: ~pemberley.lit~
  + the resource: ~library~


*** XMPP Stanzas
- Work is accomplished in XMPP by the sending and receiving of XMPP
  stanzas over an XMPP stream
- Three basic stanzas make up the core XMPP toolset. These stanzas are
  ~<presence>~, ~<message>~, and ~<iq>~
- XMPP stream is a set of two XML documents, one for each direction
  of communication. These documents have a root ~<stream:stream>~
  element. The children of this ~<stream:stream>~ element consist of
  routable stanzas and stream related top-level children.
- Each stanza is an XML element, including its children. The end
  points of XMPP communication process input and generate output on a
  stanza-by-stanza basis.
- The following example shows a simplified and short XMPP session:
  #+BEGIN_SRC xml
    <stream:stream>

      <iq type="get">
        <query xmlns="jabber:iq:roster"/>
      </iq>

      <presence/>

      <message to="darcy@pemberley.lit" from="elizabaeth@longbourn.lit/ballroom" type="chat">
        <body>I cannot talk of books in a ball-room; my head is always full of something else.</body>
      </message>

      <presence type="unavailable"/>

    </stream:stream>
  #+END_SRC
  + In this example, Elizabeth created an XMPP stream by sending the
    opening ~<stream:stream>~ tag. With the stream open, she sent her
    first stanza, an ~<iq>~ element. This ~<iq>~ element requested
    Elizabeth’s roster, the list of all her stored contacts. Next, she
    notified the server that she was online and available with a
    ~<presence>~ stanza. After noticing that Mr. Darcy was online, she
    sent him a short ~<message>~ stanza, thwarting his attempt at
    small talk. Finally, Elizabeth sent another ~<presence>~ stanza to
    inform the server she was unavailable and closed the
    ~<stream:stream>~ element, ending the session.

**** Common Attributes
- All three stanzas support a set of common attributes. Whether they
  are attributes of ~<presence>~, ~<message>~, or ~<iq>~ elements, the
  following attributes all mean the same thing.
  + ~from~
    * This attribute identifies the JID of the stanza’s origin.
    * Setting the from attribute on outgoing stanzas is not
      recommended; the server adds the correct from attribute to all
      stanzas as they pass through, and if you set the from attribute
      incorrectly, the server may reject your stanza altogether.
    * If the from attribute is missing on a received stanza in a
      client-to-server stream, this is interpreted to mean that the
      stanza originated from the server itself.
    * In the server-to-server protocol, a missing from attribute is an
      error.
  + ~to~
    * XMPP servers route your stanzas to the JID supplied in the to
      attribute. Similarly to the ~from~ attribute, if the ~to~
      attribute is missing in a client-to-server stream, the server
      assumes it is a message intended for the server itself. It is
      recommended that you omit the to attribute when you address the
      server itself.
    * If the JID specified in the ~to~ attribute is a user, the server
      potentially handles the stanza on the user’s behalf. If the
      destination is a bare JID, the server handles the stanza. This
      behavior is different for the three stanza types. If a full JID
      is specified as the destination, the server routes the stanza
      directly to the user.
  + ~type~
    * The type attribute specifies the specific kind of ~<presence>~,
      ~<message>~, or ~<iq>~ stanza. Each of the three basic stanzas has
      several possible values for the type attribute, and these are
      explained when each stanza is covered in detail. All three
      stanzas may have their type attribute set to a value of
      ~error~. This indicates that the stanza is an error response to a
      received stanza of the same kind. You must not respond to a
      stanza with an error type, to avoid feedback loops on the
      network.
  + ~id~
    * Stanzas may be given an id attribute to aid in identifying
      responses.
    * For ~<iq>~ stanzas, this attribute is required, but for the other
      two it is optional.
    * If a stanza is generated in reply to a stanza with an ~id~
      attribute, the reply stanza must contain an ~id~ attribute with
      the same value.
    * The ~id~ attribute needs to be unique enough that the stanza’s
      sender can use it to disambiguate responses.
    * Reply stanzas for ~<message>~ and ~<presence>~ stanzas are
      generally limited to reporting errors. Reply stanzas for ~<iq>~
      can signal successful operations, acknowledge a command, or
      return requested data. In all these cases, the client uses the
      id attribute of the reply stanza to identify which request
      stanza it is associated with.

**** Presence stanzas
- The ~<presence>~ stanza controls and reports the availability of an
  entity. This availability can range from simple online and offline
  to the more complex away and do not disturb. In addition, ~<presence>~
  stanzas are used to establish and terminate presence subscriptions
  to other entities.
**** Message stanzas
- A ~<message>~ stanza is fire and forget

**** IQ stanzas
- The ~<iq>~ stanza stands for Info/Query and provides a request and
  response mechanism for XMPP communication. It is very similar to the
  basic workings of the HTTP protocol, allowing both ~get~ and ~set~
  queries, similar to the GET and POST actions of HTTP.
- Each ~<iq>~ stanza is required to have a response, and, as mentioned
  previously, the stanza’s required id attribute is used to associate
  a response with the request that caused it.
- The ~<iq>~ stanza comes in four flavors differentiated by the stanza’s
  type attribute. There are two types of ~<iq>~ stanza requests, ~get~ and
  ~set~, and two types of responses, ~result~ and ~error~.

** the connection life cycle
*** Connection
- Before any stanzas are sent, an XMPP stream is necessary. Before an XMPP stream can exist, a con- nection must be made to an XMPP server.
- The first thing an XMPP client or server does when connecting to
  another XMPP server is to query the appropriate SRV record at the
  server’s domain. The response may include multiple SRV records,
  which can be used to load balance connections across multiple
  servers.
-
- If an appropriate SRV record cannot be found, the application tries
  to connect to the given domain directly as a fallback. Most
  libraries also allow you to specify a server to connect to
  explicitly.

*** Stream set up
- Once a connection is established to a given XMPP server, an XMPP
  stream is started. An XMPP stream is opened by sending the opening
  ~<stream:stream>~ element to the server. The server responds by
  sending the response stream’s opening ~<stream:stream>~ tag.
- Once XMPP streams are open in both directions, elements can be sent
  back and forth. At this stage of the connection life cycle, these
  elements will be related to the stream and the stream’s features.
- The server first sends a ~<stream:features>~ element, which details
  all the supported features on the XMPP stream. These mostly relate
  to encryption and authentication options that are available. For
  example, the server will specify if encryption (TLS) is available
  and whether or not anonymous logins are allowed.
- example
  1. First, the client sends the opening element to the server:
     #+BEGIN_SRC xml
       <?xml version='1.0'?>
       <stream:stream xmlns='jabber:client'
                      xmlns:stream='http://etherx.jabber.org/streams' version='1.0'
                      to='pemberley.lit'>
     #+END_SRC
  2. The server replies:
     #+BEGIN_SRC xml
       <?xml version='1.0'?>
       <stream:stream
           xmlns='jabber:client'
           xmlns:stream='http://etherx.jabber.org/streams'
           version='1.0'
           from='pemberley.lit' id='893ca401f5ff2ec29499984e9b7e8afc'
           xml:lang='en'>
         <stream:features>
           <stream:features>
             <starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'/>
             <compression xmlns='http://jabber.org/features/compress'>
               <method>zlib</method>
             </compression>
             <mechanisms xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>
               <mechanism>DIGEST-MD5</mechanism>
               <mechanism>PLAIN</mechanism>
             </mechanisms>
           </stream:features>
     #+END_SRC
     The XMPP streams set up between two servers look identical except
     that the top-level namespace is ~jabber:server~ instead of
     ~jabber:client~.
*** Authentication
- XMPP allows for Transport Layer Security (TLS) encryption, and most
  clients use this by default. Once TLS support is advertised by the
  server, the client starts the TLS connection and upgrades the
  current socket to an encrypted one without disconnecting. Once TLS
  encryption is established, a new pair of XMPP streams is created.
- Authentication in XMPP uses the Simple Authentication and Security
  Layers (SASL) protocol
- Disconnection
  + A polite disconnection would look like this:
    #+BEGIN_SRC xml
      <presence type='unavailable'/>
    </stream:stream>
    #+END_SRC
