- XSF: XMPP Standards Foundation
- JSF: Jabber Software Foundation
- XEPs, previously known as JEPs: XMPP Extension Protocols
  + https://xmpp.org/extensions/
- JEPs: Jabber Extension Proposals
- JID: jabber identifier
- BOSH: Bidirectional streams Over Synchronous HTTP
- PEP: Personal Eventing Protocol
- SID: Session Identifier
- RID: Request Identifier
- In-Band Bytestreams (XEP-0047)
  + which break up a large payload into smaller chunks and send them
    in a series of ~<iq>~ or ~<message>~ stanzas.
- Results Set Management (XEP-0059)
  + Roster Versioning (XEP-0237) provides a similar solution
    specifically for rosters.
- The Jingle extensions (XEP-0166, XEP-0234, XEP-0247, and others)
  provide a very flexible framework for negotiating, establishing, and
  communicating over OOB connections.

* Getting to Know XMPP (The eXtensible Messaging and Presence Protocol)

- Like HTTP, XMPP is a client-server protocol, but it differs from
  HTTP by allowing either side to send data to the other
  asynchronously. XMPP connections are long lived, and data is pushed
  instead of pulled.

** WhAt is XMPP?
- XMPP, like all protocols, defines a format for moving data between
  two or more communicating entities
- XML is known primarily as a document format, but in XMPP, XML data
  is organized as a pair of streams, one stream for each direction of
  communication. Each XML stream consists of an opening element,
  followed by XMPP stanzas and other top-level elements, and then a
  closing element. Each XMPP stanza is a first-level child element
  of the stream with all its descendent elements and attributes. At
  the end of an XMPP connection, the two streams form a pair of valid
  XML documents.


** XMPP Network
- Any XMPP network is composed of a number of actors. These actors can
  be categorized as servers, clients, components, and server
  plug-ins. An XMPP developer will write code to create or modify one
  of these types of actors. Each actor has its place on the XMPP
  network’s stage.

*** Servers
- XMPP servers, or more accurately, XMPP entities speaking the
  server-to-server protocol or the server end of the client-to-server
  protocol, are the circulatory system of any XMPP network. A server’s
  job is to route stanzas, whether they are internal from one user to
  another or from a local user to a user on a remote server.
- The set of XMPP servers that can mutually communicate forms an XMPP
  network.
- The set of public XMPP servers forms the global, federated XMPP
  network. If a server does not speak the server-to-server protocol,
  it becomes an island, unable to communicate with external servers.

*** Clients
*** Components
*** Plug-ins
*** XMPP Addressing
- JIDs are divided into two categories, bare JIDs and full JIDs. The
  full JID is always the most specific address for a particular
  entity, and the bare JID is simply the full JID with any resource
  part removed.
- For example, if a client’s full JID is ~darcy@pemberley.lit/library~,
  its bare JID would be ~darcy@pemberley.lit~. In some cases, the bare
  JID and the full JID are the same, such as when addressing a server
  or a specific multi-user chat room.

- JID: ~darcy@pemberley.lit/library~
  + the local part: ~darcy~
  + the domain: ~pemberley.lit~
  + the resource: ~library~


*** XMPP Stanzas
- Work is accomplished in XMPP by the sending and receiving of XMPP
  stanzas over an XMPP stream
- Three basic stanzas make up the core XMPP toolset. These stanzas are
  ~<presence>~, ~<message>~, and ~<iq>~
- XMPP stream is a set of two XML documents, one for each direction
  of communication. These documents have a root ~<stream:stream>~
  element. The children of this ~<stream:stream>~ element consist of
  routable stanzas and stream related top-level children.
- Each stanza is an XML element, including its children. The end
  points of XMPP communication process input and generate output on a
  stanza-by-stanza basis.
- The following example shows a simplified and short XMPP session:
  #+BEGIN_SRC xml
    <stream:stream>

      <iq type="get">
        <query xmlns="jabber:iq:roster"/>
      </iq>

      <presence/>

      <message to="darcy@pemberley.lit" from="elizabaeth@longbourn.lit/ballroom" type="chat">
        <body>I cannot talk of books in a ball-room; my head is always full of something else.</body>
      </message>

      <presence type="unavailable"/>

    </stream:stream>
  #+END_SRC
  + In this example, Elizabeth created an XMPP stream by sending the
    opening ~<stream:stream>~ tag. With the stream open, she sent her
    first stanza, an ~<iq>~ element. This ~<iq>~ element requested
    Elizabeth’s roster, the list of all her stored contacts. Next, she
    notified the server that she was online and available with a
    ~<presence>~ stanza. After noticing that Mr. Darcy was online, she
    sent him a short ~<message>~ stanza, thwarting his attempt at
    small talk. Finally, Elizabeth sent another ~<presence>~ stanza to
    inform the server she was unavailable and closed the
    ~<stream:stream>~ element, ending the session.

**** Common Attributes
- All three stanzas support a set of common attributes. Whether they
  are attributes of ~<presence>~, ~<message>~, or ~<iq>~ elements, the
  following attributes all mean the same thing.
  + ~from~
    * This attribute identifies the JID of the stanza’s origin.
    * Setting the from attribute on outgoing stanzas is not
      recommended; the server adds the correct from attribute to all
      stanzas as they pass through, and if you set the from attribute
      incorrectly, the server may reject your stanza altogether.
    * If the from attribute is missing on a received stanza in a
      client-to-server stream, this is interpreted to mean that the
      stanza originated from the server itself.
    * In the server-to-server protocol, a missing from attribute is an
      error.
  + ~to~
    * XMPP servers route your stanzas to the JID supplied in the to
      attribute. Similarly to the ~from~ attribute, if the ~to~
      attribute is missing in a client-to-server stream, the server
      assumes it is a message intended for the server itself. It is
      recommended that you omit the to attribute when you address the
      server itself.
    * If the JID specified in the ~to~ attribute is a user, the server
      potentially handles the stanza on the user’s behalf. If the
      destination is a bare JID, the server handles the stanza. This
      behavior is different for the three stanza types. If a full JID
      is specified as the destination, the server routes the stanza
      directly to the user.
  + ~type~
    * The type attribute specifies the specific kind of ~<presence>~,
      ~<message>~, or ~<iq>~ stanza. Each of the three basic stanzas has
      several possible values for the type attribute, and these are
      explained when each stanza is covered in detail. All three
      stanzas may have their type attribute set to a value of
      ~error~. This indicates that the stanza is an error response to a
      received stanza of the same kind. You must not respond to a
      stanza with an error type, to avoid feedback loops on the
      network.
  + ~id~
    * Stanzas may be given an id attribute to aid in identifying
      responses.
    * For ~<iq>~ stanzas, this attribute is required, but for the other
      two it is optional.
    * If a stanza is generated in reply to a stanza with an ~id~
      attribute, the reply stanza must contain an ~id~ attribute with
      the same value.
    * The ~id~ attribute needs to be unique enough that the stanza’s
      sender can use it to disambiguate responses.
    * Reply stanzas for ~<message>~ and ~<presence>~ stanzas are
      generally limited to reporting errors. Reply stanzas for ~<iq>~
      can signal successful operations, acknowledge a command, or
      return requested data. In all these cases, the client uses the
      id attribute of the reply stanza to identify which request
      stanza it is associated with.

**** Presence stanzas
- The ~<presence>~ stanza controls and reports the availability of an
  entity. This availability can range from simple online and offline
  to the more complex away and do not disturb. In addition, ~<presence>~
  stanzas are used to establish and terminate presence subscriptions
  to other entities.
- e.g.
  #+BEGIN_SRC javascript
  $pres().c(‘show’).t(“away”).up().c(‘status’).t(“reading”);
  #+END_SRC
**** Message stanzas
- A ~<message>~ stanza is fire and forget

**** IQ stanzas
- The ~<iq>~ stanza stands for Info/Query and provides a request and
  response mechanism for XMPP communication. It is very similar to the
  basic workings of the HTTP protocol, allowing both ~get~ and ~set~
  queries, similar to the GET and POST actions of HTTP.
- Each ~<iq>~ stanza is required to have a response, and, as mentioned
  previously, the stanza’s required id attribute is used to associate
  a response with the request that caused it.
- The ~<iq>~ stanza comes in four flavors differentiated by the stanza’s
  type attribute. There are two types of ~<iq>~ stanza requests, ~get~ and
  ~set~, and two types of responses, ~result~ and ~error~.

** the connection life cycle
*** Connection
- Before any stanzas are sent, an XMPP stream is necessary. Before an XMPP stream can exist, a con- nection must be made to an XMPP server.
- The first thing an XMPP client or server does when connecting to
  another XMPP server is to query the appropriate SRV record at the
  server’s domain. The response may include multiple SRV records,
  which can be used to load balance connections across multiple
  servers.
-
- If an appropriate SRV record cannot be found, the application tries
  to connect to the given domain directly as a fallback. Most
  libraries also allow you to specify a server to connect to
  explicitly.

*** Stream set up
- Once a connection is established to a given XMPP server, an XMPP
  stream is started. An XMPP stream is opened by sending the opening
  ~<stream:stream>~ element to the server. The server responds by
  sending the response stream’s opening ~<stream:stream>~ tag.
- Once XMPP streams are open in both directions, elements can be sent
  back and forth. At this stage of the connection life cycle, these
  elements will be related to the stream and the stream’s features.
- The server first sends a ~<stream:features>~ element, which details
  all the supported features on the XMPP stream. These mostly relate
  to encryption and authentication options that are available. For
  example, the server will specify if encryption (TLS) is available
  and whether or not anonymous logins are allowed.
- example
  1. First, the client sends the opening element to the server:
     #+BEGIN_SRC xml
       <?xml version='1.0'?>
       <stream:stream xmlns='jabber:client'
                      xmlns:stream='http://etherx.jabber.org/streams' version='1.0'
                      to='pemberley.lit'>
     #+END_SRC
  2. The server replies:
     #+BEGIN_SRC xml
       <?xml version='1.0'?>
       <stream:stream
           xmlns='jabber:client'
           xmlns:stream='http://etherx.jabber.org/streams'
           version='1.0'
           from='pemberley.lit' id='893ca401f5ff2ec29499984e9b7e8afc'
           xml:lang='en'>
         <stream:features>
           <stream:features>
             <starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'/>
             <compression xmlns='http://jabber.org/features/compress'>
               <method>zlib</method>
             </compression>
             <mechanisms xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>
               <mechanism>DIGEST-MD5</mechanism>
               <mechanism>PLAIN</mechanism>
             </mechanisms>
           </stream:features>
     #+END_SRC
     The XMPP streams set up between two servers look identical except
     that the top-level namespace is ~jabber:server~ instead of
     ~jabber:client~.
*** Authentication
- XMPP allows for Transport Layer Security (TLS) encryption, and most
  clients use this by default. Once TLS support is advertised by the
  server, the client starts the TLS connection and upgrades the
  current socket to an encrypted one without disconnecting. Once TLS
  encryption is established, a new pair of XMPP streams is created.
- Authentication in XMPP uses the Simple Authentication and Security
  Layers (SASL) protocol
- Disconnection
  + A polite disconfnection would look like this:
    #+BEGIN_SRC xml
      <presence type='unavailable'/>
    </stream:stream>
    #+END_SRC
* Designing XMPP Applications
- XMPP’s sweet spot is real-time communication, collaboration, and
  data exchange. *Where other protocols pull data, XMPP pushes it*

** XMPP versus HTTP
*** advantages of XMPP
- XMPP has the following advantages over HTTP, each of which are
  explored in detail:
  + Enables pushing data, not just pulling
    * HTTP clients can only request data from a server. Unless the
      server is responding to a client request, it cannot send data to
      the client. XMPP connections, on the other hand, are
      bidirectional. Either party can send data to the other at any
      time, as long as the connection is open.
  + Firewall friendly
  + Strong authentication and security
  + Provides many out-of-the-box tools for solving a wide range of problems
*** disadvantages of XMPP
- Stateful protocol
- Community and deployments are not as broad as HTTP
- More overhead than HTTP for simple chores
- Specialized implementations still needed
** Bridging XMPP and the web
- Even though several browsers are experimenting with features that
  use XMPP, none of the major browsers currently provides built-in
  support for the XMPP protocol. However, by using some clever
  programming and a little server-side help, you can tunnel XMPP
  sessions over HTTP connections efficiently and effectively.
- The technology that enables this efficient tunneling is called HTTP
  long polling. Coupled with a simple HTTP-based management protocol
  and an XMPP connection manager
*** Long polling
- If there is new data ready on the server, the server
  answers immediately. If there is not new data, the server keeps the
  connection open, holding any reply. Once new data arrives, it
  finally responds to the request. If no new data arrives after some
  period of time, the server can send back an empty reply, so as not
  to hold too many open connections at once. Once a request is
  returned, the client immediately sends a new one, and the whole
  process starts over.
- Multiple libraries and protocols have been designed to take
  advantage of long polling, but XMPP’s is one of the oldest
  implementations. In XMPP, this bridge is called *BOSH*, for
  Bidirectional streams Over Synchronous HTTP. You may also have heard
  of Comet or reverse HTTP, which are protocols built on the same
  technique.
*** managing the connection
- XMPP connections live for arbitrarily long periods of time, but HTTP
  requests are quite short lived. A connection manager maintains an
  XMPP connection for a third party and provides access to the
  connection via the HTTP long polling technique.
- The browser and the connection manager communicate over HTTP using a
  simple protocol called BOSH. Essentially, BOSH helps an HTTP client
  establish a new XMPP session, then transports stanzas back and forth
  over HTTP wrapped in a special ~<body>~ element. It also provides some
  security features to make sure that XMPP sessions can’t be easily
  hijacked. The connection manager communicates with an XMPP server as
  if it were a normal client.
*** making JS speak XMPP
- With HTTP long polling, you have the technology for low-latency data
  updates from a server. Combining this with a connection manager
  gives you a way to send and receive XMPP data over a series of HTTP
  requests.
*** making XMPP applications
-
* Saying hello
** The Connection life Cycle
- XMPP connections are created, destroyed, and go through a number of
  phases during their lifetimes,
- When you ask Strophe to connect to a server, you also provide it a
  callback function, which Strophe invokes every time the connection
  phase changes.
- Strophe Connection Statuses
  |----------------+----------------------------------------------------------------------------------------------------------|
  | CONNECTING     | Strophe has started its attempt to make a connection to the XMPP server.                                 |
  | AUTHENTICATING | The connection has been established, and Strophe is now attempting to authenticate and create a session. |
  | CONNECTED      | A session has been established, and user data may now flow freely.                                       |
  | DISCONNECTING  | Termination of the connection has started.                                                               |
  | DISCONNECTED   | The connection is fully terminated.                                                                      |
  | CONNFAIL       | Strophe encountered a problem trying to establish the connection.                                        |
  | AUTHFAIL       | An error occurred during the authentication process.                                                     |

  + ATTACHED: 8
  + AUTHENTICATING: 3
  + AUTHFAIL: 4
  + CONNECTED: 5
  + CONNECTING: 1
  + CONNFAIL: 2
  + CONNTIMEOUT: 10
  + DISCONNECTED: 6
  + DISCONNECTING: 7
  + ERROR: 0
  + REDIRECT: 9

** Creating a Connection
- XMPP connections are managed through the ~Strophe.Connection~ object.
  #+BEGIN_SRC js
    import O, { Strophe } from "strophe.js";

    const conn = new Strophe.Connection("https://conversejs.org/http-bind/");

    conn.connect(username, password, function(evt: any) {
      console.log(evt);
    });
  #+END_SRC
** Creating Stanzas
*** Strophe builders
    #+BEGIN_SRC js
      const pres = new Strophe.Builder("presence", {
        to: "example.com",
      });
    #+END_SRC
- Because building stanzas is such a common operation and typing ~new Strophe.Builder~
  is rather long, Strophe provides four global
  aliases for stanza creation: ~$build()~, ~$msg()~, ~$pres()~, and
  ~$iq()~. The code for these functions just creates ~Strophe.Builder~
  objects exactly like the examples shown. The function ~$build()~ takes
  the same two arguments as the constructor for ~Strophe.Builder~. The
  other three functions create ~<message/>~, ~<presence/>~, and ~<iq/>~
  stanzas, respectively, and take an optional argument of the desired
  attributes.
  #+BEGIN_SRC javascript
    import { Strophe, $build, $iq, $msg, $pres } from "strophe.js";

    const pres1 = $build(“presence”);
    const pres2 = $build(“presence”, {to: “example.com”});
    const pres3 = $pres();
    const pres4 = $pres({to: “example.com”});
  #+END_SRC
  #+BEGIN_SRC js

  #+END_SRC

  #+BEGIN_SRC js
    var message = $msg({to: 'darcy@pemberley.lit', type: 'chat'})
        .c('body').t('How do you do?');
    // produces:
    //
    //  <message to='darcy@pemberley.lit' type='chat'>
    //    <body>How do you do?</body>
    //  </message>
    //

    var iq = $iq({to: 'pemberley.lit', type: 'get', id: 'disco1'})
                .c('query', {xmlns: 'http://jabber.org/protocol/disco#info'});
    // produces:
    //
    // <iq to='pemberley.lit' type='get' id='disco1'>
    //   <query xmlns='http://jabber.org/protocol/disco#info'/>
    // </iq>

    var presence = $pres().c('show').t('away').up().c('status').t('Off to Meryton');
    // produces
    //
    // <presence>
    //   <show>away</show>
    //   <status>Off to Meryton</status>
    // </presence>
  #+END_SRC

*** sending
- e.g
  #+BEGIN_SRC javascript
    const [conn, set_conn] = useState(
      new Strophe.Connection("https://conversejs.org/http-bind/"),
      /* new Strophe.Connection("ws://localhost:5443/ws"), */
    );

    conn.connect(fhdhsni, token, function(evt) {
              set_status(evt);
            });

    useEffect(
      function() {
        if (status === Strophe.Status.CONNECTED) {
          const domain = Strophe.getDomainFromJid(conn.jid);
          const ping = $iq({ to: domain, type: "get", id: "ping1" }).c("ping", {
            xmln: "urn:xmpp:ping",
          });

          conn.send(ping);
        }
      },
      [status],
    );

  #+END_SRC

*** Adding and removing handlers
-
   #+BEGIN_SRC javascript
     conn.addHandler(
                handler: (stanza: Element) => any,
                ns: string,
                name: string,
                type: string,
                id: string,
                from: string,
                options?: { matchBare: boolean }
                ): any;
   #+END_SRC
  +
    #+BEGIN_SRC js
    conn.addHandler(
      function(res) {
        const msg = {
          id: res.getAttribute("id")!,
          name: res.getAttribute("from")!.replace(/@.*$/, ""),
          body: res.querySelector("body")!.textContent!,
        };

        set_msgs([...msgs, msg]);
      },
      undefined,
      "message",
      "chat",
      undefined,
      undefined,
    );
    #+END_SRC

  + The last four criteria — ~name~, ~type~, ~id~, and ~from~ —
    specify filters on the stanza’s element ~name~ and the ~type~,
    ~id~, and ~from~ attributes. These four criteria are checked only
    on the top-level element, not on any of the element’s descendants.
  + The first criterion, ~ns~, is slightly different, and it is checked
    for the top-level element as well as its immediate children
    * Matching on the ~ns~ (for namespace) criterion is mostly done with
      IQ stanzas. IQ stanzas generally contain a single child element
      that is namespaced according to the type of function it
      serves. For example, the ping stanza you sent earlier was an
      IQ-get stanza with a ~<ping/>~ child under the ~urn:xmpp:ping~
      namespace. Setting up a handler to catch all incoming ping
      requests could be done with the following code:
      #+BEGIN_SRC javascript
      conn.addHandler(my_ping_handler, “urn:xmpp:ping”, “iq”)
      #+END_SRC
      The function ~my_ping_handler()~ would be called anytime the
      connection received an IQ stanza with a child under the
      ~urn:xmpp:ping~ namespace. It would get all of these stanzas,
      regardless of their ~type~, ~id~, or ~fro~ attributes, because those
      criteria were left unspecified.

  + The name criterion will almost always be ~null~, to match any
    stanza, or one of ~message~, ~presence~, or ~iq~.
  + You should use ~from~ with care, because you may not always know
    which resource another user or service will use to communicate
    with you. A bare JID supplied as a ~from~ criterion will not match
    any full JID; the match must be exact.
  +
- Whenever a matching stanza is found for a handler, the handler
  function is invoked and passed the stanza as its argument. Unless
  the function returns true or some expression that evaluates to true,
  the handler function will be removed once it finishes.
* peek
-
  #+BEGIN_SRC javascript
    const [conn] = useState(new Strophe.Connection("wss://chat.fhdhsni.me:5443/ws"));

    conn.xmlInput = function(body) {
      console.log("<<<<<<<<<<<<<<<<");
      console.log(body);
      console.log("<<<<<<<<<<<<<<<<");
    };

    conn.xmlOutput = function(body) {
      console.log(">>>>>>>>>>>>>>>>");
      console.log(body);
      console.log(">>>>>>>>>>>>>>>>");
    };
  #+END_SRC

* One‑on‑One Chat
** Presence
- XMPP’s designers were quite sensitive to privacy issues, so presence
  information is controlled through subscriptions. In order for
  Elizabeth to receive presence updates from Wickham, she must first
  subscribe to those updates. Furthermore, Wickham must approve her
  subscription request.
- Presence subscriptions are asymmetric. If Elizabeth has a
  subscription to Wickham’s presence, it does not necessarily mean
  that Wickham is subscribed to Elizabeth’s. In most cases, a user
  will send a subscription request to someone, and automatically
  approve the subscription request coming from that same person.
- Presence priorities give information to the user’s server about
  which connected resources are more important for message
  delivery. Messages will be routed to the resources with the highest
  positive presence priority, and in the case of a tie, the message
  will be delivered to one or all of the resources with tied
  priorities.
  #+BEGIN_SRC js
  send($pres().c(‘priority’).t(‘-1’));
  #+END_SRC

** Messages
- a message can be addressed to a contact’s bare JID
  (~elizabeth@longbourn.lit~) or to a full JID
  (~elizabeth@longbourn.lit/library~).
** building the roster
- XMPP chat clients generally perform the following actions when they
  start:
    1. Connect and authenticate to the server.
    2. Request the roster.
    3. Send initial presence.
       + This step causes the server to send presence probes to
         contacts for whom the user has a presence subscription. These
         probes will result in a ~<presence>~ stanza being sent back to
         the user for each contact that is online.
*** requesting rosters
- Rosters are manipulated with IQ-get and IQ-set stanzas that contain
  a ~<query>~ element under the ~jabber:iq:roster~ namespace. Rosters can
  be retrieved and contacts modified and deleted using these simple
  stanzas.

- The following stanza requests Elizabeth’s roster from her server:
  #+BEGIN_SRC xml
    <iq from='elizabeth@longbourn.lit/library'
        type='get'
        id='roster1'>
      <query xmlns='jabber:iq:roster'/>
    </iq>
  #+END_SRC
  which in JS
  #+BEGIN_SRC javascript
    function() {
      const iq = $iq({ type: "get" }).c("query", {
        xmlns: "jabber:iq:roster",
      });

      conn.sendIQ(iq, function(resp) {
        console.log(resp);
      });
    }
  #+END_SRC
  + Her server will reply with something similar to the following
    #+BEGIN_SRC xml
      <iq to='elizabeth@longbourn.lit/library'
          type='result'
          id='roster1'>
          <query xmlns='jabber:iq:roster'>
            <item jid='darcy@pemberley.lit' name='Mr. Darcy' subscription='both'/>
            <item jid='jane@longbourn.lit' name='Jane' subscription='both'/>
          </query>
      </iq>
    #+END_SRC
    * The ~subscription~ attribute is set based on the *presence*
      subscription status of the contact:
      - ~none~: opposite of ~both~
      - ~both~: if there is a subscription in each direction
      - ~to~: if Elizabeth has a subscription but the other party does not
      - ~from~: if Elizabeth is not subscribed to the contact’s
        presence but the other user has a subscription to her
        presence.
    * Generally, the user will only want to see contacts in the roster
      for which the subscription value is ~both~ or ~to~.
- ~sendIQ~
  #+BEGIN_SRC javascript
    Connection.sendIQ(iq_stanza, success_callback?, error_callback?, timeout?);
  #+END_SRC
*** Adding new contacts
- e.g.
  #+BEGIN_SRC js
    const data = {jid: jid, name: name};

    /* add to roster */
    conn.sendIQ(
      $iq({ type: "set" })
        .c("query", {
          xmlns: "jabber:iq:roster",
        })
        .c("item", data),


        function on_success() {
        /* subscribe to the added jid */
        conn.send(
          $pres({ to: data.jid, type: "subscribe" }),
        );
      },
    );
    },
  #+END_SRC

*** presence subscription request
- e.g.
  #+BEGIN_SRC js
    conn.send($pres({ to: data.jid, type: "subscribe" }),);
  #+END_SRC
  the other side can respond with ~subscribed~ or ~unsubscribed~
  #+BEGIN_SRC js
    conn.send($pres({to: jid, type: "subscribed"}));
  #+END_SRC
* Service Discovery
- ~disco#info~
  + returns basic identity information and supported features for an entity
  + Most XMPP entities you will interact with will respond to
    ~disco#info~ queries. Generally, these queries are concerned with
    two kinds of information: identity and features. Identity
    information contains the entity’s name and purpose, and some
    services may have multiple identities. Feature information is
    useful to discover which particular features a service
    supports. For example, a publish-subscribe service may report that
    it supports all the required and some of the optional features
    defined in the Publish-Subscribe specification (XEP-0060) and that
    it also supports several other extensions.
- ~disco#items~
  + enumerate an entity’s children.
  + Service discovery information is organized in the form of a
    tree. The disco#items query requests the list of children for an
    entity. Some of these children will be other entities and some
    will be internal nodes. By continuing to do disco#items queries on
    each child, the entire service tree can be expanded
  + e.g.
    #+BEGIN_SRC js
      /* Disco#items Queries */
      conn.sendIQ(
        $iq({
          type: "get",
          to: "chat.fhdhsni.me",
        }).c("query", {
          xmlns: "http://jabber.org/protocol/disco#items",
        }),
        function(res) {
          console.log(res);
        },
      );
    #+END_SRC
    result:
    #+BEGIN_SRC xml
      <iq xmlns="jabber:client"
          xml:lang="en"
          to="farhad@chat.fhdhsni.me/1724753382249485781820162"
          from="chat.fhdhsni.me"
          type="result"
          id="4d667938-5243-42ff-9e3c-e48151b8f244:sendIQ">
        <query xmlns="http://jabber.org/protocol/disco#items">
          <item jid="conference.chat.fhdhsni.me"/>
          <item jid="proxy.chat.fhdhsni.me"/>
          <item jid="pubsub.chat.fhdhsni.me"/>
          <item jid="upload.chat.fhdhsni.me"/>
        </query>
      </iq>
    #+END_SRC
    which can be continued with further discovering
    #+BEGIN_SRC js
      conn.sendIQ(
        $iq({
          type: "get",
          to: "conference.chat.fhdhsni.me",
        }).c("query", {
          xmlns: "http://jabber.org/protocol/disco#items",
        }),
        function(res) {
          console.log(res);
        },
      );
    #+END_SRC

    result:
    #+BEGIN_SRC xml
      <iq xmlns="jabber:client"
          xml:lang="en"
          to="farhad@chat.fhdhsni.me/494140291225571480820210"
          from="conference.chat.fhdhsni.me"
          type="result"
          id="bb23b24f-2924-4f25-952e-ea21fb43c0be:sendIQ">
        <query xmlns="http://jabber.org/protocol/disco#items">
          <item name="foo (private, 1)" jid="otime@conference.chat.fhdhsni.me"/>
          <item name="Foobar (private, 1)" jid="peral@conference.chat.fhdhsni.me"/>
        </query>
      </iq>
    #+END_SRC
* MUC
- MUC is also a form of message broadcast. A single message sent to a
  room gets rebroadcast out to all the participants
  automatically. This makes it similar to Publish-Subscribe. Unlike
  Publish-Subscribe, MUC provides a lot of advanced management
  features typical of group chat services, such as room moderation,
  and each participant is often allowed to broadcast messages to the
  room as well.
** Group chat services
- Group chat is provided as a service, usually alongside a regular
  XMPP server. The group chat service has its own domain; for example,
  the jabber.org server runs a group chat service at
  conference.jabber.org.
- Each room on the group chat service gets its own address, which
  looks just like a user’s JID. The XMPP developer’s chat room on the
  conference.jabber.org service is at jdev@conference.jabber.org, and
  general XMPP-related chat takes place in
  jabber@conference.jabber.org.
** entering and leaving a room
- Users can join a group chat room simply by sending available
  presence to the room, along with a note that they understand the
  multi-user chat protocol. Sending presence directly to a JID instead
  of to the user’s server is called directed presence. Similarly, to
  leave, unavailable presence is sent to the room.
- Sending presence stanzas directly to a JID instead of to the user’s
  server is called sending directed presence. Directed presence is
  quite useful in XMPP protocols and extensions because it has some
  special properties. Directed presence can be sent to users or
  services without requiring that presence subscriptions be set
  up. This is useful for giving another user or an external service
  temporary access to presence information. Another property of
  directed presence is that the server keeps track of who has received
  direct presence notifications. The server uses this information to
  ensure that the recipients are notified when the sender goes
  offline, even if the sender forgets to send unavailable presence
  before logging off. There is one limitation to be aware of when
  using directed presence — only unavailable presence is sent
  automatically. Presence changes from available to away or away to
  available are not automatically broadcast on the sender’s
  behalf. Because group chat services need to keep track of
  participants’ presence, direct presence fulfills a crucial role. The
  server rarely loses track of a participant’s presence, even if that
  person forgets to send unavailable presence.
- Every participant in a group chat room gets their own address as
  well. Each participant picks a nickname for the room, and their JID
  within the room is the room’s JID with a resource added containing
  their nickname. For example, Darcy’s nickname in the Meryton ball
  chat room is darcy, so his group chat JID is
  ~ball@chat.meryton.lit/darcy~
  + If Bingley and Jane want to join the group chat room for the
    Meryton ball, they will both need to send directed presence to
    their desired identity in the room ball@chat.meryton.lit. Their
    stanzas are shown here:
    #+BEGIN_SRC xml
      <presence to='ball@chat.meryton.lit/bingley'
                from='bingley@netherfield.lit/meryton'>
        <x xmlns='http://jabber.org/protocol/muc'/>
      </presence>

      <presence to='ball@chat.meryton.lit/jane'
                from='jane@longbourn.lit/meryton'>
        <x xmlns='http://jabber.org/protocol/muc'/>
      </presence>
    #+END_SRC
    * Once they have joined the room, the group chat service will
      broadcast all the other participants’ presence statuses to
      them. After all the other participants’ presence stanzas are
      sent, the server concludes the presence broadcast by sending the
      arriving participant’s presence to everyone, including the new
      arrival. Thus, when a new participant sees their own presence
      broadcast back to them, they know they have fully joined the
      room.
    * This is what Jane’s client will receive upon joining the room:
      #+BEGIN_SRC xml
        <presence to='jane@longbourn.lit/meryton'
          from='ball@chat.meryton.lit/elizabeth'>
          <x xmlns='http://jabber.org/protocol/muc'>
            <item affiliation='member' role='participant'/>
          </x>
        </presence>
        ..
        <presence to='jane@longbourn.lit/meryton'
          from='ball@chat.meryton.lit/bingley'>
          <x xmlns='http://jabber.org/protocol/muc'>
            <item affiliation='member' role='participant'/>
          </x>
        </presence>

        <presence to='jane@longbourn.lit/meryton'
          from='ball@chat.meryton.lit/jane'>
          <x xmlns='http://jabber.org/protocol/muc'>
            <item affiliation='member' role='participant'/>
            <status code='110'/>
          </x>
        </presence>
      #+END_SRC
      The room sends the affiliations and roles of each participant
      along with their presence. Jane’s own presence broadcast also
      includes a status code of 110, which signals that this presence
      refers to the user herself. Just as with presence updates from
      Jane’s roster, Jane will also receive presence updates from the
      room as people leave and new people join.
- Leaving a room is accomplished by sending unavailable presence to
  your room JID.
  #+BEGIN_SRC xml
  <presence to='ball@chat.meryton.lit/darcy'
            from='darcy@pemberley.lit/meryton'
            type='unavailable'/>
  #+END_SRC
** inviting
   #+BEGIN_EXPORT html
   <message to='elizabeth@longbourn.lit/sitting_room'
            from='toetem-456@games.pemberley.lit'>
     <x xmlns='http://jabber.org/protocol/muc#user'>
       <invite from='referee@pemberley.lit/toetem'/>
     </x>
   </message>

   <message to='jane@longbourn.lit/outside'
            from='toetem-456@games.pemberley.lit'>
     <x xmlns='http://jabber.org/protocol/muc#user'>
       <invite from='referee@pemberley.lit/toetem'/>
     </x>
   </message>
   #+END_EXPORT
** sending and receiving Messages
- Messages are sent to the room with a special type —
  ~groupchat~. Messages directed to the bare room JID,
  ~ball@chat.meryton.lit~, for example, are broadcast out to all
  occupants. Messages sent to the full JID of an occupant in the room
  are private and relayed by the room to the real JID of the user.
  #+BEGIN_SRC js
    conn.send(
      $msg({
        type: "groupchat",
        to: "peral@conference.chat.fhdhsni.me",
      })
        .c("body")
        .t("fuckers, watup?"),
    );
  #+END_SRC
** anonymity
- XMPP multi-user chat rooms have configurable levels of anonymity,
  unlike many other group chat systems. Three levels are currently
  defined in the specification:
  + non-anonymous
    * each occupant can see the real JID of the other occupants; the
      room will broadcast an extra jid attribute in the occupant’s
      presence updates.
  + semi-anonymous
    * only owners and admins can see the real JIDs of
      occupants. Semianonymous and non-anonymous rooms are the most
      common types, and most group chat services will be configured to
      use one of these as the default for newly created rooms.
  + fully anonymous
    *  are quite rare, and only server administrators have access to
      the real JIDs of participants of these rooms. Not even the
      room’s owner can access the real JIDs.
- Normal private messages cannot be sent to participants in
  semi-anonymous or anonymous rooms, as the sender does not have
  access to the participant’s actual JID. This is why private messages
  in group chat are sent to the participant’s room JID

** Creating rooms
- rooms can be created just by joining a non-existent room. Assuming
  the service allows the user to create new rooms, sending directed
  presence to the desired room JID of the new room will cause the room
  to be created and the user to be set as the room’s owner.
  #+BEGIN_SRC xml
    <presence to='chatter@chat.netherfield.lit/bingley'
              from='bingley@netherfield.lit/drawing_room'>
      <x xmlns='http://jabber.org/protocol/muc'/>
    </presence>
  #+END_SRC
  The ~chat.netherfield.lit~ service responds with the presence
  broadcast for the room’s new and only occupant:
  #+BEGIN_SRC xml
    <presence to='bingley@netherfield.lit/drawing_room'
      from='chatter@chat.netherfield.lit/bingley'>
      <x xmlns='http://jabber.org/protocol/muc'>
        <item affiliation='owner' role='moderator'/>
        <status code='110'/>
        <status code='201'/>
      </x>
    </presence>
  #+END_SRC
  + Bingley has the ~owner~ affiliation and the ~moderator~ role.
  + 201 means that a new room has been created.

- Once the room is created, the owner will usually configure it to
  behave as desired.
  + Room persistence, or whether the room will continue to exist after
    all participants have left
  + Room description
  + Whether the room’s messages should be logged
  + Whether participants are allowed to change the room’s topic
  + The maximum number of occupants
  + Access controls like membership lists
  + Room configuration is done with Data Forms (XEP-0004)

** Understanding roles and affiliations
- Occupants will usually have a role of ~participant~ and an affiliation
  of ~member~

- the room’s creator has a role of ~moderator~ and an affiliation of ~owner~

- Roles and affiliations enable or restrict functionality, but they
  apply on different time scales.

- An affiliation is a long-term property that persists across visits
  to the room

- but roles apply only to the current visit

- For example, when the room’s owner joins the room, their ~role~ is
  ~moderator~, and when they leave, their role becomes ~none~, but even
  after leaving, their ~affiliation~ remains as ~owner~.

- Roles and affiliations are mostly hierarchical, and each level has
  all the properties of the previous one as well a few new ones

- Group Chat Roles
  | Role        | Privileges                                                          |
  |-------------+---------------------------------------------------------------------|
  | None        | No permissions - not in the room                                    |
  | Visitor     | Can observe conversation, but can't talk                            |
  | Participant | Can fully participate in public conversation                        |
  | Moderator   | Can remove users from the room, or promote participants to visitors |

- Group Chat Affiliations
  | Affiliation | Privileges                                                                                             |
  |-------------+--------------------------------------------------------------------------------------------------------|
  | Outcast     | Banned from the room                                                                                   |
  | None        | Can join the room                                                                                      |
  | Member      | Can join even if room is members-only, and can retrieve the member list                                |
  | Admin       | Can ban members or unaffiliated users; can add and remove the member affiliation or the moderator role |
  | Owner       | Can add and remove admins and owners; can configure or destroy the room                                |

- Manipulating roles and affiliations is done via IQ-set and IQ-get
  stanzas. Modifying the role or affiliation of a participant usually
  causes new presence information to be broadcast to the room for the
  affected user.
  #+BEGIN_SRC xml
    <iq id="150dbf90-14b4-4635-83a9-00b6af7e29db" to="blah@conference.localhost" type="set">
      <query xmlns="http://jabber.org/protocol/muc#admin">
        <item nick="asghar" role="none"/>
      </query>
    </iq>
  #+END_SRC
  + Note that the nick attribute is used to specify nickname; because
    roles apply to a single room visit, changing roles is done by
    nicknames instead of JIDs.
  or
  #+BEGIN_SRC xml
    <iq id="0e4e7d38-56a3-432e-9d69-cebf5e074e58" to="blah@conference.localhost" type="set">
      <query xmlns="http://jabber.org/protocol/muc#admin">
          <item affiliation="outcast" jid="asghar@localhost"/>
      </query>
    </iq>
  #+END_SRC
** Managing the Room
- Topic changes are sent out as bodiless messages that contain a
  ~<subject>~ element, and the content of the ~<subject>~ element becomes
  the new room topic
  #+BEGIN_SRC javascript
    conn.send(
      $msg({
        to: "please@conference.localhost",
        type: "groupchat",
      })
        .c("subject")
        .t("this is the topic of the roommm"),
    );
  #+END_SRC
** kicking out and banning
- kick is temporary. the user is allowed to re-enter. A kicked is user has a role of ~none~
-

   #+BEGIN_SRC js
     /* kick someone out of the room */
     conn.sendIQ(
       $iq({
         to: "please@conference.localhost",
         type: "set",
       })
         .c("query", {
           xmln: "http://jabber.org/protocol/muc#admin",
         })
         .c("item", {
           role: "none",
           nick: "jafar@localhost",
         }),
       function(res) {
         console.log(res);
       },
     );

     /* Ban someone */
     ctx.conn!.sendIQ(
       $iq({
         to: "please@conference.localhost",
         type: "set",
       })
         .c("query", {
           xmln: "http://jabber.org/protocol/muc#admin",
         })
         .c("item", {
           affiliation: "outcast",
           jid: "jafar@localhost",
           /* Users must be banned using their bare JIDs,
              not their room nicknames  */
         }),
       function(res) {
         console.log(res);
       },
     );
   #+END_SRC

** make a jid admin
   #+BEGIN_SRC js
     connection.sendIQ(
       $iq({
         to: room,
         type: "set"
       })
         .c("query", {
           xmlns: Groupie.NS_MUC + "#admin"
         })
         .c("item", {
           jid: jid],
           affiliation: "admin"
         })
   #+END_SRC

* Publish-Subscribee (pubsub)
** Data Forms extension
- It allows applications to define a form with fields of various types
  — text fields, list fields, and address fields to name a few. It
  also provides a lightweight workflow on top of these forms enabling
  applications to request, provide, submit, and cancel forms.
- An example form is shown here. This form has a type attribute whose
  value is ~form~, which means that the system expects it to be filled
  it out.
  #+BEGIN_SRC html
    <x xmlns='jabber:x:data' type='form'>
      <title>A Simple Form</title>
      <instructions>Fill out this simple form!</instructions>
      <field type='text-single'
             label='What's your favorite color?'
             var='favorite_color'>
        <required/>
      </field>
    </x>
  #+END_SRC
  A completed version of the preceding form might look like this:
  #+BEGIN_SRC xml
    <x xmlns='jabber:x:data' type='submit'>
      <field type='text-single'
             var='favorite_color'>
        <value>orange</value>
      </field>
    </x>
  #+END_SRC
*** Form elements, Fields, and types
- ~<x>~
  + The ~<x>~ element is an historical artifact; if protocol designers
    were building Data Forms today, this would probably have been the
    more descriptive ~<form>~.
  + The ~type~ attribute in a form has four possible values: ~form~,
    ~submit~, ~cancel~, and ~result~. These relate to the form’s place in a
    particular workflow
  + A value of ~form~ means that the form is blank and needs filling out
  + The ~submit~ value is used when you return a completed form
  + If you change your mind about completing a form, you can send back
    an empty form with the ~cancel~ type.
  + ~result~ type is used when the form represents a generic data set,
    or the result of submitting a form generated some response
    data. After completing a new account form at the cheaper bank, the
    clerk creates the account and hands you a document containing your
    account details. This document is a form with a ~type~ of ~result~.
- ~<field>~
  + The heart of every form is the collection of fields waiting to be
    filled out or communicating result data.
  + Every field can have some metadata associated with it.
  + Fields may also contain the ~<required>~ element, which means that
    any submission of the form must include a value for that
    field. And just like the ~<instructions>~ element in the form
    itself, each field can have a ~<desc>~ element containing a
    human-readable description of the field’s purpose.
  + Every field must have a ~var~ attribute, which uniquely identifies
    the field. This can be any identifier you like, but most XMPP
    extensions use standardized form fields as defined in Field
    Standardization for Data Forms (XEP-0068).
  + Each field has a ~type~ attribute that describes the type of data
    for the field. The following types are defined:
    * ~text-single~: A single line of text, similar to ~<input type='text'>~ in HTML
    * ~text-private~: A single line of text that is obscured during
      entry, similar to ~<input type='password'>~ in HTML
    * ~text-multi~: Multiple lines of text, similar to ~<textarea>~ in HTML
    * ~list-single~: A single value from a predefined list of options,
      similar to ~<select>~ in HTML
    * ~list-multi~: Multiple values from a predefined list of options,
      similar to ~<select multiple='multiple'>~ in HTML
      - The options for ~list-single~ and ~list-multi~ fields are
        specified by including ~<option>~ elements as children of the
        field. Each ~<option>~ element can have a label attribute, and
        the value of the option is specified in a ~<value>~
        #+BEGIN_SRC html
          <field type='list-single' var='animals'
                 label='Pick an animal'>
            <option label='Fox'>
              <value>fox</value>
            </option>
            <option label='Hare'>
              <value>hare</value>
            </option>
            <option label='Tortoise'>
              <value>tortoise</value>
            </option>
          </field>
        #+END_SRC
    * ~jid-single~: A single JID
    * ~jid-multi~: Multiple JIDs
    * ~boolean~: Either ~true~ or ~false~
    * ~hidden~: A field hidden from the user and whose value is
      normally returned unmodified
    * ~fixed~: A human-readable description, used for section headers
      in the form
  + Fields may also specify a default value by including a ~<value>~
    element as an immediate child. If the field can have multiple
    values, as with ~list-multi~, ~jid-multi~, and ~text-multi~ fields,
    multiple ~<value>~ children can be present.
    #+BEGIN_SRC html
      <field type='jid-multi' var='admins'>
          <value>alice@example.com</value>
          <value>bob@example.com</value>
      </field>
    #+END_SRC

*** Standardized Form Fields (XEP-0068)
- having forms be so malleable does have a downside. How do you get
  everyone to agree what the fields should be for common forms? XMPP
  community addressed this problem with Field Standardization for Data
  Forms (XEP-0068)
- Each standardized form has a form type, which is encoded in a
  special field
  #+BEGIN_SRC html
    <x xmlns='jabber:x:data' type='submit'>
      <field var='FORM_TYPE' type='hidden'>
        <value>http://jabber.org/protocol/pubsub#node_config</value>
      </field>
      <field var='pubsub#title'>
        <value>Best Node Ever</value>
      </field>
    </x>
  #+END_SRC
  + The standardized form type is included as a special ~hidden~ field
    with a ~var~ attribute equal to ~FORM_TYPE~.
  + The value of this field is the form type’s identifier.
  + The pubsub extension defines several different types of forms, and
    consulting the pubsub specificrtion in XEP-0060, you can see that
    http://jabber.org/protocol/pubsub#node_config is the identifier
    for the node configuration form.
- Fields within a standardized form will have ~var~ attributes that are
  defined in the specification for the form.
  #+BEGIN_SRC html
    <form_type>
      <name>http://jabber.org/protocol/pubsub#node_config</name>
      <!-- parts omitted -->
      <field var='pubsub#title'
             type='text-single'
             label='A friendly name for the node'/>
      <!-- parts omitted -->
    </form_type>
  #+END_SRC
  The content of the ~<name>~ element is what will appear in the
  ~FORM_TYPE~ field, and the ~<field>~ element specifies what kind of
  field it will be.
** Working With pubsub nodes
- Pubsub nodes are the communication hubs of the publish-subscribe
  system. Users and applications can subscribe to a node that they are
  interested in, and when data is published there, the node will
  immediately broadcast that data to all subscribers.
- These nodes are provided by pubsub services. Nearly every XMPP
  server has a built-in pubsub service for its users.
- All you need to know to start using pubsub is the location of a
  pubsub service. You can create an interesting pubsub node, and to
  subscribe, a user needs to know the service’s address and the node’s
  name.

*** Creating nodes
- A pubsub node is created by sending an IQ-set stanza to the pubsub
  service:
  #+BEGIN_SRC html
    <iq to='pubsub.pemberley.lit'
        from='darcy@pemberley.lit/library'
        type='set'
        id='create1'>
      <pubsub xmlns='http://jabber.org/protocol/pubsub'>
        <create node='latest_books'/>
      </pubsub>
    </iq>
  #+END_SRC
  + Other than Service Discovery queries, pubsub-related actions all
    contain a ~<pubsub>~ element qualified by one of the pubsub
    namespaces. Here, http://jabber.org/protocol/pubsub is used, which
    is the main pubsub namespace, but some actions, such as node
    configuration, require related namespaces like
    http://jabber.org/protocol/pubsub#owner. It’s easy to assume that
    they are all the same.
  + It’s possible to let the server choose the name when you create a node.
   #+BEGIN_SRC html
     <iq to='pubsub.pemberley.lit'
         from='darcy@pemberley.lit/library'
         type='set'
         id='create1'>
       <pubsub xmlns='http://jabber.org/protocol/pubsub'>
         <create />
       </pubsub>
     </iq>
   #+END_SRC
   the server will include the node's name with its response
   #+BEGIN_EXPORT html
   <iq from='pubsub.pemberley.lit'
       to='darcy@pemberley.lit/library'
       type='result'
       id='instant1'>
     <pubsub xmlns='http://jabber.org/protocol/pubsub'>
       <create node='1390361429'/>
     </pubsub>
   </iq>
   #+END_EXPORT

*** Configuring nodes
- Pubsub node configuration is done by submitting a form inside a
  ~<configure>~ action. Node configuration must be done by the owner of
  the node, so the ~<pubsub>~ element’s namespace is slightly different
  than the previous example. First, request a configuration form to
  see what options are available:
  #+BEGIN_EXPORT html
  <iq from='darcy@pemberley.lit/library'
      to='pubsub.pemberley.lit'
      type='get'
      id='configure1'>
    <pubsub xmlns='http://jabber.org/protocol/pubsub#owner'>
      <configure node='latest_books'/>
    </pubsub>
  </iq>
  #+END_EXPORT
  a sample response
  #+BEGIN_SRC html
    <iq xmlns="jabber:client"
        xml:lang="en"
        to="farhad@localhost/15007739549779253443202"
        from="pubsub.localhost"
        type="result"
        id="d9b8262a-5e59-485e-9bf9-b21859475335:sendIQ">
        <pubsub xmlns="http://jabber.org/protocol/pubsub#owner">
            <configure node="latest_books">
                <x xmlns="jabber:x:data" type="form">
                    <field var="FORM_TYPE" type="hidden">
                        <value>http://jabber.org/protocol/pubsub#node_config</value>
                    </field>

                    <field var="pubsub#access_model" type="list-single" label="Specify the access model">
                        <value>open</value>
                        <option label="Subscription requests must be approved and only subscribers may retrieve items">
                            <value>authorize</value>
                        </option>
                        <option label="Anyone may subscribe and retrieve items">
                            <value>open</value>
                        </option>
                        <option label="Anyone with a presence subscription of both or from may subscribe and retrieve items">
                            <value>presence</value>
                        </option>
                        <option label="Anyone in the specified roster group(s) may subscribe and retrieve items">
                            <value>roster</value>
                        </option>
                        <option label="Only those on a whitelist may subscribe and retrieve items">
                            <value>whitelist</value>
                        </option>
                    </field>

                    <field var="pubsub#deliver_notifications" type="boolean" label="Deliver event notifications">
                        <value>1</value>
                    </field>

                    <field var="pubsub#deliver_payloads" type="boolean" label="Deliver payloads with event notifications">
                        <value>1</value>
                    </field>

                    <field var="pubsub#itemreply" type="list-single" label="Whether owners or publisher should receive replies to items">
                        <value>none</value>
                        <option label="Statically specify a replyto of the node owner(s)">
                            <value>owner</value>
                        </option>
                        <option label="Dynamically specify a replyto of the item publisher">
                            <value>publisher</value>
                        </option>
                        <option>
                            <value>none</value>
                        </option>
                    </field>

                    <field var="pubsub#max_items" type="text-single" label="Max # of items to persist">
                        <value>10</value>
                    </field>

                    <field var="pubsub#max_payload_size" type="text-single" label="Max payload size in bytes">
                        <value>250000</value>
                    </field>

                    <field var="pubsub#notification_type" type="list-single" label="Specify the event message type">
                        <value>headline</value>
                        <option label="Messages of type normal">
                            <value>normal</value>
                        </option>
                        <option label="Messages of type headline">
                            <value>headline</value>
                        </option>
                    </field>

                    <field var="pubsub#notify_config" type="boolean" label="Notify subscribers when the node configuration changes">
                        <value>0</value>
                    </field>

                    <field var="pubsub#notify_delete" type="boolean" label="Notify subscribers when the node is deleted">
                        <value>0</value>
                    </field>

                    <field var="pubsub#notify_retract" type="boolean" label="Notify subscribers when items are removed from the node">
                        <value>1</value>
                    </field>

                    <field var="pubsub#persist_items" type="boolean" label="Persist items to storage">
                        <value>1</value>
                    </field>

                    <field var="pubsub#presence_based_delivery" type="boolean" label="Only deliver notifications to available users">
                        <value>0</value>
                    </field>

                    <field var="pubsub#publish_model" type="list-single" label="Specify the publisher model">
                        <value>publishers</value>
                        <option label="Only publishers may publish">
                            <value>publishers</value>
                        </option>
                        <option label="Subscribers may publish">
                            <value>subscribers</value>
                        </option>
                        <option label="Anyone may publish">
                            <value>open</value>
                        </option>
                    </field>

                    <field var="pubsub#purge_offline" type="boolean" label="Purge all items when the relevant publisher goes offline">
                        <value>0</value>
                    </field>

                    <field var="pubsub#roster_groups_allowed" type="list-multi" label="Roster groups allowed to subscribe" />

                    <field var="pubsub#send_last_published_item" type="list-single" label="When to send the last published item">
                        <value>on_sub_and_presence</value>
                        <option label="Never">
                            <value>never</value>
                        </option>
                        <option label="When a new subscription is processed">
                            <value>on_sub</value>
                        </option>
                        <option label="When a new subscription is processed and whenever a subscriber comes online">
                            <value>on_sub_and_presence</value>
                        </option>
                    </field>

                    <field var="pubsub#subscribe" type="boolean" label="Whether to allow subscriptions">
                        <value>1</value>
                    </field>
                </x>
            </configure>
        </pubsub>
    </iq>
  #+END_SRC
  + The first field in the form is the form type identifier and after
    that are the normal fields
  + sample response of form completion
    #+BEGIN_EXPORT html
    <iq from='darcy@pemberley.lit/library'
        to='pubsub.pemberley.lit'
        type='set'
        id='configure2'>
      <pubsub xmlns='http://jabber.org/protocol/pubsub#owner'>
        <configure node='latest_books'>
          <x xmlns='jabber:x:data' type='submit'>
            <field var='FORM_TYPE'>
              <value>http://jabber.org/protocol/pubsub#node_config</value>
            </field>

            <field var='pubsub#title'>
              <value>Books I've Read Lately</value>
            </field>

            <field var='pubsub#persist_items'>
              <value>true</value>
            </field>

            <field var='pubsub#max_items'>
              <value>100</value>
            </field>
          </x>
        </configure>
      </pubsub>
    </iq>

    #+END_EXPORT

*** pubsub events
- The real value of pubsub nodes is in the events that are published
  to them and broadcast to subscribers
- Anything can be included in a pubsub event. The pubsub service
  doesn’t know or care what is inside the event; it simply broadcasts
  this data to a node’s subscribers. The content of a pubsub event is
  called its payload.
- When publishing, the event is wrapped in a ~<publish>~ action within
  the ~<pubsub>~ element, and when receiving events, the same event is
  carried in a ~<message>~ stanza. In both cases the event payload is
  the same.
  + e.g: Forms are flexible enough to represent many kinds of
    payloads:
    #+BEGIN_EXPORT html
    <x xmlns='jabber:x:data' type='result'>
      <field var='title'>
        <value>A History of Pemberley</value>
      </field>
      <field var='author'>
        <value>Sir Lewis de Bourgh</value>
      </field>
    </x>
    #+END_EXPORT
*** publishing to a node
    #+BEGIN_EXPORT html
    <iq from='darcy@pemberley.lit/library'
        to='pubsub.pemberley.lit'
        type='set'
        id='publish1'>
      <pubsub xmlns='http://jabber.org/protocol/pubsub'>
        <publish node='latest_books'>
          <item>
            <x xmlns='jabber:x:data' type='result'>
              <field var='title'>
                <value>A History of Pemberley</value>
              </field>
              <field var='author'>
                <value>Sir Lewis de Bourgh</value>
              </field>
            </x>
          </item>
        </publish>
      </pubsub>
    </iq>
    #+END_EXPORT

    the server will respond with
    #+BEGIN_SRC html
      <iq from='pubsub.pemberly.lit'
          to='darcy@pemberley.lit/library'
          type='result'
          id='publish1'>
        <pubsub pubsub xmlns='http://jabber.org/protocol/pubsub'>
          <publish node='latest_books'>
            <item id='821b576dfabfc6b358b6ec4139b87f5c'/>
          </publish>
        </pubsub>
      </iq>
    #+END_SRC
    Notice that the server’s response also includes an ~<item>~
    element. Because Mr. Darcy’s ~<item>~ element did not contain an ~id~
    attribute, the server created one for him since every item must
    have an identifier. These identifiers are used for notifications,
    item retrieval, and retraction.
*** subscribing and unsubscribing
**** subscribe
    #+BEGIN_EXPORT html
    <iq from='elizabeth@longbourn.lit/outside'
        to='pubsub.pemberley.lit'
        type='set'
        id='subscribe1'>
      <pubsub pubsub xmlns='http://jabber.org/protocol/pubsub'>
        <subscribe node='latest_books'
                   jid='elizabeth@longbourn.lit/outside'/>
      </pubsub>
    </iq>
    #+END_EXPORT
    server would respond with something like
    #+BEGIN_EXPORT html
    <iq xmlns="jabber:client"
        xml:lang="en"
        to="farhad@localhost/279101230134859417237"
        from="pubsub.localhost"
        type="result"
        id="6a9c8923-e746-4831-af26-9ee7d61be547:sendIQ">

      <pubsub xmlns="http://jabber.org/protocol/pubsub">
        <subscription subscription="subscribed"
                      subid="61D962811C04D"
                      node="latest_books"
                      jid="farhad@localhost/279101230134859417237"/>
      </pubsub>
    </iq>
    #+END_EXPORT
    + Event broadcasts are sent in ~<message>~ stanzas containing an
      ~<event>~ child with the http://jabber.org/protocol/pubsub#event
      namespace. The ~<event>~ element will contain one or more ~<item>~
      elements wrapped in an ~<items>~ element; the payloads are
      contained within the ~<item>~ elements, if included.
      #+BEGIN_EXPORT html
      <message from='pubsub.pemberley.lit'
               to='elizabeth@longbourn.lit/outside'>
        <event xmlns='http://jabber.org/protocol/pubsub#event'>
          <items node='latest_books'>
            <item id='821b576dfabfc6b358b6ec4139b87f5c'>
              <x xmlns='jabber:x:data' type='result'>
                <field var='title'>
                  <value>A History of Pemberley</value>
                </field>
                <field var='author'>
                  <value>Sir Lewis de Bourgh</value>
                </field>
              </x>
            </item>
          </items>
        </event>
      </message>
      #+END_EXPORT

**** unsubscribe
     #+BEGIN_EXPORT html
     <iq from='georgiana@pemberley.lit/piano'
         to='pubsub.pemberley.lit'
         type='set'
         id='unsubscribe1'>
       <pubsub pubsub xmlns='http://jabber.org/protocol/pubsub'>
         <unsubscribe node='latest_books'
                      jid='georgiana@pemberley.lit/piano'/>
       </pubsub>
     </iq
     #+END_EXPORT
     the server response
     #+BEGIN_EXPORT html
     <iq from='pubsub.pemberley.lit'
         to='georgiana@pemberley.lit/piano'
         type='result'
         id='unsubscribe1'/>
     #+END_EXPORT

*** retrieving subscriptions
- query the list of subscribers
  #+BEGIN_EXPORT html
  <iq from='darcy@pemberley.lit/library'
      to='pubsub.pemberley.lit'
      type='get'
      id='subscribers1'>
    <pubsub xmlns='http://jabber.org/protocol/pubsub#owner'>
      <subscriptions node='latest_books'/>
    </pubsub>
  </iq>
  #+END_EXPORT
  server responds with sth like
  #+BEGIN_SRC html
    <iq from='pubsub.pemberley.lit'
        to='darcy@pemberley.lit/library'
        type='result'
        id='subscribers1'>
      <pubsub xmlns='http://jabber.org/protocol/pubsub#owner'>
        <subscriptions node='latest_books'>
          <subscription jid='elizabeth@longbourn.lit/outside'
                        subscription='subscribed'/>
          <subscription jid='bingley@netherfield.lit/house'
                        subscription='subscribed'/>
        </subscriptions>
      </pubsub>
    </iq>
  #+END_SRC

*** retrieving items
+ e.g.
    #+BEGIN_EXPORT html
    <iq from='elizabeth@longbourn.lit/outside'
        to='pubsub.pemberley.lit'
        type='get'
        id='items1'>
      <pubsub xmlns='http://jabber.org/protocol/pubsub'>
        <items node='latest_books' max_items='3'/>
      </pubsub>
    </iq>
    #+END_EXPORT
+ The server responds with the requested items along with their
  payloads:
  #+BEGIN_EXPORT html
  <iq from='pubsub.pemberley.lit'
      to='elizabeth@longbourn.lit/outside'
      type='result'
      id='items1'>
    <pubsub xmlns='http://jabber.org/protocol/pubsub'>
      <items node='latest_books'>
        <item id='4f900045977f0ccd372c4a670bcba27f'>
          <x xmlns='jabber:x:data' type='result'>
            <field var='title'>
              <value>Of Acquaintances and Persuasion</value>
            </field>
            <field var='author'>
              <value>Daleforth Carnham</value>
            </field>
          </x>
        </item>
        <item id='16ddab0d5b3572388446c552d1bdf793'>
          <x xmlns='jabber:x:data' type='result'>
            <field var='title'>
              <value>Managing Temperment</value>
            </field>
            <field var='author'>
              <value>Sarah Pratt</value>
            </field>
          </x>
        </item>
        <item id='e4139c9d583558c172a28f68ec036c6c'>
          <x xmlns='jabber:x:data' type='result'>
            <field var='title'>
              <value>The Haunting at Hertfordshire</value>
            </field>
            <field var='author'>
              <value>Sir William Lucas</value>
            </field>
          </x>
        </item>
      </items>
    </pubsub>
  </iq>
  #+END_EXPORT

+ The node could have been configured to send only notifications, in
  which case the payloads would be missing. the response would've been like:
  #+BEGIN_EXPORT html
  <iq from='pubsub.pemberley.lit'
      to='elizabeth@longbourn.lit/outside'
      type='result'
      id='items1'>
    <pubsub xmlns='http://jabber.org/protocol/pubsub'>
      <items node='latest_books'>
        <item id='4f900045977f0ccd372c4a670bcba27f'/>
        <item id='16ddab0d5b3572388446c552d1bdf793'/>
        <item id='e4139c9d583558c172a28f68ec036c6c'/>
      </items>
    </pubsub>
  </iq>
  #+END_EXPORT
  a separate request must be sent to the server to retreve the items
  with their payloads:
  #+BEGIN_EXPORT html
  <iq from='elizabeth@longbourn.lit/outside'
      to='pubsub.pemberley.lit'
      type='get'
      id='items2'>
    <pubsub xmlns='http://jabber.org/protocol/pubsub'>
      <items node='latest_books'>
        <item id='4f900045977f0ccd372c4a670bcba27f'/>
        <item id='16ddab0d5b3572388446c552d1bdf793'/>
        <item id='e4139c9d583558c172a28f68ec036c6c'/>
      </items>
    </pubsub>
  </iq>
  #+END_EXPORT
  If a node is configured to send only notifications, subscribers will
  receive ~<message>~ containing a list of items that are new. A similar
  retrieval process is necessary to get the event payloads for these
  items.

*** subscription management
- When subscribing to a pubsub node, you must include the JID at which
  you want to receive event notifications. This JID can be either the
  bare JID (as with ~elizabeth@longbourn.lit~) or a full JID (as with
  ~darcy@pemberley.lit/library~). Because delivery of events is done
  with ~<message>~ stanzas, the delivery semantics are different
  depending on whether a subscription is for the bare or full
  JID. Whether an application should use the bare or full JID depends
  on the situation
- Normally, each subscription will last as long as the pubsub node
  exists or until the user unsubscribes. A pubsub node can also have a
  different subscription life cycle; the specification contains
  several examples of expiring subscriptions (see section 12.18 of
  XEP-0060 for an example). For instance, anonymously connected users’
  subscriptions will be removed when their session terminates, even if
  they never unsubscribe explicitly. Some clever developers are even
  working on presence-based subscriptions that can be canceled as soon
  as the subscriber goes offline.

**** get a list of your subscriptions
     #+BEGIN_EXPORT html
     <iq from='elizabeth@longbourn.lit/outside'
         to='pubsub.pemberley.lit'
         type='get'
         id='mysubs1'>
       <pubsub xmlns='http://jabber.org/protocol/pubsub'>
         <subscriptions/> <!-- could specify a node attribute on the <subscriptions> action to limit to a specific node. -->
       </pubsub>
     </iq>
     #+END_EXPORT
* Extending The XMPP Protocol
- XML documents are easily extensible through the use of
  namespaces. Every attribute or element is attached to some
  namespace, and new elements and attributes can be added under
  different namespaces. XMPP systems are designed to ignore XML under
  namespaces they don’t recognize, but they will forward these
  payloads along to their final destinations. This combination of
  features makes XMPP easy to extend.
** ignoring the unknown
- XMPP extensions work because XMPP systems do not require knowledge
  of every bit of XML passing through. New things can be added without
  breaking existing XMPP software, and anything unknown will not only
  be ignored, but it will also be preserved until it is finally
  delivered to its destination.
** XML namespaces
- Namespaces are important for defining XMPP extensions because they
  allow the addition of elements and attributes that will be
  interpreted in a new context.
- An XML namespace is simply a URI, or uniform resource identifier. It
  is important to note that although a URI may sometimes look like a
  URL, it does not necessarily reference an actual location on the
  Web.
- XML elements can have a default namespace, and this namespace is
  inherited by child elements that have no namespace declaration of
  their own. For instance, XMPP client streams use a default namespace
  of jabber:client; a <message> element in the stream does not need to
  declare itself part of the jabber:client namespace because it will
  inherit this property from the default namespace. This inheritance
  is quite handy because it saves having to declare the namespace of
  every element; most of the time, elements will all be in a common,
  inherited namespace
** extended elements
- Extended elements are just new child elements that live under a
  different namespace.
- There’s no restriction on where you can place extended elements,
  except that you cannot normally place an extended element at the
  XMPP stanza level. XMPP extensions routinely add extended ele‑ ments
  even to other XMPP extensions’ elements.
- Extended elements can appear two ways. Either they can declare a new
  default namespace by including the xmlns attribute in the element,
  or they can use namespace prefixes.
*** Changing the Default Namespace
- Changing the default namespace is the most common method used with
  extended elements. Any element can declare the default namespace by
  setting the value of the ~xmlns~ attribute to the namespace desired
  #+BEGIN_EXPORT html
  <message to='elizabeth@longbourn.lit/bedroom'
           from='pubsub.pemberley.lit'>
    <event xmlns='http://jabber.org/protocol/pubsub#event'>
      <items node='latest_books'>
        <item id='821b576dfabfc6b358b6ec4139b87f5c'>
          <x xmlns='jabber:x:data' type='result'>
            <field var='title'>
              <value>A History of Pemberley</value>
            </field>
            <field var='author'>
              <value>Sir Lewis de Bourgh</value>
            </field>
          </x>
        </item>
      </items>
    </event>
  </message>
  #+END_EXPORT
  The above example shows a ~<message>~ stanza with an extended
  ~<event>~ child under a new default namespace. Some children under the
  ~<event>~ element are also under the new namespace because they have
  no namespace specifically declared, and the ~<x>~ element declares
  another default namespace for the form and its children.
*** Namespace Prefixes
- Prefixes must be defined before or at the time of their use, and
  descendants of an element that defines a prefix will also inherit
  the prefix’s definition. The prefix is defined by including an
  ~xmlns:foo~ attribute, where ~foo~ is the prefix you want you use.

    #+BEGIN_EXPORT html
    <message to='elizabeth@longbourn.lit/bedroom'
             from='pubsub.pemberley.lit'>
      <pubsub:event xmlns:pubsub='http://jabber.org/protocol/pubsub#event'>
        <pybsub:items node='latest_books'>
          <pubsub:item id='821b576dfabfc6b358b6ec4139b87f5c'>
            <form:x xmlns:form='jabber:x:data' type='result'>
              <form:field var='title'>
                <form:value>A History of Pemberley</form:value>
              </form:field>
              <form:field var='author'>
                <form:value>Sir Lewis de Bourgh</form:value>
              </form:field>
            </form:x>
          </pubsub:item>
    </pubsub:items>
    </pubsub:event>
    </message>
    #+END_EXPORT

*** extended attributes
- Extended attributes can also be created, but these are rarely used
  in protocol extensions. Attributes are treated somewhat differently
  in XML than elements; an attribute with no prefix does not belong to
  the default namespace, but to the element in which it appears. What
  interpretation an element gives to such an attribute is application
  defined. For this reason, it is suggested that only prefixed
  attributes be used for extending XMPP.

- Prefixed attributes work very similarly to prefixed elements, and
  the prefix must be defined in the same manner as with prefixed
  elements. The following example uses a prefixed attribute on a
  message’s <body> element to add an explicit emotion to the text:

  #+BEGIN_SRC html
    <message to='darcy@pemberley.lit'
             from='elizabaeth@longbourn.lit/ballroom'
             type='chat'>
      <body emote:emotion='annoyed' xmlns:emote='http;//metajack.im/ns/emote-0'>
        I cannot talk of books in a ball-room; my head is always full of
        something else.
      </body>
    </message>
  #+END_SRC

- One prefix is always defined — xml — and this prefix is often used
  to add attributes to various XMPP elements. In addition, any prefix
  beginning with “xml” (or “XML”, “xMl”, and so on) is reserved. Most
  often you will see the ~xml:lang~ attribute used to designate which
  language is used for a piece of text. It can also be used to provide
  alternate translations. For example, you could send a message with
  two ~<body>~ elements, each with a different ~xml:lang~ value. Unlike
  other prefixes, the xml prefix does not need to be defined; it is
  always implicitly defined in XML, as is the ~xmlns~ attribute.

* Strophe Plug-in
- Plug-ins are created by making a prototype object that defines the
  plug-in’s functionality and registering that prototype with the
  Strophe library. When a new Strophe connection is created, it
  creates a plug-in object from the plug-in prototype and calls the
  object’s ~init()~ function to initialize the plug-in. After
  initialization, the plug-in is ready to be used by your application
  code.
- The ~init()~ function also serves another purpose. Most plug-ins will
  need to send data over the XMPP connection and set up stanza
  handlers, and for these tasks, the plug-in needs access to a
  Strophe.Connection object. Strophe will pass the connection object
  as the first parameter to ~init()~, and the plug-in can then save this
  reference for later use.
- Another function common to most plug-ins is ~statusChanged()~. Strophe
  calls each plug-in’s ~statusChanged()~ function whenever the
  connection status changes.
- This allows the plug-in to react to events like ~CONNECTED~ and
  ~DISCONNECTED~. This function is optional, because some plug-ins only
  need to respond to direct invocation.
- Example
  #+BEGIN_SRC javascript
    Strophe.addConnectionPlugin('simple', {
      init: function (connection) {
        this.connection = connection;
      },
      online: function () {
        this.connection.send($pres());
      },
      offline: function () {
        this.connection.send($pres({type: “unavailable”}));
      }
    });
  #+END_SRC
  + users of this plugin can
    #+BEGIN_SRC js
      connection.simple.online() // to send available presence and
      connection.simple.offline() // to send unavailable presence
    #+END_SRC
  + Registering new Strophe plug-ins is accomplished via the
    ~addConnectionPlugin()~ function. This function takes the name of
    the plug-in and the plug-in prototype as arguments.
  + These plug-ins are called connection plug-ins because they augment
    the ~Strophe.Connection~ object.
- Strophe plug-ins can augment the namespaces available in the
  ~Strophe.NS~ object by using ~.addNamespace()~.
  #+BEGIN_SRC javascript
    Strophe.addNamespace('DISCO_INFO', 'http://jabber.org/protocol/disco#info';
    Strophe.addNamespace('DISCO_ITEMS', 'http://jabber.org/protocol/disco#items';
  #+END_SRC
** Creating a roster plug-in
- Managing the roster involves a few basic operations:
  + First, you’ll need to query the roster and store it.
  + Then you’ll need ways to add, edit, and delete roster items.
  + Because other connection resources might also be making roster
    changes, you’ll need to listen for those and update the roster
    accordingly
  + Finally, you will want to keep the status of your roster fresh as
    presence information comes in from your contacts.
*** storing Contacts
- Following is a sample roster expressed as a JavaScript literal
  #+BEGIN_SRC js
    contacts = {
      "darcy@pemberley.lit" {
        name: "Darcy",
        resources: {
          "library":, {
            show: "away",
            status: "reading"
          }
        },
        subscription: "both",
        ask: "",
        groups: ["Family"]
      },
      "bingley@netherfield.lit": {
        name: "Charles",
        resources: {},
        subscription: "both",
        ask: "",
        groups: ["Friends"]
      }
    };
  #+END_SRC


** XEPs
*** XEP-0136: Message Archiving
- depricated, see XEP-0313 (Ejabberd supports XEP-0313)
*** XEP-0313
- Ejabberd supports this XEP
- A stored message consists of at least the following pieces of
  information:
  + A timestamp of when the message was sent (for an outgoing message)
    or received (for an incoming message).
  + The remote JID that the stanza is to (for an outgoing message) or
    from (for an incoming message).
  + A server-assigned UID that MUST be unpredictable and unique within
    the archive.
  + The message stanza itself. The entire original stanza SHOULD be
    stored, but at a minimum only the ~<body/>~ tag MUST be preserved
    (ie. the server might, at its discretion, strip certain extensions
    from messages before storage).
- Note that 'incoming' and 'outgoing' messages are viewed within the
  context of the archived JID, rather than the system as a whole. For
  example, if romeo@montegue.lit sent a message to juliet@capulet.lit,
  it would be an outgoing message in the context of archiving for
  Romeo, and an incoming message in the context of archiving for
  Juliet.

**** Order of messages
- Order within the archive MUST be preserved, where the order of
  messages is the same as the order that the client originally
  received them (or would have received them if online). however
  implementors should take care not to rely on timestamps alone for
  ordering messages, as multiple messages may share the same
  timestamp.

**** Querying an archive
- An entity is able to query (subject to appropriate access rights) an
  archive for all messages within a certain timespan, optionally
  restricting results to those to/from a particular JID. To allow
  limiting the results or paging through them a client may use Result
  Set Management (XEP-0059), which MUST be supported by both the
  client and the server.

- A query consists of an ~<iq/>~ stanza of type 'set' addressed to the
  account or server entity hosting the archive, with a 'query'
  payload. On receiving the query, the server pushes to the client a
  series of messages in chronological order from the archive that
  match the client's given criteria. After the results it then returns
  the ~<iq/>~ result to indicate that the query is completed.

- The final ~<iq/>~ result response MUST include an RSM ~<set/>~ element,
  wrapped into a ~<fin/>~ element qualified by the ~'urn:xmpp:mam:2'~
  namespace, indicating the UID of the first and last message of the
  (possibly limited) result set. This allows clients to accurately
  page through messages.

**** Filtering results
- By default all messages match a query, and filters are used to
  request a subset of the archived messages. Filters are specified in
  a Data Forms (XEP-0004) data form included with the query. The
  hidden FORM_TYPE field MUST be set to this protocol's namespace,
  'urn:xmpp:mam:2'. Three further fields are defined by this XEP and
  MUST be supported by servers, though all of them are optional for
  the client. These fields are:
  + ~start~
  + ~end~
  + ~with~
**** Filtering by JID
- If a 'with' field is present in the form, it contains a JID against
  which to match messages. The server MUST only return messages if
  they match the supplied JID. A message in a user's archive matches
  if the JID matches either the to or from of the message. An item in
  a pubsub or MUC archive matches if the publisher of the item matches
  the JID; note that this should only be available to entities that
  would already have been allowed to know the publisher of the events
  (e.g. this could not be used by a visitor to a semi-anonymous MUC).
  #+BEGIN_SRC html
    <iq type="set"
        xmlns="jabber:client"
        id="9ff2acd4-49cb-42a7-a677-e67169432947:sendIQ">
      <query xmlns="urn:xmpp:mam:2">
        <x xmlns="jabber:x:data" type="submit">
          <field var="FORM_TYPE" type="hidden">
            <value>urn:xmpp:mam:2</value>
          </field>
          <field var="with"> <!-- here -->
            <value>jafar@localhost</value>
          </field>
          <field var="start">
            <value>2010-06-07T00:00:00Z</value>
          </field>
        </x>
        <set xmlns="http://jabber.org/protocol/rsm">
          <max>100</max>
          <before/>
        </set>
      </query>
    </iq>
  #+END_SRC
- If the ~with~ field's value is the bare JID of the archive, the
  server must only return results where both the 'to' and 'from' match
  the bare JID (either as bare or by ignoring the resource), as
  otherwise every message in the archive would match
- If ~with~ is omitted, the server MUST match all messages in the
  selected timespan with the query, regardless of the to/from
  addresses on each message.
**** Filtering by time received
- The 'start' and 'end' fields, if provided, MUST contain timestamps
  formatted according to the DateTime profile defined in XMPP Date and
  Time Profiles (XEP-0082)
- The 'start' field is used to filter out messages before a certain
  date/time. If specified, a server MUST only return messages whose
  timestamp is equal to or later than the given timestamp.
- If omitted, the server SHOULD assume the value of 'start' to be
  equal to the date/time of the earliest message stored in the
  archive.
- Conversely, the 'end' field is used to exclude from the results
  messages after a certain point in time. If specified, a server MUST
  only return messages whose timestamp is equal to or earlier than the
  timestamp given in the 'end' field.
- If omitted, the server SHOULD assume the value of 'end' to be equal
  to the date/time of the most recent message stored in the archive.
  #+BEGIN_EXPORT html
  <!-- Querying the archive for all messages in a certain timespan¶ -->
  <iq type='set' id='juliet1'>
    <query xmlns='urn:xmpp:mam:2'>
      <x xmlns='jabber:x:data' type='submit'>
        <field var='FORM_TYPE' type='hidden'>
          <value>urn:xmpp:mam:2</value>
        </field>
        <field var='start'>
          <value>2010-06-07T00:00:00Z</value>
        </field>
        <field var='end'>
          <value>2010-07-07T13:23:54Z</value>
        </field>
      </x>
    </query>
  </iq>

  <!-- Querying the archive for all messages after a certain time¶ -->
  <iq type='set' id='juliet1'>
    <query xmlns='urn:xmpp:mam:2'>
      <x xmlns='jabber:x:data' type='submit'>
        <field var='FORM_TYPE' type='hidden'>
          <value>urn:xmpp:mam:2</value>
        </field>
        <field var='start'>
          <value>2010-08-07T00:00:00Z</value>
        </field>
      </x>
    </query>
  </iq>
  #+END_EXPORT

**** Limiting results
- Finally, in order for the client or server to limit the number of
  results transmitted at a time a server MUST support Result Set
  Management (XEP-0059) and MUST support the paging mechanism
  defined therein. A client MAY include a ~<set/>~ element in its query.
  #+BEGIN_EXPORT html
  <iq type='set' id='q29302'>
    <query xmlns='urn:xmpp:mam:2'>
      <x xmlns='jabber:x:data' type='submit'>
        <field var='FORM_TYPE' type='hidden'>
          <value>urn:xmpp:mam:2</value>
        </field>
        <field var='start'>
          <value>2010-08-07T00:00:00Z</value>
        </field>
      </x>
      <set xmlns='http://jabber.org/protocol/rsm'>
        <max>10</max>
      </set>
    </query>
  </iq>
  #+END_EXPORT
  #+BEGIN_EXPORT html
   <!-- Server responds to client with limited results using RSM¶ -->
  <!-- result messages -->
  <iq type='result' id='q29302'>
    <fin xmlns='urn:xmpp:mam:2'>
      <set xmlns='http://jabber.org/protocol/rsm'>
        <first index='0'>28482-98726-73623</first>
        <last>09af3-cc343-b409f</last>
        <count>20</count>
      </set>
    </fin>
  </iq>
  #+END_EXPORT
- The ~<first>~ and ~<last>~ elements specify the UID of the first and
  last returned results (not necessarily of all the messages that
  matched the query, if the results have been limited).
- The RSM ~<count>~ element and the ~index~ attribute on the RSM ~<first>~
  element are optional, but servers SHOULD include them.
  :note:
   note from RSM:

   The responding entity SHOULD also include the number of items in the
   full result set (which MAY be approximate) encapsulated in a
   ~<count/>~ element. The ~<first/>~ element SHOULD include an ~index~
   attribute. This integer specifies the position within the full set
   (which MAY be approximate) of the first item in the page. If that
   item is the first in the full set, then the index SHOULD be '0'. If
   the last item in the page is the last item in the full set, then the
   value of the <first/> element's 'index' attribute SHOULD be the
   specified count minus the number of items in the last page.
  :end:

**** Paging through results
- Having previously made a query that returned results limited by the
  server (as described above), a client can re-send the same request
  and receive the next 'page' of results. It does this by including a
  ~<set>~ element with its request, containing an ~<after/>~ with the UID
  of the last message it received from the previous query.
  #+BEGIN_EXPORT html
  <iq type='set' id='q29303'>
    <query xmlns='urn:xmpp:mam:2'>
        <x xmlns='jabber:x:data' type='submit'>
          <field var='FORM_TYPE' type='hidden'>
            <value>urn:xmpp:mam:2</value>
          </field>
          <field var='start'>
            <value>2010-08-07T00:00:00Z</value>
          </field>
        </x>
        <set xmlns='http://jabber.org/protocol/rsm'>
           <max>10</max>
           <after>09af3-cc343-b409f</after>
        </set>
    </query>
  </iq>
  #+END_EXPORT
- If the UID contained within an ~<after>~ or ~<before>~ element is not
  present in the archive, the server MUST return an item-not-found
  error in response to the query
**** Retrieving form fields
- Client requests supported query fields
  #+BEGIN_EXPORT html
  <iq type='get' id='form1'>
    <query xmlns='urn:xmpp:mam:2'/>
  </iq>
  #+END_EXPORT
  response:
  #+BEGIN_EXPORT html
  <iq type='result' id='form1'>
    <query xmlns='urn:xmpp:mam:2'>
      <x xmlns='jabber:x:data' type='form'>
        <field type='hidden' var='FORM_TYPE'>
          <value>urn:xmpp:mam:2</value>
        </field>
        <field type='jid-single' var='with'/>
        <field type='text-single' var='start'/>
        <field type='text-single' var='end'/>
        <field type='text-single' var='urn:example:xmpp:free-text-search'/>
        <field type='text-single' var='urn:example:xmpp:stanza-content'/>
      </x>
    </query>
  </iq>
  #+END_EXPORT
**** Query results
- sample server repsonse
  #+BEGIN_EXPORT html
  <message id='aeb213' to='juliet@capulet.lit/chamber'>
    <result xmlns='urn:xmpp:mam:2' queryid='f27' id='28482-98726-73623'>
      <forwarded xmlns='urn:xmpp:forward:0'>
        <delay xmlns='urn:xmpp:delay' stamp='2010-07-10T23:08:25Z'/>
        <message xmlns='jabber:client'
          to='juliet@capulet.lit/balcony'
          from='romeo@montague.lit/orchard'
          type='chat'>
          <body>Call me but love, and I'll be new baptized; Henceforth I never will be Romeo.</body>
        </message>
      </forwarded>
    </result>
  </message>

  <message id='aeb214' to='juliet@capulet.lit/chamber'>
    <result xmlns='urn:xmpp:mam:2' queryid='f27' id='5d398-28273-f7382'>
      <forwarded xmlns='urn:xmpp:forward:0'>
        <delay xmlns='urn:xmpp:delay' stamp='2010-07-10T23:09:32Z'/>
        <message xmlns='jabber:client'
           to='romeo@montague.lit/orchard'
           from='juliet@capulet.lit/balcony'
           type='chat' id='8a54s'>
          <body>What man art thou that thus bescreen'd in night so stumblest on my counsel?</body>
        </message>
      </forwarded>
    </result>
  </message>
  #+END_EXPORT

*** XEP-0059: Result Set Management
**** Requesting the Last Page in a Result Set
- The requesting entity MAY ask for the last page in a result set by
  including in its request an empty <before/> element, and the maximum
  number of items to return.
  #+BEGIN_EXPORT html
  <iq type='set' from='stpeter@jabber.org/roundabout' to='users.jabber.org' id='page1'>
    <query xmlns='jabber:iq:search'>
      <nick>Pete</nick>
      <set xmlns='http://jabber.org/protocol/rsm'>
        <max>10</max>
        <before/>
      </set>
    </query>
  </iq>
  #+END_EXPORT
* RFC 6121
- Ask Attribute of roster item
  - The ~ask~ attribute of the ~<item/>~ element with a value of
    "subscribe" is used to signal various subscription sub-states that
    include a "Pending Out" aspect.
  - A server SHOULD include the ~ask~ attribute to inform the client
    of "Pending Out" sub-states. A client MUST NOT include the 'ask'
    attribute in the roster sets it sends to the server, but instead
    MUST use presence stanzas of type "subscribe" and "unsubscribe" to
    manage such sub-states.

- subscription attribute of roster item
  - ~none~
  - ~to~
  - ~from~
  - ~both~
  - ~remove~
    + in a roster set, the 'subscription' attribute MAY be included
      with a value of "remove", which indicates that the item is to be
      removed from the roster; in a roster set the server MUST ignore
      all values of the 'subscription' attribute other than
      "remove". Inclusion of the 'subscription' attribute is OPTIONAL.
- roster push type is ~set~
- Deleting a Roster Item
  + At any time, a client can delete an item from his or her roster by
    sending a roster set and specifying a value of "remove" for the
    'subscription' attribute.

    C:
    #+BEGIN_SRC xml
      <iq from='juliet@example.com/balcony'
          id='hm4hs97y'
          type='set'>
          <query xmlns='jabber:iq:roster'>
            <item jid='nurse@example.com'
                  subscription='remove'/>
          </query>
        </iq>
    #+END_SRC
    Success Case:
    + As with adding a roster item, if the server can successfully
      process the roster set then it MUST update the item in the
      user's roster, send a roster push to all of the user's
      interested resources (with the 'subscription' attribute set to a
      value of "remove"), and send an IQ result to the initiating
      resource.
    + In addition, the user's server might need to generate one or
      more subscription-related presence stanzas, as follows:
      * If the user has a presence subscription to the contact, then
        the user's server MUST send a presence stanza of type
        "unsubscribe" to the contact (in order to unsubscribe from the
        contact's presence).
      * If the contact has a presence subscription to the user, then
        the user's server MUST send a presence stanza of type
        "unsubscribed" to the contact (in order to cancel the
        contact's subscription to the user).
      * If the presence subscription is mutual, then the user's server
        MUST send both a presence stanza of type "unsubscribe" and a
        presence stanza of type "unsubscribed" to the contact.
        S:
        #+BEGIN_SRC xml
          <presence from='juliet@example.com'
                    id='lm3ba81g'
                    to='nurse@example.com'
                    type='unsubscribe'/>
        #+END_SRC

        S:
        #+BEGIN_SRC xml
          <presence from='juliet@example.com'
                    id='xb2c1v4k'
                    to='nurse@example.com'
                    type='unsubscribed'/>
        #+END_SRC

- presence types
  + ~unavailable~ -- Signals that the entity is no longer available
    for communication.

  + ~subscribe~ -- The sender wishes to subscribe to the recipient's
    presence.

  + ~subscribed~ -- The sender has allowed the recipient to receive
    their presence.

  + ~unsubscribe~ -- The sender is unsubscribing from another entity's
    presence.

  + ~unsubscribed~ -- The subscription request has been denied or a
    previously-granted subscription has been cancelled.

  + ~probe~ -- A request for an entity's current presence; SHOULD be
    generated only by a server on behalf of a user.

  + ~error~ -- An error has occurred regarding processing or delivery
    of a previously-sent presence stanza.

- interested resource and available resource
  + Upon authenticating with a server and binding a resource (thus
    becoming a connected resource), a client SHOULD request the roster
    before sending initial presence (however, because receiving the
    roster is not necessarily desirable for all resources, e.g., a
    connection with limited bandwidth, the client's request for the
    roster is not mandatory). After a connected resource sends initial
    presence (see Section 4.2), it is referred to as an "available
    resource". If a connected resource or available resource requests
    the roster, it is referred to as an "interested resource". The
    server MUST send roster pushes to all interested resources.

* MUC XEP 0045 SPEC
- *room JID*: Each room is identified as a "room JID" ~<room@service>~ (e.g. ~<jdev@conference.jabber.org>~),
  where "room" is the name of the room and "service" is the hostname
  at which the multi-user chat service is running.
- room ID: the local part of room room JID

- room name: A user-friendly, natural-language name for a room,
  configured by the room owner and presented in Service Discovery
  queries; contrast with Room ID.

- Room Nickname: The resourcepart of an Occupant JID; this is the
  "friendly name" by which an occupant is known in the room.

- *occupant JID*: Each occupant in a room is identified as an "occupant JID"
  ~<room@service/nick>~, where "nick" is the room nickname of the
  occupant as specified on entering the room or subsequently changed
  during the occupant's visit.

- room types
  + public vs. hidden
  + persistent vs. temporary
  + password-protected vs. unsecured
  + members-only vs. open
  + moderated vs. unmoderated
  + non-anonymous vs. semi-anonymous

- Roles are granted, revoked, and maintained based on the occupant's
  room nickname or full JID rather than bare JID.
- Affiliations are granted, revoked, and maintained based on the
  user's bare JID, not the nick as with roles.

- Order of Events
  + In-room presence from other occupants
  + In-room presence from the joining entity itself (so-called
    "self-presence")
  + Room history (if any)
  + The room subject
  + Live messages, presence updates, new user joins, etc.

- that the room is non-anonymous
  #+BEGIN_SRC xml
  <status code='100'/>
  #+END_SRC

- it's self-presence
  #+BEGIN_SRC xml
  <status code='110'/>
  #+END_SRC

- room logging enabled
  #+BEGIN_SRC xml
  <status code='170'/>
  #+END_SRC

- room logging disabled
  #+BEGIN_SRC xml
  <status code='171'/>
  #+END_SRC

- room is know non-anonymous
  #+BEGIN_SRC xml
  <status code='172'/>
  #+END_SRC

- room is know semi-anonymous
  #+BEGIN_SRC xml
  <status code='172'/>
  #+END_SRC

- room config changed
  #+BEGIN_SRC xml
  <status code='104'/>
  #+END_SRC

- kick
  #+BEGIN_SRC xml
  <status code='307'/>
  #+END_SRC

- ban
  #+BEGIN_SRC xml
  <status code='301'/>
  #+END_SRC

- the user was removed because of an affiliation change
  #+BEGIN_SRC xml
  <status code='321'/>
  #+END_SRC

- the room is changed to members only, and you're not a member
  #+BEGIN_SRC xml
  <status code='322'/>
  #+END_SRC

- kick due to technical problems
  #+BEGIN_SRC xml
  <status code='333'/>
  #+END_SRC

- manual nick change
  #+BEGIN_SRC xml
  <status code='303'/>
  #+END_SRC

 - service changed nick of occupant
  #+BEGIN_SRC xml
  <status code='210'/>
  #+END_SRC
  If the service modifies the user's nickname in accordance with local
  service policies, it MUST include a MUC status code of 210 in the
  presence stanza sent to the user. An example follows (here the
  service changes the nickname to all lowercase).

  Example 52. Occupant Changes Nickname, Modified by Service
  #+BEGIN_SRC xml
    <presence
        from='hag66@shakespeare.lit/pda'
        id='nx6z2v5'
        to='coven@chat.shakespeare.lit/OldHag'/>

    <presence
        from='coven@chat.shakespeare.lit/oldhag'
        id='D0E2B666-3373-42C9-B726-D52C40A48383'
        to='hag66@shakespeare.lit/pda'>
      <x xmlns='http://jabber.org/protocol/muc#user'>
        <item affiliation='member'
              jid='hag66@shakespeare.lit/pda'
              role='participant'/>
        <status code='110'/>
        <status code='210'/>
      </x>
    </presence>
  #+END_SRC

- In the context of a members-only room, the member list is
  essentially a "whitelist" of people who are allowed to enter the
  room. Anyone who is not a member is effectively banned from entering
  the room, even if their affiliation is not "outcast".
** creating a room
- instant room: that is accepting default config
- reserved room: needs config submission
