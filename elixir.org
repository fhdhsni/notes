* Elixir

- *.ex files will be compiled
- *.exs are script files (won't get compiled)
- snake_case naming convention
- # starts a comment line
- ~/.iex.exs is iex configuration file (more info iex> h IEx.configure)

** Types
*** Numbers
- Integers (large numbers can be used with _ e.g 1_000_000_000)
  + =0o555= (octal)
  + =0xabc= (hexdecimal)
  + =0b101100=
- Floats (64bit accuracy)
  - exponent: 1.0e-20

:NOTE:
=10 / 2= returns a float. If you need integer use =div(10, 2)=
=rem(10, 3)= returns the reminder
:END:

*** Atoms
Atoms are constants where their name is their own value.
:hello == :"hello" 
is true

*** Booleans
In fact they are atoms
:true == true
is true

*** Strings
Strings in Elixir are inserted between *double quotes*, and they are encoded in UTF-8:
for interpolation

#+BEGIN_SRC elixir
  name = "Farhad"
  "My name is #{name}"
  |> IO.puts
#+END_SRC

Note 'hello' is not an string it's a list
#+BEGIN_SRC elixir
is_list 'hello' # true
#+END_SRC

*** Anonymous functions
#+BEGIN_SRC elixir
iex> add = fn a, b -> a + b end
#Function<12.71889879/2 in :erl_eval.expr/5>
iex> add.(1, 2)
3
#+END_SRC
To call an anonymous function we use . notation like =add.(1, 2)=

*** (Linked) Lists
Elixir uses square brackets to specify a list of values. Values can be of any type:
#+BEGIN_SRC elixir
  mylist = [1, 2, true, 3]
   length mylist # 4
  [1, 2, 3] ++ [4, 5, 6] # [1, 2, 3, 4, 5, 6]
  # also there's a --
#+END_SRC

The head is the first element of a list and the tail is the remainder of the list.

#+BEGIN_SRC elixir
list = [1, 2, 3]
hd(list) # 1
tl(list) # [2, 3]
[1 | [2]] === [1, 2] # true
[1 | [2 | [3]]] === [1, 2, 3] # true
#+END_SRC


*** Tuples
Elixir uses curly brackets to define
tuples. Like lists, tuples can hold any value: Tuples store elements
contiguously in memory. This means accessing a tuple element by index
or getting the tuple size is a fast operation. Indexes start from zero.
#+BEGIN_SRC elixir
  t = {:ok, "Hi", 5}
  elem(t, 1) # :Hi
  tuple_size(t) # 3
  put_elem(t, 1, "hello") # returns a new tuple. original tuple hasn't changed (It's immutable)
#+END_SRC

** Lists or tuples?
Lists are stored in memory as linked lists, meaning that each element
in a list holds its value and points to the following element until
the end of the list is reached. We call each pair of value and pointer
a cons cell:
#+BEGIN_SRC elixir
list = [1 | [2 | [3 | []]]] # [1, 2, 3]
[0, | list ] # prepending element
#+END_SRC
This means accessing the length of a list is a linear operation: we
need to traverse the whole list in order to figure out its
size. Updating a list is fast as long as we are prepending elements:

Tuples, on the other hand, are stored contiguously in memory. This
means getting the tuple size or accessing an element by index is
fast. However, updating or adding elements to tuples is expensive
because it requires copying the whole tuple in memory.

** Pattern Matching
=a = 8=
bind variable a to number 8
=8 = a=

is a valid expression since 8 matches a

if on the left hand side of = operator is variable it'll bind to the
right hand side but if it's a value, pattern matching happens. If you
want to do pattern matching with a variable you can use pin (^)
operator
=^a = 8= doesn't bind variable to 8 but it does pattern matching

** Keyword lists

In many functional programming languages, it is common to use a list
of 2-item tuples as the representation of a key-value data
structure. In Elixir, when we have a list of tuples and the first item
of the tuple (i.e. the key) is an atom, we call it a keyword list:

#+BEGIN_SRC elixir
me = [{:name, "Farhad"}, {:status, "Awesome"}]
[name: "Farhad", status: "Awesome"] === me # true

Keyword.get me, :name #"Farhad"
me[:status] # "Awesome"

#+END_SRC

- Keys must be atoms.
- Keys are ordered, as specified by the developer.
- Keys can be given more than once.

#+BEGIN_SRC elixir
cook = fn(heat, foods) -> Keyword.values(foods) |> Enum.map(&(heat <> &1)) end
cook.("Fried ", [meat: "sausage", veg: "beans"]) # ["Fried sausage", "Fried beans"]
#+END_SRC



** Maps
Whenever you need a key-value store, maps are the “go to” data
structure in Elixir.

- Maps allow any value as a key.
- Maps’ keys do not follow any ordering.
- Duplicate values will be overrided
#+BEGIN_SRC elixir
  foo = %{:name => "Farhad", :username => "fhdhsni", :name => "notFarhad"}

  Map.get(foo, :name)             # notFarhad
  foo[:username]                  # fhdhsni
  foo.name                        # notFarhad
#+END_SRC

Keyword syntax is allowed as long as all of the keys are atoms
#+BEGIN_SRC elixir
%{a: 1, b: 2} === %{:a => 1, :b => 2} # true
#+END_SRC

Maps have the following syntax for updating a key’s value:
#+BEGIN_SRC elixir
  me = %{:name => "Farhad", :age => 25}
  notMe = %{me | :name => "someone else"} # Adding new keys are not allowed
#+END_SRC

** Functions, Guard clauses and Modules
Function declarations support guards and multiple clauses. If a
function has several clauses, Elixir will try each clause until it
finds one that matches.  Using guard clauses:
#+BEGIN_SRC elixir
  defmodule Example do
    def hello(name) when name === "Farhad" do
      IO.puts "Fuck off"
    end
    def hello(name) when is_bitstring name do
      IO.puts "Hi #{name}, Happy to see you"
    end
    def hello(_) do
      IO.puts "No idea what you doin'"
    end
  end

  Example.hello "Esi"             # Hi Esi, Happy to see you
  Example.hello "Farhad"          # Fuck off
  Example.hello 25                # No idea what you doin'
#+END_SRC
mulitple clause
#+BEGIN_SRC elixir
defmodule Math do
  def zero?(0) do
    true
  end

  def zero?(x) when is_integer(x) do
    false
  end
end

IO.puts Math.zero?(0)         #=> true
IO.puts Math.zero?(1)         #=> false
IO.puts Math.zero?([1, 2, 3]) #=> ** (FunctionClauseError)
IO.puts Math.zero?(0.0)       #=> ** (FunctionClauseError)
#+END_SRC

Using =do:= syntax

#+BEGIN_SRC elixir
defmodule Math do
  def zero?(0), do: true
  def zero?(x) when is_integer(x), do: false
end
#+END_SRC

*** Function Capturing
#+BEGIN_SRC elixir
Math.zero?(0) # true
fun = &Math.zero?/1
is_function(fun) # true
fun.(0) # true
#+END_SRC

Using capture syntax for creating functions 

#+BEGIN_SRC elixir
  fun = &(&1 + &2)                # same as: fn x, y -> x + y end
  fun.(2, 9) # 11
#+END_SRC

Capturing a function from modules
#+BEGIN_SRC elixir
fun = &List.flatten(&1, &2) # &List.flatten/2
fun.([1, [[2], 3]], [4, 5]) # [1, 2, 3, 4, 5]
#+END_SRC

If a function with default values has multiple clauses, it is required
to create a function head (without an actual body) for declaring
defaults:

#+BEGIN_SRC elixir
defmodule Concat do
  def join(a, b \\ nil, sep \\ " ")

  def join(a, b, _sep) when is_nil(b) do
    a
  end

  def join(a, b, sep) do
    a <> sep <> b
  end
end

IO.puts Concat.join("Hello", "world")      #=> Hello world
IO.puts Concat.join("Hello", "world", "_") #=> Hello_world
IO.puts Concat.join("Hello")               #=> Hello
#+END_SRC
*** overlapping function definitions
When using default values, one must be careful to avoid overlapping
function definitions. Consider the following example:

#+BEGIN_SRC elixir
defmodule Concat do
  def join(a, b) do
    IO.puts "***First join"
    a <> b
  end

  def join(a, b, sep \\ " ") do
    IO.puts "***Second join"
    a <> sep <> b
  end
end

Concat.join "hello", " world" # will run first clause
Concat.join "hello", "world", "_" # will run second clause
#+END_SRC
 invoking the =join= function with two arguments will always choose
 the first definition of =join= whereas the second one will only be
 invoked when three arguments are passed. thus providing a default
 value for =sep= in second clause is unnecessary and has no effect.

** Miscellaneous
- if statement is just a macro that takes =true= or =false= as it's
  first argument and a keyword list as it's second argument
#+BEGIN_SRC elixir
  if true, do: :this, else :that     # 
  # it's actually a macro
  if(true, [do: :this, else: :that]) # :this
  if(false, [do: :this, else: :that]) # :that
#+END_SRC
