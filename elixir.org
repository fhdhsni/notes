* Elixir
Most of these nots are from official elixir guide and learnelixir.tv
:NOTE:
- *.ex files will be compiled.

- *.exs are script files (won't get compiled)

- snake_case naming convention

- # starts a comment line

- ~/.iex.exs is iex configuration file (more info =iex> h IEx.configure=)

- === (triple equal) is used for comparing floats to integers (2 === 2.0 returns false)
:END:
** Types
*** Numbers
- Integers (large numbers can be used with _ e.g 1_000_000_000)
  + =0o555= (octal)
  + =0xabc= (hexdecimal)
  + =0b101100=
- Floats (64bit accuracy)
  - exponent: 1.0e-20

:NOTE:
=10 / 2= returns a float. If you need integer use =div(10, 2)=

=rem(10, 3)= returns the reminder
:END:

*** Atoms
Atoms are constants where their name is their own value.
#+BEGIN_SRC elixir
:hello == :"hello" # true
#+END_SRC
Module names are atoms
#+BEGIN_SRC elixir
defmodule MyMod do
  def foo(name) do
    "Hi #{name}"
  end
end
is_atom(MyMod) #true
#+END_SRC

=nil= is also an atom.

*** Booleans
In fact they are atoms
:true == true
is true

*** Strings
Strings are just binaries in Elixir. They are inserted between *double
quotes*, and they are encoded in UTF-8: for interpolation

#+BEGIN_SRC elixir
<<104, 101, 108, 108, 111>> == "hello" # true
#+END_SRC

#+BEGIN_SRC elixir
  name = "Farhad"
  "My name is #{name}"
  |> IO.puts
#+END_SRC

Note 'hello' is not a string it's a Character list
#+BEGIN_SRC elixir
is_list 'hello' # true
#+END_SRC

*** Binary list
=<<1, 2, 3>>=
- Every element is 1 byte long.
- Concatenating two binary list
=<<1, 2, 3>> <> <<4>>=
Binaries can be tagged with a size atribute
=<<1::size(16)>>= # 16 bits (2 bytes)

=<<65>> <> <<" Farhad">>= # "A Farhad"
#+BEGIN_SRC elixir
<<104, 101, 108, 108, 111>> == "hello" # true
#+END_SRC

*** Anonymous functions
#+BEGIN_SRC elixir
iex> add = fn a, b -> a + b end # same as &(&1 + &2)
#Function<12.71889879/2 in :erl_eval.expr/5>
iex> add.(1, 2)
3
#+END_SRC
To call an anonymous function we use . notation like =add.(1, 2)=

*** (/Linked/) Lists
Elixir lists are immutable head/tail pairs.
Elixir uses square brackets to specify a list of values. Values can be of any type:
#+BEGIN_SRC elixir
  mylist = [1, 2, true, 3]
   length mylist # 4
  [1, 2, 3] ++ [4, 5, 6] # [1, 2, 3, 4, 5, 6]
  # also there's a --
#+END_SRC
Appending to the end of a list is a slow operation because it needs to
copy the whole list. Think to twice before doin' so.

The head is the first element of a list and the tail is the remainder of the list.
#+BEGIN_SRC elixir
list = [1, 2, 3]
hd(list) # 1
tl(list) # [2, 3]
[1 | [2]] === [1, 2] # true
[1 | [2 | [3]]] === [1, 2, 3] # true
#+END_SRC

*** Tuples
Elixir uses curly brackets to define
tuples. Like lists, tuples can hold any value: Tuples store elements
contiguously in memory. This means accessing a tuple element by index
or getting the tuple size is a fast operation. Indexes start from zero.
#+BEGIN_SRC elixir
  t = {:ok, "Hi", 5}
  elem(t, 1) # :Hi
  tuple_size(t) # 3
  put_elem(t, 1, "hello") # returns a new tuple. original tuple hasn't changed (It's immutable)
#+END_SRC

** Lists or tuples?
Lists are stored in memory as linked lists, meaning that each element
in a list holds its value and points to the following element until
the end of the list is reached. We call each pair of value and pointer
a cons cell:
#+BEGIN_SRC elixir
list = [1 | [2 | [3 | []]]] # [1, 2, 3]
[0, | list ] # prepending element
#+END_SRC
This means accessing the length of a list is a linear operation: we
need to traverse the whole list in order to figure out its
size. Updating a list is fast as long as we are prepending elements:

Tuples, on the other hand, are stored contiguously in memory. This
means getting the tuple size or accessing an element by index is
fast. However, updating or adding elements to tuples is expensive
because it requires copying the whole tuple in memory.
|----------------+-------------------+-------------------|
|                | List              | Tuple             |
|----------------+-------------------+-------------------|
| Structure      | Linked list       | Contiguous memory |
| Insertion      | Fast (prepending) | Expensive         |
| Size           | Slow              | Fast              |
| Fetch by index | Slow              | Fast              |
| Fetch first    | Fast              | Fast              |

** Operators
*** in
To see if an element is present in a list
#+BEGIN_SRC elixir
"fhd" in ["fhd", "hsni", "blah"] # true
#+END_SRC
*** ++ and --
#+BEGIN_SRC elixir
[1, 2, 3] ++ [4] # [1, 2, 3, 4] # be careful here. this might be slow
[1, 2, 3] ++ [1, 3] # [2]
#+END_SRC
*** |

#+BEGIN_SRC elixir
me = ["fhd", "hsni"]
[25 | me] # [25, "fhd", "hsni"]

[h | t] = me
h # fhd
t # hsni

l = [1, 2, 3, 4, 5]
[a, b, c | tail] = l
#+END_SRC
*** <>
To concatenate two binaries. Remember in elixir strings are binaries
#+BEGIN_SRC elixir
"Farhad" <> " " <> "hsni" # Farhad hsni
<<104, 101, 108, 108, 111>> <> " " <> "world" # hello world
#+END_SRC
*** =~
#+BEGIN_SRC elixir
"Hello World" =~ ~r/hello/i #true
"Hello World" =~ "Hello" # true
#+END_SRC
*** Bitwise Operators
*** Logical Operators
**** and, or, &&, ||
=and=, =or= only accepts booleans
=&&=, =||= is non-strict and accepts any value

Using =||= to set a default:
#+BEGIN_SRC elixir
user = %{name: nil}
name = user.name || "Farhad"
name # Farhad
#+END_SRC
*** Capture Operator: &
captures or creates an anonymous function

Without capture operator
#+BEGIN_SRC elixir
  Enum.filter [1, 2, 3, "four"], fn(val) ->
    is_number(val)
  end
#+END_SRC
With capture operator
#+BEGIN_SRC elixir
  Enum.filter [1, 2, 3, "four"], &is_number/1 # [1, 2, 3]
  ## or ##
  Enum.filter [1, 2, 3, "four"], &is_number(&1) # [1, 2, 3]
#+END_SRC

We can even use capture operator to capture other operators like +
#+BEGIN_SRC elixir
Enum.reduce [1, 2, 3], &(&1 + &2) # 6
## capturing + operator
Enum.reduce [1, 2, 3], &+/2
#+END_SRC

Using capture operator to capture functions from other modules
#+BEGIN_SRC elixir
Enum.map ["fhd", "hsni"], &String.upcase/1
#+END_SRC
** Pattern Matching
=a = 8= bind variable a to number 8 =8 = a= is a valid expression
since 8 matches a.

If on the left hand side of = operator is variable it'll be bind to the
right hand side but if it's a value, pattern matching happens. If you
want to do pattern matching with a variable you can use pin (^)
operator. =^a = 8= doesn't bind variable to 8 but it does pattern matching.

Pattern Matching in maps are very useful.
#+BEGIN_SRC elixir
%{name: name} = %{name: "Farhad", age: 25}
name # "farhad"
#+END_SRC
Matching binaries
#+BEGIN_SRC elixir
"username: " <> usr = "username: fhdhsni"
usr #fhdhsni
#+END_SRC

#+BEGIN_SRC elixir
defmodule Bar do
  @moduledoc """

  """
  defstruct first_name: nil, last_name: nil

  def name(%Bar{} = user), do: user.first_name <> " " <> user.last_name
  def name(unsupported), do: raise "what the hell is #{inspect unsupported}?"

  def send_name, do: name(%Bar{first_name: "Farhad", last_name: "Hsni"})
end

Bar.send_name
#+END_SRC
** Keyword lists
It's a high level type (under the hood they are just lists).
In many functional programming languages, it is common to use a list
of 2-item tuples as the representation of a key-value data
structure. In Elixir, when we have a list of tuples and the first item
of the tuple (i.e. the key) is an atom, we call it a keyword list:

#+BEGIN_SRC elixir
  me = [{:name, "Farhad"}, {:status, "Awesome"}] # a list with two tuples(each one a 2-itme tuple) inside it
  [name: "Farhad", status: "Awesome"] === me # true

  Keyword.get me, :name #"Farhad"
  me[:status] # "Awesome"

#+END_SRC

- Keys must be atoms.
- Keys are ordered, as specified by the developer.
- Keys can be given more than once.

#+BEGIN_SRC elixir
cook = fn(heat, foods) -> Keyword.values(foods) |> Enum.map(&(heat <> &1)) end
cook.("Fried ", [meat: "sausage", veg: "beans"]) # ["Fried sausage", "Fried beans"]
#+END_SRC

** Maps
Whenever you need a key-value store, maps are the “go to” data
structure in Elixir.

- Maps allow any value as a key.
- Maps’ keys do not follow any ordering.
- Duplicate values will be overrided
#+BEGIN_SRC elixir
  foo = %{:name => "Farhad", :username => "fhdhsni", :name => "notFarhad"}

  Map.get(foo, :name)             # notFarhad
  foo[:username]                  # fhdhsni
  foo.name                        # only if keys are atoms
#+END_SRC

Keyword syntax is allowed as long as all of the keys are atoms
#+BEGIN_SRC elixir
%{a: 1, b: 2} === %{:a => 1, :b => 2} # true
 #+END_SRC

Maps have the following syntax for updating a key’s value.
Note: *new keys cannot be added*
#+BEGIN_SRC elixir
  me = %{:name => "Farhad", :age => 25}
  notMe = %{me | :name => "someone else"} # Adding new keys are not allowed
#+END_SRC

*** struct
Structs are extensions built on top of maps that provide compile-time
checks and default values.
#+BEGIN_SRC elixir
iex> defmodule User do
...>   defstruct name: "Farhad", age: 25 # nil is also common as default value
...> end
#+END_SRC

The keyword list used with defstruct defines what fields the struct
will have along with their *default* values.
#+BEGIN_SRC elixir
  iex> %User{}
  %User{age: 25, name: "Farhad"}
  iex> %User{name: "Esi"}         # we don't provide the age, default value (25) will be used
  %User{age: 25, name: "Esi"}

#+END_SRC
Structs provide compile-time guarantees that only the fields (and all
of them) defined through defstruct will be allowed to exist in a
struct:
#+BEGIN_SRC elixir
iex> %User{oops: :field}
 (KeyError) key :oops not found in: %User{age: 25, name: "Farhad"}
#+END_SRC

As being said earlier sturcts are just maps

#+BEGIN_SRC elixir
%User{} == %{__struct__: User, age: 25, name: "FArhad"} # true
#+END_SRC

Under the hood a =__struct__= funciton will be defined in the module
#+BEGIN_SRC elixir
defmodule User do
  defstruct name: "Farhad", email: "farhad.hsni@gmail.com"
end
#+END_SRC
#+BEGIN_SRC elixir
  defmodule User do
    def __struct__ do
      %{__struct__: User, name: "Farhad", email: "farhad.hsni@gmail.com"}
    end
  end
#+END_SRC
*** Range
Range struct
#+BEGIN_SRC elixir
  0..100 == %Range{first: 0, last: 100} # true
  0..100 == %{__struct__: Range, first: 0, last: 100} # true
#+END_SRC
*** Regular Expressions
%Regex{
  opts: "",
  source: "hello"
}
#+BEGIN_SRC elixir
is_map ~r/hello/ # true
#+END_SRC
** Functions, Guard clauses and Modules
Function declarations support guards and multiple clauses. If a
function has several clauses, Elixir will try each clause until it
finds one that matches.  Using guard clauses:
#+BEGIN_SRC elixir
  defmodule Example do
    def hello(name) when name === "Farhad" do
      IO.puts "Fuck off"
    end
    def hello(name) when is_bitstring name do
      IO.puts "Hi #{name}, Happy to see you"
    end
    def hello(_) do
      IO.puts "No idea what you doin'"
    end
  end

  Example.hello "Esi"             # Hi Esi, Happy to see you
  Example.hello "Farhad"          # Fuck off
  Example.hello 25                # No idea what you doin'
#+END_SRC
Mulitple clauses
#+BEGIN_SRC elixir
defmodule Math do
  def zero?(0), do: true
  def zero?(x) when is_integer(x), do: false
end

IO.puts Math.zero?(0)         #=> true
IO.puts Math.zero?(1)         #=> false
IO.puts Math.zero?([1, 2, 3]) #=> ** (FunctionClauseError)
IO.puts Math.zero?(0.0)       #=> ** (FunctionClauseError)
#+END_SRC
Using =do:= syntax
#+BEGIN_SRC elixir
defmodule Math do
  def zero?(0), do: true
  def zero?(x) when is_integer(x), do: false
end
#+END_SRC

*** Function Capturing
#+BEGIN_SRC elixir
Math.zero?(0) # true
fun = &Math.zero?/1
is_function(fun) # true
fun.(0) # true
#+END_SRC

Using capture syntax for creating functions

#+BEGIN_SRC elixir
  fun = &(&1 + &2)                # same as: fn x, y -> x + y end
  fun.(2, 9) # 11
#+END_SRC

Capturing a function from modules
#+BEGIN_SRC elixir
fun = &List.flatten(&1, &2) # &List.flatten/2
fun.([1, [[2], 3]], [4, 5]) # [1, 2, 3, 4, 5]
#+END_SRC

If a function with default values has multiple clauses, it is required
to create a function head (without an actual body) for declaring
defaults:

#+BEGIN_SRC elixir
defmodule Concat do
  def join(a, b \\ nil, sep \\ " ")

  def join(a, b, _sep) when is_nil(b) do
    a
  end

  def join(a, b, sep) do
    a <> sep <> b
  end
end

IO.puts Concat.join("Hello", "world")      #=> Hello world
IO.puts Concat.join("Hello", "world", "_") #=> Hello_world
IO.puts Concat.join("Hello")               #=> Hello
#+END_SRC
*** overlapping function definitions
When using default values, one must be careful to avoid overlapping
function definitions. Consider the following example:

#+BEGIN_SRC elixir
defmodule Concat do
  def join(a, b) do
    IO.puts "***First join"
    a <> b
  end

  def join(a, b, sep \\ " ") do
    IO.puts "***Second join"
    a <> sep <> b
  end
end

Concat.join "hello", " world" # will run first clause
Concat.join "hello", "world", "_" # will run second clause
#+END_SRC
 invoking the =join= function with two arguments will always choose
 the first definition of =join= whereas the second one will only be
 invoked when three arguments are passed. thus providing a default
 value for =sep= in second clause is unnecessary and has no effect.

Note the header function defines the default value of =acc=. Also note that less generalized functions are 
higher and more generalized functions are at the bottom. In this example if we put =def reduce([], _func, acc), do: acc=
bellow =def reduce(list, func, acc), do: do_reduce(list, func, acc)= we get a warning:
=warning: this clause cannot match because a previous clause at line 6 always matches=
since the more generalized function is higher and it always match.
#+BEGIN_SRC elixir
defmodule MyList do
  @moduledoc """
  
  """
  def reduce(list, func, acc \\ 0)
  def reduce([], _func, acc), do: acc
  def reduce(list, func, acc), do: do_reduce(list, func, acc)
  defp do_reduce([h | t], func, acc) do
    acc = func.(h) + acc
    reduce(t, func, acc)
  end
end

[1, 2, 3]
|> MyList.reduce(&(&1 * &1), 4)
|> IO.puts
#+END_SRC 

*** Recursive function
#+BEGIN_SRC elixir
defmodule Graph do
  def count(%{children: []}), do: 1

  def count(%{children: children}) do
    [first | rest] = children
    count(first) + count(%{children: rest})
  end

end


graph = %{
  children: [
    %{children: []},
    %{children: []},
    %{children: [
         %{children: []},
         %{children: []}
       ]
    },
    %{children: []}
  ]
}

Graph.count(graph)
#+END_SRC
Another example
#+BEGIN_SRC elixir
defmodule MyList do
  @moduledoc """
  
  """
  def length(list), do: length(list, 0)
  defp length([], count), do: count
  defp length([_|t], count), do: length(t, count + 1)
end

MyList.length([1, 2, "three", "four"]) # 4
#+END_SRC
**** Tail Call Optimization
When a function calls itself as the last operation
#+BEGIN_SRC elixir
defmodule MyList do
  @moduledoc """
  
  """
  def each([], _fun), do: :ok
  def each([h | t], func) do
    func.(h)
    each(t, func)
  end
end

MyList.each([1, 2, 3, 4], &(IO.puts &1))
#+END_SRC
** Module attributes
   Module attributes in Elixir serve three purposes:
1. They serve to annotate the module, often with information to be used by the user or the VM.
2. They work as constants.
3. They work as a temporary module storage to be used during compilation.
*** =@moduledoc= and  =@doc=
=@moduledoc= provides documentation for the current module.
=@doc= provides documentation for the function or macro that follows the attribute.
#+BEGIN_SRC elixir
defmodule Math do
  @moduledoc """
  Provides math-related functions.

  ## Examples

      iex> Math.sum(1, 2)
      3

  """

  @doc """
  Calculates the sum of two numbers.
  """
  def sum(a, b), do: a + b
end
#+END_SRC
** Enum module
Types which implements Enumerable hence can be used with Enum methods
- Lists
- Keyword Lists
- Maps (not Structs)
- Ranges
- Streams
*** Some useful Enum methods
**** Enum.map
**** Enum.each
**** Enum.at
Note when this method is used with Maps is returns a tuple.
#+BEGIN_SRC elixir
Enum.at %{:name => "Farhad", :age => 25}, 0, :default # {:age, 25}
#+END_SRC

**** Enum.filter 
Note the anonymous function gets a tuple and returns a keyword list
#+BEGIN_SRC elixir
%{:name => "Farhad", :age => 25}
|> Enum.filter(fn({_key, val}) -> is_number val end) # returns a keyword list [age: 25]
#+END_SRC

**** Enum.reduce

**** Enum.into
Converts an =Enumerable= to another type. Target must implement =Collectable= protocol.
lists and maps both implement collectable protocol

In the example we convert a keyword list to a map
#+BEGIN_SRC elixir
%{:name => "Farhad", :age => 25}
|> Enum.filter(fn({_k, v}) -> is_binary(v) end) # retuns a keyword list [name: "Farhad"]
|> Enum.into(%{}) # make it a map %{name: "Farhad"}
#+END_SRC

**** Enum.take
#+BEGIN_SRC elixir
Enum.take(10..20, 5)  # [10, 11, 12, 13, 14]
#+END_SRC

** Streams
=Stream= is a lazy version of =Enum=.  Unlike =Enum= which does it's
job immediately, =Stream= waits until you ask for the result. This
could end up to be more efficient; like iterating over a list once for
nnall rather than doin' it for each operation like =Enum= does.

#+BEGIN_QUOTE
Due to their laziness, streams are useful when working with large (or
even infinite) collections. When chaining many operations with Enum,
intermediate lists are created, while Stream creates a recipe of
computations that are executed at a later moment.
#+END_QUOTE

#+BEGIN_SRC elixir
[1, 2, "buckle up your shoe", 3, 4]
|> Stream.filter(&is_number/1) # I don't feel like doin' it write now
|> Stream.filter(&(rem(&1, 2) == 0)) # nope not yet
|> Enum.into([]) # okay, I'll do it. [2, 4]
#+END_SRC

#+BEGIN_SRC elixir
list = [1, 2, 3, "string", 4, 8]
stream = Stream.filter(list, &is_number/1)  # stream stores the anonymous functions and returns a Stream struct
stream = Stream.filter(stream, &(rem(&1, 2) == 0)) # stream stores the anonymous functions and returns a Stream struct
 Enum.into(stream, []) # up until now Stream hasn't done any actuall work. By Enum.into we make it to do the operations we asked for earlier
#+END_SRC

*** Stream.cycle
Creates a stream that cycles through the given enumerable, infinitely.
#+BEGIN_SRC elixir
Stream.cycle([1, 2, 3, "meow"])
|> Enum.take(8)
#+END_SRC
*** Stream.iterate
Emits a sequence of values, starting with =start_value=. Successive
values are generated by calling =next_fun= on the previous value.
#+BEGIN_SRC elixir
Stream.iterate(0, &(&1+1)) |> Enum.take(5) # [0, 1, 2, 3, 4]
#+END_SRC
*** Stream.resource
** Comprehension
It's another name for =for= macro in Elixir which returns a list.

The =for= macro has three parts:
1. Generators
2. Filters
3. =:into= Option

*** Generators
=element <- Enumerable=
It's possible to have multiple generators in a single =for= comprehension
#+BEGIN_SRC elixir
suits = [:hearts, :diamonds, :clubs, :spades]
faces = [2, 3, 4, 5, 6, 7, 8, 9, 10, :jack, :queen, :king, :ace]

for suit <- suits,
  face <- faces,
  do: {suit, face}
#+END_SRC
Pattern Matching is also allowed.
#+BEGIN_SRC elixir
for {:spades, face} <- deck do
  {:spades, face}
end
#+END_SRC
With bitstring
#+BEGIN_SRC elixir
pixels = <<213, 45, 132, 64, 76, 32, 76, 0, 0, 234, 32, 15>>
for <<r::8, g::8, b::8 <- pixels>>, do: {r, g, b} # [{213, 45, 132}, {64, 76, 32}, {76, 0, 0}, {234, 32, 15}]
#+END_SRC
*** Filters
#+BEGIN_SRC elixir
for element <- Enumerable, filter do
  element
end
#+END_SRC

#+BEGIN_SRC elixir
suits = [:hearts, :diamonds, :clubs, :spades]
faces = [2, 3, 4, 5, 6, 7, 8, 9, 10, :jack, :queen, :king, :ace]

for suit <- suits,
  face <- faces,
  suit == :spades,
  is_number(face),
  face > 5,
  do: {suit, face}
#+END_SRC

#+BEGIN_SRC elixir
users = [user: "john", admin: "meg", guest: "barbara"]
for {type, name} when type != :guest <- users do
    String.upcase(name)
end
#+END_SRC
*** =:into=
Return something other than a list with the =:into= option:
#+BEGIN_SRC elixir
for {key, val} <- %{name: "Farhad", dob: 1993, email: "farhad.hsni@gmail.com"},
    key in [:name, :email],
    into: %{},
    do: {key, val}
#+END_SRC
#+BEGIN_SRC elixir
for <<c <- " hello world ">>, c != ?\s, into: "", do: <<c>> # "helloworld"
#+END_SRC
*** =for= vs. =Enum= vs. =Stream=
|            | Enum    | Stream | for  |
|------------+---------+--------+------|
| map        | YES     | YES    | YES  |
| filter     | YES     | YES    | YES  |
| lazy       | NO      | YES    | NO   |
| iterations | DEPENDS | ONCE   | ONCE |
| & Operator | YES     | YES    | NO   |


A more complex example 
#+BEGIN_SRC elixir

#+END_SRC
A more complex example
#+BEGIN_SRC elixir
defmodule Triple do
  def pythagorean(n) when n > 0 do
    for a <- 1..n,
      b <- 1..n,
      c <- 1..n,
      a + b + c <= n,
      a*a + b*b == c*c,
      do: {a, b, c}
  end
end

Triple.pythagorean(5) # []
Triple.pythagorean(12) # [{3, 4, 5}, {4, 3, 5}]
#+END_SRC
** Sigils
Sigils are a way to create a shorthand. There are bunch of userful
built-in sigil but we can also create our own sigils by =sigil_*=
function in a module and use it like =~*(blah blah)=. It also possible
to override built-in sigils. 

Sigils are simply replaced by =sigil_*=
function at compile time.
#+BEGIN_SRC elixir
~r/foobar/im # sigil_r("foobar", 'im')
#+END_SRC

:NOTE:
each sigil has a lowercase and upercase version. Uppercase sigils
doesn't allow interpolation
:END:

Defining a custom sigil
#+BEGIN_SRC elixir
def sigil_u(content, _opts) do
  content
  |> String.split
  |> Enum.map(&String.upcase/1)
end
~u(foo bar) # ["FOO", "BAR"]
#+END_SRC

*** Regular Expressions sigil
#+BEGIN_SRC elixir
~r/hello/
~r|hello|
~r"hello"
~r'hello'
~r(hello)
~r[hello]
~r{hello}
~r<hello>
#+END_SRC
*** Word List sigil
#+BEGIN_SRC elixir
~w(foo bar)  # ["foo", "bar"]
~w(foo bar)a # [:foo, :bar]
#+END_SRC

*** String sigil
#+BEGIN_SRC elixir
~s(foo bar) # "foo bar"
~s({"name": "Devin Torres", "age": 27}) # JSON
~s"""
this is
a heredoc string
"""

#+END_SRC

*** Character List sigil
#+BEGIN_SRC elixir
~c(foobar) # 'foo bar'
#+END_SRC

** Mix, Hex and others
The build tool for elixir
- =mix new foobar= to create foobar project
- =iex -S mix= to start iex in the context of a mix project
- There're two ways to set a key-value config in config.exs
  + =config :projectName, key: value=
  + =config :projectName, Module.Name, key: value=
- To get a configuration from =config.exe=
  + =Application.get_env(:projectName, :key)= 
  + =Application.get_env(:projectName, __MODULE__)[:key]= 
- to install hex =mix local.hex=
- to get deps specified in mix file =mix deps.get=
- to remove deps that you have removed from mix file =mix deps.clean PACKAGE_NAME=
- to update a dependency; bump the version in mix file then =mix deps.update PACKAGE_NAME=
- add `config :package_name, setting_a: "value"` to =config/config.exs= to configure a package
- =mix hex.outdated= to find out which packages are outdated
- for uploading your package to Hex, add package/0 setting to Mixfile
#+BEGIN_SRC elixir
  defp package do
    [
      files: ["lib", "mix.exs", "README.md"],
      contributors: ["Your Name"],
      licenses: ["MIT"],
      links: %{
        "Github" => "https://github.com/fhdhsni/repo"
      }
    ]
  end
#+END_SRC
  + remember to update application/0 to specify each one of your runtime dependencies as an application in the :application list
    #+BEGIN_SRC elixir
    def application do
      [application: [:dependency_a, :dependency_b]]
    end
  #+END_SRC
  + update project/0 setting
    #+BEGIN_SRC elixir
      def project do
        [app: :my_project_name,
         version: "0.0.1",
         elixir: "~> 1.0",
         build_embedded: Mix.env == :prod,
         start_permanent: Mix.env == :prod,
         source_url: "https://github.com/fhdhsni/repo",
         description: "short description of project",
         package: package,
         deps: deps,
        ]
      end
    #+END_SRC
  + =mix hex.publish=
** ExUnit
- =assert=
  + expects truthy values
- =refute=
  + expects falsy values
- =assert_raise=
  + Assert that a code block raises an exception
- =assert_in_delta=
  + Assert that two things differ in a specific way
- =assert_receive=
  + Assert that a process message was received
*** Shared setup
#+BEGIN_SRC elixir
defmodule CryptoTest do
  use ExUnit.Case
  doctest Crypto

  setup do
    variable = 3
    {:ok, variable: variable}
  end
  
  test "the truth", %{variable: variable} do
    refute 1 + 1 == variable
  end
end
#+END_SRC
*** ExUnit.CaseTemlate
*** Running tests asynchronously
#+BEGIN_SRC elixir
  defmodule MyApp.MathTest do
    use ExUnit.Case, async: true

    # ...
  end
#+END_SRC
*** Tagging
#+BEGIN_SRC elixir
defmodule CryptoTest do
  # This would tag all the tests in the module as slow
  @moduletag :slow

  use ExUnit.Case
  doctest Crypto

  # This tags only one test
  @tag :slow
  test "2 plus one should be three" do
    assert 2 + 1 == 3
  end
end
#+END_SRC
Then you can exclude tests with a given tag by adding the following snippet to =test/test_helpers.exs=
#+BEGIN_SRC elixir
ExUnit.start()
ExUnit.configure exclude: [:slow]
#+END_SRC

**** skip
There's also the built-in =skip= tag
#+BEGIN_SRC elixir
@tag :skip
# org
@tag skip: "Reason"
#+END_SRC
*** Pending Tests
#+BEGIN_SRC elixir
# Automatically tagged with @tag :not_implemented
  test ".add subs two numbers"
  test ".div divides two numbers"
  test ".mul multiples two numbers"
#+END_SRC
*** Doctests
use =doctests MyApp.MyModule= in test file to consider doc examples as tests

Written inline with documentation for a module of function typically under an =## example= heading.
#+BEGIN_SRC elixir
  defmodule MyApp.Math do
    @doc """
    Adds two numbers together and returns the sum.

    # Examples

      iex> Math.add(1, 2)
      3

      iex> sum = Math.add(5, 5)
      ...> Math.add(sum. 5)
      15
    """
    def add(a, b), do: a + b
  end
#+END_SRC

*** Running tests
Exclude tests tagged with :slow
=mix test --exclude slow=
or include them
=mix test --include slow=
or only run those with this tag
=mix test --only slow=

** Processes
*** spawn
=spawn(a_function)=
=spawn(someModule, :some_function, [arg1, arg2])=
**** spawn
Spawned process is isolated. If it raises an error parent process won't die.
**** spawn_link
In this way failure in the spawned process propagates to parent
process.  It's also possible to link processes via =Process.link/1=

In the parent process we can =:trap_exit= and to something other than
dying if the spawned process died.
#+BEGIN_SRC elixir
  Process.flag(:trap_exit, true)
  pid = spawn_link(fn -> ... end)

  receive do
    {:EXIT, pid, reason} ->
      # Revive pid?
  end
#+END_SRC
**** spawn_monitor
#+BEGIN_SRC elixir
  {juliet, _ref} = spawn_monitor(fn -> ... end)
  receive do
    {:DOWN, _ref, :process, pid} ->
      # Revive juliet
  end
#+END_SRC
*** self
returns current process PID
*** send
The process that sends the message does not block on send/2, it puts
the message in the recipient’s mailbox and continues.
*** receive
If there is no message in the mailbox matching any of the patterns,
the current process will wait until a matching message arrives. A
timeout can also be specified with =after= block:
#+BEGIN_SRC
iex> receive do
...>   {:hello, msg}  -> msg
...> after
...>   1_000 -> "nothing after 1s"
...> end
"nothing after 1s"
#+END_SRC
Messages that don't match any of provided patterns will be left in the
process's mailbox. Mailbox may fill up.
*** flush
It flushes and prints all the messages in the mailbox.
*** kill
=Process.exit(pid, :kil)=

** GenServer
A primitive emulation of GenServer.

Server:
#+BEGIN_SRC elixir
defmodule Server do
  @moduledoc ~s"""
  account = Server.start(BankAccount, 0)

  send(account, {:deposit, 50})
  send(account, {:withdraw, 20})

  send(account, :balance) # should receive {:balance, 30}
  """

  def start(callback_module, state) do
    parent = self()
    spawn fn ->
      loop(callback_module, parent, state)
    end
  end

  def loop(callback_module, parent, state) do
    receive do
      message ->
        state = callback_module.handle_message(message, parent, state)
        loop(callback_module, parent, state)
    end
  end
end
#+END_SRC

BankAccount:
#+BEGIN_SRC elixir
defmodule BankAccount do
  
  def handle_message({:deposit, amount}, _from, balance) do
    balance + amount
  end

  def handle_message({:withdraw, amount}, _from, balance) do
    balance - amount
  end

  def handle_message(:balance, from, balance) do
    send(from, {:balance, balance})
    balance
  end

end
#+END_SRC

*** GenServer
#+BEGIN_SRC elixir
  {:ok, pid} = GenServer.start(CallbackModule, [arg1, arg2], opts) # if it crashed it won't bring the current process down
  {:ok, pid} = GenServer.start_link(CallbackModule, [arg1, arg2], opts)
#+END_SRC
1. Note that the list =[arg1, arg2]= is sent to =init= function defined inside =CallbackModule=
2. =opts= is optional.
3. =init= function sets the initial state with ={:ok, initial_state}= response
4. =handle_call= is synchronous and 
   - Handles =GenServer.call=
   - Its signature is =handle_call(arg, from_pid, current_state)=. =arg= is =GenServer.call(pid, *arg*)=
   - Should reply like ={:reply, return_value, new_state}=
5. =handle_cast= is asynchronous and
   - Handles =GenServer.cast=
   - Its signature =handle_cast(arg, current_state)=
   - Should reply ={:noreply, new_state}=
6. =handle_info= is asynchronous and
   - handles messages from everyone(like =Process.send=) except for GenServer.
7. =GenServer.cast=
   + Send a message without expecting or waiting for a response
8. =GenServer.call=
   + Send a message and wait for a response (hence blocking the current process)
9. GenServer process can be named
   =GenServer.start_link(CallbackModule, [args], name:foobar)= so we
   don't need the pid =GenServer.cast(foobar, {:save, state})=

**** Implementing BankAccount with GenServer
#+BEGIN_SRC elixir
defmodule BankAccount do
  use GenServer

  def init(balance), do: {:ok, balance}
  # receives the argument that we
  # gave to GenServer.start
  # function and returns the
  # inital state to be stored in
  # the process


  def handle_cast({:deposit, amount}, balance), do: {:noreply, balance + amount}
  def handle_cast({:withdraw, amount}, balance), do: {:noreply, balance - amount}
  # take the message that was sent as the first arugment and current
  # state of process as the last argument. If the first element of
  # tuple is :reply whatever comes next will be send back to the
  # caller. last element of the tuple is the new state

  def handle_call(:balance, _from, balance), do: {:reply, balance, balance}
  # thrid element is the new state
  # second element will be send back to the caller
  # read handle_cast comment
end
#+END_SRC
To use it:
#+BEGIN_SRC 
  {:ok, account} = GenServer.start(BankAccount, 0)
  GenServer.cast(account, {:deposit, 50})
  GenServer.cast(account, {:withdraw, 25})
  balance = GenServer.call(account, :balance) # 25
#+END_SRC
**** BankAccount as a GenServer
#+BEGIN_SRC elixir
defmodule BankAccount do
  use GenServer

  def start(balance) do
    {:ok, account} = GenServer.start(__MODULE__, balance)
    account
  end

  def deposit(account, amount) do
    GenServer.cast(account, {:deposit, amount})
  end

  def withdraw(account, amount) do
    GenServer.cast(account, {:withdraw, amount})
  end

  def balance(account) do
    GenServer.call(account, :balance)
  end

  ###
  # GenServer API
  ###

  # Handle cast messages with `handle_cast`. No response is expected,
  # so reply with the {:noreply, ...} tuple format
  def handle_cast({:deposit, amount}, balance) do
    {:noreply, balance + amount}
  end

  def handle_cast({:withdraw, amount}, balance) do
    {:noreply, balance - amount}
  end

  # Handle call messages with the `handle_call` callback. Responses are usually
  # expected, so respond with the {:reply, ...} tuple format.
  def handle_call(:balance, _from, balance) do
    {:reply, balance, balance}
  end

end
#+END_SRC
To use it:
#+BEGIN_SRC 
  account = BankAccount.start(0)
  BankAccount.deposit(account, 50)
  BankAccount.withdraw(account, 25)
  BankAccount.balance(account)      # 25
#+END_SRC
**** When to Use GenServer
Not always, for e.g above example can be implemented with the help of structs.

Implementing BankAccount with struct:
#+BEGIN_SRC elixir
defmodule BankAccount do
  defstruct balance: 0

  def new(balance) do
    %__MODULE__{balance: balance}
  end

  def deposit(account, amount) do
    %{account | balance: account.balance + amount}
  end

  def withdraw(account, amount) do
    %{account | balance: account.balance - amount}
  end

  def balance(account) do
    account.balance
  end

end
#+END_SRC
**** GenServer Features
- GenServer processes are distributed across cores
- A GenServer process works on one message at a time
- GenServer processes can be supervised and restarted
- GenServer process state can be upgraded in place

** Supervisor
*** example 1
=Basic= module:
#+BEGIN_SRC elixir
defmodule Basic do
  use GenServer

  def start_link(arg) do
    IO.puts "inside Basic start_link..."
    GenServer.start_link(__MODULE__, arg)
  end
  def init(arg) do
    IO.inspect arg
    IO.puts "inside Basic init..."
    {:ok, []}
  end
end
#+END_SRC

=BasicSupervisor= module:
#+BEGIN_SRC elixir
defmodule BasicSupervisor do
  use Supervisor

  def start_link(arg) do
    Supervisor.start_link(__MODULE__, arg) # passes =arg= to init
  end

  def init(arg) do
    children = [
      worker(Basic, [arg]) # passing =arg= (not [arg]) to Basic.start_link
    ]
    supervise(children, strategy: :one_for_one)
  end

end
#+END_SRC

To use it:
#+BEGIN_SRC 
iex(1)> {:ok, s_pid} = BasicSupervisor.start_link("Jack")
inside Basic start_link...
"Jack"
inside Basic init...
{:ok, #PID<0.126.0>}

iex(2)> [{_, pid,_ ,_}] = Supervisor.which_children(s_pid)
[{Basic, #PID<0.127.0>, :worker, [Basic]}]
iex(6)> pid
pid
#PID<0.127.0>

iex(3)> GenServer.stop(pid)
inside Basic start_link...
"Jack"
:ok
inside Basic init...
#+END_SRC

*** example 2
Implementing a simple TODO app

#+BEGIN_SRC elixir
defmodule Todo do
  use GenServer

  def start_link(state, opts \\ []), do: GenServer.start_link(__MODULE__, state, opts)

  def handle_cast({:add, task}, todo), do: {:noreply, [task | todo]}

  def handle_cast({:remove, task_index}, todo) do
    new_Todo = List.delete_at(todo, task_index)
    {:noreply, new_Todo}
  end

  def handle_call(:list, _from, todo), do: {:reply, create_todo_list(todo), todo}

  def create_todo_list(todo, str \\ "", n \\ 1)
  def create_todo_list([], str, _n) do
    IO.puts str
    str
  end

  def create_todo_list(todo, str, n) do
    [h | t] = todo
    str = str <> "#{n}- #{h}\n"
    n = n + 1
    create_todo_list(t, str, n)
  end

end
#+END_SRC
And its supervisor
#+BEGIN_SRC elixir
defmodule Todo.Supervisor do
  use Supervisor

  def start_link do
    Supervisor.start_link(__MODULE__, [])
  end

  def init([]) do
    children = [
      worker(Todo, [[]]) 
    ]
    supervise(children, strategy: :one_for_one)
  end
end
#+END_SRC
*** Notes
- to create a mix project with a Supervisor =mix nes my_project --sup=
- workers can have ids =worker(SupervisedProcess, [], id: "some_id")=
- Supervisors themself can be supervised =worker(Supervisor_module, [])=
- for data storage you might find =ets=, =dets=, or =Mnesia= more useful than third party tools
- =simple_one_for_one= is for dynamically launching processes.
** Task & Agents
*** Tasks
Asynchronous Processing
#+BEGIN_SRC elixir
  task = Task.async fn ->
    IO.puts "Hello world!"
  end

  # OR

  task = Task.async(OI. :puts, ["Hello World"])

  result = Task.await(task)
#+END_SRC

#+BEGIN_SRC elixir
defmodule Play do
  def pmap(list, fun) do
    list
    |> Enum.map(&Task.async(fn -> fun.(&1) end))
    |> Enum.map(&Task.await/1)
  end
end
#+END_SRC

To Supervise A Task

Supervisor:
#+BEGIN_SRC elixir
defmodule Play.Supervisor do
  use Supervisor
  
  def start_link do
    Supervisor.start_link(__MODULE__, [], name: __MODULE__)
  end

  def init(_) do
    children = [
      supervisor(Task.Supervisor, [[name: MyApp.TaskSupervisor]])
    ]
    supervise(children, strategy: :transient)
  end
end
#+END_SRC

Then after =Play.Supervisor.start_link=:
#+BEGIN_SRC elixir
# You can start supervised tasks like so:
Task.Supervisor.start_child(MyApp.TaskSupervisor, fn ->
  IO.puts "Hello world!"
end)

Task.Supervisor.async(MyApp.TaskSupervisor, IO, :puts, ["Hello world!"])
|> Task.await
#+END_SRC

+ =yield(task, timeout \\ 5000)=
  - Temporarily blocks the current process waiting for a task reply.
*** Agent
Agents are a simple abstraction around state.
#+BEGIN_SRC  elixir
  {:ok, agent} = Agent.start_link(fn -> 0 end)
  Agent.update(agent, fn(state) -> state + 1 end)
  Agent.get(agent, fn(state) -> state end)
#+END_SRC

implementing =BankAccount= with Agents 
#+BEGIN_SRC elixir
defmodule BankAccount do
  def start_link(balance) do
    Agent.start_link(fn -> balance end)
  end
  
  def deposit(account, amount) do
    Agent.update(account, &(&1 + amount))
  end
  
  def withdraw(account, amount) do
    Agent.update(account, &(&1 - amount))
  end
  
  def balance(account) do
    Agent.get(account, &(&1))
  end 
end
#+END_SRC
** Nodes
A Node is an instance of BEAM virtual machine.
- =Node.self= 
  + to get the current node's name
- =Node.list=
  + to get a list of connected nodes
- =iex --sname node_name=
  + to start a named node
- =Node.connect(:Farhad@Manjaro)=
  + to connect to a node
- =Node.spawn or Node.spawn_link=
  + to spawn a process in a node
#+BEGIN_SRC elixir
  pid = Node.spawn :fhd@Manjaro, fn ->
    IO.puts "yohoo"
  end
#+END_SRC

*** Note
- Code is /not sent/
- All data in the message will be /copied/
- Be aware of Network Latency
- 
** Miscellaneous
*** =if=
    if statement is just a macro that takes =true= or =false= as it's
    first argument and a keyword list as it's second argument. use =case= or =cond= instead
#+BEGIN_SRC elixir
  if true, do: :this, else :that     #
  # it's actually a macro
  if(true, [do: :this, else: :that]) # :this
  if(false, [do: :this, else: :that]) # :that
#+END_SRC

*** =alias=
Referencing a module by a different name
#+BEGIN_SRC elixir
defmodule AnotherModule do
  def add(a, b), do: a + b
end

defmodule Foo do
  alias AnotherModule, as: M

  def fun, do: M.add 2, 5
end
#+END_SRC
Using a module by last part of its name
#+BEGIN_SRC elixir
defmodule Some.Other.Mod do
  def add(a, b), do: a + b
end

defmodule MyMod do
  alias Some.Other.Mod
  def fun(a, b), do: Mod.add(a, b) # just using Mod
end
#+END_SRC
*** =import=
**** Importing the whole module
#+BEGIN_SRC elixir
defmodule AnotherModule do
  def add(a, b), do: a + b
end

defmodule Foo do
  import AnotherModule

  def fun, do: add 2, 10
end

Foo.fun # 12
#+END_SRC

**** =only=
 #+BEGIN_SRC elixir
 defmodule AnotherModule do
  def add(a, b), do: a + b
  def add(a, b, c), do: a + b + c
end

defmodule Foo do
  import AnotherModule, only: [add: 2] # 2 is the arity

  def fun, do: add 2, 10, 2
end

Foo.fun # %CompileError{description: "undefined function add/3", file: "nofile", line: 9}
 #+END_SRC
 Above snippet raise an error because we only imported to =add/2=
 function. The number is the arity of the given function.

**** =except=
#+BEGIN_SRC elixir
defmodule Some.Other.Mod do
  def add(a, b), do: a + b
  def subtract(a, b), do: a - b
end

defmodule MyMod do
  import Some.Other.Mod, except: [add: 2] # don't import add/2

  # def foo(a, b), do: add(a, b) #throws an error, we didn't import add/2
  def bar(a, b), do: subtract(a, b)
end

# MyMod.foo(10, 20) # %CompileError{description: "undefined function add/2", file: "nofile", line: 8}

MyMod.bar(20, 10) # 10
#+END_SRC
*** =cond=
Run the first block where expression is truthy.
Remember =cond= has no falling through like a switch case does in other languages.
#+BEGIN_SRC elixir
  cond do
    expression -> body
    expression -> body
    ...
  end
#+END_SRC
#+BEGIN_SRC elixir
defmodule Fun do
  def foo(%{age: age}) do
    cond do
      age > 50 -> "You gonna die, pretty soon actully"
      age > 30 -> "Enjoy misery"
      true     -> "Hmm"
    end
  end
end

Fun.foo(%{name: "Farhad", age: 51}) # "You gonna die, pretty soon actully"
#+END_SRC

*** =case=
When a *pattern* matches the value of the *expression*, the body is executed.
#+BEGIN_SRC elixir
  case expression do
    pattern -> body
    pattern -> body
    ...
  end
#+END_SRC
#+BEGIN_SRC elixir
  defmodule Fun do
    def foo(%{age: age}) do
      case age do
        :old           -> "You gonna die, pretty soon actully"
        :not_That_Old  -> "Enjoy misery"
        _              -> "Hmm" #note the use of underscore in lieu of true like in =cond=
      end
    end
  end

  Fun.foo(%{name: "Farhad", age: :something}) # Hmm
#+END_SRC
Another example
#+BEGIN_SRC elixir
case File.read("foobar.txt") do
  {:ok, content} ->
    IO.puts "content of given file: #{content}"
  {:error, reason} ->
    Io.puts "error #{reason} occurred"
  other ->
    IO.puts "An unknown error occurred. #{other}"
end
#+END_SRC
Using Guard clase in =case=
#+BEGIN_SRC elixir
v = "foo"
case v do
  v when v in [nil, false, ""] -> "moew"
  _ -> "not meow"
end
#+END_SRC
*** =with=
#+BEGIN_SRC elixir
 with
  pattern <- expression
  pattern <- expression
  ...
do
  body
end
#+END_SRC

#+BEGIN_SRC elixir
opts = %{:width => 10, :height => 15}
with {:ok, width} <- Map.fetch(opts, :width),
     {:ok, height} <- Map.fetch(opts, :height),
  do: {:ok, width * height}
#+END_SRC
*** =try do ... rescue ... after ... end=
Use try rescue as last resort.
After is optional.
#+BEGIN_SRC elixir
defmodule M do
  def say_hi(name) do
    try do
      "Hey #{String.upcase name}!!!"
  rescue
    _e -> raise "Fuck off"
    end
  end
end
M.say_hi 3
#+END_SRC
*** =raise=
#+BEGIN_SRC elixir
raise "an exception"
#+END_SRC
*** =throw/catch=
*** =defdelegate=
#+BEGIN_SRC elixir
defmodule Some.Other.Mod do
  def add(a, b), do: a + b
  def subtract(a, b), do: a - b
end

defmodule MyMod do
  defdelegate bar(a, b), to: Some.Other.Mod, as: :add
  defdelegate subtract(a, b), to: Some.Other.Mod
end

MyMod.bar(20, 10) # 30
MyMod.subtract(23, 3) # 3
#+END_SRC
*** =?=
returns ASCII code of given character (in decimal)
#+BEGIN_SRC elixir
IO.inspect ?a # 97
IO.inspect ?\s # 32 (for space)
#+END_SRC
** WAT?
*** 
#+BEGIN_SRC elixir
foo = fn 0 -> "zero"; 2 -> "two" end
foo.(0) # "zero"
foo.(2) # "two"
#+END_SRC
