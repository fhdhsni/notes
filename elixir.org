* Elixir
- Most of these notes are from official elixir guide, [[learnelixir.tv][learnelixir.tv]] and “Elixir in Action”
** Tips
1) ~*.ex~ files will be compiled.
2) ~*.exs~ are script files (won't get compiled)
3) snake_case naming convention
4) # starts a comment line
5) ~~/.iex.exs~ is iex configuration file (more info =iex> h IEx.configure=)
6) You can add additional code paths by providing the ~-pa~ switch:
   #+BEGIN_SRC
   $ iex -pa my/code/path -pa another/code/path
   #+END_SRC
7) If you don’t want a BEAM instance to terminate, you can provide the
   ~--no-halt~ parameter:
   #+BEGIN_SRC
   $ elixir --no-halt script.exs
   #+END_SRC
8) You can check which code paths are used at runtime by calling the Erlang function
   #+BEGIN_SRC
   :code.get_path
   #+END_SRC
9) Dynamically calling functions
   #+BEGIN_SRC elixir
   iex> apply(IO, :puts, ["Dynamic function call."])
   Dynamic function call.
   #+END_SRC
10) Use =i= in iex for getting information about a thing like ~i 'foo'~
11) Use =h= in iex for getting documentation of a thing like ~h List.insert_at~
12) When counting the elements in a data structure, Elixir also abides
    by a simple rule: the function is named =size= if the operation is in
    constant time (i.e. the value is pre-calculated) or =length= if the
    operation is linear (i.e. calculating the length gets slower as the
    input grows). As a mnemonic, both “length” and “linear” start with
    “l”.
13) In Elixir when can compare two different types. the order is
    =number < atom < reference < function < port < pid < tuple < map < list < bitstring=
14) Whenever a result is printed in the shell, the function
    ~Kernel.inspect/1~ is called to transform the structure into an
    inspected string.
15) see the pure data structure, without this decorated output
    #+BEGIN_SRC elixir
      iex> myset = MapSet.new() |> MapSet.put(:foo)
      #MapSet<[:foo]>

      iex> IO.puts(inspect(myset, structs: false))
      %{__struct__: MapSet, map: %{foo: []}, version: 2}
      :ok
    #+END_SRC
16) group leader:
    #+BEGIN_SRC
    iex(node1@localhost)4> Node.spawn(:node2@localhost, fn -> IO.puts("Hello from #{node}") end)
    Hello from node2@localhost
    #+END_SRC
    All standard I/O calls (such as ~IO.puts/1~) are
    forwarded to the group leader — a process that’s in charge of
    performing the actual input or output. A spawned process inherits
    the group leader from the process that spawned it, even when
    you’re spawning a process on another node. Therefore, your process
    may run on ~node2~, but its group leader is still on ~node1~. As a
    consequence, the string to be printed is created on ~node2~ , but
    the output is printed on ~node1~.
    + More info on [[https://stackoverflow.com/a/36319970/2576218][SO]]


** Types
*** Numbers
- Integers (large numbers can be used with _ e.g 1_000_000_000)
  + =0o555= (octal)
  + =0xff= (hexdecimal)
  + =0b101100=
- Floats (64bit accuracy)
  - exponent: ~1.0e-2~ (0.01)

  :NOTE:
  =10 / 2= returns a float. If you need integer use =div(10, 2)=

  =rem(10, 3)= returns the reminder
  :END:

*** Atoms
- Atoms are constants where their name is their own value.
- When you say ~variable = :some_atom~ the variable doesn’t contain
  the entire text, but only a reference to the atom table. Therefore,
  memory consumption is low, the comparisons are fast, and the code is
  still readable.
#+BEGIN_SRC elixir
:hello == :"hello" # true
#+END_SRC
Module names are atoms
#+BEGIN_SRC elixir
defmodule MyMod do
  def foo(name) do
    "Hi #{name}"
  end
end
is_atom(MyMod) #true
#+END_SRC

- =nil= is also an atom.

- There’s another syntax for atom constants. You can omit the
  beginning colon and start with an uppercase character: ~AnAtom~ This
  is called an /alias/, and at compile time it’s transformed into this:
  ~:"Elixir.AnAtom"~:
  #+BEGIN_SRC
  iex(1)> AnAtom == :"Elixir.AnAtom"
  true

  iex(2)> AnAtom == Elixir.AnAtom
  true
  #+END_SRC
  When you write ~alias IO, as: MyIO~, you instruct the compiler to
  transform ~MyIO~ into ~IO~. Resolving this further, the final result
  emitted in the generated binary is ~:Elixir.IO~. Therefore, with an
  alias set up, the following also holds:
  #+BEGIN_SRC elixir
  iex> MyIO == Elixir.IO
  true

  iex> Foo == :"Elixir.Foo"
  true

  iex> alias Foo, as: Bar
  Foo

  iex> Bar == Elixir.Foo
  true
  #+END_SRC

*** Booleans
In fact they are atoms
~:true == true~ is true

*** Strings
Strings in Elixir are represented internally by binaries which are
sequences of bytes:

#+BEGIN_SRC
iex> is_binary("hellö")
true

# We can also get the number of bytes in a string:

iex> byte_size("hellö")
6
#+END_SRC

Strings are just binaries in Elixir. They are inserted between *double
quotes*, and they are encoded in UTF-8: for interpolation

#+BEGIN_SRC elixir
<<104, 101, 108, 108, 111>> == "hello" # true
#+END_SRC

#+BEGIN_SRC elixir
  name = "Farhad"
  "My name is #{name}"
  |> IO.puts
#+END_SRC

Note ~'hello'~ is not a string it's a Character list
#+BEGIN_SRC elixir
is_list 'hello' # true
#+END_SRC

*** Binary list
=<<1, 2, 3>>=
- Every element is 1 byte long.
- Concatenating two binary list ~<<1, 2, 3>> <> <<4>>~

- Each number given to a binary is meant to represent a byte and
  therefore must go up to 255. Binaries allow modifiers to be given to
  store numbers bigger than 255 or to convert a code point to its
  UTF-8 representation:
  #+BEGIN_SRC elixir
  iex> <<255>>
  <<255>>

  iex> <<256>> # truncated
  <<0>>

  iex> <<256 :: size(16)>> # use 16 bits (2 bytes) to store the number
  <<1, 0>>

  iex> <<256 :: utf8>> # the number is a code point
  "Ā"

  iex> <<256 :: utf8, 0>>
  <<196, 128, 0>>

  iex> pixels
  <<213, 45, 132, 64, 76, 32, 76, 0, 0, 234, 32, 15>>

  iex> <<red::size(8), rest::binary>> = pixels
  <<213, 45, 132, 64, 76, 32, 76, 0, 0, 234, 32, 15>>

  iex> red
  213

  iex> rest
  <<45, 132, 64, 76, 32, 76, 0, 0, 234, 32, 15>>

  iex> <<r::8, rest::binary>> = pixels
  <<213, 45, 132, 64, 76, 32, 76, 0, 0, 234, 32, 15>>

  iex> r
  213
  #+END_SRC

- Another example, putting ~256~ into 16 bits of memory
    #+BEGIN_SRC elixir
    iex> <<257::16>>
    <<1, 1>>
    #+END_SRC
    This expression places the number 257 into 16 bits of consecutive memory space. The
    output indicates that you use 2 bytes, both having a value of 1. This is due to the binary
    representation of 257, which in 16-bit form is written ~00000001 00000001~.

- pattern matching: splits a single byte into two 4-bit values
  #+BEGIN_SRC elixir
  iex(5)>  <<a :: 4, b :: 4>> = << 155 >>
  <<155>>

  iex(6)> a
  9

  iex(7)> b
  11
  #+END_SRC
  Because the number ~155~ is in binary represented as ~10011011~, you get
  values of 9 (~1001~ binary) and 11 (~1011~ binary).
- pattern matching: ~"⏪"~ is E2(226) 8F(143) AA(170) in hex
  #+BEGIN_SRC elixir
  iex(1)> <<b1, b2, b3>> = "⏪"
  "⏪"

  iex> b1
  226

  iex> b2
  143

  iex> b3
  170
  #+END_SRC

- pattern matching:
  #+BEGIN_SRC elixir
    iex> command = "ping www.example.com"
    "ping www.example.com"

    iex> "ping " <> url = command
    "ping www.example.com"

    iex> url
    "www.example.com"
  #+END_SRC

*** bitstring
- If the total size of all the values isn’t a multiple of 8, the
  binary is called a bitstring — a sequence of bits:

- If a byte has 8 bits, what happens if we pass a size of 1 bit?
  #+BEGIN_SRC elixir
  iex> <<1 :: size(1)>>
  <<1::size(1)>>

  iex> <<2 :: size(1)>> # truncated
  <<0::size(1)>>

  iex> is_binary(<<1 :: size(1)>>)
  false

  iex> is_bitstring(<<1 :: size(1)>>)
  true

  iex> bit_size(<<1 :: size(1)>>)
  1

  iex> <<1::1, 0::1, 1::1>>
  <<5::size(3)>>
  #+END_SRC

- The value is no longer a binary, but a bitstring – a bunch of bits!
  So a binary is a bitstring where the number of bits is divisible
  by 8.
  #+BEGIN_SRC elixir
  iex> is_binary(<<1 :: size(16)>>)
  true
  iex> is_binary(<<1 :: size(15)>>)
  false
  #+END_SRC

*** Anonymous functions
Anonymous functions are closures and as such they can access variables
that are in scope when the function is defined.

#+BEGIN_SRC elixir
iex> add = fn a, b -> a + b end # same as &(&1 + &2)
#Function<12.71889879/2 in :erl_eval.expr/5>
iex> add.(1, 2)
3
#+END_SRC
To call an anonymous function we use . notation like =add.(1, 2)=

**** Pattern Matching in anonymous function and multi-lining them
#+BEGIN_SRC elixir
account_transaction = fn
    (balance, amount, :deposit) -> balance + amount
    (balance, amount, :withdraw) -> balance - amount
end
#+END_SRC

anonymous functions can have multiple clauses and guards:
#+BEGIN_SRC sh
iex> f = fn
...>   x, y when x > 0 -> x + y
...>   x, y -> x * y
...> end
#Function<12.71889879/2 in :erl_eval.expr/5>
iex> f.(1, 3)
4
iex> f.(-1, 3)
-3
#+END_SRC
The number of arguments in each anonymous function clause needs to be
the same, otherwise an error is raised.

**** Shorthand syntax
#+BEGIN_SRC elixir
  deposit = fn(balance, amount) -> amount + balance
  # becomes
  deposit = &(&1 + &2)
#+END_SRC

To define a call immediately
#+BEGIN_SRC elixir
  (fn x, y -> x - y end).(9, 3)   # 6
#+END_SRC

*** (/Linked/) Lists
Elixir lists are immutable head/tail pairs.
Elixir uses square brackets to specify a list of values. Values can be of any type:
#+BEGIN_SRC elixir
  mylist = [1, 2, true, 3]
   length mylist # 4
  [1, 2, 3] ++ [4, 5, 6] # [1, 2, 3, 4, 5, 6]
  # also there's a --
#+END_SRC
Appending to the end of a list is a slow operation because it needs to
copy the whole list. Think twice before doin' so.

The head is the first element of a list and the tail is the remainder of the list.
#+BEGIN_SRC elixir
list = [1, 2, 3]
hd(list) # 1
tl(list) # [2, 3]
[1 | [2]] === [1, 2] # true
[1 | [2 | [3]]] === [1, 2, 3] # true
#+END_SRC

*** Tuples
Elixir uses curly brackets to define tuples. Like lists, tuples can
hold any value: Tuples store elements contiguously in memory. This
means accessing a tuple element by index or getting the tuple size is
a fast operation. Indexes start from zero. However, updating or adding
elements to tuples is expensive because it requires copying the whole
tuple in memory.

#+BEGIN_SRC elixir
  t = {:ok, "Hi", 5}
  elem(t, 1) # :Hi
  tuple_size(t) # 3
  put_elem(t, 1, "hello") # returns a new tuple. original tuple hasn't changed (It's immutable)
#+END_SRC

*** reference
- a reference is an almost unique piece of information in a BEAM instance
*** pid
- a process identifier
*** port identifier
** Higher-level types
- Elixir provides some higher-level abstractions. The ones most
  frequently used are ~Range~, ~Keyword~, ~MapSet~, ~Date~, ~Time~,
  ~NaiveDateTime~, and ~DateTime~.
- [[Range]]
- [[Keyword lists]]
- [[https://hexdocs.pm/elixir/MapSet.html][MapSet]]
  + A ~MapSet~ is the implementation of a set — a store of unique
    values, where a value can be of any type.
  + ~MapSet~ doesn’t preserve the ordering of the items.
- Times and dates
  + [[https://hexdocs.pm/elixir/Date.html][~Date~]]
    * A date can be created with the =~D= sigil
      #+BEGIN_SRC elixir
        iex> date = ~D[2018-01-31]
        ~D[2018-01-31]

        iex> date.year
        2018

        iex> date.day
        31
      #+END_SRC
  + [[https://hexdocs.pm/elixir/Time.html][~Time~]]
    * Similarly, you can represent a time with the =~T= sigil, by
      providing hours, minutes, seconds, and microseconds:
      #+BEGIN_SRC elixir
        iex> time = ~T[11:59:12.00007]

        iex> time.hour
        11

        iex> time.minute
        59
      #+END_SRC
  + [[https://hexdocs.pm/elixir/NaiveDateTime.html][~NaiveDateTime~]]
    * can be created with the =~N= sigil:
      #+BEGIN_SRC elixir
      iex(1)> naive_datetime = ~N[2018-01-31 11:59:12.000007]

      iex(2)> naive_datetime.year
      2018

      iex(3)> naive_datetime.hour
      11
      #+END_SRC
  + [[https://hexdocs.pm/elixir/DateTime.html][~DateTime~]]
    * The ~DateTime~ module can be used to work with datetimes in some
      timezone. Unlike with other types, no sigil is
      available. Instead, you can create a datetime by using ~DateTime~ functions:
      #+BEGIN_SRC elixir
      iex> datetime = DateTime.from_naive!(naive_datetime, "Etc/UTC")

      iex>2018
      datetime.year

      iex>11
      datetime.hour

      iex> datetime.time_zone
      "Etc/UTC"
      #+END_SRC
- [[file:erlang.org::*IO%20Lists][IO Lists]]
  * An IO list is a special sort of list that’s useful for
    incrementally building output that will be forwarded to an I/O
    device, such as a network or a file. Each element of an IO list
    must be one of the following:
    + An integer in the range of 0 to 255
    + A binary
    + An IO list
  * In other words, an IO list is a deeply nested structure in which
    leaf elements are plain bytes (or binaries, which are again a
    sequence of bytes). For example, here’s ~"Hello world"~ represented
    as a convoluted IO list:
    #+BEGIN_SRC
    iex(1)> iolist = [[['H', 'e'], "llo,"], " worl", "d!"]
    #+END_SRC
    Notice how you can combine character lists and binary strings into a deeply nested list.
    Many I/O functions can work directly and efficiently with such data. For example,
    you can print this structure to the screen:
    #+BEGIN_SRC elixir
    iex(2)> IO.puts(iolist)
    Hello, world!
    #+END_SRC
    IO lists are useful when you need to incrementally build a stream
    of bytes. Lists usually aren’t good in this case, because
    appending to a list is an O(n) operation. In contrast, appending
    to an IO list is O(1), because you can use nesting. Here’s a
    demonstration of this technique:

    #+BEGIN_SRC elixir
    iex> iolist = []
    []

    iex> iolist = [iolist, "This"]
    [[], "This"]

    iex> iolist = [iolist, " is"]
    [[[], "This"], " is"]

    iex> iolist = [iolist, " an"]
    [[[[], "This"], " is"], " an"]

    iex> iolist = [iolist, " IO list."]
    [[[[[], "This"], " is"], " an"], " IO list."]

    iex> iolist
    [[[[[], "This"], " is"], " an"], " IO list."]
    #+END_SRC

    Each such operation is O(1), so this is performant. And you can
    send this data to an IO function.
    #+BEGIN_SRC
    iex> IO.puts(iolist)

    This is an IO list.
    #+END_SRC

** Lists or tuples?
Lists are stored in memory as linked lists, meaning that each element
in a list holds its value and points to the following element until
the end of the list is reached. We call each pair of value and pointer
a cons cell:
#+BEGIN_SRC elixir
list = [1 | [2 | [3 | []]]] # [1, 2, 3]
[0, | list ] # prepending element
#+END_SRC
This means accessing the length of a list is a linear operation: we
need to traverse the whole list in order to figure out its
size. Updating a list is fast as long as we are prepending elements:

Tuples, on the other hand, are stored contiguously in memory. This
means getting the tuple size or accessing an element by index is
fast. However, updating or adding elements to tuples is expensive
because it requires copying the whole tuple in memory.
|----------------+-------------------+-------------------|
|                | List              | Tuple             |
|----------------+-------------------+-------------------|
| Structure      | Linked list       | Contiguous memory |
| Insertion      | Fast (prepending) | Expensive         |
| Size           | Slow              | Fast              |
| Fetch by index | Slow              | Fast              |
| Fetch first    | Fast              | Fast              |

** Operators
*** in
To see if an element is present in a list
#+BEGIN_SRC elixir
"fhd" in ["fhd", "hsni", "blah"] # true
#+END_SRC
*** ~==~ vs ~===~
- The difference between ~==~ and ~===~ is that the latter is more
  strict when comparing integers and floats:
  #+BEGIN_SRC sh
  iex> 1 == 1.0
  true
  iex> 1 === 1.0
  false
  #+END_SRC
*** ++ and --
#+BEGIN_SRC elixir
[1, 2, 3] ++ [4] # [1, 2, 3, 4] # be careful here. this might be slow
[1, 2, 3] -- [1, 3] # [2]
#+END_SRC
*** |

#+BEGIN_SRC elixir
me = ["fhd", "hsni"]
[25 | me] # [25, "fhd", "hsni"]

[h | t] = me
h # fhd
t # hsni

l = [1, 2, 3, 4, 5]
[a, b, c | tail] = l
#+END_SRC
*** <>
To concatenate two binaries. Remember in elixir strings are binaries
#+BEGIN_SRC elixir
"Farhad" <> " " <> "hsni" # Farhad hsni
<<104, 101, 108, 108, 111>> <> " " <> "world" # hello world
#+END_SRC
*** =~
- [[https://hexdocs.pm/elixir/Kernel.html#=~/2][Doc]]
- Matches the term on the `left` against the regular expression or
  string on the `right`.
- Returns `true` if `left` matches `right` (if it's a regular expression)
  or contains `right` (if it's a string).
  #+BEGIN_SRC elixir
  "Hello World" =~ ~r/hello/i #true
  "Hello World" =~ "Hello" # true
  "Hello World" =~ "hello" # false
  "Hello World" =~ "." # false
  "Hello World" =~ ~r/./ # true
  #+END_SRC
*** Bitwise Operators
*** Logical Operators
- boolean operators ~or~, ~and~ and ~not~ are strict in the sense that they expect a
  boolean (~true~ or ~false~) as their first argument
- are short-circuit operators, they only execute the
  right side if the left side is not enough to determine the result:
    #+BEGIN_SRC sh
    iex> false and raise("This error will never be raised")
    false
    #+END_SRC
    Besides these boolean operators, Elixir also provides =||=, =&&= and =!=
    which accept arguments of any type. For these operators, all
    values except =false= and =nil= will evaluate to true
    #+BEGIN_SRC sh
     # or
     iex> 1 || true
     1

     iex> false || 11
     11

     # and
     iex> nil && 13
     nil

     iex> true && 17
     17

     #!
     iex> !true
     false

     iex> !1
     false

     iex> !nil
     true
    #+END_SRC
- the atoms ~false~ and ~nil~ are treated as falsy, and everything else is
  treated as truthy.
- Using ~||~ to set a default:
  #+BEGIN_SRC elixir
  user = %{name: nil}
  name = user.name || "Farhad"
  name # Farhad
  #+END_SRC
*** Capture Operator: &
captures or creates an anonymous function

Without capture operator
#+BEGIN_SRC elixir
  Enum.filter [1, 2, 3, "four"], fn(val) ->
    is_number(val)
  end
#+END_SRC
With capture operator
#+BEGIN_SRC elixir
  Enum.filter [1, 2, 3, "four"], &is_number/1 # [1, 2, 3]
  ## or ##
  Enum.filter [1, 2, 3, "four"], &is_number(&1) # [1, 2, 3]
#+END_SRC

We can even use capture operator to capture other operators like +
#+BEGIN_SRC elixir
Enum.reduce [1, 2, 3], &(&1 + &2) # 6
## capturing + operator
Enum.reduce [1, 2, 3], &+/2
#+END_SRC
#+BEGIN_SRC sh
iex> fun2 = &"Good #{&1}"
#Function<6.127694169/1 in :erl_eval.expr/5>
iex)> fun2.("morning")
"Good morning"
#+END_SRC

Using capture operator to capture functions from other modules
#+BEGIN_SRC elixir
Enum.map ["fhd", "hsni"], &String.upcase/1
#+END_SRC
** Pattern Matching
- ~a = 8~ bind variable ~a~ to number ~8~, ~8 = a~ is a valid
  expression since ~8~ matches ~a~.

- If on the left hand side of ~=~ operator is variable it'll be bind to
  the right hand side but if it's a value, pattern matching
  happens. If you want to do pattern matching with a variable you can
  use pin (^) operator. =^a = 8= doesn't bind variable to 8 but it
  does pattern matching.
- ~=~ is right-associative and the result of a pattern match is always
  the result of the term being matched (whatever is on the right side
  of the match operator)
  #+BEGIN_SRC elixir
    iex> date_time = {_, {hour, _, _}} = :calendar.local_time()
    {{2019, 2, 3}, {9, 4, 7}}

    iex> hour
    9

    iex> date_time
    {{2019, 2, 3}, {9, 4, 7}}
  #+END_SRC

- Pattern Matching in maps are very useful.
  #+BEGIN_SRC elixir
  %{name: name} = %{name: "Farhad", age: 25}
  name # "farhad"
  #+END_SRC
- Matching binaries
  #+BEGIN_SRC elixir
  "username: " <> usr = "username: fhdhsni"
  usr #fhdhsni
  #+END_SRC

- Make sure it's the struct that you want
  #+BEGIN_SRC elixir
  defmodule Bar do
    @moduledoc """

    """
    defstruct first_name: nil, last_name: nil

    def name(%Bar{} = user), do: user.first_name <> " " <> user.last_name
    def name(unsupported), do: raise "what the hell is #{inspect unsupported}?"

    def send_name, do: name(%Bar{first_name: "Farhad", last_name: "Hsni"})
  end

  Bar.send_name
  #+END_SRC
** Keyword lists
It's a high level type (under the hood they are just lists).
In many functional programming languages, it is common to use a list
of 2-item tuples as the representation of a key-value data
structure. In Elixir, when we have a list of tuples and the first item
of the tuple (i.e. the key) is an atom, we call it a keyword list:

#+BEGIN_SRC elixir
  me = [{:name, "Farhad"}, {:status, "Awesome"}] # a list with two tuples(each one a 2-item tuple) inside it
  [name: "Farhad", status: "Awesome"] === me # true

  Keyword.get me, :name #"Farhad"
  me[:status] # "Awesome"

#+END_SRC

- Keys must be atoms.
- Keys are ordered, as specified by the developer.
- Keys can be given more than once.

#+BEGIN_SRC elixir
cook = fn(heat, foods) -> Keyword.values(foods) |> Enum.map(&(heat <> &1)) end
cook.("Fried ", [meat: "sausage", veg: "beans"]) # ["Fried sausage", "Fried beans"]
#+END_SRC

To use it in a function

#+BEGIN_SRC elixir
  defmodule Account do
    def balance(transactions, options \\ []) do
      currency = options[:currency] || "dollar"
      symbol = options[:symbol] || "$"
      # ... rest of function
    end
    # ... rest of module
  end


  Account.balance(..., currency: "dollar", symbol: "$") # short syntax
  # is equal to
  Account.balance(..., [{:currency, "dollar"}, {:symbol, "$"}])
#+END_SRC

In general, when the keyword list is the last argument of a function,
the square brackets are optional.

Although we can pattern match on keyword lists, it is rarely done in
practice since pattern matching on lists requires the number of items
and their order to match:
#+BEGIN_SRC sh
iex> [a: a] = [a: 1]
[a: 1]
iex> a
1
#+END_SRC
** Maps
Whenever you need a key-value store, maps are the “go to” data
structure in Elixir.

- Maps allow any value as a key.
- Maps’ keys do not follow any ordering.
- Duplicate values will be overrided
  #+BEGIN_SRC elixir
    foo = %{:name => "Farhad", :username => "fhdhsni", :name => "notFarhad"}

    Map.get(foo, :name)             # notFarhad
    foo[:username]                  # fhdhsni
    foo.name                        # only if keys are atoms
  #+END_SRC

- Keyword syntax is allowed as long as all of the keys are atoms
  #+BEGIN_SRC elixir
  %{a: 1, b: 2} === %{:a => 1, :b => 2} # true
  #+END_SRC

- pattern matching:
  #+BEGIN_SRC elixir
  iex> %{} = %{:a => 1, 2 => :b}
  %{2 => :b, :a => 1}

  iex> %{:a => a} = %{:a => 1, 2 => :b}
  %{2 => :b, :a => 1}

  iex> a
  1

  iex> %{:c => c} = %{:a => 1, 2 => :b}
   (MatchError) no match of right hand side value: %{2 => :b, :a => 1}


  iex> %{name: name} = %{name: "Fahrad", age: 900}
  %{age: 900, name: "Fahrad"}

  iex> name
  "Fahrad"
  #+END_SRC

- Maps have the following syntax for updating a key’s value. Note that
  this is for updaing, *new keys cannot be added*, to store a new
  element to the map, you can use ~Map.put/3~
  #+BEGIN_SRC elixir
    me = %{:name => "Farhad", :age => 25}
    notMe = %{me | :name => "someone else"} # Adding new keys are not allowed
  #+END_SRC

*** struct
Structs are extensions built on top of maps that provide compile-time
checks and default values.
#+BEGIN_SRC elixir
iex> defmodule User do
...>   defstruct name: "Farhad", age: 25 # nil is also common as default value
...> end
#+END_SRC

The keyword list used with defstruct defines what fields the struct
will have along with their *default* values.
#+BEGIN_SRC elixir
  iex> %User{}
  %User{age: 25, name: "Farhad"}
  iex> %User{name: "Esi"}         # we don't provide the age, default value (25) will be used
  %User{age: 25, name: "Esi"}

#+END_SRC
Structs provide compile-time guarantees that only the fields (and all
of them) defined through defstruct will be allowed to exist in a
struct:
#+BEGIN_SRC elixir
iex> %User{oops: :field}
 (KeyError) key :oops not found in: %User{age: 25, name: "Farhad"}
#+END_SRC

As being said earlier sturcts are just maps (although Some things that
can be done with maps don’t work with structs. For example, you can’t
call the ~Enum~ function on a struct)

#+BEGIN_SRC elixir
%User{} == %{__struct__: User, age: 25, name: "Farhad"} # true
#+END_SRC

Under the hood a =__struct__= funciton will be defined in the module
#+BEGIN_SRC elixir
defmodule User do
  defstruct name: "Farhad", email: "farhad.hsni@gmail.com"
end
#+END_SRC

#+BEGIN_SRC elixir
  defmodule User do
    def __struct__ do
      %{__struct__: User, name: "Farhad", email: "farhad.hsni@gmail.com"}
    end
  end
#+END_SRC
**** Accessing and updating structs
#+BEGIN_SRC elixir
defmodule Foo do
  defstruct class: "assassin", age: "young"
end

defmodule Play do
  defstruct name: "Farhad", age: 26

  def main do
    me = %Play{name: "Jafar"} # age will be the default

    me = %{me | name: "awesome" } # updating

    IO.puts me.name # awesome

    %Play{age: the_age } = %Play{name: "Morad", age: 900}       # pattern matching
    # %Play{age: the_age } = {name: "Morad", age: 900}       # error
    # %Play{age: the_age } = %Foo{}       # error

    IO.puts the_age # 900
  end
end

Play.main()
#+END_SRC
**** Structs are bare maps underneath
none of the protocols implemented for maps are available for
structs. For example, you can neither enumerate nor access a struct.
However, since structs are just maps, they work with the functions
from the Map module:
#+BEGIN_SRC elixir
iex> jane = Map.put(%User{}, :name, "Jane")
%User{age: 27, name: "Jane"}

iex> Map.merge(jane, %User{name: "John"})
%User{age: 27, name: "John"}

iex> Map.keys(jane)
[:__struct__, :age, :name]
#+END_SRC

**** Default values and required keys
If you don’t specify a default key value when defining a struct, nil
will be assumed:
#+BEGIN_SRC elixir
defmodule Play do
  defstruct [:name]

  def main do
    me = %Play{}

    IO.inspect me.name          # nil
  end
end

Play.main()
#+END_SRC

You can also enforce that certain keys have to be specified when
creating the struct:
#+BEGIN_SRC elixir
defmodule Play do
  @enforce_keys [:name]
  defstruct [:name]

  def main do
    me = %Play{}                # (ArgumentError) the following keys
                                # must also be given when building
                                # struct Play: [:name]

  end
end

Play.main()
#+END_SRC

*** Range
Range struct
#+BEGIN_SRC elixir
  0..100 == %Range{first: 0, last: 100} # true
  0..100 == %{__struct__: Range, first: 0, last: 100} # true
#+END_SRC
- be aware that the memory footprint of a range is very small,
  regardless of the size. A million-number range is still just a small
  map.

*** Regular Expressions
%Regex{
  opts: "",
  source: "hello"
}
#+BEGIN_SRC elixir
is_map ~r/hello/ # true
#+END_SRC

** Functions, Guard clauses and Modules
- If an error is raised from inside the guard, it won’t be propagated,
  the guard expression will return ~false~ and the corresponding clause
  won’t match
- Not all expressions are allowed in guard clauses
  + [[https://hexdocs.pm/elixir/guards.html][Guards doc]]
  + comparison operators (~==~, ~!=~, ~===~, ~!==~, ~>~, ~>=~, ~<~, ~<=~)
  + strictly boolean operators (~and~, ~or~, ~not~). Note ~&&~, ~||~, and ~!~
    sibling operators are not allowed as they're not strictly
    boolean - meaning they don't require arguments to be booleans
  + arithmetic unary and binary operators (+, -, +, -, *, /)
  + ~in~ and ~not in~ operators (as long as the right-hand side is a
    list or a range)
  + "type-check" functions (~is_list/1~, ~is_number/1~, etc.)
  + functions that work on built-in datatypes (~abs/1~, ~map_size/1~, etc.)

- Functions in Elixir are identified by both their name and their
  arity. The arity of a function describes the number of arguments
  which the function takes. Function declarations support guards and
  multiple clauses. If a function has several clauses, Elixir will try
  each clause until it finds one that matches. Using guard clauses:
  #+BEGIN_SRC elixir
    defmodule Example do
      def hello(name) when name === "Farhad" do
        IO.puts "Fuck off"
      end
      def hello(name) when is_bitstring name do
        IO.puts "Hi #{name}, Happy to see you"
      end
      def hello(_) do
        IO.puts "No idea what you doin'"
      end
    end

    Example.hello "Esi"             # Hi Esi, Happy to see you
    Example.hello "Farhad"          # Fuck off
    Example.hello 25                # No idea what you doin'
  #+END_SRC
- Mulitple clauses
  #+BEGIN_SRC elixir
  defmodule Math do
    def zero?(0), do: true
    def zero?(x) when is_integer(x), do: false
  end

  IO.puts Math.zero?(0)         #=> true
  IO.puts Math.zero?(1)         #=> false
  IO.puts Math.zero?([1, 2, 3]) #=> ** (FunctionClauseError)
  IO.puts Math.zero?(0.0)       #=> ** (FunctionClauseError)
  #+END_SRC
- Using =do:= syntax
  #+BEGIN_SRC elixir
  defmodule Math do
    def zero?(0), do: true
    def zero?(x) when is_integer(x), do: false
  end
  #+END_SRC
- Note that Elixir (Erlang) terms can be compared with the operators
  ~<~ and ~>~, even if they’re not of the same type.

*** Function Capturing
#+BEGIN_SRC elixir
Math.zero?(0) # true
fun = &Math.zero?/1
is_function(fun) # true
fun.(0) # true
#+END_SRC

Using capture syntax for creating functions

#+BEGIN_SRC elixir
  fun = &(&1 + &2)                # same as: fn x, y -> x + y end
  fun.(2, 9) # 11
#+END_SRC

Capturing a function from modules
#+BEGIN_SRC elixir
fun = &List.flatten(&1, &2) # &List.flatten/2
fun.([1, [[2], 3]], [4, 5]) # [1, 2, 3, 4, 5]
#+END_SRC

If a function with default values has multiple clauses, it is required
to create a function head (without an actual body) for declaring
defaults:

#+BEGIN_SRC elixir
defmodule Concat do
  def join(a, b \\ nil, sep \\ " ")

  def join(a, b, _sep) when is_nil(b) do
    a
  end

  def join(a, b, sep) do
    a <> sep <> b
  end
end

IO.puts Concat.join("Hello", "world")      #=> Hello world
IO.puts Concat.join("Hello", "world", "_") #=> Hello_world
IO.puts Concat.join("Hello")               #=> Hello
#+END_SRC

Another usecase would be doing so for documentation purposes. e.g.
#+BEGIN_SRC elixir
@doc """
Runs the given command.
"""
def run(command)

def run({:create, bucket}) do
  KV.Registry.create(KV.Registry, bucket)
  {:ok, "OK\r\n"}
end
#+END_SRC

*** overlapping function definitions
When using default values, one must be careful to avoid overlapping
function definitions. Consider the following example:

#+BEGIN_SRC elixir
defmodule Concat do
  def join(a, b) do
    IO.puts "***First join"
    a <> b
  end

  def join(a, b, sep \\ " ") do
    IO.puts "***Second join"
    a <> sep <> b
  end
end

Concat.join "hello", " world" # will run first clause
Concat.join "hello", "world", "_" # will run second clause
#+END_SRC
invoking the =join= function with two arguments will always choose
the first definition of =join= whereas the second one will only be
invoked when three arguments are passed. thus providing a default
value for =sep= in second clause is unnecessary and has no effect.


#+BEGIN_SRC elixir
defmodule MyList do
  @moduledoc """

  """
  def reduce(list, func, acc \\ 0)
  def reduce([], _func, acc), do: acc
  def reduce(list, func, acc), do: do_reduce(list, func, acc)
  defp do_reduce([h | t], func, acc) do
    acc = func.(h) + acc
    reduce(t, func, acc)
  end
end

[1, 2, 3]
|> MyList.reduce(&(&1 * &1), 4)
|> IO.puts
#+END_SRC
- The header function defines the default value of =acc=.
- Less generalized functions are higher and more generalized functions are at the bottom.
- If we put =def reduce([], _func, acc), do: acc= bellow =def
  reduce(list, func, acc), do: do_reduce(list, func, acc)= we get a
  warning: =warning: this clause cannot match because a previous
  clause at line 6 always matches= since the more generalized function
  is higher and it always match.

*** Recursive function
#+BEGIN_SRC elixir
defmodule Graph do
  def count(%{children: []}), do: 1

  def count(%{children: children}) do
    [first | rest] = children
    count(first) + count(%{children: rest})
  end

end


graph = %{
  children: [
    %{children: []},
    %{children: []},
    %{children: [
         %{children: []},
         %{children: []}
       ]
    },
    %{children: []}
  ]
}

Graph.count(graph)
#+END_SRC
Another example
#+BEGIN_SRC elixir
defmodule MyList do
  @moduledoc """

  """
  def length(list), do: length(list, 0)
  defp length([], count), do: count
  defp length([_|t], count), do: length(t, count + 1)
end

MyList.length([1, 2, "three", "four"]) # 4
#+END_SRC
**** Tail Call Optimization
When a function calls itself as the last operation
#+BEGIN_SRC elixir
defmodule MyList do
  @moduledoc """

  """
  def each([], _fun), do: :ok
  def each([h | t], func) do
    func.(h)
    each(t, func)
  end
end

MyList.each([1, 2, 3, 4], &(IO.puts &1))
#+END_SRC
** IO and the file system
- By default, files are opened in binary mode, which requires
  developers to use the specific =IO.binread/2= and =IO.binwrite/2=
  functions from the IO module

#+BEGIN_SRC sh
iex> {:ok, file} = File.open "hello", [:write]
{:ok, #PID<0.47.0>}
iex> IO.binwrite file, "world"
:ok
iex> File.close file
:ok
iex> File.read "hello"
{:ok, "world"}
#+END_SRC

#+BEGIN_SRC elixir
case File.read(file) do
  {:ok, body}      -> # do something with the `body`
  {:error, reason} -> # handle the error caused by `reason`
end
#+END_SRC
** alias, require, and import
Elixir provides three directives (~alias~, ~require~ and ~import~) plus a
macro called ~use~ summarized below:
#+BEGIN_SRC elixir
# Alias the module so it can be called as Bar instead of Foo.Bar
alias Foo.Bar, as: Bar

# Require the module in order to use its macros
require Foo

# Import functions from Foo so they can be called without the `Foo.` prefix. If you have a sigil_x
# in Foo, the module that imports Foo can use it like ~x/blah/
import Foo

# Invokes the custom code defined in Foo as an extension point
use Foo
#+END_SRC

the first three are called directives because they have lexical scope,
while ~use~ is a common extension point that allows the used module to
inject code.
*** alias
Referencing a module by a different name
#+BEGIN_SRC elixir
defmodule AnotherModule do
  def add(a, b), do: a + b
end

defmodule Foo do
  alias AnotherModule, as: M

  def fun, do: M.add 2, 5
end
#+END_SRC
Using a module by last part of its name
#+BEGIN_SRC elixir
defmodule Some.Other.Mod do
  def add(a, b), do: a + b
end

defmodule MyMod do
  alias Some.Other.Mod
  def fun(a, b), do: Mod.add(a, b) # just using Mod
end
#+END_SRC

#+BEGIN_SRC elixir
defmodule Stats do
  alias Math.List, as: List
  # In the remaining module definition List expands to Math.List.
end
#+END_SRC
The original List can still be accessed within Stats by the
fully-qualified name =Elixir.List=.

:NOTE:
Note: All modules defined in Elixir are defined inside the main Elixir
namespace. However, for convenience, you can omit “Elixir.” when
referencing them.
:END:

Note that alias is lexically scoped, which allows you to set aliases
inside specific functions:
#+BEGIN_SRC elixir
defmodule Math do
  def plus(a, b) do
    alias Math.List
    # ...
  end

  def minus(a, b) do
    # ...
  end
end
#+END_SRC
*** require
Elixir provides macros as a mechanism for meta-programming (writing
code that generates code). Macros are expanded at compile time. Public
functions in modules are globally available, but in order to use
macros, you need to opt-in by requiring the module they are defined
in.
#+BEGIN_SRC sh

iex(2)> Integer.is_odd(3)
 (CompileError) iex:2: you must require Integer before invoking the macro Integer.is_odd/1
    (elixir) src/elixir_dispatch.erl:97: :elixir_dispatch.dispatch_require/6

iex(2)> require Integer
Integer

iex(3)> Integer.is_odd(3)
true
#+END_SRC
=require= is also lexically scoped
*** import
We use ~import~ whenever we want to easily access functions or *macros*
from other modules without using the fully-qualified name.
#+BEGIN_SRC sh
iex> import List, only: [duplicate: 2]
List
iex> duplicate :ok, 3
[:ok, :ok, :ok]
#+END_SRC

~import~ also supports =:macros= and =:functions= to be given to =:only=. For
example, to import all macros, one could write:
#+BEGIN_SRC elixir
import Integer, only: :macros
#+END_SRC
#+BEGIN_SRC elixir
import Integer, only: :functions
#+END_SRC

Note that ~import~ is lexically scoped too. This means that we can
import specific macros or functions inside function definitions:
#+BEGIN_SRC elixir
defmodule Math do
  def some_function do
    import List, only: [duplicate: 2]
    duplicate(:ok, 10)
  end
end
#+END_SRC
*Note that importing a module automatically requires it.*

**** Importing the whole module
#+BEGIN_SRC elixir
defmodule AnotherModule do
  def add(a, b), do: a + b
end

defmodule Foo do
  import AnotherModule

  def fun, do: add 2, 10
end

Foo.fun # 12
#+END_SRC

**** =only=
 #+BEGIN_SRC elixir
 defmodule AnotherModule do
  def add(a, b), do: a + b
  def add(a, b, c), do: a + b + c
end

defmodule Foo do
  import AnotherModule, only: [add: 2] # 2 is the arity

  def fun, do: add 2, 10, 2
end

Foo.fun # %CompileError{description: "undefined function add/3", file: "nofile", line: 9}
 #+END_SRC
 Above snippet raise an error because we only imported to =add/2=
 function. The number is the arity of the given function.

**** =except=
#+BEGIN_SRC elixir
defmodule Some.Other.Mod do
  def add(a, b), do: a + b
  def subtract(a, b), do: a - b
end

defmodule MyMod do
  import Some.Other.Mod, except: [add: 2] # don't import add/2

  # def foo(a, b), do: add(a, b) #throws an error, we didn't import add/2
  def bar(a, b), do: subtract(a, b)
end

# MyMod.foo(10, 20) # %CompileError{description: "undefined function add/2", file: "nofile", line: 8}

MyMod.bar(20, 10) # 10
#+END_SRC
*** use
The =use= macro is frequently used as an extension point. This means
that, when you use a module FooBar, you allow that module to inject
any code in the current module, such as importing itself or other
modules, defining new functions, setting a module state, etc.

For example, in order to write tests using the ExUnit framework, a
developer should use the =ExUnit.Case= module:
#+BEGIN_SRC elixir
defmodule AssertionTest do
  use ExUnit.Case, async: true

  test "always pass" do
    assert true
  end
end
#+END_SRC
Behind the scenes, use requires the given module and then calls the
=__using__/1= callback on it allowing the module to inject some code
into the current context. Generally speaking, the following module:
#+BEGIN_SRC elixir
defmodule Example do
  use Feature, option: :value
end
#+END_SRC
is compiled to
#+BEGIN_SRC elixir
defmodule Example do
  require Feature
  Feature.__using__(option: :value)
end
#+END_SRC
*** Understanding Aliases
An alias in Elixir is a capitalized identifier (like String, Keyword,
etc) which is converted to an atom during compilation. For instance,
the String alias translates by default to the atom =:"Elixir.String"=:
#+BEGIN_SRC
iex> is_atom(String)
true
iex> to_string(String)
"Elixir.String"
iex> :"Elixir.String" == String
true
#+END_SRC
Aliases expand to atoms because in the Erlang VM (and consequently
Elixir) modules are always represented by atoms. For example, that’s
the mechanism we use to call Erlang modules:
#+BEGIN_SRC
iex> :lists.flatten([1, [2], 3])
[1, 2, 3]
#+END_SRC
*** Module nesting
#+BEGIN_SRC elixir
defmodule Foo do
  defmodule Bar do
  end
end
#+END_SRC
The example above will define two modules: Foo and Foo.Bar. The second
can be accessed as Bar inside Foo as long as they are in the same
lexical scope. The code above is exactly the same as:
#+BEGIN_SRC elixir
defmodule Elixir.Foo do
  defmodule Elixir.Foo.Bar do
  end
  alias Elixir.Foo.Bar, as: Bar
end
#+END_SRC
- this nesting is a convenience. After the compilation, there’s no
  special relation between the modules

*** Multi alias/import/require/use
#+BEGIN_SRC
alias MyApp.{Foo, Bar, Baz}
#+END_SRC
** Module attributes
   Module attributes in Elixir serve three purposes:
1. They serve to annotate the module, often with information to be used by the user or the VM.
2. They work as constants.
3. They work as a temporary module storage to be used during compilation.
*** As annotations
Elixir has a handful of reserved attributes. Here are a few of them, the most commonly used ones:

- =@moduledoc=: provides documentation for the current module.

- =@doc=: provides documentation for the function or macro that
  follows the attribute.
- =@behaviour=: (notice the British spelling) used for specifying an
  OTP or user-defined behaviour.

- =@before_compile= - provides a hook that will be invoked before the
  module is compiled. This makes it possible to inject functions
  inside the module exactly before compilation

-
e.g.

#+BEGIN_SRC elixir
defmodule Math do
  @moduledoc """
  Provides math-related functions.

  ## Examples

      iex> Math.sum(1, 2)
      3

  """

  @doc """
  Calculates the sum of two numbers.
  """
  def sum(a, b), do: a + b
end
#+END_SRC
Elixir provide a tool called =ExDoc= which is used to generate HTML
pages from the documentation.
*** As “constants”
Elixir developers will often use module attributes as constants:

#+BEGIN_SRC elixir
defmodule Play do
  @initial_state %{host: "127.0.0.1", port: 3456}

  def main do
    IO.inspect @initial_state
  end
end
#+END_SRC

Every time an attribute is read inside a function, a snapshot of its
current value is taken. In other words, the value is read at
compilation time and not at runtime. As we are going to see, this also
makes attributes useful to be used as storage during module
compilation.

#+BEGIN_SRC elixir
defmodule MyServer do
  @my_data 14
  def first_data, do: @my_data
  @my_data 13
  def second_data, do: @my_data
end

MyServer.first_data #=> 14
MyServer.second_data #=> 13
#+END_SRC
*** As temporary storage
** Protocols
- Protocols are a mechanism to achieve polymorphism (runtime decision
  about which code to execute) in Elixir.
- A protocol is a module in which you declare functions without
  implementing them. Consider it a rough equivalent of an OO
  interface.
  #+BEGIN_SRC elixir
    defprotocol String.Chars do
      def to_string(thing) #  At runtime, the type of this argument
                           #  determines the implementation that’s called.
    end
  #+END_SRC
  Now different data types can implement the protocal
  #+BEGIN_SRC elixir
    defimpl String.Chars, for: Integer do
      def to_string(term) do
        Integer.to_string(term)
      end
    end
  #+END_SRC

- ~for: Type~: The ~Type~ is an atom and can be any of following
  aliase which are Elixir built-in types: ~Atom~, ~BitString~, ~Float~
  ~Function~, ~Integer~, ~List~, ~Map~, ~PID~, ~Port~, ~Reference~ and
  ~Tuple~
  + In addition, the alias ~Any~ is allowed, which makes it possible
    to specify a fallback implementation. An error will be raised,
    unless a fallback to ~Any~ is specified in the protocol definition
    and an ~Any~ implementation exists.
  + ~Type~ can also be an arbitrary alias
    #+BEGIN_SRC elixir
      defimpl String.Chars, for: SomeAlias do
          ...
      end
    #+END_SRC
    This implementation will be called if the first argument of the
    protocol function (the ~thing~) is a struct defined in the
    corresponding module.
    #+BEGIN_SRC elixir
      defimpl String.Chars, for: TodoList do
        def to_string(_) do
          "#TodoList"
        end
      end
    #+END_SRC

- e.g.
  #+BEGIN_SRC elixir
    defprotocol Blah do
      def foo(thing)
    end

    defimpl Blah, for: Learn do
      def foo(arg) do
        "goddamn #{arg.name}"
      end
    end

    defmodule Learn do
      defstruct [:name]

      def hello do
        me = %Learn{name: "Farhad"}
        Blah.foo(me)
      end
    end

    # goddamn farhad
    Learn.hello()
  #+END_SRC

- It’s important to notice that the protocol implementation doesn’t
  need to be part of any module. you can implement a protocol for a
  type even if you can’t modify the type’s source code. You can place
  the protocol implementation anywhere in your own code, and the
  runtime will be able to take advantage of it.

- Example
  #+BEGIN_SRC elixir
    # defining the protocol
    defprotocol Size do
      @doc "Calculates the size (and not the length!) of a data structure"
      def size(data)
    end

    # implementing the protocal for different data types
    defimpl Size, for: BitString do
      def size(string), do: byte_size(string)
    end

    defimpl Size, for: Map do
      def size(map), do: map_size(map)
    end

    defimpl Size, for: Tuple do
      def size(tuple), do: tuple_size(tuple)
    end
  #+END_SRC

  Usage
  #+BEGIN_SRC elixir
  iex> Size.size("foo")
  3

  iex> Size.size({:ok, "hello"})
  2

  iex> Size.size(%{label: "some label"})
  1

  iex> Size.size([1, 2, 3])
   (Protocol.UndefinedError) protocol Size not implemented for [1, 2, 3]
  #+END_SRC

- Instead of sharing protocol implementation with maps, structs
  require their own protocol implementation. Since a ~MapSet~ has its
  size precomputed and accessible through ~MapSet.size/1~, we can define
  a ~Size~ implementation for it:
  #+BEGIN_SRC elixir
  defimpl Size, for: MapSet do
    def size(set), do: MapSet.size(set)
  end
  #+END_SRC

  #+BEGIN_SRC elixir
  defmodule User do
    defstruct [:name, :age]
  end

  defimpl Size, for: User do
    def size(_user), do: 2
  end
  #+END_SRC
*** Implementing =Any=
#+BEGIN_SRC elixir
defimpl Size, for: Any do
  def size(_), do: 0
end
#+END_SRC
To use the above implementation we have to opt-in manually.

**** Deriving
When deriving, Elixir will implement the Size protocol for =Play=
based on the implementation provided for =Any=.

we can do so by =@derive= attribute:
#+BEGIN_SRC elixir
defmodule Play do
  @derive [Size]
  defstruct name: "farhad", age: 26
end
#+END_SRC

**** Fallback to Any
Another alternative to =@derive= is to explicitly tell the protocol to
fallback to =Any= when an implementation cannot be found. This can be
achieved by setting =@fallback_to_any= to =true= in the protocol
definition:
#+BEGIN_SRC elixir
defprotocol Size do
  @doc "Calculates the size (and not the length!) of a data structure"
  @fallback_to_any true
  def size(data)
end
#+END_SRC

*** Built-in protocols
- Elixir comes with some predefined protocols.
- ~String.Chars~: for converting data into a binary string
- ~List.Chars~: converts input data to a character string (a list of
  characters)
- ~Enumerable~:
- ~Collectable~: a collectable structure is one that you can
  repeatedly add elements to. A collectable can be used with
  comprehensions to collect results or with ~Enum.into/2~ to transfer
  elements of one structure (enumerable) to another (collectable).

*** Example implementing ~Collectable~
#+BEGIN_SRC elixir
  defmodule TodoList do
    defstruct auto_id: 1, entries: %{}

    def new(entries \\ []) do
      Enum.reduce(entries, %TodoList{}, &add_entry(&2, &1))
    end

    def add_entry(todo_list, entry) do
      entry = Map.put(entry, :id, todo_list.auto_id)
      new_entries = Map.put(todo_list.entries, todo_list.auto_id, entry)

      %TodoList{todo_list | entries: new_entries, auto_id: todo_list.auto_id + 1}
    end

  end

  defimpl Collectable, for: TodoList do
    def into(original) do
      {original, &into_callback/2}
    end

    defp into_callback(todo_list, {:cont, entry}) do
      TodoList.add_entry(todo_list, entry)
    end

    defp into_callback(todo_list, :done), do: todo_list
    defp into_callback(todo_list, :halt), do: :ok
  end
#+END_SRC
- Usage
  #+BEGIN_SRC elixir
    iex> entries
    [
      %{date: ~D[2018-12-19], title: "Dentist"},
      %{date: ~D[2018-12-20], title: "Shopping"},
      %{date: ~D[2018-12-19], title: "Movies"}
    ]

    iex> for entry <- entries, into: TodoList.new(), do: entry
    %TodoList{
      auto_id: 4,
      entries: %{
        1 => %{date: ~D[2018-12-19], id: 1, title: "Dentist"},
        2 => %{date: ~D[2018-12-20], id: 2, title: "Shopping"},
        3 => %{date: ~D[2018-12-19], id: 3, title: "Movies"}
      }
    }
  #+END_SRC
** Enum module
Types which implements Enumerable hence can be used with Enum methods
- Lists
- Keyword Lists
- Maps (not Structs)
- Ranges
- Streams
*** Some useful Enum methods
**** Enum.map
**** Enum.each
**** Enum.at
Note when this method is used with Maps is returns a tuple.
#+BEGIN_SRC elixir
Enum.at %{:name => "Farhad", :age => 25}, 0, :default # {:age, 25}
#+END_SRC

**** Enum.filter
Note the anonymous function gets a tuple and returns a keyword list
#+BEGIN_SRC elixir
%{:name => "Farhad", :age => 25}
|> Enum.filter(fn({_key, val}) -> is_number val end) # returns a keyword list [age: 25]
#+END_SRC

**** Enum.reduce
**** Enum.into
Converts an =Enumerable= to another type. Target must implement
=Collectable= protocol. lists and maps both implement collectable
protocol

In the example we convert a keyword list to a map
#+BEGIN_SRC elixir
%{:name => "Farhad", :age => 25}
|> Enum.filter(fn({_k, v}) -> is_binary(v) end) # retuns a keyword list [name: "Farhad"]
|> Enum.into(%{}) # make it a map %{name: "Farhad"}
#+END_SRC

**** Enum.take
#+BEGIN_SRC elixir
Enum.take(10..20, 5)  # [10, 11, 12, 13, 14]
#+END_SRC

** Streams
=Stream= is a lazy version of =Enum=.  Unlike =Enum= which does it's
job immediately, =Stream= waits until you ask for the result. This
could end up to be more efficient; like iterating over a list once for
all rather than doin' it for each operation like =Enum= does.

#+BEGIN_QUOTE
Due to their laziness, streams are useful when working with large (or
even infinite) collections. When chaining many operations with Enum,
intermediate lists are created, while Stream creates a recipe of
computations that are executed at a later moment.
#+END_QUOTE

#+BEGIN_SRC elixir
[1, 2, "buckle up your shoe", 3, 4]
|> Stream.filter(&is_number/1) # I don't feel like doin' it write now
|> Stream.filter(&(rem(&1, 2) == 0)) # nope not yet
|> Enum.into([]) # okay, I'll do it. [2, 4]
#+END_SRC

#+BEGIN_SRC elixir
  list = [1, 2, 3, "string", 4, 8]

  # stream stores the anonymous functions and returns a Stream struct
  stream = Stream.filter(list, &is_number/1)

  # stream stores the anonymous functions and returns a Stream struct
  stream = Stream.filter(stream, &(rem(&1, 2) == 0))

  Enum.into(stream, []) # up until now Stream hasn't done any actuall
                         # work. By Enum.into we make it to do the
                         # operations we asked for earlier
#+END_SRC

*** Stream.cycle
Creates a stream that cycles through the given enumerable, infinitely.
#+BEGIN_SRC elixir
Stream.cycle([1, 2, 3, "meow"])
|> Enum.take(8)
#+END_SRC
*** Stream.iterate
Emits a sequence of values, starting with =start_value=. Successive
values are generated by calling =next_fun= on the previous value.
#+BEGIN_SRC elixir
Stream.iterate(0, &(&1+1)) |> Enum.take(5) # [0, 1, 2, 3, 4]
#+END_SRC
*** Stream.resource
** Comprehension
- [[https://hexdocs.pm/elixir/Kernel.SpecialForms.html#for/1][doc]]
- It's another name for =for= macro in Elixir which returns a list.
- comprehensions can iterate through anything that’s enumerable
- comprehensions can return anything that’s collectable. Some examples
  include lists, maps, MapSet, and file streams

- The =for= macro has three parts:
  1. Generators
  2. Filters
  3. =:into= Option
     + the following types support ~Collectable~
       * Map
       * List
       * IO.Stream
       * Bitstring (binary)

*** Generators
=element <- Enumerable=
It's possible to have multiple generators in a single =for= comprehension
#+BEGIN_SRC elixir
suits = [:hearts, :diamonds, :clubs, :spades]
faces = [2, 3, 4, 5, 6, 7, 8, 9, 10, :jack, :queen, :king, :ace]

for suit <- suits,
  face <- faces,
  do: {suit, face}
#+END_SRC
Pattern Matching is also allowed.
#+BEGIN_SRC elixir
for {:spades, face} <- deck do
  {:spades, face}
end
#+END_SRC
With bitstring
#+BEGIN_SRC elixir
pixels = <<213, 45, 132, 64, 76, 32, 76, 0, 0, 234, 32, 15>>
for <<r::8, g::8, b::8 <- pixels>>, do: {r, g, b} # [{213, 45, 132}, {64, 76, 32}, {76, 0, 0}, {234, 32, 15}]
#+END_SRC
*** Filters
#+BEGIN_SRC elixir
for element <- Enumerable, filter do
  element
end
#+END_SRC

#+BEGIN_SRC elixir
suits = [:hearts, :diamonds, :clubs, :spades]
faces = [2, 3, 4, 5, 6, 7, 8, 9, 10, :jack, :queen, :king, :ace]

for suit <- suits,
  face <- faces,
  suit == :spades,
  is_number(face),
  face > 5,
  do: {suit, face}
#+END_SRC

#+BEGIN_SRC elixir
users = [user: "john", admin: "meg", guest: "barbara"]

for {type, name} when type != :guest <- users do
    String.upcase(name)
end
#+END_SRC

#+BEGIN_SRC elixir
    dirs = ['/home/farhad/Downloads/Educator.Algebra.1', '/home/farhad/Pictures']

    for dir <- dirs,
        file <- File.ls!(dir),
        path = Path.join(dir, file),
        File.regular?(path) do
      File.stat!(path).size
    end
#+END_SRC
*** =:into=
- Return something other than a list with the =:into= option:
  #+BEGIN_SRC elixir
  for {key, val} <- %{name: "Farhad", dob: 1993, email: "farhad.hsni@gmail.com"},
      key in [:name, :email],
      into: %{},
      do: {key, val}
  #+END_SRC
- e.g.
  #+BEGIN_SRC elixir
  for <<c <- " hello world ">>, c != ?\s, into: "", do: <<c>> # "helloworld"
  #+END_SRC
- e.g.
  #+BEGIN_SRC
  iex> multiplication_table = for x <- 1..9, y <- 1..9, into: %{} do {{x, y}, x*y} end
  ...

  iex> multiplication_table[{8, 6}]
  48
  #+END_SRC


Sets, maps, and other dictionaries can also be given to the ~:into~
option. In general, =:into= accepts any structure that implements the
=Collectable= protocol.

IO module provides streams (that are both Enumerables and Collectables)
#+BEGIN_SRC elixir
    stream = IO.stream(:stdio, :line)

    for line <- stream, into: stream do
      String.upcase(line) <> "\n"
    end
#+END_SRC

*** =for= vs. =Enum= vs. =Stream=
|            | Enum    | Stream | for  |
|------------+---------+--------+------|
| map        | YES     | YES    | YES  |
| filter     | YES     | YES    | YES  |
| lazy       | NO      | YES    | NO   |
| iterations | DEPENDS | ONCE   | ONCE |
| & Operator | YES     | YES    | NO   |

A more complex example
#+BEGIN_SRC elixir
defmodule Triple do
  def pythagorean(n) when n > 0 do
    for a <- 1..n,
      b <- 1..n,
      c <- 1..n,
      a + b + c <= n,
      a*a + b*b == c*c,
      do: {a, b, c}
  end
end

Triple.pythagorean(5) # []
Triple.pythagorean(12) # [{3, 4, 5}, {4, 3, 5}]
#+END_SRC
** Sigils
Sigils are one of the mechanisms provided by the language for working
with textual representations. Sigils start with the tilde (~)
character which is followed by a letter (which identifies the sigil)
and then a delimiter; optionally, modifiers can be added after the
final delimiter.

Sigils are a way to create a shorthand. There are bunch of userful
built-in sigil but we can also create our own sigils by =sigil_*=
function in a module and use it like =~*(blah blah)=. It also possible
to override built-in sigils.

Sigils are simply replaced by =sigil_*=
function at compile time.
#+BEGIN_SRC elixir
~r/foobar/im # sigil_r("foobar", 'im')
#+END_SRC

:NOTE:
Each sigil has a lowercase and upercase version. Uppercase sigils
doesn't allow interpolation
#+BEGIN_SRC elixir
name = "Farhad"
~S(my name is #{name}) # "my name is \#{name}"
~s(my name is #{name}) # "my name is Farhad"
#+END_SRC
:END:

Defining a custom sigil
#+BEGIN_SRC elixir
def sigil_u(content, _opts) do
  content
  |> String.split
  |> Enum.map(&String.upcase/1)
end
~u(foo bar) # ["FOO", "BAR"]
#+END_SRC
another example
#+BEGIN_SRC elixir
defmodule MySigils do
  def sigil_i(string, []), do: String.to_integer(string)
  def sigil_i(string, [?n]), do: -String.to_integer(string)
end

~i(13) # 13
~i(42)n # -42
#+END_SRC

*** delimiters
#+BEGIN_SRC elixir
~r/hello/
~r|hello|
~r"hello"
~r'hello'
~r(hello)
~r[hello]
~r{hello}
~r<hello>
#+END_SRC
*** Word List sigil
#+BEGIN_SRC elixir
~w(foo bar)  # ["foo", "bar"]
~w(foo bar)a # [:foo, :bar]
#+END_SRC

*** String sigil
#+BEGIN_SRC elixir
~s(foo bar) # "foo bar"
~s({"name": "Devin Torres", "age": 27}) # JSON
~s"""
this is
a heredoc string
"""

#+END_SRC

*** Character List sigil
#+BEGIN_SRC elixir
iex(1)> ~c(it's #{40 + 2})
'it\'s 42'

iex(2)> ~C(it's #{40 + 2})
'it\'s \#{40 + 2}'
#+END_SRC

** try, catch, and rescue
- BEAM distinguishes three types of runtime errors: errors, exits, and
  throws
  #+BEGIN_SRC elixir
    defmodule Play do
      def main do
        try do
          throw("catch me")
          # raise("oh no")
          # exit("i'm tired")
        catch
          :error, foo ->
            IO.inspect(foo)

          :exit, foo ->
            IO.inspect(foo)

          :throw, foo ->
            IO.inspect(foo)
        after
          IO.puts """
          I always run, that being said, I won't affect the result of the
          entire `try` expression. The result of `try` is the result of
          the last statement either from the `do` block or from the
          corresponding `catch` block if something was caught
          """
        end
      end
    end
  #+END_SRC
- A runtime error also has a value, which can be any arbitrary term.
- If a runtime error isn’t handled, the corresponding process will
  terminate.
- In a complex system, most bugs are flushed out in the testing
  phase. The remaining bugs mostly fall into a so-called /Heisenbug
  category/ — unpredictable errors that occur irregularly in special
  circumstances and are hard to reproduce. The cause of such errors
  usually lies in corruptness of the state. Therefore, a reasonable
  remedy for such errors is to let the process crash and start another
  one.

*** raise
#+BEGIN_SRC elixir
iex> raise "oops"
 (RuntimeError) oops
iex> raise ArgumentError, message: "invalid argument foo"
 (ArgumentError) invalid argument foo
#+END_SRC

*** defexception
#+BEGIN_SRC elixir
defmodule MyError do
  defexception message: "default message"
end

raise MyError # (MyError) default message
raise MyError, message: "custom message" # (MyError) custom message
#+END_SRC

*** try/rescue
#+BEGIN_SRC elixir
defmodule Main do
  defexception message: "fuck this shit"

  def run do
    try do
      raise __MODULE__
    rescue
      e in __MODULE__ -> {"oh I know this one", e}

      RuntimeError -> "oops runtime error"

      _ -> "I have know idea"
    end
  end
end

Main.run()
#+END_SRC

*** throws
- The purpose of throws is to allow nonlocal returns. Elixir programs
  are organized in many nested function calls. In particular, loops
  are implemented as recursions. The consequence is that there are no
  constructs such as ~break~, ~continue~, and ~return~, which you’ve
  probably seen in other languages. When you’re deep in a loop, it’s
  not trivial to stop the loop and return a value, and throws can help
  with this. You can throw a value and catch it up the call stack. But
  using throws for control flow is hacky, somewhat reminiscent of
  ~goto~, and you should avoid this technique as much as possible.

- In Elixir, we avoid using =try/rescue= because we don’t use errors
  for control flow. We take errors literally: they are reserved for
  unexpected and/or exceptional situations. In case you actually need
  flow control constructs, =throws= should be used.

- In Elixir, a value can be thrown and later be caught. =throw= and
  =catch= are reserved for situations where it is not possible to
  retrieve a value unless by using =throw= and =catch=.
  #+BEGIN_SRC elixir
  try do
    Enum.each -50..50, fn(x) ->
      if rem(x, 13) == 0, do: throw(x)
    end
    "Got nothing"
  catch
    x -> "Got #{x}"
  end
  #+END_SRC
*** Exits
A process can also die by explicitly sending an =exit= signal:
#+BEGIN_SRC
iex> spawn_link fn -> exit(1) end
 (EXIT from #PID<0.56.0>) evaluator process exited with reason: 1
#+END_SRC

=exit= can also be “caught” using =try/catch=:
#+BEGIN_SRC elixir
try do
  exit "I am exiting"
catch
  :exit, _ -> "not really"
end
#+END_SRC

*** after
#+BEGIN_SRC elixir
{:ok, file} = File.open "sample", [:utf8, :write]

try do
  IO.write file, "olá"
  raise "oops, something went wrong"
after
  File.close(file)
end
#+END_SRC

The =after= clause will be executed regardless of whether or not the
tried block succeeds.

Elixir will automatically wrap the function body in a try whenever one
of =after=, =rescue= or =catch= is specified.
#+BEGIN_SRC elixir
defmodule Main do
  def run do
    Enum.each(1..10, fn x -> IO.puts(x) end)
  after
    IO.puts("inside after")
  end
end
#+END_SRC

*** else
If an else block is present, it will match on the results of the try
block whenever the try block finishes without a throw or an error.

#+BEGIN_SRC elixir
  defmodule Main do
    def run do
      x = 2

      try do
        1 / x
      rescue
        ArithmeticError -> :infinity
      else
        y when y < 1 and y > -1 -> :small
        _ -> :large
      end
    end
  end

  Main.run()
  |> IO.inspect()                 # :small
#+END_SRC

** Typespecs and behaviours
*** [[https://hexdocs.pm/elixir/typespecs.html][Typespecs]]
Elixir comes with typespecs, which are a notation used for:
- declaring typed function signatures (specifications);
- declaring custom data types.
**** Function specifications
 #+BEGIN_SRC elixir
 defmodule Main do
   @spec inc(number) :: integer

   def inc(x) do
     x + 1
   end
 end

 Main.inc(8)
 #+END_SRC
**** Defining custom types
 #+BEGIN_SRC elixir
 defmodule LousyCalculator do
   @typedoc """
   Just a number followed by a string.
   """
   @type number_with_remark :: {number, String.t}

   @spec add(number, number) :: number_with_remark
   def add(x, y), do: {x + y, "You need a calculator to do that?"}

   @spec multiply(number, number) :: number_with_remark
   def multiply(x, y), do: {x * y, "It is like addition on steroids."}
 end
 #+END_SRC

*** Behaviours
- In Erlang terminology, a behaviour is generic code that implements a
  common pattern. The generic logic is exposed through the behaviour
  module, and you can plug into it by implementing a corresponding
  callback module. The callback module must satisfy a contract defined
  by the behaviour, meaning it must implement and export a set of
  functions. The behaviour module then calls into these functions,
  allowing you to provide your own specialization of the generic code.

- Behaviours provide a way to:
  - define a set of functions that have to be implemented by a module
  - ensure that a module implements all the functions in that set

- example
  #+BEGIN_SRC elixir
  defmodule Parser do
    @callback parse(String.t) :: {:ok, term} | {:error, String.t}
    @callback extensions() :: [String.t]
  end
  #+END_SRC
  Modules adopting the =Parser= behaviour will have to implement all the
  functions defined with the =@callback= directive. As you can see,
  =@callback= expects a function name but also a function specification
  like the ones used with the =@spec= directive we saw above. Also note
  that the =term= type is used to represent the parsed value. In Elixir,
  the =term= type is a shortcut to represent any type.
  #+BEGIN_SRC elixir
  defmodule JSONParser do
    @behaviour Parser

    @impl Parser
    def parse(str), do: {:ok, "some json " <> str} # ... parse JSON

    @impl Parser
    def extensions, do: ["json"]
  end
  #+END_SRC
**** Dynamic dispatch
Behaviours are frequently used with dynamic dispatching. For example,
we could add a =parse!= function to the Parser module that dispatches
to the given implementation and returns the =:ok= result or raises in
cases of =:error=:
#+BEGIN_SRC elixir
defmodule Parser do
  @callback parse(String.t) :: {:ok, term} | {:error, String.t}
  @callback extensions() :: [String.t]

  def parse!(implementation, contents) do
    case implementation.parse(contents) do
      {:ok, data} -> data
      {:error, error} -> raise ArgumentError, "parsing error: #{error}"
    end
  end
end
#+END_SRC
** Debugging
*** IO.inspect/2
we can label the outputs
#+BEGIN_SRC elixir
[1, 2, 3]
|> IO.inspect(label: "before") # before: [1, 2, 3]
|> Enum.map(&(&1 * 2))
|> IO.inspect(label: "after")  # after: [2, 4, 6]
|> Enum.sum
#+END_SRC
**** binding
#+BEGIN_SRC elixir
def some_fun(a, b, c) do
  IO.inspect binding()
end
#+END_SRC
When =some_fun/3= is invoked with =:foo, "bar", :baz= it prints:
#+BEGIN_SRC
[a: :foo, b: "bar", c: :baz]
#+END_SRC
*** IEx.pry/0 and IEx.break!/2
[[https://elixir-lang.org/getting-started/debugging.html#iexpry0-and-iexbreak2][doc]]

#+BEGIN_SRC elixir
  def run(a, b, c) do
  require IEx
    IEx.pry()                     # break point
    jafar = "jafar"
    IEx.pry()                     # break point
  end
#+END_SRC
*** Debugger
if =:debugger.start()= doesn't work remove erlang-nox and install the full erlang version.
https://brainlid.org/elixir/2015/11/27/linux-elixir-observer-start.html

#+BEGIN_SRC
$ iex -S mix
iex(1)> :debugger.start()
{:ok, #PID<0.87.0>}
iex(2)> :int.ni(Example)
{:module, Example}
iex(3)> :int.break(Example, 3)
:ok
iex(4)> Example.double_sum(1,2)

#+END_SRC
*** Observer
#+BEGIN_SRC
$ iex -S mix
iex(1)> :observer.start()
#+END_SRC

Also =runtime_info/0= is a gives a minimal overview.
** erlang
Elixir discourages simply wrapping Erlang libraries in favor of
directly interfacing with Erlang code.
*** The binary module
The built-in Elixir String module handles binaries that are UTF-8
encoded. The binary module is useful when you are dealing with binary
data that is not necessarily UTF-8 encoded.
#+BEGIN_SRC
iex> String.to_charlist "Ø"
[216]
iex> :binary.bin_to_list "Ø"
[195, 152]
#+END_SRC
The =String= module returns Unicode codepoints, while =:binary= deals with
raw data bytes.
*** The crypto module
#+BEGIN_SRC
iex> Base.encode16(:crypto.hash(:sha256, "Elixir"))
"3315715A7A3AD57428298676C5AE465DADA38D951BDFAC9348A8A31E9C7401CB"
#+END_SRC
The =:crypto= module is not part of the Erlang standard library, but is
included with the Erlang distribution. This means you must list
=:crypto= in your project’s applications list whenever you use it. To do
this, edit your ~mix.exs~ file to include:

#+BEGIN_SRC elixir
def application do
  [extra_applications: [:crypto]]
end
#+END_SRC

*** The digraph module
The digraph module (as well as digraph_utils) contains functions for
dealing with directed graphs built of vertices and edges. After
constructing the graph, the algorithms in there will help finding, for
instance, the shortest path between two vertices, or loops in the
graph.

#+BEGIN_SRC elixir
iex> digraph = :digraph.new()
iex> coords = [{0.0, 0.0}, {1.0, 0.0}, {1.0, 1.0}]
iex> [v0, v1, v2] = (for c <- coords, do: :digraph.add_vertex(digraph, c))
iex> :digraph.add_edge(digraph, v0, v1)
iex> :digraph.add_edge(digraph, v1, v2)
iex> :digraph.get_short_path(digraph, v0, v2)
[{0.0, 0.0}, {1.0, 0.0}, {1.0, 1.0}]
#+END_SRC
Note that the functions in ~:digraph~ alter the graph structure
in-place, this is possible because they are implemented as ETS tables.

*** Erlang Term Storage
The modules =ets= and =dets= handle storage of large data structures in
memory or on disk respectively.

ETS lets you create a table containing tuples. By default, ETS tables
are protected, which means only the owner process may write to the
table but any other process can read. ETS has some functionality to be
used as a simple database, a key-value store or as a cache mechanism.
#+BEGIN_SRC
iex> table = :ets.new(:ets_test, [])
# Store as tuples with {name, population}
iex> :ets.insert(table, {"China", 1_374_000_000})
iex> :ets.insert(table, {"India", 1_284_000_000})
iex> :ets.insert(table, {"USA", 322_000_000})
iex> :ets.i(table)
<1   > {<<"India">>,1284000000}
<2   > {<<"USA">>,322000000}
<3   > {<<"China">>,1374000000}
#+END_SRC

*** The math module
*** The queue module
#+BEGIN_SRC
iex> q = :queue.new
iex> q = :queue.in("A", q)
iex> q = :queue.in("B", q)
iex> {value, q} = :queue.out(q)
iex> value
{:value, "A"}
iex> {value, q} = :queue.out(q)
iex> value
{:value, "B"}
iex> {value, q} = :queue.out(q)
iex> value
:empty
#+END_SRC
*** the rand module
#+BEGIN_SRC
iex> :rand.uniform()
0.8175669086010815
iex> _ = :rand.seed(:exs1024, {123, 123534, 345345})
iex> :rand.uniform()
0.5820506340260994
iex> :rand.uniform(6)
6
#+END_SRC
*** The zip and zlib modules
** Mix, Hex and others
The build tool for elixir
- =mix new foobar= to create foobar project
- =iex -S mix= to start iex in the context of a mix project
- ~mix run -e "IO.puts(MyProject.hello())"~
- There're two ways to set a key-value config in config.exs
  + =config :projectName, key: value=
  + =config :projectName, Module.Name, key: value=
- To get a configuration from =config.exe=
  + =Application.get_env(:projectName, :key)=
  + =Application.get_env(:projectName, __MODULE__)[:key]=
- to install hex =mix local.hex=
- to get deps specified in mix file =mix deps.get=
- to remove deps that you have removed from mix file =mix deps.clean PACKAGE_NAME=
- to update a dependency; bump the version in mix file then =mix deps.update PACKAGE_NAME=
- add ~config :package_name, setting_a: "value"~ to =config/config.exs= to configure a package
- =mix hex.outdated= to find out which packages are outdated
- for uploading your package to Hex, add ~package/0~ setting to Mixfile
  #+BEGIN_SRC elixir
    defp package do
      [
        files: ["lib", "mix.exs", "README.md"],
        contributors: ["Your Name"],
        licenses: ["MIT"],
        links: %{
          "Github" => "https://github.com/fhdhsni/repo"
        }
      ]
    end
  #+END_SRC
  + remember to update =application/0= to specify each one of your
    runtime dependencies as an application in the =:application= list
    #+BEGIN_SRC elixir
    def application do
      [application: [:dependency_a, :dependency_b]]
    end
  #+END_SRC
  + update project/0 setting
    #+BEGIN_SRC elixir
      def project do
        [app: :my_project_name,
         version: "0.0.1",
         elixir: "~> 1.0",
         build_embedded: Mix.env == :prod,
         start_permanent: Mix.env == :prod,
         source_url: "https://github.com/fhdhsni/repo",
         description: "short description of project",
         package: package,
         deps: deps,
        ]
      end
    #+END_SRC
  + =mix hex.publish=
*** custom tasks
- https://hexdocs.pm/mix/Mix.html#module-mix-task

** ExUnit
- =assert=
  + expects truthy values
- =refute=
  + expects falsy values
- =assert_raise=
  + Assert that a code block raises an exception
- =assert_in_delta=
  + Assert that two things differ in a specific way
- =assert_receive=
  + Assert that a process message was received
*** Shared setup
#+BEGIN_SRC elixir
defmodule CryptoTest do
  use ExUnit.Case
  doctest Crypto

  setup do
    variable = 3
    {:ok, variable: variable}
  end

  test "the truth", %{variable: variable} do
    refute 1 + 1 == variable
  end
end
#+END_SRC
*** ExUnit.CaseTemplate
*** Running tests asynchronously
#+BEGIN_SRC elixir
  defmodule MyApp.MathTest do
    use ExUnit.Case, async: true

    # ...
  end
#+END_SRC
*** Tagging
#+BEGIN_SRC elixir
defmodule CryptoTest do
  # This would tag all the tests in the module as slow
  @moduletag :slow

  use ExUnit.Case
  doctest Crypto

  # This tags only one test
  @tag :slow
  test "2 plus one should be three" do
    assert 2 + 1 == 3
  end
end
#+END_SRC
Then you can exclude tests with a given tag by adding the following snippet to =test/test_helpers.exs=
#+BEGIN_SRC elixir
ExUnit.start()
ExUnit.configure exclude: [:slow]
#+END_SRC

**** skip
There's also the built-in =skip= tag
#+BEGIN_SRC elixir
@tag :skip
# org
@tag skip: "Reason"
#+END_SRC
*** Pending Tests
#+BEGIN_SRC elixir
# Automatically tagged with @tag :not_implemented
  test ".add subs two numbers"
  test ".div divides two numbers"
  test ".mul multiples two numbers"
#+END_SRC
*** Doctests
use =doctests MyApp.MyModule= in test file to consider doc examples as tests

Written inline with documentation for a module of function typically under an =## Examples= heading.
#+BEGIN_SRC elixir
  defmodule MyApp.Math do
    @doc """
    Adds two numbers together and returns the sum.

    ## Examples

        iex> Math.add(1, 2)
        3

        iex> sum = Math.add(5, 5)
        ...> Math.add(sum. 5)
        15

    """
    def add(a, b), do: a + b
  end
#+END_SRC

Another example
#+BEGIN_SRC elixir
defmodule KVServer.Command do
  @doc ~S"""
  Parses the given `line` into a command.

  ## Examples

      iex> KVServer.Command.parse("CREATE shopping\r\n")
      {:ok, {:create, "shopping"}}

  """
  def parse(_line) do
    :not_implemented
  end
end
#+END_SRC
Note that we started the documentation string using =@doc ~S"""=. The
=~S= prevents the =\r\n= characters from being converted to a carriage
return and line feed until they are evaluated in the test.

*** Running tests
Exclude tests tagged with :slow
=mix test --exclude slow=
or include them
=mix test --include slow=
or only run those with this tag
=mix test --only slow=

** Processes
- processes share no memory. Thus, sending a message to another
  process results in a deep copy of the message contents. A special
  case where deep-copying doesn’t take place involves binaries
  (including strings) that are larger than 64 bytes. These are
  maintained on a special shared binary heap, and sending them doesn’t
  result in a deep copy.
- Each BEAM scheduler is in reality an OS thread that manages the
  execution of BEAM processes. By default, BEAM uses only as many
  schedulers as there are logical processors available
- Internally, each scheduler maintains a run queue, which is something
  like a list of BEAM processes it’s responsible for. Each process
  gets a small execution window, after which it’s preempted and
  another process is executed. The execution window is approximately
  2,000 function calls (internally called reductions).
- There are some special cases when a process will implicitly yield
  execution to the scheduler before its execution time is up. The most
  notable situation is when using ~receive~. Another example is a call
  to the ~Process.sleep/1~ function. In both cases, the process is
  suspended, and the scheduler can run other processes.
- Another important case of implicit yielding involves I/O operations,
  which are internally executed on separate threads called async
  threads. When issuing an I/O call, the calling process is preempted,
  and other processes get the execution slot. After the I/O operation
  finishes, the scheduler resumes the calling process. A great benefit
  of this is that your I/O code looks synchronous, while under the
  hood it still runs asynchronously. By default, BEAM fires up 10
  async threads, but you can change this via the ~+A n~ Erlang flag.
- if your OS supports it, you can rely on a kernel poll such as ~epoll~
  or ~kqueue~, which takes advantage of the OS kernel for nonblocking
  I/O. You can request the use of a kernel poll by providing the ~+K true~
  Erlang flag when you start the BEAM. Implicit yields provide
  additional benefits. If most processes are suspended most of the
  time — for example, while the kernel is doing I/O or while many
  processes are waiting for messages — BEAM schedulers are even more
  efficient and have bigger overall throughput.
- a process can be registered under a local name (an atom), where
  local means the name is registered only in the currently running
  BEAM instance.
- There are various reasons for running a piece of code in a dedicated
  server process:
  + The code must manage a long-living state.
  + The code handles a kind of a resource that can and should be
    reused, such as a TCP connection, database connection, file
    handle, pipe to an OS process, and so on.
  + A critical section of the code must be synchronized. Only one
    process may run this code in any moment.
- One link connects exactly two processes and is always bidirectional
*** Process registrations
- The basic registration facility is a local registration that allows you to use a simple atom as an alias to the single process on a node.
- ~Registry~ extends this by letting you use rich aliases — any term can be used as an alias.
- ~:global~ allows you to register a cluster-wide alias.
- ~:pg2~ is useful for registering multiple processes behind a
  cluster-wide alias (process group), which is usually suitable for
  distributed pub-sub scenarios.

*** monitor
- Sometimes you need to connect two processes, A and B, in such a way
  that process A is notified when B terminates, but not the other
  way around. In such cases, you can use a monitor, which is something
  like a unidirectional link.
  #+BEGIN_SRC elixir
  monitor_ref = Process.monitor(target_pid)
  #+END_SRC
  + This makes the current process monitor the target process. The
    result is a unique reference that identifies the monitor. A single
    process can create multiple monitors.
  + If the monitored process dies, your process receives a message in the format
    #+BEGIN_SRC elixir
    {:DOWN, monitor_ref, :process, from_pid, exit_reason}.
    #+END_SRC
  + you can also stop the monitor by calling ~Process.demonitor(monitor_ref)~
*** Monitors or links?
- Links are bi-directional. If you link two processes and one of them
  crashes, the other side will crash too (unless it is trapping
  exits). A monitor is uni-directional: only the monitoring process
  will receive notifications about the monitored one. In other words:
  use links when you want linked crashes, and monitors when you just
  want to be informed of crashes, exits, and so on.
- There are two main differences between monitors and links. First,
  monitors are unidirectional — only the process that created a
  monitor receives notifications. In addition, unlike a link, the
  observer process won’t crash when the monitored process
  terminates. Instead, a message is sent, which you can handle or
  ignore.

*** =spawn=
#+BEGIN_SRC sh
iex> pid = spawn fn -> 1 + 2 end
#PID<0.43.0>
iex> Process.alive?(pid)
false
#+END_SRC
=spawn(someModule, :some_function, [arg1, arg2])=
**** spawn
Spawned process is isolated. If it raises an error parent process won't die.
**** spawn_link
In this way failure in the spawned process propagates to parent
process. It's also possible to link processes via =Process.link/1=

In the parent process we can =:trap_exit= and to something other than
dying if the spawned process died.
#+BEGIN_SRC elixir
  Process.flag(:trap_exit, true)
  pid = spawn_link(fn -> raise("Something went wrong") end)

  receive do
    {:EXIT, pid, reason} ->
      # Revive pid?
  end
#+END_SRC
**** spawn_monitor
#+BEGIN_SRC elixir
  {juliet, _ref} = spawn_monitor(fn -> ... end)
  receive do
    {:DOWN, _ref, :process, pid} ->
      # Revive juliet
  end
#+END_SRC
*** =self=
returns current process PID
*** =send=
The process that sends the message does not block on send/2, it puts
the message in the recipient’s mailbox and continues.
*** =receive=
- The receive expression works as follows:
  1. Take the first message from the mailbox.
  2. Try to match it against any of the provided patterns, going from
     top to bottom.
  3. If a pattern matches the message, run the corresponding code.
  4. If no pattern matches, put the message back into the mailbox at
     the same position it originally occupied. Then try the next
     message.
  5. If there are no more messages in the queue, wait for a new one to
     arrive. When a new message arrives, start from step 1, inspecting
     the first message in the mailbox.
  6. If the ~after~ clause is specified and no message is matched in the
     given amount of time, run the code from the ~after~ block.

- messages are analyzed one by one, from oldest to newest, until a
  message is matched. Let’s say your process contains a million
  unhandled messages. When a new message arrives, receive iterates
  through the existing million messages before processing the new one.

- If a message doesn’t match any of the provided clauses, it’s put
  back into the process mailbox, and the next message is processed.
- If there is no message in the mailbox matching any of the patterns,
  the current process will wait until a matching message arrives. A
  timeout can also be specified with =after= block:
  #+BEGIN_SRC
  iex> receive do
  ...>   {:hello, msg}  -> msg
  ...> after
  ...>   1_000 -> "nothing after 1s"
  ...> end
  "nothing after 1s"
  #+END_SRC
  Messages that don't match any of provided patterns will be left in the
  process's mailbox. Mailbox may fill up.
*** =flush=
It flushes and prints all the messages in the mailbox.
*** =kill=
=Process.exit(pid, :kil)=

example
#+BEGIN_SRC elixir
  defmodule Play do
    def ground(pid) do
      # send self(), {:hello, "World"}
      receive do
        {:hello, msg} -> IO.puts msg
        {:world, _msg} -> IO.puts "fuck this shit"
      after
        1_000 -> send pid, {:bye, "papa"}
      end
    end
  end

  spawn Play, :ground, [self()]
  # Play.ground
  # send pid, {:hello, "World"}

  receive do
    {:bye, name} -> IO.puts name  # papa
    _ -> IO.puts "unknown crap"
  end
#+END_SRC

*** keeping state
#+BEGIN_SRC elixir
defmodule KV do
  def start_link do
    Task.start_link(fn -> loop(%{}) end)
  end

  defp loop(map) do
    receive do
      {:get, key, caller} ->
        send caller, Map.get(map, key)
        loop(map)
      {:put, key, value} ->
        loop(Map.put(map, key, value))
    end
  end
end


{:ok, pid} = KV.start_link;

send pid, {:put, "name", "farhad"}

send pid, {:get, "name", self()}

receive do
  name -> IO.inspect name       # farhad
end
#+END_SRC
*** Processes that shouldn’t crash
- There are two important situations in which you should explicitly handle an error:
   + In critical processes that shouldn’t crash
   + When you expect an error that can be dealt with in a meaningful
     way
- Processes that shouldn’t crash are informally called a system’s
  error kernel—processes that are critical for the entire system to
  work and whose state can’t be restored in a simple and consistent
  way. Such processes are the heart of your system, and you generally
  don’t want them to crash, because without them the system can’t
  provide any service.
- If the code of your error-kernel process is complex, consider
  splitting it into two processes: one that holds state, and another
  that does the actual work. The former process then becomes extremely
  simple and is unlikely to crash, whereas the worker process can be
  removed from the error kernel (because it no longer maintains
  critical state).
- In addition, you could consider including defensive ~try/catch~
  statements in each ~handle_*~ callback of a critical process
  #+BEGIN_SRC elixir
    def handle_call(message, _, state) do
      try
          new_state =
            state
            |> transformation_1()
            |> transformation_2()
          ...

          {:reply, response, new_state}

      catch _, _ ->
          {:reply, {:error, reason}, state}
      end
    end

  #+END_SRC

** GenServer
- A primitive emulation of GenServer.
  + Server:
  #+BEGIN_SRC elixir
  defmodule Server do
    @moduledoc ~s"""
    account = Server.start(BankAccount, 0)

    send(account, {:deposit, 50})
    send(account, {:withdraw, 20})

    send(account, :balance) # should receive {:balance, 30}
    """

    def start(callback_module, state) do
      parent = self()
      spawn fn ->
        loop(callback_module, parent, state)
      end
    end

    def loop(callback_module, parent, state) do
      receive do
        message ->
          state = callback_module.handle_message(message, parent, state)
          loop(callback_module, parent, state)
      end
    end
  end
  #+END_SRC
  + callback module:
  #+BEGIN_SRC elixir
  defmodule BankAccount do

    def handle_message({:deposit, amount}, _from, balance) do
      balance + amount
    end

    def handle_message({:withdraw, amount}, _from, balance) do
      balance - amount
    end

    def handle_message(:balance, from, balance) do
      send(from, {:balance, balance})
      balance
    end

  end
  #+END_SRC
- Graceful termination of a ~GenServer~ worker involves invoking the
  ~terminate/2~ callback, but only if the worker process is trapping
  exits. Therefore, if you want to do some cleanup from a ~GenServer~
  process, make sure you set up an exit trap from an ~init/1~ callback.

*** GenServer behaviour
- ~GenServer.start/2~ works synchronously. In other words, ~start/2~
  returns only after the ~init/1~ callback has finished in the server
  process. Consequently, the client process that starts the server
  is blocked until the server process is initialized.
- note that ~GenServer.call/2~ doesn’t wait indefinitely for a
  response. By default, if the response message doesn’t arrive in five
  seconds, an error is raised in the client process. You can alter
  this by using ~GenServer.call(pid, request, timeout)~, where the
  ~timeout~ is given in milliseconds. In addition, if the receiver
  process happens to terminate while you’re waiting for the response,
  GenServer detects it and raises a corresponding error in the caller
  process.

- You can get a compile-time warning here if you tell the compiler
  that the function being defined is supposed to satisfy a contract by
  some behaviour. To do this, you need to provide the ~@impl~ module
  attribute immediately before the first clause of the callback
  function:
  #+BEGIN_SRC elixir
    defmodule EchoServer do
      use GenServer

      @impl GenServer
      def handle_call(some_request, server_state) do
        {:reply, some_request, server_state}
      end
    end
  #+END_SRC
  The ~@impl GenServer~ tells the compiler that the function about to be
  defined is a callback function for the ~GenServer~ behaviour. As soon
  as you execute this expression in the shell, you’ll get a warning

- =init= function sets the initial state with ={:ok, initial_state}= response
  + In ~init/1~, you can decide against starting the server. In this
    case, you can either return ~{:stop, reason}~ or ~:ignore~. In both
    cases, the server won’t proceed with the loop, and will instead
    terminate.
- =handle_call= is synchronous and
  + Handles =GenServer.call=
  + Its signature is =handle_call(arg, from_pid, current_state)=. =arg= is =GenServer.call(pid, *arg*)=
  + Should reply like ={:reply, return_value, new_state}=
- =handle_cast= is asynchronous and
  + Handles =GenServer.cast=
  + Its signature =handle_cast(arg, current_state)=
  + Should reply ={:noreply, new_state}=
- =handle_info= is asynchronous and
  + must be used for all other messages a server may receive that are
    not sent via =GenServer.call/2= or =GenServer.cast/2=, including
    regular messages sent with =send/2=. The monitoring =:DOWN= messages
    are such an example of this.
- =GenServer.cast=
  + Send a message without expecting or waiting for a response
- =GenServer.call=
  + Send a message and wait for a response (hence blocking the current process)
- GenServer process can be named
  =GenServer.start_link(CallbackModule, [args], name:foobar)= so we
  don't need the pid =GenServer.cast(foobar, {:save, state})=
- Returning ~{:stop, reason, new_state}~ from ~handle_*~ callbacks
  causes GenServer to stop the server process. If the termination is
  part of the standard workflow, you should use the atom ~:normal~
  as the stoppage reason. If you’re in ~handle_call/3~ and also need
  to respond to the caller before terminating, you can return
  ~{:stop, reason, response, new_state}~.
- You can stop the server process by invoking
  ~GenServer.stop/3~ from the client process.

*** Process lifecycle
- A client process starts the server by calling ~GenServer.start~ and
  providing the callback module (1). This creates the new server
  process, which is powered by the ~GenServer~ behaviour.
- Requests can be issued by client processes using various ~GenServer~
  functions or plain ~send~. When a message is received, ~GenServer~
  invokes callback functions to handle it. Therefore, callback
  functions are always executed in the server process.
- The process state is maintained in the ~GenServer~ loop but is
  defined and manipulated by the callback functions. It starts with
  ~init/1~, which defines the initial state that’s then passed to
  subsequent ~handle_*~ callbacks (2). Each of these callbacks
  receives the current state and must return its new version, which is
  used by the ~GenServer~ loop in place of the old one.

#+BEGIN_SRC
                                          |
      client process                      |                 server process
                                          |
                                          |
 +-------------------+                    |       +----------------+ (1)          +---------------+
 |  GenServer.start  +--------------------|-----> | GenServer init +------------> |     init      |
 +-------------------+                    |       +----------------+              +---------------+
                                          |                | (2)
                                          |                |
 +-------------------+                    |                |                          +---------------+
 |  GenServer.cast   +-------------+      |                |                 +------> | handle_cast   |
 +-------------------+             |      |                |                 |        +---------------+
                                   |      |                v                 |
 +-------------------+             |      |       +-----------------+        |        +---------------+
 |  GenServer.call   +--------------------|-----> | GenServer loop  +---------------> | handle_call   |
 +-------------------+             |      |       +-----------------+        |        +---------------+
                                   |      |                |                 |
 +-------------------+             |      |                |                 |        +---------------+
 |      send         +-------------+      |                |                 +------> | handle_info   |
 +-------------------+                    |                |                          +---------------+
                                          |                |
                                          |                |
                                          |                |                       +-------------+
                                          |                +---------------------> |   terminat  |
                                          |                                        +-------------+
                                          |
                                          |
#+END_SRC
**** Implementing BankAccount with GenServer
#+BEGIN_SRC elixir
defmodule BankAccount do
  use GenServer

  def init(balance), do: {:ok, balance}
  # receives the argument that we
  # gave to GenServer.start
  # function and returns the
  # inital state to be stored in
  # the process


  def handle_cast({:deposit, amount}, balance), do: {:noreply, balance + amount}
  def handle_cast({:withdraw, amount}, balance), do: {:noreply, balance - amount}
  # take the message that was sent as the first arugment and current
  # state of process as the last argument. If the first element of
  # tuple is :reply whatever comes next will be send back to the
  # caller. last element of the tuple is the new state

  def handle_call(:balance, _from, balance), do: {:reply, balance, balance}
  # thrid element is the new state
  # second element will be send back to the caller
  # read handle_cast comment
end
#+END_SRC
To use it:
#+BEGIN_SRC
  {:ok, account} = GenServer.start(BankAccount, 0)
  GenServer.cast(account, {:deposit, 50})
  GenServer.cast(account, {:withdraw, 25})
  balance = GenServer.call(account, :balance) # 25
#+END_SRC
**** BankAccount as a GenServer
#+BEGIN_SRC elixir
defmodule BankAccount do
  use GenServer

  def start(balance) do
    {:ok, account} = GenServer.start(__MODULE__, balance)
    account
  end

  def deposit(account, amount) do
    GenServer.cast(account, {:deposit, amount})
  end

  def withdraw(account, amount) do
    GenServer.cast(account, {:withdraw, amount})
  end

  def balance(account) do
    GenServer.call(account, :balance)
  end

  ###
  # GenServer API
  ###

  # Handle cast messages with `handle_cast`. No response is expected,
  # so reply with the {:noreply, ...} tuple format
  def handle_cast({:deposit, amount}, balance) do
    {:noreply, balance + amount}
  end

  def handle_cast({:withdraw, amount}, balance) do
    {:noreply, balance - amount}
  end

  # Handle call messages with the `handle_call` callback. Responses are usually
  # expected, so respond with the {:reply, ...} tuple format.
  def handle_call(:balance, _from, balance) do
    {:reply, balance, balance}
  end

end
#+END_SRC
To use it:
#+BEGIN_SRC
  account = BankAccount.start(0)
  BankAccount.deposit(account, 50)
  BankAccount.withdraw(account, 25)
  BankAccount.balance(account)      # 25
#+END_SRC
**** When to Use GenServer
Not always, for e.g above example can be implemented with the help of structs.

Implementing BankAccount with struct:
#+BEGIN_SRC elixir
defmodule BankAccount do
  defstruct balance: 0

  def new(balance) do
    %__MODULE__{balance: balance}
  end

  def deposit(account, amount) do
    %{account | balance: account.balance + amount}
  end

  def withdraw(account, amount) do
    %{account | balance: account.balance - amount}
  end

  def balance(account) do
    account.balance
  end

end
#+END_SRC
**** GenServer Features
- GenServer processes are distributed across cores
- A GenServer process works on one message at a time
- GenServer processes can be supervised and restarted
- GenServer process state can be upgraded in place

** Supervisor
- A supervisor is a generic process that manages the lifecycle of
  other processes in a system. A supervisor process can start other
  processes, which are then considered to be its children. Using
  links, monitors, and exit traps, a supervisor detects possible
  terminations of any child, and can restart it if needed.
- If worker processes are small services in a system, you can think of
  supervisors as being service managers—a built-in equivalent of
  ~systemd~. They’re responsible for the lifecycle of services they
  directly manage. If any critical service stops, its parent will try
  to restart it.

*** child specification
- in erlang it's like ~{ChildId, StartFunc, Restart, Shutdown, Type, Modules}~
  + e.g.
    #+BEGIN_SRC erlang
    [{
    fake_id,                                      %% ChildId
    {fake_mod, start_link, [SomeArg]},            %% StartFunc
    permanent,                                    %% Restart
    5000,                                         %% Shutdown
    worker,                                       %% Type
    [fake_mod]                                    %% Modules
   },
   {other_id,
    {event_manager_mod, start_link, []},
    transient,
    infinity,
    worker,
    dynamic}]
    #+END_SRC
  + for more, read erlang section on [[file:erlang.org::Child Specifications][Child Specifications]]
- Sample snippet
  #+BEGIN_SRC elixir
    Supervisor.start_link(
      [
        %{
          id: Todo.Cache,
          start: {Todo.Cache, :start_link, [nil]}
        }
      ],
      strategy: :one_for_one
    )
  #+END_SRC
- Instead of providing child spec directly, ~Supervisor~ also allows
  you to pass a tuple ~{module_name, arg}~ in the child specification
  list. In this case, ~Supervisor~ will first invoke
  ~module_name.child_spec(arg)~ to get the actual specification. This
  function must return the specification map. The supervisor then
  proceeds to start the child according to the specification.
  + e.g.
    #+BEGIN_SRC elixir
      Supervisor.start_link(
        [{Todo.Cache, nil}],
        strategy: :one_for_one
      )
    #+END_SRC
- If you don’t care about the argument passed to ~child_spec/1~, you
  can include just the module name in the child specification list. In
  this case, Supervisor will pass the empty list ~[]~ to
  ~child_spec/1~.
  #+BEGIN_SRC elixir
    Supervisor.start_link(
      [Todo.Cache],
      strategy: :one_for_one
    )
  #+END_SRC
- A default ~child_spec/1~ is implemented if you have ~use GenServer~
  #+BEGIN_SRC elixir
    iex> Todo.Cache.child_spec(nil)
    %{id: Todo.Cache, start: {Todo.Cache, :start_link, [nil]}}
  #+END_SRC

- [[https://hexdocs.pm/elixir/Supervisor.html#module-child-specification][Elixir doc]]

*** Starting processes dynamically
- used when you can’t specify supervisor children up front. For such
  cases, you need a dynamic supervisor that can start children on
  demand. In Elixir, this feature is available via the
  ~DynamicSupervisor~ module.
- ~DynamicSupervisor~ is similar to ~Supervisor~, but where
  ~Supervisor~ is used to start a predefined list of children,
  ~DynamicSupervisor~ is used to start children on demand. When you
  start a dynamic supervisor, you don’t provide a list of child
  specifications, so only the supervisor process is started. Then,
  whenever you want to, you can start a supervised child using
  ~DynamicSupervisor.start_child/2~.



*** Using a callback module
- You develop the module that must implement the ~init/1~ function. This
  function must return the list of child specifications and additional
  supervisor options, such as its strategy
  #+BEGIN_SRC elixir
    defmodule Todo.System do
      use Supervisor

      def start_link do
        Supervisor.start_link(__MODULE__, nil)
      end

      # returns something like {:ok, {%{intensity: 3, period: 5, strategy: :one_for_one}, [%{id: Todo.Cache, start: {Todo.Cache, :start_link, [[]]}}]}}
      def init(_) do                # the required callback function
        Supervisor.init([Todo.Cache], strategy: :one_for_one)
      end
    end
  #+END_SRC
*** Restart frequency
- The supervisor relies on the maximum restart frequency, which
  defines how many restarts are allowed in a given time period. By
  default, the maximum restart frequency is *three restarts* in *five seconds*.
- You can change these parameters by passing ~:max_restarts~ and
  ~:max_seconds~ options to ~Supervisor.start_link/2~.

*** example 1
~Basic~ module:
#+BEGIN_SRC elixir
defmodule Basic do
  use GenServer

  def start_link(arg) do
    IO.puts "inside Basic start_link..."
    GenServer.start_link(__MODULE__, arg)
  end

  def init(arg) do
    IO.inspect arg
    IO.puts "inside Basic init..."
    {:ok, []}
  end
end
#+END_SRC

=BasicSupervisor= module:
#+BEGIN_SRC elixir
defmodule BasicSupervisor do
  use Supervisor

  def start_link(arg) do
    Supervisor.start_link(__MODULE__, arg) # passes =arg= to init
  end

  def init(arg) do
    children = [
      worker(Basic, [arg]) # passing =arg= (not [arg]) to Basic.start_link
    ]
    supervise(children, strategy: :one_for_one)
  end

end
#+END_SRC

To use it:
#+BEGIN_SRC
iex(1)> {:ok, s_pid} = BasicSupervisor.start_link("Jack")
inside Basic start_link...
"Jack"
inside Basic init...
{:ok, #PID<0.126.0>}

iex(2)> [{_, pid,_ ,_}] = Supervisor.which_children(s_pid)
[{Basic, #PID<0.127.0>, :worker, [Basic]}]
iex(6)> pid
pid
#PID<0.127.0>

iex(3)> GenServer.stop(pid)
inside Basic start_link...
"Jack"
:ok
inside Basic init...
#+END_SRC

*** example 2
Implementing a simple TODO app

#+BEGIN_SRC elixir
defmodule Todo do
  use GenServer

  def start_link(state, opts \\ []), do: GenServer.start_link(__MODULE__, state, opts)

  def handle_cast({:add, task}, todo), do: {:noreply, [task | todo]}

  def handle_cast({:remove, task_index}, todo) do
    new_Todo = List.delete_at(todo, task_index)
    {:noreply, new_Todo}
  end

  def handle_call(:list, _from, todo), do: {:reply, create_todo_list(todo), todo}

  def create_todo_list(todo, str \\ "", n \\ 1)
  def create_todo_list([], str, _n) do
    IO.puts str
    str
  end

  def create_todo_list(todo, str, n) do
    [h | t] = todo
    str = str <> "#{n}- #{h}\n"
    n = n + 1
    create_todo_list(t, str, n)
  end

end
#+END_SRC
And its supervisor
#+BEGIN_SRC elixir
defmodule Todo.Supervisor do
  use Supervisor

  def start_link do
    Supervisor.start_link(__MODULE__, [])
  end

  def init([]) do
    children = [
      worker(Todo, [[]])
    ]
    supervise(children, strategy: :one_for_one)
  end
end
#+END_SRC
*** Notes
- to create a mix project with a Supervisor =mix new my_project --sup=
- workers can have ids =worker(SupervisedProcess, [], id: "some_id")=
- Supervisors themselves can be supervised =worker(Supervisor_module, [])=
- for data storage you might find =ets=, =dets=, or =Mnesia= more useful than third party tools
- =simple_one_for_one= is for dynamically launching processes.

** ~Registry~
#+BEGIN_SRC
                                                +-------------------+
                                                |                   |
                    1. register(complex_alias)  |     Registry      |      2. lookup(complex_alias)
                              +--------------->>|                   |<<--------------------+
                              |                 +-------------------+                      |
                              |                                                            |
                              |                                                            |
                              |                                                            |
                     +--------+----------+                      3. send request +----------+--------+
                     |      server       |<<------------------------------------+      client       |
                     +-------------------+                                      +-------------------+

In step 1, the worker process registers itself, usually during initialization. Some time
later, the client process will query the registry for the pid of the desired worker.
The client can then issue a request to the server process.
#+END_SRC
- A process registry differs from standard local registration (which
  only allows for names to be atom) in that names can be arbitrarily
  complex.
- This module (~Registry~) allows you to associate a process with one or more
  arbitrary complex keys, and then find the process (its pid) by doing
  a key-based lookup.
  #+BEGIN_SRC elixir
    iex>  Registry.start_link(name: :my_registry, keys: :unique)
    {:ok, #PID<0.165.0>}

    iex> spawn(fn ->
    ...>           Registry.register(:my_registry, {:database_worker, 1}, nil)
    ...>           receive do
    ...>             msg -> IO.puts("got message #{inspect(msg)}")
    ...>           end
    ...>       end)
    #PID<0.173.0>

    iex> [{db_worker_pid, _value}] = Registry.lookup(:my_registry, {:database_worker, 1})
    [{#PID<0.173.0>, nil}]

    iex> send(db_worker_pid, :some_message)
    got message :some_message
    :some_message

    iex> Registry.lookup(:my_registry, {:database_worker, 1})
    []
  #+END_SRC
- A very useful property of Registry is that it links to all the
  registered processes. This allows the registry to notice the
  termination of these processes and remove the corresponding entry
  from its internal structure.

*** Via tuples
- A /via tuple/ is a mechanism that allows you to use an arbitrary
  third-party registry to register OTP-compliant processes, such as
  ~GenServer~ and supervisor.
- You can provide a ~:name~ option when starting a ~GenServer~:
  #+BEGIN_SRC elixir
  GenServer.start_link(callback_module, some_arg, name: some_name)
  #+END_SRC
  If you pass an atom to the ~:name~ option, it makes the started
  process to be registered locally. But the ~:name~ option can also be
  provided in the shape of ~{:via, some_module, some_arg}~. Such a
  tuple is also called a via tuple. If you provide a via tuple as the
  name option, ~GenServer~ will invoke a well-defined function from
  ~some_module~ to register the process. Likewise, you can pass a via
  tuple as the first argument to ~GenServer.cast~ and
  ~GenServer.call~, and ~GenServer~ will discover the pid using
  ~some_module~. In this sense, ~some_module~ acts like a custom
  thirdparty process registry, and the via tuple is the way of
  connecting such a registry with ~GenServer~ and similar OTP
  abstractions.The third element of the via tuple, ~some_arg~, is a
  piece of data that’s passed to functions of ~some_module~. The exact
  shape of this data is defined by the registry module. At the very
  least, this piece of data must contain the name under which the
  process should be registered and looked up. In the case of ~Registry~,
  the third argument should be a pair, ~{registry_name, process_key}~,
  so the entire via tuple then has the shape of ~{:via, Registry, {registry_name, process_key}}~.
  #+BEGIN_SRC elixir
    defmodule EchoServer do
      use GenServer

      def start_link(id) do
        GenServer.start_link(__MODULE__, nil, name: via_tuple(id))
      end

      def call(id, some_request) do
        GenServer.call(via_tuple(id), some_request)
      end

      defp via_tuple(id) do
        # The registered name of the process will be {__MODULE__, id}
        {:via, Registry, {:my_registry, {__MODULE__, id}}}
      end

      def handle_call(some_request, _, state) do
        {:reply, some_request, state}
      end
    end
  #+END_SRC

  Now you can start and interact with multiple echo servers without
  needing to keep track of their pids:
  #+BEGIN_SRC elixir
  iex> Registry.start_link(name: :my_registry, keys: :unique)
  iex> EchoServer.start_link("server one")
  iex> EchoServer.start_link("server two")

  iex(5)> EchoServer.call("server one", :some_request)
  :some_request

  iex> EchoServer.call("server two", :another_request)
  :another_request
  #+END_SRC

** Task & Agents
*** Tasks
- Tasks build on top of the spawn functions to provide better error
  reports and introspection. They are Asynchronous units of
  computation that allow spawning a process and potentially retrieving
  its result at a later time. Sometimes it is useful to run a task to
  compute a value and read its result later on. For this, tasks also
  provide the async/await pattern:
  + snippet
    #+BEGIN_SRC elixir
    task = Task.async(fn -> compute_something_expensive end)
    res  = compute_something_else()
    res + Task.await(task)
    #+END_SRC
  + snippet
    #+BEGIN_SRC elixir
      task = Task.async fn ->
        IO.puts "Hello world!"
      end

      # OR

      task = Task.async(IO, :puts, ["Hello World"])

      result = Task.await(task)
    #+END_SRC
    + snippet
    #+BEGIN_SRC elixir
    defmodule Play do
      def pmap(list, fun) do
        list
        |> Enum.map(&Task.async(fn -> fun.(&1) end))
        |> Enum.map(&Task.await/1)
      end
    end
    #+END_SRC
- To Supervise A Task
  + Supervisor:
    #+BEGIN_SRC elixir
    defmodule Play.Supervisor do
      use Supervisor

      def start_link do
        Supervisor.start_link(__MODULE__, [], name: __MODULE__)
      end

      def init(_) do
        children = [
          supervisor(Task.Supervisor, [[name: MyApp.TaskSupervisor]])
        ]
        supervise(children, strategy: :transient)
      end
    end
    #+END_SRC
  + Then after =Play.Supervisor.start_link=:
    #+BEGIN_SRC elixir
    # You can start supervised tasks like so:
    Task.Supervisor.start_child(MyApp.TaskSupervisor, fn ->
      IO.puts "Hello world!"
    end)

    Task.Supervisor.async(MyApp.TaskSupervisor, IO, :puts, ["Hello world!"])
    |> Task.await
    #+END_SRC
- =yield(task, timeout \\ 5000)=
  + Temporarily blocks the current process waiting for a task reply.
**** Awaited tasks
- An awaited task is a process that executes some function, sends the
  function result back to the starter process, and then terminates.
- It should be noted that ~Task.async/1~ links the new task to the
  starter process. Therefore, if any task process crashes, the starter
  process will crash too (unless it’s trapping exits). The crash of
  the starter process will, in turn, cause all the other tasks started
  by the same process to crash. In other words, starting multiple
  tasks with ~Task.async/1~ has all-or-nothing semantics. The crash of a
  single task takes down all other tasks as well as the starter
  process.
  #+BEGIN_SRC elixir
    iex> run_query =
                   fn query_def ->
                        Process.sleep(2000)
                        "#{query_def} result"
                  end

    iex> 1..5 |>
                Enum.map(&Task.async(fn -> run_query.("query #{&1}") end)) |>
                Enum.map(&Task.await/1)

    # after 2 sec
    ["query 1 result", "query 2 result", "query 3 result", "query 4 result",
    "query 5 result"]
  #+END_SRC

**** Non-awaited tasks
- Sometimes you don’t want to send the result message back to the
  starter process.
- in some cases you won’t want to link the task process to the starter
  process. This is typically done to make sure the task process lives
  on even if the starter process terminates. In such situations, you
  can use ~Task.start_link/1~. The ~Task.start_link/1~ function can be
  thought of as an OTP-compliant wrapper around plain ~spawn_link~. The
  function starts a separate process and links it to the caller. Then
  the provided lambda is executed in the started process. Once the
  lambda finishes, the process terminates with the reason
  ~:normal~. Unlike ~Task.async/1~, ~Task.start_link/1~ won’t send any
  message to the starter process.

*** Agent
- Agents are a simple abstraction around state.
  #+BEGIN_SRC  elixir
  {:ok, agent} = Agent.start_link(fn -> 0 end)
  Agent.update(agent, fn state -> state + 1 end)
  Agent.get(agent, fn state -> state end) # 1
  #+END_SRC
- The Agent module provides an abstraction that’s similar to
  ~GenServer~. Agents require a bit less ceremony and can therefore
  eliminate some boilerplate associated with GenServers. On the flip
  side, Agent doesn’t support all the scenarios that ~GenServer~
  does. As a mechanical rule, if a GenServer-powered module
  implements only ~init/1~, ~handle_cast/2~, and ~handle_call/3~, it can be
  replaced with an Agent . But if you need to use ~handle_info/2~ or
  ~terminate/1~, Agent won’t suffice, and you’ll need to use GenServer.
- ~Agent.update/2~ is synchronous. The function only returns after the
  update has succeeded. An asynchronous update can be performed with
  ~Agent.cast/2~.
- Limitations of agents
  + The Agent module can’t be used if you need to handle plain
    messages, or if you want to run some logic on termination. In such
    cases, you need to use GenServer.

- example
  #+BEGIN_SRC elixir
  defmodule BankAccount do
    def start_link(balance) do
      Agent.start_link(fn -> balance end)
    end

    def deposit(account, amount) do
      Agent.update(account, &(&1 + amount))
    end

    def withdraw(account, amount) do
      Agent.update(account, &(&1 - amount))
    end

    def balance(account) do
      Agent.get(account, &(&1))
    end
  end
  #+END_SRC

** ETS
- Read [[file:erlang.org::*ETS][the Erlang notes]]
- ETS table is a separate memory-data structure where you can store
  Erlang terms. This makes it possible to share the system-wide state
  without introducing a dedicated server process. The data is kept in
  an ETS table — a dynamic memory structure where you can store
  tuples.

  + There’s no specific ETS data type. A table is identified by its ID
    (a reference type) or a global name (an atom).
  + ETS tables are mutable. A write to a table will affect subsequent
    read operations.
  + Multiple processes can write to or read from a single ETS
    table. Writes and reads are concurrent.
  + Minimum isolation is ensured. Multiple processes can safely write
    to the same row of the same table. The last write wins.
  + An ETS table resides in a separate memory space. Any data coming
    in or out is deep-copied.
  + ETS doesn’t put pressure on the garbage collector. Overwritten or
    deleted data is immediately released.
  + An ETS table is deeply connected to its owner process (by default,
    the process that created the table). If the owner process
    terminates, the ETS table is reclaimed.
  + Other than on owner-process termination, there’s no automatic
    garbage collection of an ETS table. Even if you don’t hold a
    reference to the table, it still occupies memory.

** Nodes
A Node is an instance of BEAM virtual machine.
- =Node.self=
  + to get the current node's name
- =Node.list=
  + to get a list of connected nodes
- =iex --sname node_name=
  + to start a named node
- =Node.connect(:Farhad@Manjaro)=
  + to connect to a node
- =Node.spawn or Node.spawn_link=
  + to spawn a process in a node
#+BEGIN_SRC elixir
  pid = Node.spawn :fhd@Manjaro, fn ->
    IO.puts "yohoo"
  end
#+END_SRC

*** Note
- Code is /not sent/
- All data in the message will be /copied/
- Be aware of Network Latency

** Miscellaneous
*** ~if~
- if statement is just a macro that takes =true= or =false= as it's
  first argument and a keyword list as it's second argument. use
  =case= or =cond= instead
#+BEGIN_SRC elixir
  if true, do: :this, else :that     #
  # it's actually a macro
  if(true, [do: :this, else: :that]) # :this
  if(false, [do: :this, else: :that]) # :that

  def max(a, b) do
    if(a > b, do: a, else: b)
  end
#+END_SRC
- If the condition isn’t met and the ~else~ clause isn’t specified, the
  return value is the atom ~nil~

*** =cond=
- Run the first block where expression is truthy.
- =cond= has no falling through like a switch case does in other languages.
- If none of the conditions is satisfied, ~cond~ raises an error
#+BEGIN_SRC elixir
  cond do
    expression -> body
    expression -> body
    ...
  end
#+END_SRC
#+BEGIN_SRC elixir
defmodule Fun do
  def foo(%{age: age}) do
    cond do
      age > 50 -> "You gonna die, pretty soon actully"
      age > 30 -> "Enjoy misery"
      true     -> "Hmm"
    end
  end
end

Fun.foo(%{name: "Farhad", age: 51}) # "You gonna die, pretty soon actully"
#+END_SRC

*** =case=
- If no clause matches, an error is raised.
- When a *pattern* matches the value of the *expression*, the body is
  executed.
  #+BEGIN_SRC elixir
    case expression do
      pattern -> body
      pattern -> body
      ...
    end
  #+END_SRC
- example
  #+BEGIN_SRC elixir
    defmodule Fun do
      def foo(%{age: age}) do
        case age do
          :old           -> "You gonna die, pretty soon actully"
          :not_That_Old  -> "Enjoy misery"
          _              -> "Hmm" #note the use of underscore in lieu of true like in =cond=
        end
      end
    end

    Fun.foo(%{name: "Farhad", age: :something}) # Hmm
  #+END_SRC
- Another example
  #+BEGIN_SRC elixir
  case File.read("foobar.txt") do
    {:ok, content} ->
      IO.puts "content of given file: #{content}"
    {:error, reason} ->
      Io.puts "error #{reason} occurred"
    other ->
      IO.puts "An unknown error occurred. #{other}"
  end
  #+END_SRC
- Using guard clase in =case=
  #+BEGIN_SRC elixir
  v = "foo"
  case v do
    v when v in [nil, false, ""] -> "moew"
    _ -> "not meow"
  end
  #+END_SRC
*** =with=
- [[https://hexdocs.pm/elixir/Kernel.SpecialForms.html#with/1][with special form]] doc
- If any match fails, however, ~with~ will not proceed to evaluate
  subsequent expressions. Instead, it will immediately return the
  result that couldn’t be matched.
- The benefit of ~with~ is that it returns the first term that fails to
  be matched against the corresponding pattern
- Guards can be used in patterns as well

- syntax
  #+BEGIN_SRC elixir
  with
    pattern <- expression,
    pattern <- expression,
    ...
  do
    body
  end
  #+END_SRC
- example
  #+BEGIN_SRC elixir
  opts = %{:width => 10, :height => 15}
  with {:ok, width} <- Map.fetch(opts, :width),
       {:ok, height} <- Map.fetch(opts, :height),
    do: {:ok, width * height}
  #+END_SRC
- example
  #+BEGIN_SRC elixir
    def extract_user(user) do
      with {:ok, login} <- extract_login(user),
           {:ok, email} <- extract_email(user),
           {:ok, password} <- extract_password(user) do
        {:ok, %{login: login, email: email, password: password}}
      end
    end
  #+END_SRC
*** =try do ... rescue ... after ... end=
Use try rescue as last resort.
~after~ is optional.
#+BEGIN_SRC elixir
defmodule M do
  def say_hi(name) do
    try do
      "Hey #{String.upcase name}!!!"
  rescue
    _e -> raise "Fuck off"
    end
  end
end
M.say_hi 3
#+END_SRC
*** =raise=
#+BEGIN_SRC elixir
raise "an exception"
#+END_SRC
*** =throw/catch=
*** =defdelegate=
#+BEGIN_SRC elixir
defmodule Some.Other.Mod do
  def add(a, b), do: a + b
  def subtract(a, b), do: a - b
end

defmodule MyMod do
  defdelegate bar(a, b), to: Some.Other.Mod, as: :add
  defdelegate subtract(a, b), to: Some.Other.Mod
end

MyMod.bar(20, 10) # 30
MyMod.subtract(23, 3) # 3
#+END_SRC
*** =?=
returns ASCII code of given character (in decimal)
#+BEGIN_SRC elixir
IO.inspect ?a # 97
IO.inspect ?\s # 32 (for space)
#+END_SRC
*** Multiclause (lambda) anonymous function
- example
  #+BEGIN_SRC elixir
  foo = fn 0 -> "zero"; 2 -> "two" end
  foo.(0) # "zero"
  foo.(2) # "two"
  #+END_SRC
- example with guard
  #+BEGIN_SRC elixir
        test_num = fn
          x when is_number(x) and x < 0 ->
            :negative

          0 ->
            :zero

          x when is_number(x) and x > 0 ->
            :positive
        end
  #+END_SRC
** =.app= file
#+BEGIN_SRC
{application,kv,
             [{applications,[kernel,stdlib,elixir,logger]},
              {description,"kv"},
              {modules,['Elixir.KV','Elixir.KV.Bucket','Elixir.KV.Registry',
                        'Elixir.KV.Supervisor']},
              {registered,[]},
              {vsn,"0.1.0"},
              {extra_applications,[logger]}]}.
#+END_SRC
This file contains Erlang terms (written using Erlang syntax). This
file holds our application definition. It contains our application
version, all the modules defined by it, as well as a list of
applications we depend on, like Erlang’s =kernel=, =elixir= itself,
and =logger= which is specified in the =:extra_applications= list in
=mix.exs=.

We can configure the generated =.app= file by customizing the
values returned by the =application/0= inside our =mix.exs= project
file.
** Application
- Applications let you organize your system into reusable
  components. Applications are a standard way of building
  Elixir/Erlang production systems and libraries, and relying on them
  brings various benefits, such as dependency management, simplified
  system starting, and the ability to build standalone, deployable
  releases.
- An OTP application is a component that consists of multiple modules
  and that can depend on other applications. This makes it possible to
  start the entire system and dependent components with a single
  function call.
*** library applications
- There’s no application callback module, which in turn means there’s
  no top-level process to be started.
- components that don’t need to create their own supervision tree
- For example, Erlang’s own ~stdlib~ application
  (http://erlang.org/doc/apps/stdlib/index.html) is a pure library
  application because it exposes various utility modules but doesn’t
  need to manage its own supervision tree.

*** Configuring applications
- ~Mix.env/0~
  + The function ~Mix.env/0~ is not available at runtime, so you
    shouldn’t invoke it from your regular code (standard functions
    that are compiled and executed at runtime). This function can only
    be used in config scripts, in the code of custom mix tasks, and in
    the code that’s executed at compile time (Elixir macros).
  + Depending on the mix environment, this expression will import the
    configuration from ~config/dev.exs~, ~config/test.exs~, or
    ~config/prod.exs~.

** Macros
** Special forms
- the basic building blocks of Elixir, and therefore cannot be
  overridden by the developer.
- [[https://hexdocs.pm/elixir/Kernel.SpecialForms.html][Kernel.SpecialForms]]
** data abstraction in Elixir
- A module is in charge of abstracting some data.
- The module’s functions usually expect an instance of the data
  abstraction as the first argument.
- Modifier functions return a modified version of the abstraction.
- Query functions return some other type of data.
** records
- [[https://hexdocs.pm/elixir/Record.html][doc]]
** a few helper
- Functions and macros, such as ~put_in/2~, rely on the [[https://hexdocs.pm/elixir/Access.html][Access]] module
- ~Kernel.put_in~
- ~Kernel.get_in~
- ~Kernel.update_in~
- ~Kernel.get_and_update_in~
** BEAM
- By default, BEAM uses as many schedulers as there are CPU cores
  available. Each scheduler runs in its own thread, and the entire VM
  runs in a single OS process.
- A scheduler is in charge of the interchangeable execution of
  processes. Each process gets an execution time slot; after the time
  is up, the running process is preempted, and the next one takes
  over.
- Processes are light. It takes only a couple of microseconds to
  create a single process, and its initial memory footprint is a few
  kilobytes. By comparison, OS threads usually use a couple of
  megabytes just for the stack. Therefore, you can create a large
  number of processes: the theoretical limit imposed by the VM is
  roughly 134 million!
- Concurrency vs. parallelism:
  It’s important to realize that concurrency doesn’t necessarily imply
  parallelism. Two concurrent things have independent execution
  contexts, but this doesn’t mean they will run in parallel. If you
  run two CPU-bound concurrent tasks and you only have one CPU core,
  parallel execution can’t happen. You can achieve parallelism by
  adding more CPU cores and relying on an efficient concurrent
  framework. But you should be aware that concurrency itself doesn’t
  necessarily speed things up.
** Distributed
- checkout
  + [[https://hexdocs.pm/elixir/Node.html][Node]]
  + [[http://erlang.org/doc/man/net_kernel.html][:net_kernel]]
  + [[http://erlang.org/doc/man/net_adm.html][:net_adm]]
  + [[http://erlang.org/doc/man/rpc.html][:rpc]]
  + [[http://erlang.org/doc/man/pg2.html][:pg2]]
- start and connect
  #+BEGIN_SRC
  $ iex --sname node1@localhost
  iex(node1@localhost)1>
  #+END_SRC

  #+BEGIN_SRC
  iex(node1@localhost)1> node()
  :node1@localhost
  #+END_SRC

  #+BEGIN_SRC
  $ iex --sname node2@localhost

  iex(node2@localhost)1> Node.connect(:node1@localhost)
  true
  #+END_SRC

  #+BEGIN_SRC
  iex(node1@localhost)2> Node.list()
  [:node2@localhost]

  ##

  iex(node2@localhost)2>Node.list()
  [:node1@localhost]
  #+END_SRC
- When ~Node.connect/1~ is invoked, BEAM tries to establish a TCP
  connection with the target BEAM instance.
- ~Node.list/0~, which returns a list of all nodes connected to the
  current one (the current node isn’t listed).
- In a multinode environment, When you register a process locally, the
  scope of registration is only the current node. This means you can
  use the same registered name on different nodes (but only once on
  each node)
- It’s possible to reference a locally registered process on another
  node by using ~{some_alias, some_node}~.
  #+BEGIN_SRC
  iex(node1@localhost)> send({:shell, :node2@localhost}, "Hello from node1!")
  #+END_SRC

*** Process discovery
- ~Registry~ module isn’t cluster-aware and works only in the scope of
  a local node.
- The simplest way to do cluster-wide discovery is to use the [[http://erlang.org/doc/man/global.html][:global module]],
  which provides a global name registration facility. Read [[file:erlang.org::*global][my Erlang notes]]
- Global registration can also be used with ~GenServer~
  #+BEGIN_SRC elixir
  GenServer.start_link(__MODULE__, arg, name: {:global, some_global_alias})
  GenServer.call({:global, some_global_alias}, ...)
  #+END_SRC
  if a registered process crashes or the owner node disconnects, the
  alias is automatically unregistered on all other machines.
**** Groups of processes
- Another frequent discovery pattern occurs when you want to register
  multiple processes under the same alias. This may sound strange, but
  it’s useful in situations where you want to categorize processes in
  a cluster and broadcast messages to all processes in a category.
  + take a look at [[http://erlang.org/doc/man/pg2.html][pg2]]
    #+BEGIN_SRC
    ### node1
    iex(node1@localhost)11> :pg2.start()
    iex(node1@localhost)12> :pg2.create({:todo_list, "bob"})
    :ok

    ### node2
    iex(node2@localhost)9> :pg2.start()
    iex(node2@localhost)10> :pg2.which_groups()
    [todo_list: "bob"]
    iex(node2@localhost)11> :pg2.join({:todo_list, "bob"}, self())
    :ok

    ### node1
    iex(node1@localhost)13> :pg2.get_members({:todo_list, "bob"})
    [#PID<8531.90.0>]

    #+END_SRC

*** cluster-wide locks
- They allow you to grab an arbitrary named lock. Once you have a
  particular lock, no other process in the cluster can acquire it
  until you release it.
  #+BEGIN_SRC
  ### node1
  iex(node1@localhost)1> :global.set_lock({:some_resource, self()})
  true

  ### node2
  iex(node2@localhost)1> :global.set_lock({:some_resource, self()}) # Blocks until the lock is released

  ### node1
  iex(node1@localhost)2> :global.del_lock({:some_resource, self()})
  true

  ### node2
  # The lock is now held by the shell process on node2.
  iex(node2@localhost)2>
  #+END_SRC
  The tuple you provide consists of the resource ID and the requester
  ID. The resource ID is an arbitrary term, whereas the requester ID
  identifies a unique requester. Two different requesters can’t
  acquire the same lock in the cluster. Usually you’ll want to use the
  process ID as the requester ID, which means that at any point, at
  most one process can acquire the lock.
  + ~:global.trans/2~, simple helper for the acquire/release pattern
  + Locks can help here, because they let you synchronize multiple
    processes on different nodes without needing to send large
    messages to another process. Let’s say you need to ensure that the
    processing of a large amount of data is serialized in the entire
    cluster (at any point in time, at most one process may run in the
    entire cluster). Normally this is done by passing the data to a
    process that acts as a synchronization point.
    #+BEGIN_SRC elixir
      def process(large_data) do
        :global.trans(
          {:some_resource, self}, # Acquires the cluster-wide lock
          fn ->
            do_something_with(large_data) # Runs in the caller process
          end
        )
      end
    #+END_SRC
    Calling ~:global.trans/2~ ensures cluster-wide isolation. At most
    one process in the cluster can be running ~do_something_with/1~ on
    ~:some_resource~ at any point in time.  Because ~do_something_with/1~
    is running in the caller process, you avoid sending a huge message
    to another synchronization process. Invoking ~:global_trans/2~
    introduces additional chatter between nodes, but messages used to
    acquire the lock are much smaller than passing the contents of
    large_data to another process on another node, so you save
    bandwidth.

*** Avoid spawning lambdas or sending them to different nodes
- You can spawn lambdas from your shell, which is a somewhat special
  case because shell-defined lambdas embed their own code and are
  interpreted dynamically on each invocation. In contrast, lambdas
  that are defined in module functions can be spawned remotely (or
  sent to a remote node via a message) only if both nodes are powered
  by exactly the same compiled code. These requirements are hard to
  satisfy if you start running a multinode cluster and then need to
  update the code. You can’t simultaneously upgrade all the nodes in
  the cluster, so at some point the code on the nodes will
  differ. Therefore, it’s generally better to avoid passing lambdas to
  a remote node. Instead, you should use the ~Node.spawn/4~ function,
  which accepts an MFA that identifies a function to be invoked on the
  target node. This is safe to use as long as the module exists on the
  target node and exports the corresponding function
*** Detecting partitions
- a node periodically pings its peers via tick messages, and if a peer
  fails to respond to these messages, it will be considered
  disconnected. Each process can subscribe to notifications about
  changes in connected nodes via [[http://erlang.org/doc/man/net_kernel.html#monitor_nodes-1][~:net_kernel.monitor_nodes/1]]~
- ~Node.monitor/2~
- you can also set up a monitor or a link to a remote process. This
  works just as it does with local processes. If a remote process
  crashes (or the node disconnects), you’ll receive a message (when
  using monitors) or an exit signal (when using links)
*** [[file:erlang.org::*Hidden%20Nodes][Hidden Nodes]]
*** Firewalls and EPMD
- Given that nodes communicate via TCP connection, it’s obvious that
  you need to have some ports that are open to other machines. When
  one node wants to connect to another node on a different machine, it
  needs to communicate with two different components.
- The first component, the Erlang Port Mapper Daemon (EPMD), is an OS
  process that’s started automatically when you start the first Erlang
  node on the host machine. This component acts as a node name
  resolver on the host machine. EPMD knows the names of all currently
  running BEAM nodes on the machine. When a node wants to connect to a
  node on this machine, it first queries EPMD to determine which port
  the target node is listening on, and then it contacts the target
  node. EPMD listens on port 4369, and this port must be accessible
  from remote machines. In addition, each node listens on a random
  port that needs to be accessible as well, because it’s used to
  establish the connection between two nodes. Obviously it’s not
  particularly helpful that the node’s listening port is random,
  because it’s not possible to define firewall rules.

- you can provide a fixed range of ports on which a node will
  listen. This can be done by setting the ~inet_dist_listen_min~ and
  ~inet_dist_listen_max~ environment variables of the kernel app at the
  command line:
  #+BEGIN_SRC
  $ iex \
  --erl '-kernel inet_dist_listen_min 10000' \
  --erl '-kernel inet_dist_listen_max 10100' \
  --sname node1@localhost
  #+END_SRC
- You can manually inspect the ports of all nodes on the host machine
  via ~:net_adm.names/0~:
  #+BEGIN_SRC
  iex(node1@localhost)1> :net_adm.names()
  {:ok, [{'node1', 10000}]}
  #+END_SRC
  or from command line
  #+BEGIN_SRC shell
  $ epmd -names
  #+END_SRC
*** Security
- http://erlang.org/doc/apps/ssl/ssl_distribution.html.
** Running the system
- ~mix run --no-halt~
- Run the system in the background ~elixir -S mix run --no-halt~, By
  using the ~--detached~ flag, you can start the system in detached
  mode. ~elixir --detached -S mix run --no-halt~
  + turn the beam instance into a node so you can interact with it
    #+BEGIN_SRC
    $ elixir --detached --sname todo_system@localhost -S mix run --no-halt
    #+END_SRC
    * You can check that it’s running by looking at which BEAM nodes
      exist on your system: ~epmd -names~
    * establish a remote shell: with the the ~--remsh~ option you can
      start another node and use it as a shell to the ~todo_system~
      node
      #+BEGIN_SRC
      $ iex --sname debugger@localhost --remsh todo_system@localhost --hidden
      #+END_SRC
      you start the ~debugger~ node, but the shell is running in the
      context of ~todo_system~. Whatever function you call will be
      invoked on ~todo_system~.
    * To stop the running system, you can use the [[https://hexdocs.pm/elixir/System.html#stop/1][System.stop]] function
    * stop a node programmatically
      ~stop_node.exs~
      #+BEGIN_SRC elixir
        if Node.connect(:todo_system@localhost) == true do
          :rpc.call(:todo_system@localhost, System, :stop, [])
          IO.puts "Node terminated."
        else
          IO.puts "Can't connect to a remote node."
        end
      #+END_SRC
      Then you can run the script from the command line:
      #+BEGIN_SRC
      $ elixir --sname terminator@localhost stop_node.exs
      #+END_SRC
*** Running scripts
+ https://hexdocs.pm/mix/Mix.Tasks.Escript.Build.html
*** OTP releases
- An OTP release is a standalone, compiled, runnable system that
  consists of the minimum set of OTP applications needed by the
  system.
  + An OTP release can optionally include the minimum set of Erlang
    runtime binaries (If you embed the minimum Erlang runtime into the
    release, you don’t even need Elixir and Erlang installed on the
    production server.), which makes the release completely
    self-sufficient.
  + A release doesn’t contain artifacts, such as source code,
    documentation files, or tests.
  + releases pave the way for systematic online system upgrades (and
    downgrades), known in Erlang as /release handling/.
- Read [[file:erlang.org::*OTP%20releases][OTP releases]] and use [[https://github.com/bitwalker/distillery][Distillery]]
*** [[https://github.com/bitwalker/distillery][Distillery]]
- ~mix release.ini~ to generate an example config file placed in
  ~rel/config.exs~
- build the release by ~MIX_ENV=prod mix release~.
- To start the system as a background process, you can use the start
  argument:
  #+BEGIN_SRC
  $ _build/prod/rel/appname/bin/appname start
  #+END_SRC
  This isn’t the same as a detached process. Instead, the system is
  started via the [[http://erlang.org/doc/man/run_erl.html][run_erl]] tool. This tool redirects standard output to
  a log file residing in the ~_build/prod/rel/appname/var/log~ folder,
  which allows you to analyze your system’s console output. Once the
  system is running in the background, you can start a remote shell to
  the node:
  #+BEGIN_SRC
  $ _build/prod/rel/appname/bin/appname remote_console

  iex(appname@127.0.0.1)1>
  #+END_SRC
  At this point, you have an iex shell session running in the context
  of the production node. Pressing Ctrl-C twice to exit the shell
  stops the remote shell, but the ~appname~ node will still be
  running.

  It’s also possible to attach directly to the shell of the running
  process. On the surface, this looks like the remote shell, but it
  offers an important benefit: it captures the standard output of the
  running node. Whatever the running node prints — for example, via
  ~IO.puts~ — is seen in the attached process (which isn’t the case for
  the remote shell).  To attach to the shell, you use the attach
  argument:
  #+BEGIN_SRC
  $ _build/prod/rel/appname/bin/appname attach

  iex(appname@127.0.0.1)1>
  #+END_SRC
  Be careful when attaching to the shell. Unlike a remote shell, an
  attached shell runs in the context of the running node. You’re
  merely attached to the running node via an OS pipe. The consequence
  is that stopping the shell by pressing Ctrl-C twice will terminate
  the running node. As hinted at the prompt, you should press Ctrl-D
  to exit (detach) from the running node.

  If the system is running as a background process, and you want to
  stop it, you can use the stop argument:
  #+BEGIN_SRC
  $ _build/prod/rel/todo/bin/todo stop
  #+END_SRC
** benchmarking
   - http://erlang.org/doc/efficiency_guide/profiling.html
   - [[http://erlang.org/doc/man/timer.html#tc-1][:timer.tc/1]]
   - [[https://github.com/alco/benchfella][Benchfella]]
   - [[https://github.com/PragTob/benchee][Benchee]]
   - ~cprof~: [[https://hexdocs.pm/mix/Mix.Tasks.Profile.Cprof.html][mix profile.cprof]]
   - ~eprof~: [[https://hexdocs.pm/mix/Mix.Tasks.Profile.Eprof.html][mix profile.eprof]]
   - ~fprof~: [[https://hexdocs.pm/mix/Mix.Tasks.Profile.Fprof.html][mix profile.fprof]]
** Logging
- [[https://hexdocs.pm/logger/Logger.html][logger]]
** Interacting with the system
- ~:erlang.system_info/1~
- ~:erlang.memory/0~
- ~Process.list/0~
- ~Process.info/1~
- include ~:runtime_tools~
  #+BEGIN_SRC elixir
    defmodule Todo.MixProject do
      ...
      def application do
        [
          extra_applications: [:logger, :runtime_tools],
          ...
        ]
      end
      ...
    end
  #+END_SRC
** Tracing
- [[http://erlang.org/doc/man/sys.html][:sys]]: allows you to trace OTP-compliant processes
  + Tracing is done on the standard output, so you need to attach to
    the system (as opposed to establishing a remote shell). Then you
    can turn on tracing for a particular process with the help of ~:sys.trace/2~:
    #+BEGIN_SRC
    $ _build/prod/rel/appname/bin/appname attach

    ## start tracing
    iex(appname@127.0.0.1)1> :sys.trace(pid, true)

    ## stop tracing
    iex(appname@127.0.0.1)1> :sys.trace(pid, false)
    #+END_SRC
  + ~:sys.get_state/1~
  + ~:sys.replace_state/2~
- [[http://erlang.org/doc/man/dbg.html][:dbg]]
- [[http://erlang.org/doc/man/erlang.html#trace-3][:erlang.trace/3]] allows you to subscribe to events in the system such
  as message-passing or function call
  #+BEGIN_SRC
  $ iex --name tracer@127.0.0.1 --cookie mycookie --hidden

  # Starts the tracer process
  iex(tracer@127.0.0.1)1> :dbg.tracer()

  # Subscribes only to events from the mynode node
  iex(tracer@127.0.0.1)2> :dbg.n(:'mynode@127.0.0.1')

  # Subscribes to function calls in all processes
  iex(tracer@127.0.0.1)3> :dbg.p(:all, [:call])

  # Sets the trace pattern to all functions from the Todo.Server process
  iex(tracer@127.0.0.1)4> :dbg.tp(Todo.Server, [])

  # stop all traces
  iex(tracer@127.0.0.1)4> :dbg.stop_clear()
  #+END_SRC
