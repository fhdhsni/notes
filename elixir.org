* Elixir
Most of these notes are from official elixir guide and learnelixir.tv
** Tips
1) *.ex files will be compiled.
2) *.exs are script files (won't get compiled)
3) snake_case naming convention
4) # starts a comment line
5) ~/.iex.exs is iex configuration file (more info =iex> h IEx.configure=)
6) === (triple equal) is used for comparing floats to integers (2 === 2.0 returns false)
7) Use =i= in iex for getting information about a thing like =i 'foo'=
8) When counting the elements in a data structure, Elixir also abides
   by a simple rule: the function is named =size= if the operation is in
   constant time (i.e. the value is pre-calculated) or =length= if the
   operation is linear (i.e. calculating the length gets slower as the
   input grows). As a mnemonic, both “length” and “linear” start with
   “l”.
9) Elixir provides three boolean operators: =or=, =and= and =not=. These
   operators are strict in the sense that they expect a boolean (true
   or false) as their first argument:
10) =or= and =and= are short-circuit operators. They only execute the
    right side if the left side is not enough to determine the result:
    #+BEGIN_SRC sh
    iex> false and raise("This error will never be raised")
    false
    #+END_SRC
    Besides these boolean operators, Elixir also provides =||=, =&&= and =!=
    which accept arguments of any type. For these operators, all
    values except =false= and =nil= will evaluate to true
    #+BEGIN_SRC sh
     # or
     iex> 1 || true
     1iex> false || 11
     11
     # and
     iex> nil && 13
     nil
     iex> true && 17
     17
     #!
     iex> !true
     false
     iex> !1
     false
     iex> !nil
     true
    #+END_SRC
- In Elixir when can compare two different types. the order is
  =number < atom < reference < function < port < pid < tuple < map < list < bitstring=

** Types
*** Numbers
- Integers (large numbers can be used with _ e.g 1_000_000_000)
  + =0o555= (octal)
  + =0xabc= (hexdecimal)
  + =0b101100=
- Floats (64bit accuracy)
  - exponent: 1.0e-20

:NOTE:
=10 / 2= returns a float. If you need integer use =div(10, 2)=

=rem(10, 3)= returns the reminder
:END:

*** Atoms
Atoms are constants where their name is their own value.
#+BEGIN_SRC elixir
:hello == :"hello" # true
#+END_SRC
Module names are atoms
#+BEGIN_SRC elixir
defmodule MyMod do
  def foo(name) do
    "Hi #{name}"
  end
end
is_atom(MyMod) #true
#+END_SRC

=nil= is also an atom.

*** Booleans
In fact they are atoms
:true == true
is true

*** Strings
Strings in Elixir are represented internally by binaries which are
sequences of bytes:

#+BEGIN_SRC
iex> is_binary("hellö")
true

# We can also get the number of bytes in a string:

iex> byte_size("hellö")
6
#+END_SRC

Strings are just binaries in Elixir. They are inserted between *double
quotes*, and they are encoded in UTF-8: for interpolation

#+BEGIN_SRC elixir
<<104, 101, 108, 108, 111>> == "hello" # true
#+END_SRC

#+BEGIN_SRC elixir
  name = "Farhad"
  "My name is #{name}"
  |> IO.puts
#+END_SRC

Note 'hello' is not a string it's a Character list
#+BEGIN_SRC elixir
is_list 'hello' # true
#+END_SRC

*** Binary list
=<<1, 2, 3>>=
- Every element is 1 byte long.
- Concatenating two binary list
=<<1, 2, 3>> <> <<4>>=

Each number given to a binary is meant to represent a byte and
therefore must go up to 255. Binaries allow modifiers to be given to
store numbers bigger than 255 or to convert a code point to its UTF-8
representation:

#+BEGIN_SRC elixir sh
iex> <<255>>
<<255>>
iex> <<256>> # truncated
<<0>>
iex> <<256 :: size(16)>> # use 16 bits (2 bytes) to store the number
<<1, 0>>
iex> <<256 :: utf8>> # the number is a code point
"Ā"
iex> <<256 :: utf8, 0>>
<<196, 128, 0>>
#+END_SRC

*** bitstring
If a byte has 8 bits, what happens if we pass a size of 1 bit?

#+BEGIN_SRC sh
iex> <<1 :: size(1)>>
<<1::size(1)>>
iex> <<2 :: size(1)>> # truncated
<<0::size(1)>>
iex> is_binary(<<1 :: size(1)>>)
false
iex> is_bitstring(<<1 :: size(1)>>)
true
iex> bit_size(<<1 :: size(1)>>)
1
#+END_SRC

The value is no longer a binary, but a bitstring – a bunch of bits! So
a binary is a bitstring where the number of bits is divisible by 8.

#+BEGIN_SRC sh
iex> is_binary(<<1 :: size(16)>>)
true
iex> is_binary(<<1 :: size(15)>>)
false
#+END_SRC

*** Anonymous functions
Anonymous functions are closures and as such they can access variables
that are in scope when the function is defined.

#+BEGIN_SRC elixir
iex> add = fn a, b -> a + b end # same as &(&1 + &2)
#Function<12.71889879/2 in :erl_eval.expr/5>
iex> add.(1, 2)
3
#+END_SRC
To call an anonymous function we use . notation like =add.(1, 2)=


**** Pattern Matching in anonymous function and multi lining them
#+BEGIN_SRC elixir
account_transaction = fn
    (balance, amount, :deposit) -> balance + amount
    (balance, amount, :withdraw) -> balance - amount
end
#+END_SRC

anonymous functions can have multiple clauses and guards:
#+BEGIN_SRC sh
iex> f = fn
...>   x, y when x > 0 -> x + y
...>   x, y -> x * y
...> end
#Function<12.71889879/2 in :erl_eval.expr/5>
iex> f.(1, 3)
4
iex> f.(-1, 3)
-3
#+END_SRC
The number of arguments in each anonymous function clause needs to be
the same, otherwise an error is raised.

**** Shorthand syntax
#+BEGIN_SRC elixir
  deposit = fn(balance, amount) -> amount + balance
  # becomes
  deposit = &(&1 + &2)
#+END_SRC

To define a call immediately
#+BEGIN_SRC elixir
  (fn x, y -> x - y end).(9, 3)   # 6
#+END_SRC

*** (/Linked/) Lists
Elixir lists are immutable head/tail pairs.
Elixir uses square brackets to specify a list of values. Values can be of any type:
#+BEGIN_SRC elixir
  mylist = [1, 2, true, 3]
   length mylist # 4
  [1, 2, 3] ++ [4, 5, 6] # [1, 2, 3, 4, 5, 6]
  # also there's a --
#+END_SRC
Appending to the end of a list is a slow operation because it needs to
copy the whole list. Think twice before doin' so.

The head is the first element of a list and the tail is the remainder of the list.
#+BEGIN_SRC elixir
list = [1, 2, 3]
hd(list) # 1
tl(list) # [2, 3]
[1 | [2]] === [1, 2] # true
[1 | [2 | [3]]] === [1, 2, 3] # true
#+END_SRC

*** Tuples
Elixir uses curly brackets to define tuples. Like lists, tuples can
hold any value: Tuples store elements contiguously in memory. This
means accessing a tuple element by index or getting the tuple size is
a fast operation. Indexes start from zero. However, updating or adding
elements to tuples is expensive because it requires copying the whole
tuple in memory.

#+BEGIN_SRC elixir
  t = {:ok, "Hi", 5}
  elem(t, 1) # :Hi
  tuple_size(t) # 3
  put_elem(t, 1, "hello") # returns a new tuple. original tuple hasn't changed (It's immutable)
#+END_SRC

** Lists or tuples?
Lists are stored in memory as linked lists, meaning that each element
in a list holds its value and points to the following element until
the end of the list is reached. We call each pair of value and pointer
a cons cell:
#+BEGIN_SRC elixir
list = [1 | [2 | [3 | []]]] # [1, 2, 3]
[0, | list ] # prepending element
#+END_SRC
This means accessing the length of a list is a linear operation: we
need to traverse the whole list in order to figure out its
size. Updating a list is fast as long as we are prepending elements:

Tuples, on the other hand, are stored contiguously in memory. This
means getting the tuple size or accessing an element by index is
fast. However, updating or adding elements to tuples is expensive
because it requires copying the whole tuple in memory.
|----------------+-------------------+-------------------|
|                | List              | Tuple             |
|----------------+-------------------+-------------------|
| Structure      | Linked list       | Contiguous memory |
| Insertion      | Fast (prepending) | Expensive         |
| Size           | Slow              | Fast              |
| Fetch by index | Slow              | Fast              |
| Fetch first    | Fast              | Fast              |

** Operators
*** in
To see if an element is present in a list
#+BEGIN_SRC elixir
"fhd" in ["fhd", "hsni", "blah"] # true
#+END_SRC
*** == vs ===
The difference between == and === is that the latter is more strict
when comparing integers and floats:
#+BEGIN_SRC sh
iex> 1 == 1.0
true
iex> 1 === 1.0
false
#+END_SRC
*** ++ and --
#+BEGIN_SRC elixir
[1, 2, 3] ++ [4] # [1, 2, 3, 4] # be careful here. this might be slow
[1, 2, 3] ++ [1, 3] # [2]
#+END_SRC
*** |

#+BEGIN_SRC elixir
me = ["fhd", "hsni"]
[25 | me] # [25, "fhd", "hsni"]

[h | t] = me
h # fhd
t # hsni

l = [1, 2, 3, 4, 5]
[a, b, c | tail] = l
#+END_SRC
*** <>
To concatenate two binaries. Remember in elixir strings are binaries
#+BEGIN_SRC elixir
"Farhad" <> " " <> "hsni" # Farhad hsni
<<104, 101, 108, 108, 111>> <> " " <> "world" # hello world
#+END_SRC
*** =~
#+BEGIN_SRC elixir
"Hello World" =~ ~r/hello/i #true
"Hello World" =~ "Hello" # true
#+END_SRC
*** Bitwise Operators
*** Logical Operators
**** and, or, &&, ||
=and=, =or= only accepts booleans
=&&=, =||= is non-strict and accepts any value

Using =||= to set a default:
#+BEGIN_SRC elixir
user = %{name: nil}
name = user.name || "Farhad"
name # Farhad
#+END_SRC
*** Capture Operator: &
captures or creates an anonymous function

Without capture operator
#+BEGIN_SRC elixir
  Enum.filter [1, 2, 3, "four"], fn(val) ->
    is_number(val)
  end
#+END_SRC
With capture operator
#+BEGIN_SRC elixir
  Enum.filter [1, 2, 3, "four"], &is_number/1 # [1, 2, 3]
  ## or ##
  Enum.filter [1, 2, 3, "four"], &is_number(&1) # [1, 2, 3]
#+END_SRC

We can even use capture operator to capture other operators like +
#+BEGIN_SRC elixir
Enum.reduce [1, 2, 3], &(&1 + &2) # 6
## capturing + operator
Enum.reduce [1, 2, 3], &+/2
#+END_SRC
#+BEGIN_SRC sh
iex> fun2 = &"Good #{&1}"
#Function<6.127694169/1 in :erl_eval.expr/5>
iex)> fun2.("morning")
"Good morning"
#+END_SRC

Using capture operator to capture functions from other modules
#+BEGIN_SRC elixir
Enum.map ["fhd", "hsni"], &String.upcase/1
#+END_SRC
** Pattern Matching
=a = 8= bind variable /a/ to number /8/, =8 = a= is a valid expression
 since 8 matches a.

If on the left hand side of = operator is variable it'll be bind to the
right hand side but if it's a value, pattern matching happens. If you
want to do pattern matching with a variable you can use pin (^)
operator. =^a = 8= doesn't bind variable to 8 but it does pattern matching.

Pattern Matching in maps are very useful.
#+BEGIN_SRC elixir
%{name: name} = %{name: "Farhad", age: 25}
name # "farhad"
#+END_SRC
Matching binaries
#+BEGIN_SRC elixir
"username: " <> usr = "username: fhdhsni"
usr #fhdhsni
#+END_SRC

#+BEGIN_SRC elixir
defmodule Bar do
  @moduledoc """

  """
  defstruct first_name: nil, last_name: nil

  def name(%Bar{} = user), do: user.first_name <> " " <> user.last_name
  def name(unsupported), do: raise "what the hell is #{inspect unsupported}?"

  def send_name, do: name(%Bar{first_name: "Farhad", last_name: "Hsni"})
end

Bar.send_name
#+END_SRC
** Keyword lists
It's a high level type (under the hood they are just lists).
In many functional programming languages, it is common to use a list
of 2-item tuples as the representation of a key-value data
structure. In Elixir, when we have a list of tuples and the first item
of the tuple (i.e. the key) is an atom, we call it a keyword list:

#+BEGIN_SRC elixir
  me = [{:name, "Farhad"}, {:status, "Awesome"}] # a list with two tuples(each one a 2-item tuple) inside it
  [name: "Farhad", status: "Awesome"] === me # true

  Keyword.get me, :name #"Farhad"
  me[:status] # "Awesome"

#+END_SRC

- Keys must be atoms.
- Keys are ordered, as specified by the developer.
- Keys can be given more than once.

#+BEGIN_SRC elixir
cook = fn(heat, foods) -> Keyword.values(foods) |> Enum.map(&(heat <> &1)) end
cook.("Fried ", [meat: "sausage", veg: "beans"]) # ["Fried sausage", "Fried beans"]
#+END_SRC

To use it in a function

#+BEGIN_SRC elixir
  defmodule Account do
    def balance(transactions, options \\ []) do
      currency = options[:currency] || "dollar"
      symbol = options[:symbol] || "$"
      # ... rest of function
    end
    # ... rest of module
  end


  Account.balance(..., currency: "dollar", symbol: "$") # short syntax
  # is equal to
  Account.balance(..., [{:currency, "dollar"}, {:symbol, "$"}])
#+END_SRC

In general, when the keyword list is the last argument of a function,
the square brackets are optional.


Although we can pattern match on keyword lists, it is rarely done in
practice since pattern matching on lists requires the number of items
and their order to match:
#+BEGIN_SRC sh
iex> [a: a] = [a: 1]
[a: 1]
iex> a
1
#+END_SRC
** Maps
Whenever you need a key-value store, maps are the “go to” data
structure in Elixir.

- Maps allow any value as a key.
- Maps’ keys do not follow any ordering.
- Duplicate values will be overrided
#+BEGIN_SRC elixir
  foo = %{:name => "Farhad", :username => "fhdhsni", :name => "notFarhad"}

  Map.get(foo, :name)             # notFarhad
  foo[:username]                  # fhdhsni
  foo.name                        # only if keys are atoms
#+END_SRC

Keyword syntax is allowed as long as all of the keys are atoms
#+BEGIN_SRC elixir
%{a: 1, b: 2} === %{:a => 1, :b => 2} # true
 #+END_SRC

pattern matching:
#+BEGIN_SRC elixir
iex> %{} = %{:a => 1, 2 => :b}
%{2 => :b, :a => 1}
iex> %{:a => a} = %{:a => 1, 2 => :b}
%{2 => :b, :a => 1}
iex> a
1
iex> %{:c => c} = %{:a => 1, 2 => :b}
 (MatchError) no match of right hand side value: %{2 => :b, :a => 1}
#+END_SRC

Maps have the following syntax for updating a key’s value.
Note: *new keys cannot be added*
#+BEGIN_SRC elixir
  me = %{:name => "Farhad", :age => 25}
  notMe = %{me | :name => "someone else"} # Adding new keys are not allowed
#+END_SRC

*** struct
Structs are extensions built on top of maps that provide compile-time
checks and default values.
#+BEGIN_SRC elixir
iex> defmodule User do
...>   defstruct name: "Farhad", age: 25 # nil is also common as default value
...> end
#+END_SRC

The keyword list used with defstruct defines what fields the struct
will have along with their *default* values.
#+BEGIN_SRC elixir
  iex> %User{}
  %User{age: 25, name: "Farhad"}
  iex> %User{name: "Esi"}         # we don't provide the age, default value (25) will be used
  %User{age: 25, name: "Esi"}

#+END_SRC
Structs provide compile-time guarantees that only the fields (and all
of them) defined through defstruct will be allowed to exist in a
struct:
#+BEGIN_SRC elixir
iex> %User{oops: :field}
 (KeyError) key :oops not found in: %User{age: 25, name: "Farhad"}
#+END_SRC

As being said earlier sturcts are just maps

#+BEGIN_SRC elixir
%User{} == %{__struct__: User, age: 25, name: "FArhad"} # true
#+END_SRC

Under the hood a =__struct__= funciton will be defined in the module
#+BEGIN_SRC elixir
defmodule User do
  defstruct name: "Farhad", email: "farhad.hsni@gmail.com"
end
#+END_SRC

#+BEGIN_SRC elixir
  defmodule User do
    def __struct__ do
      %{__struct__: User, name: "Farhad", email: "farhad.hsni@gmail.com"}
    end
  end
#+END_SRC
**** Accessing and updating structs
#+BEGIN_SRC elixir
defmodule Foo do
  defstruct class: "assassin", age: "young"
end

defmodule Play do
  defstruct name: "Farhad", age: 26

  def main do
    me = %Play{name: "Jafar"} # age will be the default

    me = %{me | name: "awesome" } # updating

    IO.puts me.name # awesome

    %Play{age: the_age } = %Play{name: "Morad", age: 900}       # pattern matching
    # %Play{age: the_age } = {name: "Morad", age: 900}       # error
    # %Play{age: the_age } = %Foo{}       # error

    IO.puts the_age # 900
  end
end

Play.main()
#+END_SRC
**** Structs are bare maps underneath
none of the protocols implemented for maps are available for
structs. For example, you can neither enumerate nor access a struct.
However, since structs are just maps, they work with the functions
from the Map module:
#+BEGIN_SRC elixir
iex> jane = Map.put(%User{}, :name, "Jane")
%User{age: 27, name: "Jane"}
iex> Map.merge(jane, %User{name: "John"})
%User{age: 27, name: "John"}
iex> Map.keys(jane)
[:__struct__, :age, :name]
#+END_SRC

**** Default values and required keys
If you don’t specify a default key value when defining a struct, nil
will be assumed:
#+BEGIN_SRC elixir
defmodule Play do
  defstruct [:name]

  def main do
    me = %Play{}

    IO.inspect me.name          # nil
  end
end

Play.main()
#+END_SRC

You can also enforce that certain keys have to be specified when
creating the struct:
#+BEGIN_SRC elixir
defmodule Play do
  @enforce_keys [:name]
  defstruct [:name]

  def main do
    me = %Play{}                # (ArgumentError) the following keys
                                # must also be given when building
                                # struct Play: [:name]

  end
end

Play.main()
#+END_SRC

*** Range
Range struct
#+BEGIN_SRC elixir
  0..100 == %Range{first: 0, last: 100} # true
  0..100 == %{__struct__: Range, first: 0, last: 100} # true
#+END_SRC
*** Regular Expressions
%Regex{
  opts: "",
  source: "hello"
}
#+BEGIN_SRC elixir
is_map ~r/hello/ # true
#+END_SRC

** Functions, Guard clauses and Modules
Functions in Elixir are identified by both their name and their
arity. The arity of a function describes the number of arguments which
the function takes.  Function declarations support guards and multiple
clauses. If a function has several clauses, Elixir will try each
clause until it finds one that matches.  Using guard clauses:
#+BEGIN_SRC elixir
  defmodule Example do
    def hello(name) when name === "Farhad" do
      IO.puts "Fuck off"
    end
    def hello(name) when is_bitstring name do
      IO.puts "Hi #{name}, Happy to see you"
    end
    def hello(_) do
      IO.puts "No idea what you doin'"
    end
  end

  Example.hello "Esi"             # Hi Esi, Happy to see you
  Example.hello "Farhad"          # Fuck off
  Example.hello 25                # No idea what you doin'
#+END_SRC
Mulitple clauses
#+BEGIN_SRC elixir
defmodule Math do
  def zero?(0), do: true
  def zero?(x) when is_integer(x), do: false
end

IO.puts Math.zero?(0)         #=> true
IO.puts Math.zero?(1)         #=> false
IO.puts Math.zero?([1, 2, 3]) #=> ** (FunctionClauseError)
IO.puts Math.zero?(0.0)       #=> ** (FunctionClauseError)
#+END_SRC
Using =do:= syntax
#+BEGIN_SRC elixir
defmodule Math do
  def zero?(0), do: true
  def zero?(x) when is_integer(x), do: false
end
#+END_SRC

*** Function Capturing
#+BEGIN_SRC elixir
Math.zero?(0) # true
fun = &Math.zero?/1
is_function(fun) # true
fun.(0) # true
#+END_SRC

Using capture syntax for creating functions

#+BEGIN_SRC elixir
  fun = &(&1 + &2)                # same as: fn x, y -> x + y end
  fun.(2, 9) # 11
#+END_SRC

Capturing a function from modules
#+BEGIN_SRC elixir
fun = &List.flatten(&1, &2) # &List.flatten/2
fun.([1, [[2], 3]], [4, 5]) # [1, 2, 3, 4, 5]
#+END_SRC

If a function with default values has multiple clauses, it is required
to create a function head (without an actual body) for declaring
defaults:

#+BEGIN_SRC elixir
defmodule Concat do
  def join(a, b \\ nil, sep \\ " ")

  def join(a, b, _sep) when is_nil(b) do
    a
  end

  def join(a, b, sep) do
    a <> sep <> b
  end
end

IO.puts Concat.join("Hello", "world")      #=> Hello world
IO.puts Concat.join("Hello", "world", "_") #=> Hello_world
IO.puts Concat.join("Hello")               #=> Hello
#+END_SRC
*** overlapping function definitions
When using default values, one must be careful to avoid overlapping
function definitions. Consider the following example:

#+BEGIN_SRC elixir
defmodule Concat do
  def join(a, b) do
    IO.puts "***First join"
    a <> b
  end

  def join(a, b, sep \\ " ") do
    IO.puts "***Second join"
    a <> sep <> b
  end
end

Concat.join "hello", " world" # will run first clause
Concat.join "hello", "world", "_" # will run second clause
#+END_SRC
invoking the =join= function with two arguments will always choose
the first definition of =join= whereas the second one will only be
invoked when three arguments are passed. thus providing a default
value for =sep= in second clause is unnecessary and has no effect.


#+BEGIN_SRC elixir
defmodule MyList do
  @moduledoc """

  """
  def reduce(list, func, acc \\ 0)
  def reduce([], _func, acc), do: acc
  def reduce(list, func, acc), do: do_reduce(list, func, acc)
  defp do_reduce([h | t], func, acc) do
    acc = func.(h) + acc
    reduce(t, func, acc)
  end
end

[1, 2, 3]
|> MyList.reduce(&(&1 * &1), 4)
|> IO.puts
#+END_SRC
- The header function defines the default value of =acc=.
- Less generalized functions are higher and more generalized functions are at the bottom.
- If we put =def reduce([], _func, acc), do: acc= bellow =def
  reduce(list, func, acc), do: do_reduce(list, func, acc)= we get a
  warning: =warning: this clause cannot match because a previous
  clause at line 6 always matches= since the more generalized function
  is higher and it always match.

*** Recursive function
#+BEGIN_SRC elixir
defmodule Graph do
  def count(%{children: []}), do: 1

  def count(%{children: children}) do
    [first | rest] = children
    count(first) + count(%{children: rest})
  end

end


graph = %{
  children: [
    %{children: []},
    %{children: []},
    %{children: [
         %{children: []},
         %{children: []}
       ]
    },
    %{children: []}
  ]
}

Graph.count(graph)
#+END_SRC
Another example
#+BEGIN_SRC elixir
defmodule MyList do
  @moduledoc """

  """
  def length(list), do: length(list, 0)
  defp length([], count), do: count
  defp length([_|t], count), do: length(t, count + 1)
end

MyList.length([1, 2, "three", "four"]) # 4
#+END_SRC
**** Tail Call Optimization
When a function calls itself as the last operation
#+BEGIN_SRC elixir
defmodule MyList do
  @moduledoc """

  """
  def each([], _fun), do: :ok
  def each([h | t], func) do
    func.(h)
    each(t, func)
  end
end

MyList.each([1, 2, 3, 4], &(IO.puts &1))
#+END_SRC
** IO and the file system
- By default, files are opened in binary mode, which requires
  developers to use the specific =IO.binread/2= and =IO.binwrite/2=
  functions from the IO module

#+BEGIN_SRC sh
iex> {:ok, file} = File.open "hello", [:write]
{:ok, #PID<0.47.0>}
iex> IO.binwrite file, "world"
:ok
iex> File.close file
:ok
iex> File.read "hello"
{:ok, "world"}
#+END_SRC

#+BEGIN_SRC elixir
case File.read(file) do
  {:ok, body}      -> # do something with the `body`
  {:error, reason} -> # handle the error caused by `reason`
end
#+END_SRC
** alias, require, and import
Elixir provides three directives (alias, require and import) plus a
macro called use summarized below:
#+BEGIN_SRC elixir
# Alias the module so it can be called as Bar instead of Foo.Bar
alias Foo.Bar, as: Bar

# Require the module in order to use its macros
require Foo

# Import functions from Foo so they can be called without the `Foo.` prefix
import Foo

# Invokes the custom code defined in Foo as an extension point
use Foo
#+END_SRC

the first three are called directives because they have lexical scope,
while use is a common extension point that allows the used module to
inject code.
*** alias
Referencing a module by a different name
#+BEGIN_SRC elixir
defmodule AnotherModule do
  def add(a, b), do: a + b
end

defmodule Foo do
  alias AnotherModule, as: M

  def fun, do: M.add 2, 5
end
#+END_SRC
Using a module by last part of its name
#+BEGIN_SRC elixir
defmodule Some.Other.Mod do
  def add(a, b), do: a + b
end

defmodule MyMod do
  alias Some.Other.Mod
  def fun(a, b), do: Mod.add(a, b) # just using Mod
end
#+END_SRC

#+BEGIN_SRC elixir
defmodule Stats do
  alias Math.List, as: List
  # In the remaining module definition List expands to Math.List.
end
#+END_SRC
The original List can still be accessed within Stats by the
fully-qualified name =Elixir.List=.

:NOTE:
Note: All modules defined in Elixir are defined inside the main Elixir
namespace. However, for convenience, you can omit “Elixir.” when
referencing them.
:END:

Note that alias is lexically scoped, which allows you to set aliases
inside specific functions:
#+BEGIN_SRC elixir
defmodule Math do
  def plus(a, b) do
    alias Math.List
    # ...
  end

  def minus(a, b) do
    # ...
  end
end
#+END_SRC
*** require
Elixir provides macros as a mechanism for meta-programming (writing
code that generates code). Macros are expanded at compile time. Public
functions in modules are globally available, but in order to use
macros, you need to opt-in by requiring the module they are defined
in.
#+BEGIN_SRC sh

iex(2)> Integer.is_odd(3)
 (CompileError) iex:2: you must require Integer before invoking the macro Integer.is_odd/1
    (elixir) src/elixir_dispatch.erl:97: :elixir_dispatch.dispatch_require/6

iex(2)> require Integer
Integer

iex(3)> Integer.is_odd(3)
true
#+END_SRC
=require= is also lexically scoped
*** import
We use import whenever we want to easily access functions or macros
from other modules without using the fully-qualified name.
#+BEGIN_SRC sh
iex> import List, only: [duplicate: 2]
List
iex> duplicate :ok, 3
[:ok, :ok, :ok]
#+END_SRC

import also supports =:macros= and =:functions= to be given to =:only=. For
example, to import all macros, one could write:
#+BEGIN_SRC elixir
import Integer, only: :macros
#+END_SRC
#+BEGIN_SRC elixir
import Integer, only: :functions
#+END_SRC

Note that import is lexically scoped too. This means that we can
import specific macros or functions inside function definitions:
#+BEGIN_SRC elixir
defmodule Math do
  def some_function do
    import List, only: [duplicate: 2]
    duplicate(:ok, 10)
  end
end
#+END_SRC
*Note that importing a module automatically requires it.*

**** Importing the whole module
#+BEGIN_SRC elixir
defmodule AnotherModule do
  def add(a, b), do: a + b
end

defmodule Foo do
  import AnotherModule

  def fun, do: add 2, 10
end

Foo.fun # 12
#+END_SRC

**** =only=
 #+BEGIN_SRC elixir
 defmodule AnotherModule do
  def add(a, b), do: a + b
  def add(a, b, c), do: a + b + c
end

defmodule Foo do
  import AnotherModule, only: [add: 2] # 2 is the arity

  def fun, do: add 2, 10, 2
end

Foo.fun # %CompileError{description: "undefined function add/3", file: "nofile", line: 9}
 #+END_SRC
 Above snippet raise an error because we only imported to =add/2=
 function. The number is the arity of the given function.

**** =except=
#+BEGIN_SRC elixir
defmodule Some.Other.Mod do
  def add(a, b), do: a + b
  def subtract(a, b), do: a - b
end

defmodule MyMod do
  import Some.Other.Mod, except: [add: 2] # don't import add/2

  # def foo(a, b), do: add(a, b) #throws an error, we didn't import add/2
  def bar(a, b), do: subtract(a, b)
end

# MyMod.foo(10, 20) # %CompileError{description: "undefined function add/2", file: "nofile", line: 8}

MyMod.bar(20, 10) # 10
#+END_SRC
*** use
The =use= macro is frequently used as an extension point. This means
that, when you use a module FooBar, you allow that module to inject
any code in the current module, such as importing itself or other
modules, defining new functions, setting a module state, etc.

For example, in order to write tests using the ExUnit framework, a
developer should use the =ExUnit.Case= module:
#+BEGIN_SRC elixir
defmodule AssertionTest do
  use ExUnit.Case, async: true

  test "always pass" do
    assert true
  end
end
#+END_SRC
Behind the scenes, use requires the given module and then calls the
=__using__/1= callback on it allowing the module to inject some code
into the current context. Generally speaking, the following module:
#+BEGIN_SRC elixir
defmodule Example do
  use Feature, option: :value
end
#+END_SRC
is compiled to
#+BEGIN_SRC elixir
defmodule Example do
  require Feature
  Feature.__using__(option: :value)
end
#+END_SRC
*** Understanding Aliases
An alias in Elixir is a capitalized identifier (like String, Keyword,
etc) which is converted to an atom during compilation. For instance,
the String alias translates by default to the atom =:"Elixir.String"=:
#+BEGIN_SRC
iex> is_atom(String)
true
iex> to_string(String)
"Elixir.String"
iex> :"Elixir.String" == String
true
#+END_SRC
Aliases expand to atoms because in the Erlang VM (and consequently
Elixir) modules are always represented by atoms. For example, that’s
the mechanism we use to call Erlang modules:
#+BEGIN_SRC
iex> :lists.flatten([1, [2], 3])
[1, 2, 3]
#+END_SRC
*** Module nesting
#+BEGIN_SRC elixir
defmodule Foo do
  defmodule Bar do
  end
end
#+END_SRC
The example above will define two modules: Foo and Foo.Bar. The second
can be accessed as Bar inside Foo as long as they are in the same
lexical scope. The code above is exactly the same as:
#+BEGIN_SRC elixir
defmodule Elixir.Foo do
  defmodule Elixir.Foo.Bar do
  end
  alias Elixir.Foo.Bar, as: Bar
end
#+END_SRC

*** Multi alias/import/require/use
#+BEGIN_SRC
alias MyApp.{Foo, Bar, Baz}
#+END_SRC
** Module attributes
   Module attributes in Elixir serve three purposes:
1. They serve to annotate the module, often with information to be used by the user or the VM.
2. They work as constants.
3. They work as a temporary module storage to be used during compilation.
*** As annotations
Elixir has a handful of reserved attributes. Here are a few of them, the most commonly used ones:

- =@moduledoc=: provides documentation for the current module.

- =@doc=: provides documentation for the function or macro that
  follows the attribute.
- =@behaviour=: (notice the British spelling) used for specifying an
  OTP or user-defined behaviour.

- =@before_compile= - provides a hook that will be invoked before the
  module is compiled. This makes it possible to inject functions
  inside the module exactly before compilation

-
e.g.

#+BEGIN_SRC elixir
defmodule Math do
  @moduledoc """
  Provides math-related functions.

  ## Examples

      iex> Math.sum(1, 2)
      3

  """

  @doc """
  Calculates the sum of two numbers.
  """
  def sum(a, b), do: a + b
end
#+END_SRC
Elixir provide a tool called =ExDoc= which is used to generate HTML
pages from the documentation.
*** As “constants”
Elixir developers will often use module attributes as constants:

#+BEGIN_SRC elixir
defmodule Play do
  @initial_state %{host: "127.0.0.1", port: 3456}

  def main do
    IO.inspect @initial_state
  end
end
#+END_SRC

Every time an attribute is read inside a function, a snapshot of its
current value is taken. In other words, the value is read at
compilation time and not at runtime. As we are going to see, this also
makes attributes useful to be used as storage during module
compilation.

#+BEGIN_SRC elixir
defmodule MyServer do
  @my_data 14
  def first_data, do: @my_data
  @my_data 13
  def second_data, do: @my_data
end

MyServer.first_data #=> 14
MyServer.second_data #=> 13
#+END_SRC
*** As temporary storage
** Protocols
Protocols are a mechanism to achieve polymorphism in Elixir.
#+BEGIN_SRC elixir
defprotocol Size do
  @doc "Calculates the size (and not the length!) of a data structure"
  def size(data)
end

defimpl Size, for: BitString do
  def size(string), do: byte_size(string)
end

defimpl Size, for: Map do
  def size(map), do: map_size(map)
end

defimpl Size, for: Tuple do
  def size(tuple), do: tuple_size(tuple)
end
#+END_SRC

#+BEGIN_SRC elixir
iex> Size.size("foo")
3
iex> Size.size({:ok, "hello"})
2
iex> Size.size(%{label: "some label"})
1
iex> Size.size([1, 2, 3])
 (Protocol.UndefinedError) protocol Size not implemented for [1, 2, 3]
#+END_SRC
- Elixir data structures
  + =Atom=
  + =BitString=
  + =Float=
  + =Function=
  + =Integer=
  + =List=
  + =Map=
  + =PID=
  + =Port=
  + =Reference=
  + =Tuple=

Instead of sharing protocol implementation with maps, structs require
their own protocol implementation. Since a MapSet has its size
precomputed and accessible through MapSet.size/1, we can define a Size
implementation for it:
#+BEGIN_SRC elixir
defimpl Size, for: MapSet do
  def size(set), do: MapSet.size(set)
end
#+END_SRC

#+BEGIN_SRC elixir
defmodule User do
  defstruct [:name, :age]
end

defimpl Size, for: User do
  def size(_user), do: 2
end
#+END_SRC
*** Implementing =Any=
#+BEGIN_SRC elixir
defimpl Size, for: Any do
  def size(_), do: 0
end
#+END_SRC
To use the above implementation we have to opt-in manually.

**** Deriving
When deriving, Elixir will implement the Size protocol for =Play=
based on the implementation provided for =Any=.

we can do so by =@derive= attribute:
#+BEGIN_SRC elixir
defmodule Play do
  @derive [Size]
  defstruct name: "farhad", age: 26
end
#+END_SRC


**** Fallback to Any
Another alternative to =@derive= is to explicitly tell the protocol to
fallback to =Any= when an implementation cannot be found. This can be
achieved by setting =@fallback_to_any= to =true= in the protocol
definition:
#+BEGIN_SRC elixir
defprotocol Size do
  @doc "Calculates the size (and not the length!) of a data structure"
  @fallback_to_any true
  def size(data)
end
#+END_SRC

** Enum module
Types which implements Enumerable hence can be used with Enum methods
- Lists
- Keyword Lists
- Maps (not Structs)
- Ranges
- Streams
*** Some useful Enum methods
**** Enum.map
**** Enum.each
**** Enum.at
Note when this method is used with Maps is returns a tuple.
#+BEGIN_SRC elixir
Enum.at %{:name => "Farhad", :age => 25}, 0, :default # {:age, 25}
#+END_SRC

**** Enum.filter
Note the anonymous function gets a tuple and returns a keyword list
#+BEGIN_SRC elixir
%{:name => "Farhad", :age => 25}
|> Enum.filter(fn({_key, val}) -> is_number val end) # returns a keyword list [age: 25]
#+END_SRC

**** Enum.reduce
**** Enum.into
Converts an =Enumerable= to another type. Target must implement
=Collectable= protocol.  lists and maps both implement collectable
protocol

In the example we convert a keyword list to a map
#+BEGIN_SRC elixir
%{:name => "Farhad", :age => 25}
|> Enum.filter(fn({_k, v}) -> is_binary(v) end) # retuns a keyword list [name: "Farhad"]
|> Enum.into(%{}) # make it a map %{name: "Farhad"}
#+END_SRC

**** Enum.take
#+BEGIN_SRC elixir
Enum.take(10..20, 5)  # [10, 11, 12, 13, 14]
#+END_SRC

** Streams
=Stream= is a lazy version of =Enum=.  Unlike =Enum= which does it's
job immediately, =Stream= waits until you ask for the result. This
could end up to be more efficient; like iterating over a list once for
all rather than doin' it for each operation like =Enum= does.

#+BEGIN_QUOTE
Due to their laziness, streams are useful when working with large (or
even infinite) collections. When chaining many operations with Enum,
intermediate lists are created, while Stream creates a recipe of
computations that are executed at a later moment.
#+END_QUOTE

#+BEGIN_SRC elixir
[1, 2, "buckle up your shoe", 3, 4]
|> Stream.filter(&is_number/1) # I don't feel like doin' it write now
|> Stream.filter(&(rem(&1, 2) == 0)) # nope not yet
|> Enum.into([]) # okay, I'll do it. [2, 4]
#+END_SRC

#+BEGIN_SRC elixir
  list = [1, 2, 3, "string", 4, 8]

  # stream stores the anonymous functions and returns a Stream struct
  stream = Stream.filter(list, &is_number/1)

  # stream stores the anonymous functions and returns a Stream struct
  stream = Stream.filter(stream, &(rem(&1, 2) == 0))

  Enum.into(stream, []) # up until now Stream hasn't done any actuall
                         # work. By Enum.into we make it to do the
                         # operations we asked for earlier
#+END_SRC

*** Stream.cycle
Creates a stream that cycles through the given enumerable, infinitely.
#+BEGIN_SRC elixir
Stream.cycle([1, 2, 3, "meow"])
|> Enum.take(8)
#+END_SRC
*** Stream.iterate
Emits a sequence of values, starting with =start_value=. Successive
values are generated by calling =next_fun= on the previous value.
#+BEGIN_SRC elixir
Stream.iterate(0, &(&1+1)) |> Enum.take(5) # [0, 1, 2, 3, 4]
#+END_SRC
*** Stream.resource
** Comprehension
It's another name for =for= macro in Elixir which returns a list.

The =for= macro has three parts:
1. Generators
2. Filters
3. =:into= Option

*** Generators
=element <- Enumerable=
It's possible to have multiple generators in a single =for= comprehension
#+BEGIN_SRC elixir
suits = [:hearts, :diamonds, :clubs, :spades]
faces = [2, 3, 4, 5, 6, 7, 8, 9, 10, :jack, :queen, :king, :ace]

for suit <- suits,
  face <- faces,
  do: {suit, face}
#+END_SRC
Pattern Matching is also allowed.
#+BEGIN_SRC elixir
for {:spades, face} <- deck do
  {:spades, face}
end
#+END_SRC
With bitstring
#+BEGIN_SRC elixir
pixels = <<213, 45, 132, 64, 76, 32, 76, 0, 0, 234, 32, 15>>
for <<r::8, g::8, b::8 <- pixels>>, do: {r, g, b} # [{213, 45, 132}, {64, 76, 32}, {76, 0, 0}, {234, 32, 15}]
#+END_SRC
*** Filters
#+BEGIN_SRC elixir
for element <- Enumerable, filter do
  element
end
#+END_SRC

#+BEGIN_SRC elixir
suits = [:hearts, :diamonds, :clubs, :spades]
faces = [2, 3, 4, 5, 6, 7, 8, 9, 10, :jack, :queen, :king, :ace]

for suit <- suits,
  face <- faces,
  suit == :spades,
  is_number(face),
  face > 5,
  do: {suit, face}
#+END_SRC

#+BEGIN_SRC elixir
users = [user: "john", admin: "meg", guest: "barbara"]

for {type, name} when type != :guest <- users do
    String.upcase(name)
end
#+END_SRC

#+BEGIN_SRC elixir
    dirs = ['/home/farhad/Downloads/Educator.Algebra.1', '/home/farhad/Pictures']

    for dir <- dirs,
        file <- File.ls!(dir),
        path = Path.join(dir, file),
        File.regular?(path) do
      File.stat!(path).size
    end
#+END_SRC
*** =:into=
Return something other than a list with the =:into= option:

#+BEGIN_SRC elixir
for {key, val} <- %{name: "Farhad", dob: 1993, email: "farhad.hsni@gmail.com"},
    key in [:name, :email],
    into: %{},
    do: {key, val}
#+END_SRC
#+BEGIN_SRC elixir
for <<c <- " hello world ">>, c != ?\s, into: "", do: <<c>> # "helloworld"
#+END_SRC


Sets, maps, and other dictionaries can also be given to the :into
option. In general, =:into= accepts any structure that implements the
=Collectable= protocol.

IO module provides streams (that are both Enumerables and Collectables)
#+BEGIN_SRC elixir
    stream = IO.stream(:stdio, :line)

    for line <- stream, into: stream do
      String.upcase(line) <> "\n"
    end
#+END_SRC


*** =for= vs. =Enum= vs. =Stream=
|            | Enum    | Stream | for  |
|------------+---------+--------+------|
| map        | YES     | YES    | YES  |
| filter     | YES     | YES    | YES  |
| lazy       | NO      | YES    | NO   |
| iterations | DEPENDS | ONCE   | ONCE |
| & Operator | YES     | YES    | NO   |

A more complex example
#+BEGIN_SRC elixir
defmodule Triple do
  def pythagorean(n) when n > 0 do
    for a <- 1..n,
      b <- 1..n,
      c <- 1..n,
      a + b + c <= n,
      a*a + b*b == c*c,
      do: {a, b, c}
  end
end

Triple.pythagorean(5) # []
Triple.pythagorean(12) # [{3, 4, 5}, {4, 3, 5}]
#+END_SRC
** Sigils
Sigils are one of the mechanisms provided by the language for working
with textual representations. Sigils start with the tilde (~)
character which is followed by a letter (which identifies the sigil)
and then a delimiter; optionally, modifiers can be added after the
final delimiter.

Sigils are a way to create a shorthand. There are bunch of userful
built-in sigil but we can also create our own sigils by =sigil_*=
function in a module and use it like =~*(blah blah)=. It also possible
to override built-in sigils.

Sigils are simply replaced by =sigil_*=
function at compile time.
#+BEGIN_SRC elixir
~r/foobar/im # sigil_r("foobar", 'im')
#+END_SRC

:NOTE:
Each sigil has a lowercase and upercase version. Uppercase sigils
doesn't allow interpolation
#+BEGIN_SRC elixir
name = "Farhad"
~S(my name is #{name}) # "my name is \#{name}"
~s(my name is #{name}) # "my name is Farhad"
#+END_SRC
:END:

Defining a custom sigil
#+BEGIN_SRC elixir
def sigil_u(content, _opts) do
  content
  |> String.split
  |> Enum.map(&String.upcase/1)
end
~u(foo bar) # ["FOO", "BAR"]
#+END_SRC
another example
#+BEGIN_SRC elixir
defmodule MySigils do
  def sigil_i(string, []), do: String.to_integer(string)
  def sigil_i(string, [?n]), do: -String.to_integer(string)
end

~i(13) # 13
~i(42)n # -42
#+END_SRC

*** delimiters
#+BEGIN_SRC elixir
~r/hello/
~r|hello|
~r"hello"
~r'hello'
~r(hello)
~r[hello]
~r{hello}
~r<hello>
#+END_SRC
*** Word List sigil
#+BEGIN_SRC elixir
~w(foo bar)  # ["foo", "bar"]
~w(foo bar)a # [:foo, :bar]
#+END_SRC

*** String sigil
#+BEGIN_SRC elixir
~s(foo bar) # "foo bar"
~s({"name": "Devin Torres", "age": 27}) # JSON
~s"""
this is
a heredoc string
"""

#+END_SRC

*** Character List sigil
#+BEGIN_SRC elixir
~c(foobar) # 'foobar'
#+END_SRC

** try, catch, and rescue
*** raise
#+BEGIN_SRC elixir
iex> raise "oops"
 (RuntimeError) oops
iex> raise ArgumentError, message: "invalid argument foo"
 (ArgumentError) invalid argument foo
#+END_SRC

*** defexception
#+BEGIN_SRC elixir
defmodule MyError do
  defexception message: "default message"
end

raise MyError # (MyError) default message
raise MyError, message: "custom message" # (MyError) custom message
#+END_SRC

*** try/rescue
#+BEGIN_SRC elixir
defmodule Main do
  defexception message: "fuck this shit"

  def run do
    try do
      raise __MODULE__
    rescue
      e in __MODULE__ -> {"oh I know this one", e}
      RuntimeError -> "oops runtime error"
      _ -> "I have know idea"
    end
  end
end

Main.run()
#+END_SRC

*** throws
In Elixir, we avoid using =try/rescue= because we don’t use errors for
control flow. We take errors literally: they are reserved for
unexpected and/or exceptional situations. In case you actually need
flow control constructs, =throws= should be used.

In Elixir, a value can be thrown and later be caught. =throw= and =catch=
are reserved for situations where it is not possible to retrieve a
value unless by using =throw= and =catch=.

#+BEGIN_SRC elixir
try do
  Enum.each -50..50, fn(x) ->
    if rem(x, 13) == 0, do: throw(x)
  end
  "Got nothing"
catch
  x -> "Got #{x}"
end
#+END_SRC

*** Exits
A process can also die by explicitly sending an =exit= signal:
#+BEGIN_SRC
iex> spawn_link fn -> exit(1) end
 (EXIT from #PID<0.56.0>) evaluator process exited with reason: 1
#+END_SRC

=exit= can also be “caught” using =try/catch=:
#+BEGIN_SRC elixir
try do
  exit "I am exiting"
catch
  :exit, _ -> "not really"
end
#+END_SRC

*** after
#+BEGIN_SRC elixir
{:ok, file} = File.open "sample", [:utf8, :write]

try do
  IO.write file, "olá"
  raise "oops, something went wrong"
after
  File.close(file)
end
#+END_SRC

The =after= clause will be executed regardless of whether or not the
tried block succeeds.


Elixir will automatically wrap the function body in a try whenever one
of =after=, =rescue= or =catch= is specified.
#+BEGIN_SRC elixir
defmodule Main do
  def run do
    Enum.each(1..10, fn x -> IO.puts(x) end)
  after
    IO.puts("inside after")
  end
end
#+END_SRC

*** else
If an else block is present, it will match on the results of the try
block whenever the try block finishes without a throw or an error.

#+BEGIN_SRC elixir
  defmodule Main do
    def run do
      x = 2

      try do
        1 / x
      rescue
        ArithmeticError -> :infinity
      else
        y when y < 1 and y > -1 -> :small
        _ -> :large
      end
    end
  end

  Main.run()
  |> IO.inspect()                 # :small
#+END_SRC

** Typespecs and behaviours
*** Typespecs
Elixir comes with typespecs, which are a notation used for:
- declaring typed function signatures (specifications);
- declaring custom data types.
**** Function specifications
 #+BEGIN_SRC elixir
 defmodule Main do
   @spec inc(number) :: integer
   def inc(x) do
     x + 1
   end
 end

 Main.inc(8)
 #+END_SRC
**** Defining custom types
 #+BEGIN_SRC elixir
 defmodule LousyCalculator do
   @typedoc """
   Just a number followed by a string.
   """
   @type number_with_remark :: {number, String.t}

   @spec add(number, number) :: number_with_remark
   def add(x, y), do: {x + y, "You need a calculator to do that?"}

   @spec multiply(number, number) :: number_with_remark
   def multiply(x, y), do: {x * y, "It is like addition on steroids."}
 end
 #+END_SRC

*** Behaviours
Behaviours provide a way to:
- define a set of functions that have to be implemented by a module;
- ensure that a module implements all the functions in that set.

#+BEGIN_SRC elixir
defmodule Parser do
  @callback parse(String.t) :: {:ok, term} | {:error, String.t}
  @callback extensions() :: [String.t]
end
#+END_SRC
Modules adopting the =Parser= behaviour will have to implement all the
functions defined with the =@callback= directive. As you can see,
=@callback= expects a function name but also a function specification
like the ones used with the =@spec= directive we saw above. Also note
that the =term= type is used to represent the parsed value. In Elixir,
the =term= type is a shortcut to represent any type.

**** Adopting behaviours
#+BEGIN_SRC elixir
defmodule JSONParser do
  @behaviour Parser

  @impl Parser
  def parse(str), do: {:ok, "some json " <> str} # ... parse JSON

  @impl Parser
  def extensions, do: ["json"]
end
#+END_SRC
**** Dynamic dispatch
Behaviours are frequently used with dynamic dispatching. For example,
we could add a =parse!= function to the Parser module that dispatches to
the given implementation and returns the =:ok= result or raises in cases
of =:error=:
#+BEGIN_SRC elixir
defmodule Parser do
  @callback parse(String.t) :: {:ok, term} | {:error, String.t}
  @callback extensions() :: [String.t]

  def parse!(implementation, contents) do
    case implementation.parse(contents) do
      {:ok, data} -> data
      {:error, error} -> raise ArgumentError, "parsing error: #{error}"
    end
  end
end
#+END_SRC
** Debugging
*** IO.inspect/2
we can label the outputs
#+BEGIN_SRC elixir
[1, 2, 3]
|> IO.inspect(label: "before") # before: [1, 2, 3]
|> Enum.map(&(&1 * 2))
|> IO.inspect(label: "after")  # after: [2, 4, 6]
|> Enum.sum
#+END_SRC
**** binding
#+BEGIN_SRC elixir
def some_fun(a, b, c) do
  IO.inspect binding()
end
#+END_SRC
When =some_fun/3= is invoked with =:foo, "bar", :baz= it prints:
#+BEGIN_SRC
[a: :foo, b: "bar", c: :baz]
#+END_SRC
*** IEx.pry/0 and IEx.break!/2
[[https://elixir-lang.org/getting-started/debugging.html#iexpry0-and-iexbreak2][doc]]

#+BEGIN_SRC elixir
  def run(a, b, c) do
    require IEx
    IEx.pry()                     # break point
    jafar = "jafar"
    IEx.pry()                     # break point
  end
#+END_SRC
*** Debugger
if =:debugger.start()= doesn't work remove erlang-nox and install the full erlang version.
https://brainlid.org/elixir/2015/11/27/linux-elixir-observer-start.html

#+BEGIN_SRC
$ iex -S mix
iex(1)> :debugger.start()
{:ok, #PID<0.87.0>}
iex(2)> :int.ni(Example)
{:module, Example}
iex(3)> :int.break(Example, 3)
:ok
iex(4)> Example.double_sum(1,2)

#+END_SRC
*** Observer
#+BEGIN_SRC
$ iex -S mix
iex(1)> :observer.start()
#+END_SRC

Also =runtime_info/0= is a gives a minimal overview.
** erlang
Elixir discourages simply wrapping Erlang libraries in favor of
directly interfacing with Erlang code.
*** The binary module
The built-in Elixir String module handles binaries that are UTF-8
encoded. The binary module is useful when you are dealing with binary
data that is not necessarily UTF-8 encoded.
#+BEGIN_SRC
iex> String.to_charlist "Ø"
[216]
iex> :binary.bin_to_list "Ø"
[195, 152]
#+END_SRC
The =String= module returns Unicode codepoints, while =:binary= deals with
raw data bytes.
*** The crypto module
#+BEGIN_SRC
iex> Base.encode16(:crypto.hash(:sha256, "Elixir"))
"3315715A7A3AD57428298676C5AE465DADA38D951BDFAC9348A8A31E9C7401CB"
#+END_SRC
The =:crypto= module is not part of the Erlang standard library, but is
included with the Erlang distribution. This means you must list
=:crypto= in your project’s applications list whenever you use it. To do
this, edit your =mix.exs file to include:

#+BEGIN_SRC elixir
def application do
  [extra_applications: [:crypto]]
end
#+END_SRC

*** The digraph module
The digraph module (as well as digraph_utils) contains functions for
dealing with directed graphs built of vertices and edges. After
constructing the graph, the algorithms in there will help finding, for
instance, the shortest path between two vertices, or loops in the
graph.

#+BEGIN_SRC elixir
iex> digraph = :digraph.new()
iex> coords = [{0.0, 0.0}, {1.0, 0.0}, {1.0, 1.0}]
iex> [v0, v1, v2] = (for c <- coords, do: :digraph.add_vertex(digraph, c))
iex> :digraph.add_edge(digraph, v0, v1)
iex> :digraph.add_edge(digraph, v1, v2)
iex> :digraph.get_short_path(digraph, v0, v2)
[{0.0, 0.0}, {1.0, 0.0}, {1.0, 1.0}]
#+END_SRC
Note that the functions in :digraph alter the graph structure
in-place, this is possible because they are implemented as ETS tables.

*** Erlang Term Storage
The modules =ets= and =dets= handle storage of large data structures in
memory or on disk respectively.

ETS lets you create a table containing tuples. By default, ETS tables
are protected, which means only the owner process may write to the
table but any other process can read. ETS has some functionality to be
used as a simple database, a key-value store or as a cache mechanism.
#+BEGIN_SRC
iex> table = :ets.new(:ets_test, [])
# Store as tuples with {name, population}
iex> :ets.insert(table, {"China", 1_374_000_000})
iex> :ets.insert(table, {"India", 1_284_000_000})
iex> :ets.insert(table, {"USA", 322_000_000})
iex> :ets.i(table)
<1   > {<<"India">>,1284000000}
<2   > {<<"USA">>,322000000}
<3   > {<<"China">>,1374000000}
#+END_SRC

*** The math module
*** The queue module
#+BEGIN_SRC
iex> q = :queue.new
iex> q = :queue.in("A", q)
iex> q = :queue.in("B", q)
iex> {value, q} = :queue.out(q)
iex> value
{:value, "A"}
iex> {value, q} = :queue.out(q)
iex> value
{:value, "B"}
iex> {value, q} = :queue.out(q)
iex> value
:empty
#+END_SRC
*** the rand module
#+BEGIN_SRC
iex> :rand.uniform()
0.8175669086010815
iex> _ = :rand.seed(:exs1024, {123, 123534, 345345})
iex> :rand.uniform()
0.5820506340260994
iex> :rand.uniform(6)
6
#+END_SRC
*** The zip and zlib modules
** Mix, Hex and others
The build tool for elixir
- =mix new foobar= to create foobar project
- =iex -S mix= to start iex in the context of a mix project
- There're two ways to set a key-value config in config.exs
  + =config :projectName, key: value=
  + =config :projectName, Module.Name, key: value=
- To get a configuration from =config.exe=
  + =Application.get_env(:projectName, :key)=
  + =Application.get_env(:projectName, __MODULE__)[:key]=
- to install hex =mix local.hex=
- to get deps specified in mix file =mix deps.get=
- to remove deps that you have removed from mix file =mix deps.clean PACKAGE_NAME=
- to update a dependency; bump the version in mix file then =mix deps.update PACKAGE_NAME=
- add `config :package_name, setting_a: "value"` to =config/config.exs= to configure a package
- =mix hex.outdated= to find out which packages are outdated
- for uploading your package to Hex, add package/0 setting to Mixfile
#+BEGIN_SRC elixir
  defp package do
    [
      files: ["lib", "mix.exs", "README.md"],
      contributors: ["Your Name"],
      licenses: ["MIT"],
      links: %{
        "Github" => "https://github.com/fhdhsni/repo"
      }
    ]
  end
#+END_SRC
  + remember to update =application/0= to specify each one of your
    runtime dependencies as an application in the =:application= list
    #+BEGIN_SRC elixir
    def application do
      [application: [:dependency_a, :dependency_b]]
    end
  #+END_SRC
  + update project/0 setting
    #+BEGIN_SRC elixir
      def project do
        [app: :my_project_name,
         version: "0.0.1",
         elixir: "~> 1.0",
         build_embedded: Mix.env == :prod,
         start_permanent: Mix.env == :prod,
         source_url: "https://github.com/fhdhsni/repo",
         description: "short description of project",
         package: package,
         deps: deps,
        ]
      end
    #+END_SRC
  + =mix hex.publish=
** ExUnit
- =assert=
  + expects truthy values
- =refute=
  + expects falsy values
- =assert_raise=
  + Assert that a code block raises an exception
- =assert_in_delta=
  + Assert that two things differ in a specific way
- =assert_receive=
  + Assert that a process message was received
*** Shared setup
#+BEGIN_SRC elixir
defmodule CryptoTest do
  use ExUnit.Case
  doctest Crypto

  setup do
    variable = 3
    {:ok, variable: variable}
  end

  test "the truth", %{variable: variable} do
    refute 1 + 1 == variable
  end
end
#+END_SRC
*** ExUnit.CaseTemlate
*** Running tests asynchronously
#+BEGIN_SRC elixir
  defmodule MyApp.MathTest do
    use ExUnit.Case, async: true

    # ...
  end
#+END_SRC
*** Tagging
#+BEGIN_SRC elixir
defmodule CryptoTest do
  # This would tag all the tests in the module as slow
  @moduletag :slow

  use ExUnit.Case
  doctest Crypto

  # This tags only one test
  @tag :slow
  test "2 plus one should be three" do
    assert 2 + 1 == 3
  end
end
#+END_SRC
Then you can exclude tests with a given tag by adding the following snippet to =test/test_helpers.exs=
#+BEGIN_SRC elixir
ExUnit.start()
ExUnit.configure exclude: [:slow]
#+END_SRC

**** skip
There's also the built-in =skip= tag
#+BEGIN_SRC elixir
@tag :skip
# org
@tag skip: "Reason"
#+END_SRC
*** Pending Tests
#+BEGIN_SRC elixir
# Automatically tagged with @tag :not_implemented
  test ".add subs two numbers"
  test ".div divides two numbers"
  test ".mul multiples two numbers"
#+END_SRC
*** Doctests
use =doctests MyApp.MyModule= in test file to consider doc examples as tests

Written inline with documentation for a module of function typically under an =## example= heading.
#+BEGIN_SRC elixir
  defmodule MyApp.Math do
    @doc """
    Adds two numbers together and returns the sum.

    # Examples

      iex> Math.add(1, 2)
      3

      iex> sum = Math.add(5, 5)
      ...> Math.add(sum. 5)
      15
    """
    def add(a, b), do: a + b
  end
#+END_SRC

*** Running tests
Exclude tests tagged with :slow
=mix test --exclude slow=
or include them
=mix test --include slow=
or only run those with this tag
=mix test --only slow=

** Processes
*** =spawn=
=spawn(a_function)=
#+BEGIN_SRC sh
iex> pid = spawn fn -> 1 + 2 end
#PID<0.43.0>
iex> Process.alive?(pid)
false
#+END_SRC
=spawn(someModule, :some_function, [arg1, arg2])=
**** spawn
Spawned process is isolated. If it raises an error parent process won't die.
**** spawn_link
In this way failure in the spawned process propagates to parent
process. It's also possible to link processes via =Process.link/1=

In the parent process we can =:trap_exit= and to something other than
dying if the spawned process died.
#+BEGIN_SRC elixir
  Process.flag(:trap_exit, true)
  pid = spawn_link(fn -> ... end)

  receive do
    {:EXIT, pid, reason} ->
      # Revive pid?
  end
#+END_SRC
**** spawn_monitor
#+BEGIN_SRC elixir
  {juliet, _ref} = spawn_monitor(fn -> ... end)
  receive do
    {:DOWN, _ref, :process, pid} ->
      # Revive juliet
  end
#+END_SRC
*** =self=
returns current process PID
*** =send=
The process that sends the message does not block on send/2, it puts
the message in the recipient’s mailbox and continues.
*** =receive=
If there is no message in the mailbox matching any of the patterns,
the current process will wait until a matching message arrives. A
timeout can also be specified with =after= block:
#+BEGIN_SRC
iex> receive do
...>   {:hello, msg}  -> msg
...> after
...>   1_000 -> "nothing after 1s"
...> end
"nothing after 1s"
#+END_SRC
Messages that don't match any of provided patterns will be left in the
process's mailbox. Mailbox may fill up.
*** =flush=
It flushes and prints all the messages in the mailbox.
*** =kill=
=Process.exit(pid, :kil)=

example
#+BEGIN_SRC elixir
  defmodule Play do
    def ground(pid) do
      # send self(), {:hello, "World"}
      receive do
        {:hello, msg} -> IO.puts msg
        {:world, _msg} -> IO.puts "fuck this shit"
      after
        1_000 -> send pid, {:bye, "papa"}
      end
    end
  end

  spawn Play, :ground, [self()]
  # Play.ground
  # send pid, {:hello, "World"}

  receive do
    {:bye, name} -> IO.puts name  # papa
    _ -> IO.puts "unknown crap"
  end
#+END_SRC

*** keeping state
#+BEGIN_SRC elixir
defmodule KV do
  def start_link do
    Task.start_link(fn -> loop(%{}) end)
  end

  defp loop(map) do
    receive do
      {:get, key, caller} ->
        send caller, Map.get(map, key)
        loop(map)
      {:put, key, value} ->
        loop(Map.put(map, key, value))
    end
  end
end


{:ok, pid} = KV.start_link;

send pid, {:put, "name", "farhad"}

send pid, {:get, "name", self()}

receive do
  name -> IO.inspect name       # farhad
end
#+END_SRC
** GenServer
A primitive emulation of GenServer.

Server:
#+BEGIN_SRC elixir
defmodule Server do
  @moduledoc ~s"""
  account = Server.start(BankAccount, 0)

  send(account, {:deposit, 50})
  send(account, {:withdraw, 20})

  send(account, :balance) # should receive {:balance, 30}
  """

  def start(callback_module, state) do
    parent = self()
    spawn fn ->
      loop(callback_module, parent, state)
    end
  end

  def loop(callback_module, parent, state) do
    receive do
      message ->
        state = callback_module.handle_message(message, parent, state)
        loop(callback_module, parent, state)
    end
  end
end
#+END_SRC

BankAccount:
#+BEGIN_SRC elixir
defmodule BankAccount do

  def handle_message({:deposit, amount}, _from, balance) do
    balance + amount
  end

  def handle_message({:withdraw, amount}, _from, balance) do
    balance - amount
  end

  def handle_message(:balance, from, balance) do
    send(from, {:balance, balance})
    balance
  end

end
#+END_SRC

*** GenServer
#+BEGIN_SRC elixir
  {:ok, pid} = GenServer.start(CallbackModule, [arg1, arg2], opts) # if it crashed it won't bring the current process down
  {:ok, pid} = GenServer.start_link(CallbackModule, [arg1, arg2], opts)
#+END_SRC
1. Note that the list =[arg1, arg2]= is sent to =init= function defined inside =CallbackModule=
2. =opts= is optional.
3. =init= function sets the initial state with ={:ok, initial_state}= response
4. =handle_call= is synchronous and
   - Handles =GenServer.call=
   - Its signature is =handle_call(arg, from_pid, current_state)=. =arg= is =GenServer.call(pid, *arg*)=
   - Should reply like ={:reply, return_value, new_state}=
5. =handle_cast= is asynchronous and
   - Handles =GenServer.cast=
   - Its signature =handle_cast(arg, current_state)=
   - Should reply ={:noreply, new_state}=
6. =handle_info= is asynchronous and
   - must be used for all other messages a server may receive that are
     not sent via =GenServer.call/2= or =GenServer.cast/2=, including
     regular messages sent with =send/2=. The monitoring =:DOWN= messages
     are such an example of this.
7. =GenServer.cast=
   + Send a message without expecting or waiting for a response
8. =GenServer.call=
   + Send a message and wait for a response (hence blocking the current process)
9. GenServer process can be named
   =GenServer.start_link(CallbackModule, [args], name:foobar)= so we
   don't need the pid =GenServer.cast(foobar, {:save, state})=

**** Implementing BankAccount with GenServer
#+BEGIN_SRC elixir
defmodule BankAccount do
  use GenServer

  def init(balance), do: {:ok, balance}
  # receives the argument that we
  # gave to GenServer.start
  # function and returns the
  # inital state to be stored in
  # the process


  def handle_cast({:deposit, amount}, balance), do: {:noreply, balance + amount}
  def handle_cast({:withdraw, amount}, balance), do: {:noreply, balance - amount}
  # take the message that was sent as the first arugment and current
  # state of process as the last argument. If the first element of
  # tuple is :reply whatever comes next will be send back to the
  # caller. last element of the tuple is the new state

  def handle_call(:balance, _from, balance), do: {:reply, balance, balance}
  # thrid element is the new state
  # second element will be send back to the caller
  # read handle_cast comment
end
#+END_SRC
To use it:
#+BEGIN_SRC
  {:ok, account} = GenServer.start(BankAccount, 0)
  GenServer.cast(account, {:deposit, 50})
  GenServer.cast(account, {:withdraw, 25})
  balance = GenServer.call(account, :balance) # 25
#+END_SRC
**** BankAccount as a GenServer
#+BEGIN_SRC elixir
defmodule BankAccount do
  use GenServer

  def start(balance) do
    {:ok, account} = GenServer.start(__MODULE__, balance)
    account
  end

  def deposit(account, amount) do
    GenServer.cast(account, {:deposit, amount})
  end

  def withdraw(account, amount) do
    GenServer.cast(account, {:withdraw, amount})
  end

  def balance(account) do
    GenServer.call(account, :balance)
  end

  ###
  # GenServer API
  ###

  # Handle cast messages with `handle_cast`. No response is expected,
  # so reply with the {:noreply, ...} tuple format
  def handle_cast({:deposit, amount}, balance) do
    {:noreply, balance + amount}
  end

  def handle_cast({:withdraw, amount}, balance) do
    {:noreply, balance - amount}
  end

  # Handle call messages with the `handle_call` callback. Responses are usually
  # expected, so respond with the {:reply, ...} tuple format.
  def handle_call(:balance, _from, balance) do
    {:reply, balance, balance}
  end

end
#+END_SRC
To use it:
#+BEGIN_SRC
  account = BankAccount.start(0)
  BankAccount.deposit(account, 50)
  BankAccount.withdraw(account, 25)
  BankAccount.balance(account)      # 25
#+END_SRC
**** When to Use GenServer
Not always, for e.g above example can be implemented with the help of structs.

Implementing BankAccount with struct:
#+BEGIN_SRC elixir
defmodule BankAccount do
  defstruct balance: 0

  def new(balance) do
    %__MODULE__{balance: balance}
  end

  def deposit(account, amount) do
    %{account | balance: account.balance + amount}
  end

  def withdraw(account, amount) do
    %{account | balance: account.balance - amount}
  end

  def balance(account) do
    account.balance
  end

end
#+END_SRC
**** GenServer Features
- GenServer processes are distributed across cores
- A GenServer process works on one message at a time
- GenServer processes can be supervised and restarted
- GenServer process state can be upgraded in place

*** Monitors or links?
when should we use monitors and when should we use links?

Links are bi-directional. If you link two processes and one of them
crashes, the other side will crash too (unless it is trapping
exits). A monitor is uni-directional: only the monitoring process will
receive notifications about the monitored one. In other words: use
links when you want linked crashes, and monitors when you just want to
be informed of crashes, exits, and so on.
** Supervisor
*** example 1
=Basic= module:
#+BEGIN_SRC elixir
defmodule Basic do
  use GenServer

  def start_link(arg) do
    IO.puts "inside Basic start_link..."
    GenServer.start_link(__MODULE__, arg)
  end
  def init(arg) do
    IO.inspect arg
    IO.puts "inside Basic init..."
    {:ok, []}
  end
end
#+END_SRC

=BasicSupervisor= module:
#+BEGIN_SRC elixir
defmodule BasicSupervisor do
  use Supervisor

  def start_link(arg) do
    Supervisor.start_link(__MODULE__, arg) # passes =arg= to init
  end

  def init(arg) do
    children = [
      worker(Basic, [arg]) # passing =arg= (not [arg]) to Basic.start_link
    ]
    supervise(children, strategy: :one_for_one)
  end

end
#+END_SRC

To use it:
#+BEGIN_SRC
iex(1)> {:ok, s_pid} = BasicSupervisor.start_link("Jack")
inside Basic start_link...
"Jack"
inside Basic init...
{:ok, #PID<0.126.0>}

iex(2)> [{_, pid,_ ,_}] = Supervisor.which_children(s_pid)
[{Basic, #PID<0.127.0>, :worker, [Basic]}]
iex(6)> pid
pid
#PID<0.127.0>

iex(3)> GenServer.stop(pid)
inside Basic start_link...
"Jack"
:ok
inside Basic init...
#+END_SRC

*** example 2
Implementing a simple TODO app

#+BEGIN_SRC elixir
defmodule Todo do
  use GenServer

  def start_link(state, opts \\ []), do: GenServer.start_link(__MODULE__, state, opts)

  def handle_cast({:add, task}, todo), do: {:noreply, [task | todo]}

  def handle_cast({:remove, task_index}, todo) do
    new_Todo = List.delete_at(todo, task_index)
    {:noreply, new_Todo}
  end

  def handle_call(:list, _from, todo), do: {:reply, create_todo_list(todo), todo}

  def create_todo_list(todo, str \\ "", n \\ 1)
  def create_todo_list([], str, _n) do
    IO.puts str
    str
  end

  def create_todo_list(todo, str, n) do
    [h | t] = todo
    str = str <> "#{n}- #{h}\n"
    n = n + 1
    create_todo_list(t, str, n)
  end

end
#+END_SRC
And its supervisor
#+BEGIN_SRC elixir
defmodule Todo.Supervisor do
  use Supervisor

  def start_link do
    Supervisor.start_link(__MODULE__, [])
  end

  def init([]) do
    children = [
      worker(Todo, [[]])
    ]
    supervise(children, strategy: :one_for_one)
  end
end
#+END_SRC
*** Notes
- to create a mix project with a Supervisor =mix nes my_project --sup=
- workers can have ids =worker(SupervisedProcess, [], id: "some_id")=
- Supervisors themself can be supervised =worker(Supervisor_module, [])=
- for data storage you might find =ets=, =dets=, or =Mnesia= more useful than third party tools
- =simple_one_for_one= is for dynamically launching processes.
** Task & Agents
*** Tasks
Tasks build on top of the spawn functions to provide better error
reports and introspection. They are Asynchronous units of computation
that allow spawning a process and potentially retrieving its result at
a later time.

Asynchronous Processing
#+BEGIN_SRC elixir
  task = Task.async fn ->
    IO.puts "Hello world!"
  end

  # OR

  task = Task.async(IO, :puts, ["Hello World"])

  result = Task.await(task)
#+END_SRC

#+BEGIN_SRC elixir
defmodule Play do
  def pmap(list, fun) do
    list
    |> Enum.map(&Task.async(fn -> fun.(&1) end))
    |> Enum.map(&Task.await/1)
  end
end
#+END_SRC

To Supervise A Task

Supervisor:
#+BEGIN_SRC elixir
defmodule Play.Supervisor do
  use Supervisor

  def start_link do
    Supervisor.start_link(__MODULE__, [], name: __MODULE__)
  end

  def init(_) do
    children = [
      supervisor(Task.Supervisor, [[name: MyApp.TaskSupervisor]])
    ]
    supervise(children, strategy: :transient)
  end
end
#+END_SRC

Then after =Play.Supervisor.start_link=:
#+BEGIN_SRC elixir
# You can start supervised tasks like so:
Task.Supervisor.start_child(MyApp.TaskSupervisor, fn ->
  IO.puts "Hello world!"
end)

Task.Supervisor.async(MyApp.TaskSupervisor, IO, :puts, ["Hello world!"])
|> Task.await
#+END_SRC

+ =yield(task, timeout \\ 5000)=
  - Temporarily blocks the current process waiting for a task reply.
*** Agent
Agents are a simple abstraction around state.

#+BEGIN_SRC  elixir
{:ok, agent} = Agent.start_link(fn -> 0 end)
Agent.update(agent, fn(state) -> state + 1 end)
Agent.get(agent, fn(state) -> state end) # 1
#+END_SRC

implementing =BankAccount= with Agents
#+BEGIN_SRC elixir
defmodule BankAccount do
  def start_link(balance) do
    Agent.start_link(fn -> balance end)
  end

  def deposit(account, amount) do
    Agent.update(account, &(&1 + amount))
  end

  def withdraw(account, amount) do
    Agent.update(account, &(&1 - amount))
  end

  def balance(account) do
    Agent.get(account, &(&1))
  end
end
#+END_SRC
** Nodes
A Node is an instance of BEAM virtual machine.
- =Node.self=
  + to get the current node's name
- =Node.list=
  + to get a list of connected nodes
- =iex --sname node_name=
  + to start a named node
- =Node.connect(:Farhad@Manjaro)=
  + to connect to a node
- =Node.spawn or Node.spawn_link=
  + to spawn a process in a node
#+BEGIN_SRC elixir
  pid = Node.spawn :fhd@Manjaro, fn ->
    IO.puts "yohoo"
  end
#+END_SRC

*** Note
- Code is /not sent/
- All data in the message will be /copied/
- Be aware of Network Latency

** Miscellaneous
*** =if=
    if statement is just a macro that takes =true= or =false= as it's
    first argument and a keyword list as it's second argument. use =case= or =cond= instead
#+BEGIN_SRC elixir
  if true, do: :this, else :that     #
  # it's actually a macro
  if(true, [do: :this, else: :that]) # :this
  if(false, [do: :this, else: :that]) # :that
#+END_SRC

*** =cond=
Run the first block where expression is truthy.
Remember =cond= has no falling through like a switch case does in other languages.
#+BEGIN_SRC elixir
  cond do
    expression -> body
    expression -> body
    ...
  end
#+END_SRC
#+BEGIN_SRC elixir
defmodule Fun do
  def foo(%{age: age}) do
    cond do
      age > 50 -> "You gonna die, pretty soon actully"
      age > 30 -> "Enjoy misery"
      true     -> "Hmm"
    end
  end
end

Fun.foo(%{name: "Farhad", age: 51}) # "You gonna die, pretty soon actully"
#+END_SRC

*** =case=
When a *pattern* matches the value of the *expression*, the body is executed.
#+BEGIN_SRC elixir
  case expression do
    pattern -> body
    pattern -> body
    ...
  end
#+END_SRC
#+BEGIN_SRC elixir
  defmodule Fun do
    def foo(%{age: age}) do
      case age do
        :old           -> "You gonna die, pretty soon actully"
        :not_That_Old  -> "Enjoy misery"
        _              -> "Hmm" #note the use of underscore in lieu of true like in =cond=
      end
    end
  end

  Fun.foo(%{name: "Farhad", age: :something}) # Hmm
#+END_SRC
Another example
#+BEGIN_SRC elixir
case File.read("foobar.txt") do
  {:ok, content} ->
    IO.puts "content of given file: #{content}"
  {:error, reason} ->
    Io.puts "error #{reason} occurred"
  other ->
    IO.puts "An unknown error occurred. #{other}"
end
#+END_SRC
Using Guard clase in =case=
#+BEGIN_SRC elixir
v = "foo"
case v do
  v when v in [nil, false, ""] -> "moew"
  _ -> "not meow"
end
#+END_SRC

*** =with=
#+BEGIN_SRC elixir
 with
  pattern <- expression
  pattern <- expression
  ...
do
  body
end
#+END_SRC

#+BEGIN_SRC elixir
opts = %{:width => 10, :height => 15}
with {:ok, width} <- Map.fetch(opts, :width),
     {:ok, height} <- Map.fetch(opts, :height),
  do: {:ok, width * height}
#+END_SRC
*** =try do ... rescue ... after ... end=
Use try rescue as last resort.
After is optional.
#+BEGIN_SRC elixir
defmodule M do
  def say_hi(name) do
    try do
      "Hey #{String.upcase name}!!!"
  rescue
    _e -> raise "Fuck off"
    end
  end
end
M.say_hi 3
#+END_SRC
*** =raise=
#+BEGIN_SRC elixir
raise "an exception"
#+END_SRC
*** =throw/catch=
*** =defdelegate=
#+BEGIN_SRC elixir
defmodule Some.Other.Mod do
  def add(a, b), do: a + b
  def subtract(a, b), do: a - b
end

defmodule MyMod do
  defdelegate bar(a, b), to: Some.Other.Mod, as: :add
  defdelegate subtract(a, b), to: Some.Other.Mod
end

MyMod.bar(20, 10) # 30
MyMod.subtract(23, 3) # 3
#+END_SRC
*** =?=
returns ASCII code of given character (in decimal)
#+BEGIN_SRC elixir
IO.inspect ?a # 97
IO.inspect ?\s # 32 (for space)
#+END_SRC
** WAT?

#+BEGIN_SRC elixir
foo = fn 0 -> "zero"; 2 -> "two" end
foo.(0) # "zero"
foo.(2) # "two"
#+END_SRC
