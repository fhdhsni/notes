* Elixir

- *.ex files will be compiled
- *.exs are script files (won't get compiled)
- snake_case naming convention
- # starts a comment line
- ~/.iex.exs is iex configuration file (more info iex> h IEx.configure)

** Types
*** Numbers
- Integers (large numbers can be used with _ e.g 1_000_000_000)
  + =0o555= (octal)
  + =0xabc= (hexdecimal)
  + =0b101100=
- Floats (64bit accuracy)
  - exponent: 1.0e-20

:NOTE:
=10 / 2= returns a float. If you need integer use =div(10, 2)=

=rem(10, 3)= returns the reminder
:END:

*** Atoms
Atoms are constants where their name is their own value.
#+BEGIN_SRC elixir
:hello == :"hello" # true
#+END_SRC 
Module names are atoms
#+BEGIN_SRC elixir
defmodule MyMod do
  def foo(name) do
    "Hi #{name}"
  end
end
is_atom(MyMod) #true
#+END_SRC

=nil= is also an atom.

*** Booleans
In fact they are atoms
:true == true
is true

*** Strings
Strings are just binaries in Elixir. They are inserted between *double
quotes*, and they are encoded in UTF-8: for interpolation

#+BEGIN_SRC elixir
<<104, 101, 108, 108, 111>> == "hello" # true
#+END_SRC

#+BEGIN_SRC elixir
  name = "Farhad"
  "My name is #{name}"
  |> IO.puts
#+END_SRC

Note 'hello' is not a string it's a Character list
#+BEGIN_SRC elixir
is_list 'hello' # true
#+END_SRC

*** Binary list
=<<1, 2, 3>>=
- Every element is 1 byte long.
- Concatenating two binary list
=<<1, 2, 3>> <> <<4>>=
Binaries can be tagged with a size atribute
=<<1::size(16)>>= # 16 bits (2 bytes)

=<<65>> <> <<" Farhad">>= # "A Farhad"
#+BEGIN_SRC elixir
<<104, 101, 108, 108, 111>> == "hello" # true
#+END_SRC

*** Anonymous functions
#+BEGIN_SRC elixir
iex> add = fn a, b -> a + b end # same as &(&1 + &2)
#Function<12.71889879/2 in :erl_eval.expr/5>
iex> add.(1, 2)
3
#+END_SRC
To call an anonymous function we use . notation like =add.(1, 2)=

*** (/Linked/) Lists
Elixir lists are immutable head/tail pairs.
Elixir uses square brackets to specify a list of values. Values can be of any type:
#+BEGIN_SRC elixir
  mylist = [1, 2, true, 3]
   length mylist # 4
  [1, 2, 3] ++ [4, 5, 6] # [1, 2, 3, 4, 5, 6]
  # also there's a --
#+END_SRC
Appending to the end of a list is a slow operation because it needs to
copy the whole list. Think to twice before doin' so.

The head is the first element of a list and the tail is the remainder of the list.
#+BEGIN_SRC elixir
list = [1, 2, 3]
hd(list) # 1
tl(list) # [2, 3]
[1 | [2]] === [1, 2] # true
[1 | [2 | [3]]] === [1, 2, 3] # true
#+END_SRC

*** Tuples
Elixir uses curly brackets to define
tuples. Like lists, tuples can hold any value: Tuples store elements
contiguously in memory. This means accessing a tuple element by index
or getting the tuple size is a fast operation. Indexes start from zero.
#+BEGIN_SRC elixir
  t = {:ok, "Hi", 5}
  elem(t, 1) # :Hi
  tuple_size(t) # 3
  put_elem(t, 1, "hello") # returns a new tuple. original tuple hasn't changed (It's immutable)
#+END_SRC

** Lists or tuples?
Lists are stored in memory as linked lists, meaning that each element
in a list holds its value and points to the following element until
the end of the list is reached. We call each pair of value and pointer
a cons cell:
#+BEGIN_SRC elixir
list = [1 | [2 | [3 | []]]] # [1, 2, 3]
[0, | list ] # prepending element
#+END_SRC
This means accessing the length of a list is a linear operation: we
need to traverse the whole list in order to figure out its
size. Updating a list is fast as long as we are prepending elements:

Tuples, on the other hand, are stored contiguously in memory. This
means getting the tuple size or accessing an element by index is
fast. However, updating or adding elements to tuples is expensive
because it requires copying the whole tuple in memory.
|----------------+-------------------+-------------------|
|                | List              | Tuple             |
|----------------+-------------------+-------------------|
| Structure      | Linked list       | Contiguous memory |
| Insertion      | Fast (prepending) | Expensive         |
| Size           | Slow              | Fast              |
| Fetch by index | Slow              | Fast              |
| Fetch first    | Fast              | Fast              |

** Pattern Matching
=a = 8=
bind variable a to number 8
=8 = a=

is a valid expression since 8 matches a

if on the left hand side of = operator is variable it'll bind to the
right hand side but if it's a value, pattern matching happens. If you
want to do pattern matching with a variable you can use pin (^)
operator
=^a = 8= doesn't bind variable to 8 but it does pattern matching

Pattern Matching in maps is very useful.
#+BEGIN_SRC elixir
%{name: name} = %{name: "Farhad", age: 25}
name # "farhad"
#+END_SRC

** Keyword lists
It's a high level type (under the hood they are just lists).
In many functional programming languages, it is common to use a list
of 2-item tuples as the representation of a key-value data
structure. In Elixir, when we have a list of tuples and the first item
of the tuple (i.e. the key) is an atom, we call it a keyword list:

#+BEGIN_SRC elixir
  me = [{:name, "Farhad"}, {:status, "Awesome"}] # a list with two tuples(each one a 2-itme tuple) inside it
  [name: "Farhad", status: "Awesome"] === me # true

  Keyword.get me, :name #"Farhad"
  me[:status] # "Awesome"

#+END_SRC

- Keys must be atoms.
- Keys are ordered, as specified by the developer.
- Keys can be given more than once.

#+BEGIN_SRC elixir
cook = fn(heat, foods) -> Keyword.values(foods) |> Enum.map(&(heat <> &1)) end
cook.("Fried ", [meat: "sausage", veg: "beans"]) # ["Fried sausage", "Fried beans"]
#+END_SRC

** Maps
Whenever you need a key-value store, maps are the “go to” data
structure in Elixir.

- Maps allow any value as a key.
- Maps’ keys do not follow any ordering.
- Duplicate values will be overrided
#+BEGIN_SRC elixir
  foo = %{:name => "Farhad", :username => "fhdhsni", :name => "notFarhad"}

  Map.get(foo, :name)             # notFarhad
  foo[:username]                  # fhdhsni
  foo.name                        # only if keys are atoms
#+END_SRC

Keyword syntax is allowed as long as all of the keys are atoms
#+BEGIN_SRC elixir
%{a: 1, b: 2} === %{:a => 1, :b => 2} # true
 #+END_SRC

Maps have the following syntax for updating a key’s value.
Note: *new keys cannot be added*
#+BEGIN_SRC elixir
  me = %{:name => "Farhad", :age => 25}
  notMe = %{me | :name => "someone else"} # Adding new keys are not allowed
#+END_SRC

*** struct
Structs are extensions built on top of maps that provide compile-time
checks and default values.
#+BEGIN_SRC elixir
iex> defmodule User do
...>   defstruct name: "John", age: 27
...> end
#+END_SRC

The keyword list used with defstruct defines what fields the struct
will have along with their *default* values.
#+BEGIN_SRC elixir
iex> %User{}
%User{age: 27, name: "John"}
iex> %User{name: "Meg"}
%User{age: 27, name: "Meg"}

#+END_SRC
Structs provide compile-time guarantees that only the fields (and all
of them) defined through defstruct will be allowed to exist in a
struct:
#+BEGIN_SRC elixir
iex> %User{oops: :field}
 (KeyError) key :oops not found in: %User{age: 27, name: "John"}
#+END_SRC

As being said earlier sturcts are just maps

#+BEGIN_SRC elixir
%User{} == %{__struct__: User, age: 27, name: "John"} # true
#+END_SRC 

*** Range
Range struct
#+BEGIN_SRC elixir
  0..100 == %Range{first: 0, last: 100} # true
  0..100 == %{__struct__: Range, first: 0, last: 100} # true
#+END_SRC
*** Regular Expressions
%Regex{
  opts: "",
  source: "hello"
}
#+BEGIN_SRC elixir
is_map ~r/hello/ # true
#+END_SRC
** Functions, Guard clauses and Modules
Function declarations support guards and multiple clauses. If a
function has several clauses, Elixir will try each clause until it
finds one that matches.  Using guard clauses:
#+BEGIN_SRC elixir
  defmodule Example do
    def hello(name) when name === "Farhad" do
      IO.puts "Fuck off"
    end
    def hello(name) when is_bitstring name do
      IO.puts "Hi #{name}, Happy to see you"
    end
    def hello(_) do
      IO.puts "No idea what you doin'"
    end
  end

  Example.hello "Esi"             # Hi Esi, Happy to see you
  Example.hello "Farhad"          # Fuck off
  Example.hello 25                # No idea what you doin'
#+END_SRC
mulitple clause
#+BEGIN_SRC elixir
defmodule Math do
  def zero?(0) do
    true
  end

  def zero?(x) when is_integer(x) do
    false
  end
end

IO.puts Math.zero?(0)         #=> true
IO.puts Math.zero?(1)         #=> false
IO.puts Math.zero?([1, 2, 3]) #=> ** (FunctionClauseError)
IO.puts Math.zero?(0.0)       #=> ** (FunctionClauseError)
#+END_SRC
Using =do:= syntax
#+BEGIN_SRC elixir
defmodule Math do
  def zero?(0), do: true
  def zero?(x) when is_integer(x), do: false
end
#+END_SRC

*** Function Capturing
#+BEGIN_SRC elixir
Math.zero?(0) # true
fun = &Math.zero?/1
is_function(fun) # true
fun.(0) # true
#+END_SRC

Using capture syntax for creating functions 

#+BEGIN_SRC elixir
  fun = &(&1 + &2)                # same as: fn x, y -> x + y end
  fun.(2, 9) # 11
#+END_SRC

Capturing a function from modules
#+BEGIN_SRC elixir
fun = &List.flatten(&1, &2) # &List.flatten/2
fun.([1, [[2], 3]], [4, 5]) # [1, 2, 3, 4, 5]
#+END_SRC

If a function with default values has multiple clauses, it is required
to create a function head (without an actual body) for declaring
defaults:

#+BEGIN_SRC elixir
defmodule Concat do
  def join(a, b \\ nil, sep \\ " ")

  def join(a, b, _sep) when is_nil(b) do
    a
  end

  def join(a, b, sep) do
    a <> sep <> b
  end
end

IO.puts Concat.join("Hello", "world")      #=> Hello world
IO.puts Concat.join("Hello", "world", "_") #=> Hello_world
IO.puts Concat.join("Hello")               #=> Hello
#+END_SRC
*** overlapping function definitions
When using default values, one must be careful to avoid overlapping
function definitions. Consider the following example:

#+BEGIN_SRC elixir
defmodule Concat do
  def join(a, b) do
    IO.puts "***First join"
    a <> b
  end

  def join(a, b, sep \\ " ") do
    IO.puts "***Second join"
    a <> sep <> b
  end
end

Concat.join "hello", " world" # will run first clause
Concat.join "hello", "world", "_" # will run second clause
#+END_SRC
 invoking the =join= function with two arguments will always choose
 the first definition of =join= whereas the second one will only be
 invoked when three arguments are passed. thus providing a default
 value for =sep= in second clause is unnecessary and has no effect.
*** Recursive function
#+BEGIN_SRC elixir
defmodule Graph do
  def count(%{children: []}), do: 1
  
  def count(%{children: children}) do
    [first | rest] = children
    count(first) + count(%{children: rest})
  end

end


graph = %{
  children: [
    %{children: []},
    %{children: []},
    %{children: [
         %{children: []},
         %{children: []}
       ]
    },
    %{children: []}
  ]
}

Graph.count(graph)
#+END_SRC

** Miscellaneous
*** =if= 
    if statement is just a macro that takes =true= or =false= as it's
    first argument and a keyword list as it's second argument. use =case= or =cond= instead
#+BEGIN_SRC elixir
  if true, do: :this, else :that     # 
  # it's actually a macro
  if(true, [do: :this, else: :that]) # :this
  if(false, [do: :this, else: :that]) # :that
#+END_SRC

*** =alias=
Referencing a module by a different name
#+BEGIN_SRC elixir
defmodule AnotherModule do
  def add(a, b), do: a + b
end

defmodule Foo do
  alias AnotherModule, as: M

  def fun, do: M.add 2, 5
end
#+END_SRC

*** =import=

**** Importing the whole module 
#+BEGIN_SRC elixir
defmodule AnotherModule do
  def add(a, b), do: a + b
end

defmodule Foo do
  import AnotherModule

  def fun, do: add 2, 10
end

Foo.fun # 12
#+END_SRC

**** Importing the only the specified function from a module 
 #+BEGIN_SRC elixir
 defmodule AnotherModule do
  def add(a, b), do: a + b
  def add(a, b, c), do: a + b + c
end

defmodule Foo do
  import AnotherModule, only: [add: 2]

  def fun, do: add 2, 10, 2
end

Foo.fun # %CompileError{description: "undefined function add/3", file: "nofile", line: 9}
 #+END_SRC
 Above snippet raise an error because we only imported to =add/2=
 function. the number keyword list is the arity of the given function

*** =cond=
Remember =cond= has now falling through like a switch case does in other languages
#+BEGIN_SRC elixir
  cond do
    expression -> body
    expression -> body
    ...
  end
#+END_SRC
#+BEGIN_SRC elixir
defmodule Fun do
  def foo(%{age: age}) do
    cond do
      age > 50 -> "You gonna die, pretty soon actully"
      age > 30 -> "Enjoy misery"
      true     -> "Hmm"
    end
  end
end

Fun.foo(%{name: "Farhad", age: 51}) # "You gonna die, pretty soon actully"
#+END_SRC

*** =case=
When a *pattern* matches the value of the *expression*, the body is executed
#+BEGIN_SRC elixir
  case expression do
    pattern -> body
    pattern -> body
    ...
  end
#+END_SRC
#+BEGIN_SRC elixir
  defmodule Fun do
    def foo(%{age: age}) do
      case age do
        :old           -> "You gonna die, pretty soon actully"
        :not_That_Old  -> "Enjoy misery"
        _              -> "Hmm" #note the use of underscore in lieu of true like in =cond=
      end
    end
  end

  Fun.foo(%{name: "Farhad", age: :something}) # Hmm
#+END_SRC
*** =with=
#+BEGIN_SRC elixir
 with
  pattern <- expression
  pattern <- expression
  ...
do
  body
end
#+END_SRC

#+BEGIN_SRC elixir
opts = %{:width => 10, :height => 15}
with {:ok, width} <- Map.fetch(opts, :width),
     {:ok, height} <- Map.fetch(opts, :height),
  do: {:ok, width * height}
#+END_SRC
*** =try do ... rescue ... after ... end=
Use try rescue as last resort.
After is optional.
#+BEGIN_SRC elixir
defmodule M do
  def say_hi(name) do
    try do
      "Hey #{String.upcase name}!!!"
  rescue
    _e -> raise "Fuck off" 
    end
  end
end
M.say_hi 3
#+END_SRC
*** =raise=
#+BEGIN_SRC elixir
raise "an exception"
#+END_SRC
*** =throw/catch=
*** 
