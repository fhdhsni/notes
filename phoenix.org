- Notes from Phoenix documentation

* Endpoint
- the start and end of the request lifecycle
- handles all aspects of requests up until the point where the router
  takes over
- provides a core set of plugs to apply to all requests
- dispatches requests into a designated router

- Phoenix applications start the ~HelloWeb.Endpoint~ as a supervised
  process. By default, the Endpoint is added to the supervision tree
  in ~lib/hello/application.ex~ as a supervised process. Each request
  begins and ends its lifecycle inside your application in an
  endpoint. The endpoint handles starting the web server and
  transforming requests through several defined plugs before calling
  the ~Router~.
- Endpoints gather together common functionality and serve as entrance
  and exit for all of the HTTP requests to your application. The
  endpoint holds plugs that are common to all requests coming into
  your application.

- Faults in the different parts of the supervision tree, such as the
  Ecto Repo, will not immediately impact the main application. The
  supervisor is therefore able to restart those processes separately
  after unexpected faults. It is also possible for an application to
  have multiple endpoints, each with its own supervision tree.
- There are many functions defined in the endpoint module, read the
  [[https://hexdocs.pm/phoenix/Phoenix.Endpoint.html][Endpoint doc]]
**  Using SSL
- To prepare an application to serve requests over SSL, we need to add
  a little bit of configuration and two environment variables. In
  order for SSL to actually work, we’ll need a key file and
  certificate file from a certificate authority. The environment
  variables that we’ll need are paths to those two files.
- If we add the ~otp_app:~ key whose value is the name of our
  application, Plug will begin to look for them at the root of our
  application. We can then put those files in our ~priv~ directory and
  set the paths to ~priv/our_keyfile.key~ and ~priv/our_cert.crt~.
  Here’s an example configuration from ~config/prod.exs~.
  #+BEGIN_SRC elixir
    use Mix.Config

    config :hello, HelloWeb.Endpoint,
      http: [port: {:system, "PORT"}],
      url: [host: "example.com"],
      cache_static_manifest: "priv/static/cache_manifest.json",
      https: [
        port: 443,
        otp_app: :hello,
        keyfile: System.get_env("SOME_APP_SSL_KEY_PATH"),
        certfile: System.get_env("SOME_APP_SSL_CERT_PATH"),
        # OPTIONAL Key for intermediate certificates:
        cacertfile: System.get_env("INTERMEDIATE_CERTFILE_PATH")
      ]
  #+END_SRC
  Without the ~otp_app:~ key, we need to provide absolute paths to the
  files wherever they are on the filesystem in order for Plug to find
  them.
  #+BEGIN_SRC
  Path.expand("../../../some/path/to/ssl/key.pem", __DIR__)
  #+END_SRC
- [[*~mix phx.*~][SSL in development]]
- Force SSL
  + This can be accomplished by setting the ~:force_ssl~ option in your
    endpoint configuration. It expects a list of options which are
    forwarded to ~Plug.SSL~. By default it sets the
    “strict-transport-security” header in HTTPS requests, forcing
    browsers to always use HTTPS. If an unsafe (HTTP) request is sent,
    it redirects to the HTTPS version using the ~:host~ specified in the
    ~:url~ configuration. For example:
    #+BEGIN_SRC elixir
      config :my_app, MyApp.Endpoint,
        force_ssl: [rewrite_on: [:x_forwarded_proto]]
    #+END_SRC
    + To dynamically redirect to the host of the current request, set
      ~:host~ in the ~:force_ssl~ configuration to ~nil~.
      #+BEGIN_SRC elixir
        config :my_app, MyApp.Endpoint,
          force_ssl: [rewrite_on: [:x_forwarded_proto], host: nil]
      #+END_SRC
- [[https://hexdocs.pm/phoenix/endpoint.html#hsts][HSTS]] or “http strict-transport-security” is a mechanism that allows a
  website to declare itself as only accessible via a secure connection
  (HTTPS). But it does have other consequenses. RFC6797 which defines
  HSTS also specifies that the browser should keep track of the policy
  of a host and apply it until it expires. It also specifies that
  traffic on any port other than 80 is assumed to be encrypted as per
  the policy.

* Router
- parses incoming requests and dispatches them to the correct
  controller/action, passing parameters as needed
- provides helpers to generate route paths or urls to resources
- defines named pipelines through which we may pass our requests
- Pipelines - allow easy application of groups of plugs to a set of
  routes
- ~resources "/users", UserController~ expands out to eight clauses of
  the ~match/5~ function.
  #+BEGIN_SRC elixir
    user_path  GET     /users           HelloWeb.UserController :index
    user_path  GET     /users/:id/edit  HelloWeb.UserController :edit
    user_path  GET     /users/new       HelloWeb.UserController :new
    user_path  GET     /users/:id       HelloWeb.UserController :show
    user_path  POST    /users           HelloWeb.UserController :create
    user_path  PATCH   /users/:id       HelloWeb.UserController :update
               PUT     /users/:id       HelloWeb.UserController :update
    user_path  DELETE  /users/:id       HelloWeb.UserController :delete
  #+END_SRC
  if you don't all of 'em
  #+BEGIN_SRC
  resources "/posts", PostController, only: [:index, :show]
  #+END_SRC
  or exclude some of 'em
  #+BEGIN_SRC
  resources "/comments", CommentController, except: [:delete]
  #+END_SRC
** Forward
- The ~Phoenix.Router.forward/4~ macro can be used to send all requests
  that start with a particular path to a particular plug.

  #+BEGIN_SRC elixir
    defmodule HelloWeb.Router do
      use HelloWeb, :router
      ...
      scope "/" do
        pipe_through [:authenticate_user, :ensure_admin]
        forward "/jobs", BackgroundJob.Plug # <<----
      end
    end
  #+END_SRC

  #+BEGIN_SRC elixir
    defmodule BackgroundJob.Plug do
      def init(opts), do: opts

      def call(conn, opts) do
        conn
        |> Plug.Conn.assign(:name, Keyword.get(opts, :name, "Background Job"))
        |> BackgroundJob.Router.call(opts)
      end
    end

    defmodule BackgroundJob.Router do
      use Plug.Router

      plug(:match)
      plug(:dispatch)

      get("/", do: send_resp(conn, 200, "Welcome to #{conn.assigns.name}"))
      get("/active", do: send_resp(conn, 200, "5 Active Jobs"))
      get("/pending", do: send_resp(conn, 200, "3 Pending Jobs"))
      match(_, do: send_resp(conn, 404, "Not found"))
    end
  #+END_SRC

** Path Helpers
- Path helpers are functions which are dynamically defined on the
  ~Router.Helpers~ module for an individual application. For us, that is
  ~HelloWeb.Router.Helpers~. Their names are derived from the name of
  the controller used in the route definition. Our controller is
  ~HelloWeb.PageController~, and ~page_path~ is the function which will
  return the path to the root of our application.

  router.ex
  #+BEGIN_SRC elixir
      scope "/", HelloWeb do
        pipe_through(:browser)

        get("/", PageController, :index)
        get("/hello", HelloController, :index)
        get("/hello/:messenger", HelloController, :show)
      end
  #+END_SRC

  ~iex -S mix~
  #+BEGIN_SRC text
    iex> HelloWeb.Router.Helpers.page_path(HelloWeb.Endpoint, :index)
    "/"

    iex> HelloWeb.Router.Helpers.hello_path(HelloWeb.Endpoint, :index)
    "/hello"


    iex> HelloWeb.Router.Helpers.hello_path(HelloWeb.Endpoint, :show, :farhad)
    "/hello/farhad"

    iex> HelloWeb.Router.Helpers.hello_url(HelloWeb.Endpoint, :show, :farhad)
    "http://localhost:4000/hello/farhad"

    iex(7)> HelloWeb.Router.Helpers.hello_url(HelloWeb.Endpoint, :show, :farhad, hey: :yo)
    "http://localhost:4000/hello/farhad?hey=yo"
  #+END_SRC
** Nested Resources
- Let’s say we also have a ~posts~ resource which has a many-to-one
  relationship with ~users~
  #+BEGIN_SRC elixir
    resources "/users", UserController do
      resources "/posts", PostController
    end
  #+END_SRC

  ~mix phx.routes~
  #+BEGIN_SRC elixir
    user_path  GET     /users                          HelloWeb.UserController :index
    user_path  GET     /users/:id/edit                 HelloWeb.UserController :edit
    user_path  GET     /users/new                      HelloWeb.UserController :new
    user_path  GET     /users/:id                      HelloWeb.UserController :show
    user_path  POST    /users                          HelloWeb.UserController :create
    user_path  PATCH   /users/:id                      HelloWeb.UserController :update
               PUT     /users/:id                      HelloWeb.UserController :update
    user_path  DELETE  /users/:id                      HelloWeb.UserController :delete
    user_post_path  GET     /users/:user_id/posts           HelloWeb.PostController :index
    user_post_path  GET     /users/:user_id/posts/:id/edit  HelloWeb.PostController :edit
    user_post_path  GET     /users/:user_id/posts/new       HelloWeb.PostController :new
    user_post_path  GET     /users/:user_id/posts/:id       HelloWeb.PostController :show
    user_post_path  POST    /users/:user_id/posts           HelloWeb.PostController :create
    user_post_path  PATCH   /users/:user_id/posts/:id       HelloWeb.PostController :update
                    PUT     /users/:user_id/posts/:id       HelloWeb.PostController :update
    user_post_path  DELETE  /users/:user_id/posts/:id       HelloWeb.PostController :delete
  #+END_SRC
** Scoped Routes
- Scopes are a way to group routes under a common path prefix and
  scoped set of plug middleware.
- Let’s say we have user generated reviews on a site, and that those
  reviews first need to be approved by an admin. The semantics of
  these resources are quite different, and they might not share the
  same controller. Scopes enable us to segregate these routes.
  #+BEGIN_SRC elixir
    scope "/", HelloWeb do
      pipe_through :browser
      ...
      resources "/reviews", ReviewController
      ...
    end

    scope "/admin", as: :admin do # <-- as: admin to fix path helpers, generates admin_review_path
      resources "/reviews", HelloWeb.Admin.ReviewController
    end
  #+END_SRC
  ~mix phx.routes~
  #+BEGIN_SRC text
    ...
    review_path  GET     /reviews                        HelloWeb.ReviewController :index
    review_path  GET     /reviews/:id/edit               HelloWeb.ReviewController :edit
    review_path  GET     /reviews/new                    HelloWeb.ReviewController :new
    review_path  GET     /reviews/:id                    HelloWeb.ReviewController :show
    review_path  POST    /reviews                        HelloWeb.ReviewController :create
    review_path  PATCH   /reviews/:id                    HelloWeb.ReviewController :update
                 PUT     /reviews/:id                    HelloWeb.ReviewController :update
    review_path  DELETE  /reviews/:id                    HelloWeb.ReviewController :delete

    ...
    admin_review_path  GET     /admin/reviews                  HelloWeb.Admin.ReviewController :index
    admin_review_path  GET     /admin/reviews/:id/edit         HelloWeb.Admin.ReviewController :edit
    admin_review_path  GET     /admin/reviews/new              HelloWeb.Admin.ReviewController :new
    admin_review_path  GET     /admin/reviews/:id              HelloWeb.Admin.ReviewController :show
    admin_review_path  POST    /admin/reviews                  HelloWeb.Admin.ReviewController :create
    admin_review_path  PATCH   /admin/reviews/:id              HelloWeb.Admin.ReviewController :update
                       PUT     /admin/reviews/:id              HelloWeb.Admin.ReviewController :update
    admin_review_path  DELETE  /admin/reviews/:id              HelloWeb.Admin.ReviewController :delete
  #+END_SRC
- the use of nested scopes is generally discouraged because it can
  sometimes make our code confusing and less clear. That being said,
  suppose that we had a versioned API:
  #+BEGIN_SRC elixir
    scope "/api", HelloWeb.Api, as: :api do
      pipe_through :api

      scope "/v1", V1, as: :v1 do
        resources "/images",  ImageController
        resources "/reviews", ReviewController
        resources "/users",   UserController
      end
    end
  #+END_SRC
  ~mix phx.routes~ gives up
  #+BEGIN_SRC elixir
     api_v1_image_path  GET     /api/v1/images            HelloWeb.Api.V1.ImageController :index
     api_v1_image_path  GET     /api/v1/images/:id/edit   HelloWeb.Api.V1.ImageController :edit
     api_v1_image_path  GET     /api/v1/images/new        HelloWeb.Api.V1.ImageController :new
     api_v1_image_path  GET     /api/v1/images/:id        HelloWeb.Api.V1.ImageController :show
     api_v1_image_path  POST    /api/v1/images            HelloWeb.Api.V1.ImageController :create
     api_v1_image_path  PATCH   /api/v1/images/:id        HelloWeb.Api.V1.ImageController :update
                        PUT     /api/v1/images/:id        HelloWeb.Api.V1.ImageController :update
     api_v1_image_path  DELETE  /api/v1/images/:id        HelloWeb.Api.V1.ImageController :delete
    api_v1_review_path  GET     /api/v1/reviews           HelloWeb.Api.V1.ReviewController :index
    api_v1_review_path  GET     /api/v1/reviews/:id/edit  HelloWeb.Api.V1.ReviewController :edit
    api_v1_review_path  GET     /api/v1/reviews/new       HelloWeb.Api.V1.ReviewController :new
    api_v1_review_path  GET     /api/v1/reviews/:id       HelloWeb.Api.V1.ReviewController :show
    api_v1_review_path  POST    /api/v1/reviews           HelloWeb.Api.V1.ReviewController :create
    api_v1_review_path  PATCH   /api/v1/reviews/:id       HelloWeb.Api.V1.ReviewController :update
                        PUT     /api/v1/reviews/:id       HelloWeb.Api.V1.ReviewController :update
    api_v1_review_path  DELETE  /api/v1/reviews/:id       HelloWeb.Api.V1.ReviewController :delete
      api_v1_user_path  GET     /api/v1/users             HelloWeb.Api.V1.UserController :index
      api_v1_user_path  GET     /api/v1/users/:id/edit    HelloWeb.Api.V1.UserController :edit
      api_v1_user_path  GET     /api/v1/users/new         HelloWeb.Api.V1.UserController :new
      api_v1_user_path  GET     /api/v1/users/:id         HelloWeb.Api.V1.UserController :show
      api_v1_user_path  POST    /api/v1/users             HelloWeb.Api.V1.UserController :create
      api_v1_user_path  PATCH   /api/v1/users/:id         HelloWeb.Api.V1.UserController :update
                        PUT     /api/v1/users/:id         HelloWeb.Api.V1.UserController :update
      api_v1_user_path  DELETE  /api/v1/users/:id         HelloWeb.Api.V1.UserController :delete
  #+END_SRC
** Pipelines
- Pipelines are simply plugs stacked up together in a specific order
  and given a name. They allow us to customize behaviors and
  transformations related to the handling of requests. Phoenix
  provides us with some default pipelines for a number of common
  tasks. In turn we can customize them as well as create new pipelines
  to meet our needs.
*** The Endpoint Plugs
- Endpoints organize all the plugs common to every request, and apply
  them before dispatching into the router(s) with their underlying
  ~:browser~, ~:api~, and custom pipelines. The default Endpoint plugs do
  quite a lot of work. Here they are in order.
- ~Plug.Static~ - serves static assets. Since this plug comes before the
  logger, serving of static assets is not logged
- ~Phoenix.CodeReloader~ - a plug that enables code reloading for all
  entries in the web directory. It is configured directly in the
  Phoenix application
- ~Plug.RequestId~ - generates a unique request id for each request.
- ~Plug.Logger~ - logs incoming requests
- ~Plug.Parsers~ - parses the request body when a known parser is
  available. By default parsers parse urlencoded, multipart and json
  (with jason). The request body is left untouched when the request
  content-type cannot be parsed
- ~Plug.MethodOverride~ - converts the request method to PUT, PATCH or
  DELETE for POST requests with a valid _method parameter
- ~Plug.Head~ - converts HEAD requests to GET requests and strips the
  response body
- ~Plug.Session~ - a plug that sets up session management. Note that
  fetch_session/2 must still be explicitly called before using the
  session as this plug just sets up how the session is fetched
- ~Plug.Router~ - plugs a router into the request cycle

*** The ~:browser~ and ~:api~ Pipelines
- Phoenix defines two other pipelines by default, ~:browser~ and
  ~:api~. The router will invoke these after it matches a route,
  assuming we have called~ pipe_through/1~ with them in the enclosing
  scope.
- The router invokes a pipeline on a route defined within a scope. If
  no scope is defined, the router will invoke the pipeline on all the
  routes in the router.
- If we know that our application only renders views for the browser,
  we can simplify our router quite a bit by removing the ~api~ stuff as
  well as the scopes:
  #+BEGIN_SRC elixir
    defmodule HelloWeb.Router do
      use HelloWeb, :router

      pipeline :browser do
        plug :accepts, ["html"]
        plug :fetch_session
        plug :fetch_flash
        plug :protect_from_forgery
        plug :put_secure_browser_headers
      end

      pipe_through :browser

      get "/", HelloWeb.PageController, :index

      resources "/reviews", HelloWeb.ReviewController
    end
  #+END_SRC
  Removing all scopes forces the router to invoke the ~:browser~
  pipeline on all routes.

*** Creating New Pipelines
- Phoenix allows us to create our own custom pipelines anywhere in the
  router. To do so, we call the ~pipeline/2~ macro with these arguments:
  an atom for the name of our new pipeline and a block with all the
  plugs we want in it.
  #+BEGIN_SRC elixir
    defmodule HelloWeb.Router do
      use HelloWeb, :router

      pipeline :browser do
        plug :accepts, ["html"]
        plug :fetch_session
        plug :fetch_flash
        plug :protect_from_forgery
        plug :put_secure_browser_headers
      end

      pipeline :review_checks do
        plug :ensure_authenticated_user
        plug :ensure_user_owns_review
      end

      scope "/reviews", HelloWeb do
        pipe_through :review_checks

        resources "/", ReviewController
      end
    end
  #+END_SRC

*** Channel Routes
- Channels handle incoming and outgoing messages broadcast over a
  socket for a given topic. Channel routes, then, need to match
  requests by socket and topic in order to dispatch to the correct
  channel.

  lib/hello_web/endpoint.ex
  #+BEGIN_SRC elixir
    defmodule HelloWeb.Endpoint do
      use Phoenix.Endpoint, otp_app: :hello

      socket "/socket", HelloWeb.UserSocket,
        websocket: true,
        longpoll: false
      ...
    end
  #+END_SRC
  Next, we need to open our ~lib/hello_web/channels/user_socket.ex~
  file and use the ~channel/3~ macro to define our channel routes.
  The routes will match a topic pattern to a channel to handle
  events. If we have a channel module called ~RoomChannel~ and a topic
  called ~"rooms:*"~
  #+BEGIN_SRC elixir
    defmodule HelloWeb.UserSocket do
      use Phoenix.Socket

      channel "rooms:*", HelloWeb.RoomChannel
      ...
    end
  #+END_SRC
  Each socket can handle requests for multiple channels.
  #+BEGIN_SRC elixir
  channel "rooms:*", HelloWeb.RoomChannel
  channel "foods:*", HelloWeb.FoodChannel
  #+END_SRC
  We can mount multiple socket handlers in our endpoint:
  #+BEGIN_SRC elixir
  socket "/socket", HelloWeb.UserSocket
  socket "/admin-socket", HelloWeb.AdminSocket
  #+END_SRC

* Controllers
- provide functions, called /actions/, to handle requests
- actions:
  + prepare data and pass it into views
  + invoke rendering via views
  + perform redirects
- Phoenix controllers act as intermediary modules. Their functions -
  called actions - are invoked from the router in response to HTTP
  requests. The actions, in turn, gather all the necessary data and
  perform all the necessary steps before invoking the view layer to
  render a template or returning a JSON response.
** Actions
- some convention to follow for our actions
  + ~index~ - renders a list of all items of the given resource type
  + ~show~ - renders an individual item by id
  + ~new~ - renders a form for creating a new item
  + ~create~ - receives params for one new item and saves it in a datastore
  + ~edit~ - retrieves an individual item by id and displays it in a form for editing
  + ~update~ - receives params for one edited item and saves it to a datastore
  + ~delete~ - receives an id for an item to be deleted and deletes it from a datastore
- Each action takes two parameters, which will be provided by Phoenix
  behind the scenes.
  + The first parameter is always ~conn~, a struct which holds
    information about the request such as the host, path elements,
    port, query string, and much more. conn, comes to Phoenix via
    Elixir’s Plug middleware framework. [[https://hexdocs.pm/plug/Plug.Conn.html][Plug’s documentation]]
  + The second parameter is ~params~. Not surprisingly, this is a map
    which holds any parameters passed along in the HTTP request.
** Flash Messages
- The ~Phoenix.Controller~ module provides the ~put_flash/3~ and
  ~get_flash/2~ functions to help us set and retrieve flash messages
  as a key value pair. (There's also a ~clear_flash/1~)
  #+BEGIN_SRC elixir
    defmodule HelloWeb.PageController do
      ...
      def index(conn, _params) do
        conn
        |> put_flash(:info, "Welcome to Phoenix, from flash info!")
        |> put_flash(:error, "Let's pretend we have an error.")
        |> render("index.html")
      end
    end
  #+END_SRC
** Rendering
- ~text/2~
- ~json/2~
- ~html/2~
- ~render/3~
  + ~render/3~ is defined in the ~Phoenix.View~ module instead of
    ~Phoenix.Controller~, but it is aliased in ~Phoenix.Controller~ for
    convenience.
    #+BEGIN_SRC elixir
      defmodule HelloWeb.HelloController do
        use HelloWeb, :controller

        def show(conn, %{"messenger" => messenger}) do
          render(conn, "show.html", messenger: messenger)
        end

        # same as above
        # def show(conn, %{"messenger" => messenger}) do
        #   conn
        #   |> assign(:messenger, messenger)   # Plug.Conn.assign/3
        #   |> render("show.html")
        # end
      end
    #+END_SRC
    In order for the ~render/3~ function to work correctly, the
    controller must have the same root name as the individual
    view. The individual view must also have the same root name as the
    template directory where the ~show.html.eex~ template lives. In
    other words, the ~HelloController~ requires ~HelloView~, and ~HelloView~
    requires the existence of the ~lib/hello_web/templates/hello~
    directory, which must contain the ~show.html.eex~ template.
    #+BEGIN_SRC
      lib
      ├── hello/
      ├── hello.ex
      ├── hello_web
      │  ├── channels/
      │  ├── controllers
      │  │  ├── hello_controller.ex # <-- controller
      │  │  └── page_controller.ex
      │  ├── endpoint.ex
      │  ├── gettext.ex
      │  ├── router.ex
      │  ├── templates
      │  │  ├── hello                # <-- directory
      │  │  │  ├── index.html.eex
      │  │  │  └── show.html.eex    # <-- template
      │  │  ├── layout
      │  │  │  └── app.html.eex
      │  │  └── page/
      │  └── views
      │     ├── error_helpers.ex
      │     ├── error_view.ex
      │     ├── hello_view.ex         # <-- view
      │     ├── layout_view.ex
      │     └── page_view.ex
      └── hello_web.ex
    #+END_SRC
  + Providing defaults: we can use plugs and transform
    ~conn~ on its way towards the controller action.
    #+BEGIN_SRC elixir
      plug :assign_welcome_message, "Welcome Back"

      def index(conn, _params) do
        conn
        |> assign(:message, "Welcome Forward")
        |> render("index.html")
      end

      defp assign_welcome_message(conn, msg) do
        assign(conn, :message, msg)
      end
    #+END_SRC
  + How to apply a plug only to specific actions
    #+BEGIN_SRC elixir
      defmodule HelloWeb.PageController do
        use HelloWeb, :controller

        plug :assign_welcome_message, "Hi!" when action in [:index, :show]
      ...
    #+END_SRC
  + By default, the results of the template render will be inserted
    into a layout, which will also be rendered.
*** Sending responses directly
- send a response with a status of “201” and no body whatsoever. We
  can use ~send_resp/3~ function.
  #+BEGIN_SRC elixir
    def index(conn, _params) do
      conn
      |> send_resp(201, "")
    end
  #+END_SRC
- ~put_resp_content_type/2~
  #+BEGIN_SRC elixir
    def index(conn, _params) do
      conn
      |> put_resp_content_type("text/plain")
      |> send_resp(201, "")
    end
  #+END_SRC

*** Assigning Layouts
- Layouts are just a special subset of templates. They live in
  ~lib/hello_web/templates/layout~. Phoenix created one for us when we
  generated our app. It’s called ~app.html.eex~, and it is the layout
  into which all templates will be rendered by default.

- Since layouts are really just templates, they need a view to render
  them. This is the ~LayoutView~ module defined in
  ~lib/hello_web/views/layout_view.ex~. Since Phoenix generated this
  view for us, we won’t have to create a new one as long as we put the
  layouts we want to render inside the ~lib/hello_web/templates/layout~
  directory.
- without layout
  #+BEGIN_SRC elixir
    defmodule HelloWeb.PageController do
      use HelloWeb, :controller

      def index(conn, _params) do
        conn
        |> put_layout(false)
        |> render("index.html")
      end
    end
  #+END_SRC
- select a layout
  #+BEGIN_SRC elixir
    defmodule HelloWeb.PageController do
      use HelloWeb, :controller

      def index(conn, _params) do
        conn
        |> put_layout("admin.html")
        |> render("index.html")
      end
    end
  #+END_SRC
  #+BEGIN_SRC text
    lib
    ├── hello/
    ├── hello.ex
    ├── hello_web
    │  ├── channels/
    │  ├── controllers
    │  │  └── page_controller.ex  # <-- controller
    │  ├── endpoint.ex
    │  ├── gettext.ex
    │  ├── router.ex
    │  ├── templates
    │  │  ├── layout
    │  │  │  ├── admin.html.eex # <-- layout
    │  │  │  └── app.html.eex
    │  │  └── page
    │  │     └── index.html.eex # <-- template
    │  └── views
    │     ├── error_helpers.ex
    │     ├── error_view.ex
    │     ├── layout_view.ex    # <-- layout view
    │     └── page_view.ex      # <-- view
    └── hello_web.ex

  #+END_SRC

*** Setting the Content Type
- setting mime
  #+BEGIN_SRC elixir
  def index(conn, _params) do
    conn
    |> put_resp_content_type("text/xml")
    |> render("index.xml", content: some_xml_content)
  end
  #+END_SRC
- [[https://github.com/elixir-plug/mime/blob/master/priv/mime.types][mime.types]]

*** Setting the HTTP Status
- ~Plug.Conn~ module, imported into all controllers, has a
  ~put_status/2~ function to do this.
- ~Plug.Conn.put_status/2~ takes ~conn~ as the first parameter and as
  the second parameter either an integer or a “friendly name” used as
  an atom for the status code we want to set. The list of status code
  atom representations can be found in ~Plug.Conn.Status.code/1~
  documentation.
  #+BEGIN_SRC elixir
    def index(conn, _params) do
      conn
      |> put_status(202)            # same as put_status(:accepted)
      |> render("index.html")
    end
  #+END_SRC
  :NOTE:
   :continue - 100
   :switching_protocols - 101
   :processing - 102
   :early_hints - 103
   :ok - 200
   :created - 201
   :accepted - 202
   :non_authoritative_information - 203
   :no_content - 204
   :reset_content - 205
   :partial_content - 206
   :multi_status - 207
   :already_reported - 208
   :im_used - 226
   :multiple_choices - 300
   :moved_permanently - 301
   :found - 302
   :see_other - 303
   :not_modified - 304
   :use_proxy - 305
   :switch_proxy - 306
   :temporary_redirect - 307
   :permanent_redirect - 308
   :bad_request - 400
   :unauthorized - 401
   :payment_required - 402
   :forbidden - 403
   :not_found - 404
   :method_not_allowed - 405
   :not_acceptable - 406
   :proxy_authentication_required - 407
   :request_timeout - 408
   :conflict - 409
   :gone - 410
   :length_required - 411
   :precondition_failed - 412
   :request_entity_too_large - 413
   :request_uri_too_long - 414
   :unsupported_media_type - 415
   :requested_range_not_satisfiable - 416
   :expectation_failed - 417
   :im_a_teapot - 418
   :misdirected_request - 421
   :unprocessable_entity - 422
   :locked - 423
   :failed_dependency - 424
   :unordered_collection - 425
   :upgrade_required - 426
   :precondition_required - 428
   :too_many_requests - 429
   :request_header_fields_too_large - 431
   :unavailable_for_legal_reasons - 451
   :internal_server_error - 500
   :not_implemented - 501
   :bad_gateway - 502
   :service_unavailable - 503
   :gateway_timeout - 504
   :http_version_not_supported - 505
   :variant_also_negotiates - 506
   :insufficient_storage - 507
   :loop_detected - 508
   :not_extended - 510
   :network_authentication_required - 511
  :END:
  #+BEGIN_SRC elixir
    def index(conn, _params) do
      conn
      |> put_status(:not_found)
      |> put_view(HelloWeb.ErrorView)
      |> render("404.html")
    end
  #+END_SRC

*** Redirection
- ~redirect/2~
  #+BEGIN_SRC elixir
    def index(conn, _params) do
      redirect(conn, to: "/redirect_test")
      # or for external links: redirect(conn, external: "https://elixir-lang.org/")
    end
  #+END_SRC
- Phoenix differentiates between redirecting to a path within the
  application and redirecting to a url - either within our application
  or external to it.

*** Action Fallback
- Action Fallback allows us to centralize error handling code in plugs
  which are called when a controller action fails to return a
  ~Plug.Conn.t~. These plugs receive both the ~conn~ which was originally
  passed to the controller action along with the return value of the
  action.
- usecase
  + instead of
    #+BEGIN_SRC elixir
      defmodule HelloWeb.MyController do
        use Phoenix.Controller
        alias Hello.{Authorizer, Blog}
        alias HelloWeb.ErrorView

        def show(conn, %{"id" => id}, current_user) do
          with {:ok, post} <- Blog.fetch_post(id),
               :ok <- Authorizer.authorize(current_user, :view, post) do

            render(conn, "show.json", post: post)
          else
            {:error, :not_found} ->
              conn
              |> put_status(:not_found)
              |> put_view(ErrorView)
              |> render(:"404")
            {:error, :unauthorized} ->
              conn
              |> put_status(403)
              |> put_view(ErrorView)
              |> render(:"403")
          end
        end
      end
    #+END_SRC
    Many times - especially when implementing controllers for an API -
    error handling in the controllers like this results in a lot of
    repetition. Instead we can define a plug which knows how to handle
    these error cases.
    #+BEGIN_SRC elixir
      defmodule HelloWeb.MyFallbackController do
        use Phoenix.Controller
        alias HelloWeb.ErrorView

        def call(conn, {:error, :not_found}) do
          conn
          |> put_status(:not_found)
          |> put_view(ErrorView)
          |> render(:"404")
        end

        def call(conn, {:error, :unauthorized}) do
          conn
          |> put_status(403)
          |> put_view(ErrorView)
          |> render(:"403")
        end
      end
    #+END_SRC
    and to use is
    #+BEGIN_SRC elixir
      defmodule HelloWeb.MyController do
        use Phoenix.Controller
        alias Hello.{Authorizer, Blog}

        action_fallback HelloWeb.MyFallbackController # <-- specify action fallback

        def show(conn, %{"id" => id}, current_user) do
          with {:ok, post} <- Blog.fetch_post(id),
               :ok <- Authorizer.authorize(current_user, :view, post) do

            render(conn, "show.json", post: post)
          end
        end
      end
    #+END_SRC

*** Halting the Plug Pipeline
- Controllers are plugs…. specifically plugs which are called toward
  the end of the plug pipeline. At any step of the pipeline we might
  have cause to stop processing - typically because we’ve redirected
  or rendered a response. ~Plug.Conn.t~ has a ~:halted~ key - setting it
  to true will cause downstream plugs to be skipped. We can do that
  easily using ~Plug.Conn.halt/1~.
  #+BEGIN_SRC elixir
       ...
        case Blog.get_post(conn.params["id"]) do
          {:ok, post} ->
            assign(conn, :post, post)
          {:error, :notfound} ->
            conn
            |> send_resp(404, "Not found")
            |> halt()
        end
  #+END_SRC
- ~halt/1~ simply sets the ~:halted~ key on ~Plug.Conn.t~ to ~true~

* Views
- render templates
- act as a presentation layer
- define helper functions, available in templates, to decorate data
  for presentation

- Phoenix views have two main jobs. First and foremost, they render
  templates (this includes layouts). The core function involved in
  rendering, ~render/3~, is defined in Phoenix itself in the
  ~Phoenix.View~ module. ~Views~ also provide functions which take raw
  data and make it easier for templates to consume. Similar to
  decorators or the facade pattern

- Naming convention: The ~PageController~ requires a ~PageView~ to render
  templates in the ~lib/hello_web/templates/page/~

- change the directory Phoenix considers to be the template root:
  + Phoenix provides a ~view/0~ function in the ~HelloWeb~ module defined
    in ~lib/hello_web.ex~. The first line of ~view/0~ allows us to change
    our root directory by changing the value assigned to the ~:root~
    key.

- “templates” in Phoenix are really just function definitions on their
  view module. At compile-time, Phoenix precompiles all ~*.html.eex~
  templates and turns them into ~render/2~ function clauses on their
  respective view modules. At runtime, all templates are already
  loaded in memory. There’s no disk reads, complex file caching, or
  template engine computation involved. This is also why we are able
  to define functions in our views and they are immediately available
  inside the templates (also remember layouts are just templates) –
  the call to those functions are just local function calls.

- When we ~use HelloWeb, :view~, we get other conveniences as
  well. Since ~view/0~ aliases ~HelloWeb.Router.Helpers~ as ~Routes~ (look
  in ~lib/hello_web.ex~), we can simply call these helpers by using
  ~Routes.*_path~ in templates.
  #+BEGIN_SRC html
  <p><a href="<%= Routes.page_path(@conn, :index) %>">Link back to this page</a></p>
  #+END_SRC

  ~hello/lib/hello_web/views/page_view.ex~
  #+BEGIN_SRC elixir
    defmodule HelloWeb.PageController do
      use HelloWeb, :controller

      def index(conn, _params) do
        render(conn, "index.html")
      end
    end
  #+END_SRC

  ~hello/lib/hello_web/views/page_view.ex~
  #+BEGIN_SRC elixir
    defmodule HelloWeb.PageView do
      use HelloWeb, :view

      def render("index.html", assigns) do
        "rendering with assigns #{inspect(Map.keys(assigns))}"
      end
    end
  #+END_SRC

- The ~Phoenix.View~ module gains access to template behavior via the
  ~use Phoenix.Template~ line in its ~__using__/1~ macro
- ~Phoenix.View.render/3~

   ~lib/hello_web/views/page_view.ex~
  #+BEGIN_SRC elixir
    defmodule HelloWeb.PageView do
      use HelloWeb, :view

      def message do
        "Hello from the view!"
      end
    end
  #+END_SRC

  ~lib/hello_web/templates/page/test.html.eex~
  #+BEGIN_SRC html
  This is the message: <%= message() %>
  #+END_SRC

  ~iex -S mix~
  #+BEGIN_SRC
  iex> Phoenix.View.render(HelloWeb.PageView, "test.html", %{})
  {:safe, [["" | "This is the message: "] | "Hello from the view!"]}
  #+END_SRC

- layout
  + Layouts are just templates. They have a view, just like other
    templates.

- Rendering JSON
  + The view’s job is not only to render HTML templates. Views are
    about data presentation. Given a bag of data, the view’s purpose
    is to present that in a meaningful way given some format, be it
    HTML, JSON, CSV, or others.
  + It is possible to respond with JSON back directly from the
    controller and skip the ~View~. However, if we think about a
    controller as having the responsibilities of receiving a request
    and fetching data to be sent back, data manipulation and
    formatting don’t fall under those responsibilities.

    ~lib/hello_web/controllers/page_controller.ex~
    #+BEGIN_SRC elixir
      defmodule HelloWeb.PageController do
        use HelloWeb, :controller

        def show(conn, _params) do
          page = %{title: "foo"}

          render(conn, "show.json", page: page)
        end

        def index(conn, _params) do
          pages = [%{title: "foo"}, %{title: "bar"}]

          render(conn, "index.json", pages: pages)
        end
      end
    #+END_SRC

    ~lib/hello_web/views/page_view.ex~
    #+BEGIN_SRC elixir
      defmodule HelloWeb.PageView do
        use HelloWeb, :view

        def render("index.json", %{pages: pages}) do
          %{data: render_many(pages, HelloWeb.PageView, "page.json")}
        end

        def render("show.json", %{page: page}) do
          %{data: render_one(page, HelloWeb.PageView, "page.json")}
        end


        # in %{page: page}, the key `page` comes from the name of the View,
        # so if it was HelloWeb.ShitView, the would've been `shit`
        def render("page.json", %{page: page}) do
          %{title: page.title}
        end
      end
    #+END_SRC
    The ~render/2~ matching "~index.json~" will respond with JSON as
    you would expect:
    #+BEGIN_SRC text
      {
        "data": [
          {
           "title": "foo"
          },
          {
           "title": "bar"
          },
       ]
      }
    #+END_SRC
    And the ~render/2~ matching "~show.json~":
    #+BEGIN_SRC text
      {
        "data": {
          "title": "foo"
        }
      }
    #+END_SRC
    The name used in assigns is determined from the view. For example
    the ~PageView~ will use ~%{page: page}~ and the ~AuthorView~ will use
    ~%{author: author}~. This can be overridden with the ~as~
    option. Let’s assume that the author view uses ~%{writer: writer}~
    instead of ~%{author: author}~:
    #+BEGIN_SRC elixir
      def render("page_with_authors.json", %{page: page}) do
        %{title: page.title,
          authors: render_many(page.authors, AuthorView, "author.json", as: :writer)}
      end
    #+END_SRC

* Templates
- files containing the contents that will be served in a response
- provide the basic structure for a response, and allow dynamic data
  to be substituted in
- are precompiled and fast
- Templates are files into which we pass data to form complete HTTP
  responses. For a web application these responses would typically be
  full HTML documents. For an API, they would most often be JSON or
  possibly XML.
- templates live in the ~lib/hello_web/templates~ directory, organized
  into directories named after a view. Each directory has its own view
  module to render the templates in it.
- Phoenix generates a ~lib/hello_web.ex~ file that serves as place to
  group common imports and aliases. All declarations here within the
  view block apply to all your templates.
- Templates are just function calls, so like regular code, composing
  your greater template by small, purpose-built functions can lead to
  clearer design
- The way we pass data into a template is by the ~assigns~ map, and the
  way we get the values out of the assigns map is by referencing the
  keys with a preceding ~@~. ~@~ is actually a macro that translates ~@key~
  to ~Map.get(assigns, :key)~.
- template within template

  controller
  #+BEGIN_SRC elixir
    defmodule HelloWeb.PageController do
      use HelloWeb, :controller

      def test(conn, _params) do
        render(conn, "test.html")
      end
    end
  #+END_SRC

  view
  #+BEGIN_SRC elixir
    defmodule HelloWeb.PageView do
      use HelloWeb, :view

      def connection_keys(conn) do
        conn
        |> Map.from_struct()
        |> Map.keys()
      end
    end
  #+END_SRC

  ~key.html.eex~
  #+BEGIN_SRC
  <p><%= @key %></p>
  #+END_SRC

  ~test.html.eex~
  #+BEGIN_SRC html
    <div class="phx-hero">
      <%= for key <- connection_keys(@conn) do %>

        <!-- render a template within another template, that's how layout works -->
        <%= render("key.html", key: key) %>
        <!-- same as
        <%= render(HelloWeb.PageView, "key.html", key: key) %>
        -->
      <% end %>
    </div>
  #+END_SRC

* Channels
- manage sockets for easy realtime communication
- are analogous to controllers except that they allow bi-directional
  communication with persistent connections
- Clients connect and subscribe to one or more topics, whether
  that’s ~public_chat~ or ~updates:user1~. Any message sent on a topic,
  whether from the server or from a client, is sent to all clients
  subscribed to that topic
  #+BEGIN_SRC text
                                                                      +----------------+
                                                         +--Topic X-->| Mobile Client  |
                                                         |            +----------------+
                                  +-------------------+  |
    +----------------+            |                   |  |            +----------------+
    | Browser Client |--Topic X-->| Phoenix Server(s) |--+--Topic X-->| Desktop Client |
    +----------------+            |                   |  |            +----------------+
                                  +-------------------+  |
                                                         |            +----------------+
                                                         +--Topic X-->|   IoT Client   |
                                                                      +----------------+
  #+END_SRC
- To start communicating:
  1. a client connects to a node (a Phoenix server)
  2. joins one or more channels using that single network connection
  3. *One channel server process is created per client, per topic*
  4. The appropriate socket handler initializes a ~%Phoenix.Socket~ for
     the channel server (possibly after authenticating the client)
  5. The channel server then holds onto the ~%Phoenix.Socket{}~ and can
     maintain any state it needs within its ~socket.assigns~
  6. Once the connection is established, each incoming message from a
     client is routed, based on its topic, to the correct channel
     server. If the channel server asks to broadcast a message, that
     message is sent to the local PubSub, which sends it out to any
     clients connected to the same server and subscribed to that
     topic.
     #+BEGIN_SRC text
                                        Channel   +-------------------------+      +--------+
                                         route    | Sending Client, Topic 1 |      | Local  |
                                     +----------->|     Channel.Server      |----->| PubSub |--+
       +----------------+            |            +-------------------------+      +--------+  |
       | Sending Client |-Transport--+                                                  |      |
       +----------------+                         +-------------------------+           |      |
                                                  | Sending Client, Topic 2 |           |      |
                                                  |     Channel.Server      |           |      |
                                                  +-------------------------+           |      |
                                                                                        |      |
                                                  +-------------------------+           |      |
       +----------------+                         | Browser Client, Topic 1 |           |      |
       | Browser Client |<-------Transport--------|     Channel.Server      |<----------+      |
       +----------------+                         +-------------------------+                  |
                                                                                               |
                                                                                               |
                                                                                               |
                                                  +-------------------------+                  |
       +----------------+                         |  Phone Client, Topic 1  |                  |
       |  Phone Client  |<-------Transport--------|     Channel.Server      |<-+               |
       +----------------+                         +-------------------------+  |   +--------+  |
                                                                               |   | Remote |  |
                                                  +-------------------------+  +---| PubSub |<-+
       +----------------+                         |  Watch Client, Topic 1  |  |   +--------+  |
       |  Watch Client  |<-------Transport--------|     Channel.Server      |<-+               |
       +----------------+                         +-------------------------+                  |
                                                                                               |
                                                                                               |
                                                  +-------------------------+      +--------+  |
       +----------------+                         |   IoT Client, Topic 1   |      | Remote |  |
       |   IoT Client   |<-------Transport--------|     Channel.Server      |<-----| PubSub |<-+
       +----------------+                         +-------------------------+      +--------+
     #+END_SRC
** endpoint
- In your Phoenix app’s ~Endpoint~ module, a ~socket~ declaration
  specifies which socket handler will receive connections on a given
  URL.
  #+BEGIN_SRC elixir
    socket "/socket", HelloWeb.UserSocket,
      websocket: true,
      longpoll: false
  #+END_SRC
** Socket Handlers
- Socket handlers, such as ~HelloWeb.UserSocket~, are called when
  Phoenix is setting up a channel connection.
- Connections to a given URL will all use the same socket handler,
  based on your endpoint configuration. But that handler can be used
  for setting up connections on any number of topics.
- Within the handler, you can authenticate and identify a socket
  connection and set default socket assigns.
** Channel Routes
- Channel routes are defined in socket handlers, such as
  ~HelloWeb.UserSocket~. They match on the topic string and dispatch
  matching requests to the given Channel module.
** Channels
- Channels handle events from clients, so they are similar to
  Controllers, but there are two key differences:
  1. Channel events can go both directions - incoming and outgoing
  2. Channel connections also persist beyond a single request/response
     cycle.
- Each Channel will implement one or more clauses of each of these
  four callback functions:
  + ~join/3~
    * To authorize the socket to join a topic, we return ~{:ok, socket}~
      or ~{:ok, reply, socket}~. To deny access, we return ~{:error, reply}~.
  + ~terminate/2~

  + ~handle_in/3~
    * We handle incoming events with ~handle_in/3~
      #+BEGIN_SRC elixir
        def handle_in("new_msg", %{"body" => body}, socket) do
          broadcast!(socket, "new_msg", %{body: body})
          {:noreply, socket}
        end
      #+END_SRC
  + ~handle_out/3~
    * ~handle_out/3~ isn’t a required callback, but it allows us to
      customize and filter broadcasts before they reach each client.
    * e.g.
      #+BEGIN_SRC elixir
        defmodule HelloWeb.RoomChannel do
          use Phoenix.Channel
          intercept(["new_msg"])

          def join("room:lobby", _message, socket) do
            {:ok, socket}
          end

          def join("room:" <> _private_room_id, _params, _socket) do
            {:error, %{reason: "unauthorized"}}
          end

          def handle_in("new_msg", %{"body" => body}, socket) do
            broadcast!(socket, "new_msg", %{body: body})
            {:noreply, socket}
          end

          def handle_out("new_msg", msg, socket) do
            push(socket, "new_msg", %{"body" => String.upcase(msg.body)})
            {:noreply, socket}
          end
        end
      #+END_SRC

** Topics
- Topics are string identifiers - names that the various layers use in
  order to make sure messages end up in the right place
** Messages
- The ~[[https://hexdocs.pm/phoenix/Phoenix.Socket.Message.html][Phoenix.Socket.Message]]~ module defines a struct with the
  following keys which denotes a valid message:
  + ~topic~ - The string topic or "~topic:subtopic~" pair namespace,
    such as "~messages~" or "~messages:123~"
  + ~event~ - The string event name, for example "phx_join"
  + ~payload~ - The message payload
  + ~ref~ - The unique string ref
** PubSub
- ~PubSub~ consists of the ~[[https://hexdocs.pm/phoenix_pubsub/1.1.0/Phoenix.PubSub.html][Phoenix.PubSub]]~ module and a variety of
  modules for different adapters and their GenServers. These modules
  contain functions which are the nuts and bolts of organizing Channel
  communication - subscribing to topics, unsubscribing from topics,
  and broadcasting messages on a topic.

** Socket Assigns
- Similar to connection structs, ~%Plug.Conn{}~, it is possible to
  assign values to a channel socket. [[https://hexdocs.pm/phoenix/Phoenix.Socket.html#assign/3][Phoenix.Socket.assign/3]] is
  conveniently imported into a channel module as ~assign/3~:
  #+BEGIN_SRC elixir
  socket = assign(socket, :user, msg["user"])
  #+END_SRC
  Sockets store assigned values as a map in ~socket.assigns~.

* Context
- Contexts are dedicated modules that expose and group related
  functionality.
- Phoenix projects are structured like Elixir and any other Elixir
  project – we split our code into contexts. A context will group
  related functionality, such as posts and comments, often
  encapsulating patterns such as data access and data validation. By
  using contexts, we decouple and isolate our systems into manageable,
  independent parts.
- sample
  #+BEGIN_SRC sh
    $ mix phx.gen.html Accounts User users name:string username:string:unique
     * creating lib/hello_web/controllers/user_controller.ex
     * creating lib/hello_web/templates/user/edit.html.eex
     * creating lib/hello_web/templates/user/form.html.eex
     * creating lib/hello_web/templates/user/index.html.eex
     * creating lib/hello_web/templates/user/new.html.eex
     * creating lib/hello_web/templates/user/show.html.eex
     * creating lib/hello_web/views/user_view.ex
     * creating test/hello_web/controllers/user_controller_test.exs
     * creating lib/hello/accounts/user.ex
     * creating priv/repo/migrations/20190218064836_create_users.exs
     * creating lib/hello/accounts.ex
     * injecting lib/hello/accounts.ex
     * creating test/hello/accounts/accounts_test.exs
     * injecting test/hello/accounts/accounts_test.exs

    Add the resource to your browser scope in lib/hello_web/router.ex:

        resources "/users", UserController

    Remember to update your repository by running migrations: mix ecto.migrate


    $ mix phx.gen.context Accounts Credential credentials email:string:unique user_id:references:users
     * creating lib/hello/accounts/credential.ex
     * creating priv/repo/migrations/20190218082757_create_credentials.exs
     * injecting lib/hello/accounts.ex
     * injecting test/hello/accounts/accounts_test.exs

    Remember to update your repository by running migrations: mix ecto.migrate
  #+END_SRC
  + ~phx.gen.context~ task is just like ~phx.gen.html~, except it
    doesn’t generate the web files for us.

* PubSub
- underlies the channel layer and allows clients to subscribe to
  topics
- abstracts the underlying pubsub adapter for third-party pubsub
  integration

* Built on top of
**  Plug
- Plug is a specification for constructing composable modules to build
  web applications. Plugs are reusable modules or functions built to
  that specification. They provide discrete behaviors - like request
  header parsing or logging. Because the Plug API is small and
  consistent, plugs can be defined and executed in a set order, like a
  pipeline. They can also be re-used within a project or across
  projects.

- The core Phoenix components like Endpoints, Routers, and Controllers
  are all just Plugs internally

- Plug is a specification for composable modules in between web
  applications. It is also an abstraction layer for connection
  adapters of different web servers. The basic idea of Plug is to
  unify the concept of a “connection” that we operate on. This differs
  from other HTTP middleware layers such as Rack, where the request
  and response are separated in the middleware stack.

*** function plugs
- In order to act as a plug, a function simply needs to accept a
  connection struct (~%Plug.Conn{}~) and options. It also needs to
  return a connection struct. Any function that meets those criteria
  will do.
  #+BEGIN_SRC elixir
    def put_headers(conn, key_values) do
      Enum.reduce key_values, conn, fn {k, v}, conn ->
        Plug.Conn.put_resp_header(conn, to_string(k), v)
      end
    end
  #+END_SRC
  and we use them to compose a series of transformations on our
  connection in Phoenix
  #+BEGIN_SRC elixir
    defmodule HelloWeb.MessageController do
      use HelloWeb, :controller

      plug :put_headers, %{content_encoding: "gzip", cache_control: "max-age=3600"}
      plug :put_layout, "bare.html"

      ...
    end
  #+END_SRC
  e.g
  #+BEGIN_SRC elixir
    defmodule HelloWeb.MessageController do
      use HelloWeb, :controller

      plug :authenticate
      plug :fetch_message
      plug :authorize_message

      def show(conn, params) do
        render(conn, :show, page: find_message(params["id"]))
      end

      defp authenticate(conn, _) do
        case Authenticator.find_user(conn) do
          {:ok, user} ->
            assign(conn, :user, user)
          :error ->
            conn |> put_flash(:info, "You must be logged in") |> redirect(to: "/") |> halt()
        end
      end

      defp fetch_message(conn, _) do
        case find_message(conn.params["id"]) do
          nil ->
            conn |> put_flash(:info, "That message wasn't found") |> redirect(to: "/") |> halt()
          message ->
            assign(conn, :message, message)
        end
      end

      defp authorize_message(conn, _) do
        if Authorizer.can_access?(conn.assigns[:user], conn.assigns[:message]) do
          conn
        else
          conn |> put_flash(:info, "You can't access that page") |> redirect(to: "/") |> halt()
        end
      end
    end
  #+END_SRC

*** module plugs
- Module plugs are another type of Plug that let us define a
  connection transformation in a module. The module only needs to
  implement two functions:
  + ~init/1~ which initializes any arguments or options to be passed
    to ~call/2~
  + ~call/2~ which carries out the connection transformation. ~call/2~
    is just a function plug that we saw earlier
  + e.g.
    #+BEGIN_SRC elixir
      defmodule HelloWeb.Plugs.Locale do
        import Plug.Conn

        @locales ["en", "fr", "de"]

        def init(default), do: default

        def call(%Plug.Conn{params: %{"locale" => loc}} = conn, _default) when loc in @locales do
          assign(conn, :locale, loc)
        end
        def call(conn, default), do: assign(conn, :locale, default)
      end

      defmodule HelloWeb.Router do
        use HelloWeb, :router

        pipeline :browser do
          plug :accepts, ["html"]
          plug :fetch_session
          plug :fetch_flash
          plug :protect_from_forgery
          plug :put_secure_browser_headers
          plug HelloWeb.Plugs.Locale, "en"
        end
        ...
    #+END_SRC

**  Ecto
- Ecto is a language integrated query composition tool and database
  wrapper for Elixir. With Ecto, we can read and write to different
  databases, model our domain data, write complex queries in a
  type-safe way, protect against attack vectors - including SQL
  injection, and much more.
- Ecto is built around four main abstractions:
  + *Repo* - A repository represents a connection to an individual
    database. Every database operation is done via the repository.

  + *Schema* - Schemas are our data definitions. They define table names
    and fields as well as each field’s type. Schemas also define
    associations - the relationships between our resources.

  + *Query* - Queries tie both schemas and repositories together,
    allowing us to elegantly retrieve data from the repository and
    cast it into the schemas themselves.

  + *Changeset* - Changesets declare transformations we need to perform
    on our data before our application can use it. These include type
    casting, validations, and more.
*** Repo
- Ecto Repos are the interface into a storage system, be it a Database
  like PostgreSQL or an external service like a RESTful API.

- sample
  #+BEGIN_SRC elixir
    defmodule Hello.Repo do
      use Ecto.Repo,
        otp_app: :hello,
        adapter: Ecto.Adapter.Postgres
    end
  #+END_SRC

- repo has three main tasks
  1. to bring in all the common query functions from ~Ecto.Repo~

  2. to set the ~otp_app~ name equal to our application name

  3. to configure our database adapter.

- [[https://hexdocs.pm/ecto/Ecto.Query.html#content][Ecto.Query documentation]]

*** Schema
- Ecto schemas are responsible for mapping Elixir values to external
  data sources, as well as mapping external data back into Elixir
  data-structures.
- We can also define relationships to other schemas in our
  applications.
- Ecto schemas at their core are simply Elixir structs.

- Generate a schema
  #+BEGIN_SRC
   $ mix phx.gen.schema User users name:string email:string bio:string number_of_pets:integer

   * creating ./lib/hello/user.ex
   * creating priv/repo/migrations/20170523151118_create_users.exs

   Remember to update your repository by running migrations:

   $ mix ecto.migrate
  #+END_SRC
- defined schema
  #+BEGIN_SRC elixir
    defmodule Hello.User do
      use Ecto.Schema
      import Ecto.Changeset
      alias Hello.User


      schema "users" do
        field :bio, :string
        field :email, :string
        field :name, :string
        field :number_of_pets, :integer

        timestamps()
      end

      @doc false
      def changeset(%User{} = user, attrs) do
        user
        |> cast(attrs, [:name, :email, :bio, :number_of_pets])
        |> validate_required([:name, :email, :bio, :number_of_pets])
      end
    end
  #+END_SRC
  +  Our ~schema~ block is what tells Ecto how to cast our ~%User{}~
    struct fields to and from the external ~users~ table.

*** Query

*** Changeset
- Ecto also handles data validation and type casting with changesets,
- Often, the ability to simply cast data to and from the database
  isn’t enough and extra data validation is required. This is where
  Ecto Changesets come in.
- Changesets define a pipeline of transformations our data needs to
  undergo before it will be ready for our application to use. These
  transformations might include type-casting, user input validation,
  and filtering out any extraneous parameters
- Often we’ll use changesets to validate user input before writing it
  to the database
- Ecto Repos are also changeset-aware, which allows them not only to
  refuse invalid data, but also perform the minimal database updates
  possible by inspecting the changeset to know which fields have
  changed.
- sample changeset
  #+BEGIN_SRC elixir
    def changeset(%User{} = user, attrs) do
      user
      |> cast(attrs, [:name, :email, :bio, :number_of_pets])
      |> validate_required([:name, :email, :bio, :number_of_pets])
      |> validate_length(:bio, min: 2)
      |> validate_length(:bio, max: 140)
      |> validate_format(:email, ~r/@/)
    end
  #+END_SRC
  + ~cast/3~
    1. first takes a struct
    2. then the parameters (the proposed updates)
    3. the final field is the list of columns to be updated.
  + ~validate_required/3~
    * checks that this list of fields is present in the changeset that
      ~cast/3~ returns.
- [[https://hexdocs.pm/ecto/Ecto.Changeset.html][Ecto.Changeset]]

*** Data Persistence

* Miscellaneous
- All of our application’s static assets like js, css, and image files
  live in assets, which are built into ~priv/static~ by webpack
- Our application file is at ~lib/hello/application.ex~
- Ecto Repo in ~lib/hello/repo.ex~
- Phoenix will look for the template in a directory named after our
  controller, so for ~HelloWeb.HelloController~ it looks for the
  template inside ~lib/hello_web/templates/hello~
  #+BEGIN_SRC elixir
    defmodule HelloWeb.HelloController do
      use HelloWeb, :controller

      def index(conn, _params) do
        render(conn, "index.html")
      end
    end
  #+END_SRC
- modules responsible for rendering are views
- In order to render any templates for our ~HelloController~, we need a
  ~HelloView~. The names are significant here - the first part of the
  names of the view and controller must match. ~hello/lib/hello_web/views/hello_view.ex~
- Templates are scoped to a view, which are scoped to
  controller. Phoenix creates a ~lib/hello_web/templates~ directory
  where we can put all these.
- ~<%= %>~. Notice that the initial tag has an equals sign like this:
  ~<%=~ . That means that any Elixir code that goes between those tags
  will be executed, and the resulting value will replace the tag. If
  the equals sign were missing, the code would still be executed, but
  the value would not appear on the page.

* Mix Tasks
- ~phx.routes~
  + show us all the routes defined for a given router
- ~phx.gen.cert~
  + generate a self-signed certificates to be used in development
- ~phx.gen.presence~
  + generate a presence module
- ~phx.gen.schema~
  + If we don’t need a complete HTML/JSON resource and are not
    interested in generating or altering a context we can use the mix
    phx.gen.schema task. It will generate a schema, and a migration.
- ~phx.gen.html~
  + takes a number of arguments, the module name of the context, the
    module name of the schema, the resource name, and a list of
    column_name:type attributes.
    #+BEGIN_SRC shell
    $ mix phx.gen.html Blog Post posts body:string word_count:integer

    * creating lib/hello_web/controllers/post_controller.ex
    * creating lib/hello_web/templates/post/edit.html.eex
    * creating lib/hello_web/templates/post/form.html.eex
    * creating lib/hello_web/templates/post/index.html.eex
    * creating lib/hello_web/templates/post/new.html.eex
    * creating lib/hello_web/templates/post/show.html.eex
    * creating lib/hello_web/views/post_view.ex
    * creating test/hello_web/controllers/post_controller_test.exs
    * creating lib/hello/blog/post.ex
    * creating priv/repo/migrations/20170906150129_create_posts.exs
    * creating lib/hello/blog/blog.ex
    * injecting lib/hello/blog/blog.ex
    * creating test/hello/blog/blog_test.exs
    * injecting test/hello/blog/blog_test.exs
    #+END_SRC
  + ~--no-context~, when we don’t want to create a context or schema
    for our resource
  + ~--no-schema~ when we want a context created without a schema for
    our resource
- ~phx.gen.json~
  + generate all the code to stand up a complete JSON resource - ecto
    migration, ecto schema, controller with all the necessary actions
    and view. This command will not create any template for the app
- ~phx.gen.context~
  + If we don’t need a complete HTML/JSON resource and instead are
    only interested in a context
  + It will generate a context, a schema, a migration and a test case.
- ~phx.gen.channel~
- ~phx.gen.presence~
- ~mix phx.server~
  + if you want an iex session: ~iex -S mix phx.server~
- ~mix phx.digest~
  + This task does two things, it creates a digest for our static
    assets and then compresses them.
    * “Digest” here refers to an MD5 digest of the contents of an
      asset which gets added to the filename of that asset.
    * We can optionally determine which files should be gzipped
      #+BEGIN_SRC elixir
      config :phoenix, :gzippable_exts, ~w(.js .css)
      #+END_SRC
** ecto
- ~ecto.create~
  + create the database specified in our repo
- ~ecto.drop~
  + will drop the database specified in our repo
- ~ecto.gen.repo~
- ~ecto.gen.migration~
  + sample
    #+BEGIN_SRC
    $ mix ecto.gen.migration add_comments_table
    * creating priv/repo/migrations
    * creating priv/repo/migrations/20150318001628_add_comments_table.exs
    #+END_SRC
    #+BEGIN_SRC elixir
      defmodule Hello.Repo.Migrations.AddCommentsTable do
        use Ecto.Migration

        def change do
          create table(:comments) do
            add :body,       :string
            add :word_count, :integer
            timestamps()
          end
        end
      end
    #+END_SRC
    ~change/0~ will handle both forward migrations and rollbacks
- ~ecto.migrate~
  + to have our changes applied to the database
  + When we first run ~ecto.migrate~, it will create a table for us
    called ~schema_migrations~. This will keep track of all the
    migrations which we run by storing the timestamp portion of the
    migration’s filename.
  + When we roll back a migration, ~ecto.rollback~ will remove the
    record representing this migration from ~schema_migrations~.
- ~ecto.rollback~
  + will reverse the last migration we have run, undoing the schema
    changes.
** Creating Our Own Mix Tasks
1. The first thing we need to do is create a ~mix/tasks~ directory
   inside of ~lib~
   #+BEGIN_SRC bash
   $ mkdir -p lib/mix/tasks
   #+END_SRC
2. create a new file, ~hello.greeting.ex~
   #+BEGIN_SRC elixir
     defmodule Mix.Tasks.Hello.Greeting do
       use Mix.Task

       @shortdoc "Sends a greeting to us from Hello Phoenix"

       @moduledoc """
         This is where we would put any long form documentation or doctests.
       """

       def run(_args) do
         Mix.shell.info("Greetings from the Hello Phoenix Application!")
       end

       # We can define other functions as needed here.
     end
   #+END_SRC
3. run ~mix hello.greeting~
4. If you want to make your new mix task to use your application’s
   infrastructure, you need to make sure the application is started
   when mix task is being executed. This is particularly useful if you
   need to access your database from within the mix task.
   #+BEGIN_SRC elixir
     . . .
     def run(_args) do
       Mix.Task.run("app.start")
       Mix.shell.info("Now I have access to Repo and other goodies!")
     end
     . . .
   #+END_SRC

* Custom Errors
- Phoenix provides an ~ErrorView~, ~lib/hello_web/views/error_view.ex~, to
  render errors in our applications. The full module name will include
  the name of our application, as in ~Hello.ErrorView~.
- Phoenix will detect any 400 or 500 status level errors in our
  application and use the ~render/2~ function in our ~ErrorView~ to render
  an appropriate error template. Any errors which don’t match an
  existing clause of ~render/2~ will be caught by ~template_not_found/2~.
- https://hexdocs.pm/phoenix/errors.html



* Phoenix book
- action -> view -> template
- The ~<%= %>~ brackets surround the code we want to substitute into
  the rendered page

** The Request Pipeline
- The Phoenix encourages breaking big functions down into smaller
  ones. Then, it provides a place to explicitly register each smaller
  function in a way that’s easy to understand and replace. We’ll tie
  all of these functions together with the ~Plug~ library.
- Think of the Plug library as a specification for building
  applications that connect to the web. Each plug consumes and
  produces a common data structure called ~Plug.Conn~
- Think of each individual plug as a function that takes a conn, does
  something small, and returns a slightly changed conn.
- The web server provides the initial data for our request, and then
  Phoenix calls one plug after another.
- Each plug can transform the conn in some small way until you
  eventually send a response back to the user.
- Plugs are functions. Your web applications are pipelines of plugs.

- structure
  #+BEGIN_SRC text
    ...
    ├── assets
    ├── config
    ├── lib
    ├──── hello
    ├──── hello_web
    ├── test
    ...
  #+END_SRC
  + Browser files like JavaScript and CSS go into ~assets~
  + Phoenix configuration goes into ~config~
  + supervision trees, long-running processes, and application
    business logic goes into ~lib/hello~
  + web-related code—including controllers, views, and templates—goes
    in ~lib/hello_web~.
  + ~config/config.exs~
    #+BEGIN_SRC elixir
      use Mix.Config
      # Configures the endpoint
      config :hello, HelloWeb.Endpoint,
      url: [host: "localhost"],
      secret_key_base: "U8VmJ...hNnTsFFvrhmD",
      render_errors: [view: HelloWeb.ErrorView, accepts: ~w(html json)],
      pubsub: [name: Hello.PubSub,
      adapter: Phoenix.PubSub.PG2]
    #+END_SRC
    this code has our /endpoint/, which is the beginning of our
    world. The ~config~ function call configures the ~HelloWeb.Endpoint~
    endpoint in our ~:hello~ application, giving a keyword list with
    configuration options.
  + ~HelloWeb.Endpoint~
    #+BEGIN_SRC elixir
      defmodule HelloWeb.Endpoint do
        use Phoenix.Endpoint, otp_app: :hello
        plug Plug.Static, ...
        plug Plug.RequestId
        plug Plug.Telemetry, ...
        plug Plug.Parsers, ...
        plug Plug.MethodOverride
        plug Plug.Head
        plug Plug.Session, ...
        plug HelloWeb.Router
      end
    #+END_SRC
    Endpoints are the chain of functions at the beginning of each
    request.
- Summarizing what we have so far: an endpoint is a plug, one that’s
  made up of other plugs. Your application is a series of plugs,
  beginning with an endpoint and ending with a controller:
- When you break it down, every traditional Phoenix application looks
  like this:
  #+BEGIN_SRC elixir
    connection
    |> endpoint()
    |> router()
    |> pipeline()
    |> controller()
  #+END_SRC
  + The endpoint has functions that happen for every request.
  + The connection goes through a named pipeline, which has common
    functions for each major type of request.
  + The controller invokes the model and renders a template through a
    view.

*** Controllers, Views, and Templates
- a request comes through an endpoint, through the router, through a
  pipeline, and into the controller.
- For Phoenix, your web-related code, including controllers, views,
  and templates goes into the ~lib/hello_web/~ directory.
  #+BEGIN_SRC text
    lib
    ├── hello
    │   ├── application.ex
    │   └── repo.ex
    ├── hello.ex
    │
    ├── hello_web
    │   ├── channels
    │   │   └── user_socket.ex
    │   ├── controllers
    │   │   ├── hello_controller.ex
    │   │   └── page_controller.ex
    │   ├── endpoint.ex
    │   ├── gettext.ex
    │   ├── router.ex
    │   ├── templates
    │   │   ├── hello
    │   │   │   └── world.html.eex
    │   │   ├── layout
    │   │   │   └── app.html.eex
    │   │   └── page
    │   │   │   └── index.html.eex
    │   └── views
    │       ├── error_helpers.ex
    │       ├── error_view.ex
    │       ├── hello_view.ex
    │       ├── layout_view.ex
    │       └── page_view.ex
    └── hello_web.ex
  #+END_SRC
  + ~hello.ex~ and ~hello_web.ex~. The ~Hello~ module is an empty
    module which defines the top-level interface and documentation for
    your application.
  + The ~HelloWeb~ module contains some glue code that defines the
    overall structure to the web-related modules of your application.
  + The endpoint will filter out static requests and also parse the
    request into pieces, and trigger the router
  +  The browser pipeline will honor Accept headers, fetch the
    session, and protect from attacks like Cross-Site Request Forgery
    (CSRF).
- You have a good picture of exactly which functions Phoenix calls on
  a request to ~/hello~, and where that code lives within the code base:
  #+BEGIN_SRC elixir
    connection # Plug.Conn
    |> endpoint() # lib/hello_web/endpoint.ex
    |> browser() # lib/hello_web/router.ex
    |> HelloController.world() # lib/hello_web/controllers/hello_controller.ex
    |> HelloView.render( # lib/hello_web/views/hello_view.ex
    "world.html") # lib/hello_web/templates/hello/world.html.eex
  #+END_SRC
** Controllers
*** Understanding Controllers
- Each controller is also a plug.
- e.g.
  #+BEGIN_SRC elixir

  connection
  |> endpoint()
  |> router()
  |> browser_pipeline()
  |> UserController.action()        # to break this down further
                                    #  connection
                                    #  |> UserController.index()
                                    #  |> UserView.render("index.html")
  #+END_SRC
  We need to build the controller to do the work for our individual
  request, the view to render our template, and the template

*** the Context
- A context in Phoenix is nothing more than a module that groups
  functions with a shared purpose. For example, our application will
  need to read, modify and delete user accounts. We will strive to
  keep all of this code in a single module.
- Generally speaking, a context encapsulates all business logic for a
  common purpose.
- This way, we can interact with our business logic from controllers,
  channels or remote APIs, without having to duplicate code.
- In a nutshell, a controller exists to work with context
  functions. It parses end user requests, calls context functions and
  translates those results into something the end user can understand.
- Each slice of code has an isolated purpose. The context doesn’t know
  about the controller, and the controller doesn’t know about the
  business rules.
- We can add many new features, fixes or business logic changes by
  simply changing contexts, without touching the web layer at all. We
  can also unit test our business logic thoroughly via the context API
  while focusing our integration tests on the controller.
- A context will group related functionality, such as posts and
  comments, often encapsulating patterns such as data access and data
  validation, all driven by our business needs
*** Coding Views
- A view is a module containing rendering functions that convert data
  into a format the end user will consume, like HTML or JSON
- You can write such functions as you would any other Elixir
  function. Those rendering functions can also be defined from
  templates. A /template/ is a function on that module, compiled from a
  file containing a raw markup language and embedded Elixir code to
  process substitutions and loops.
- The separation of the view and template concepts makes it easy to
  render data any way you want, be it with a raw function, an embedded
  Elixir engine, or any other template engine.
- In short, views are modules responsible for rendering. Templates are
  web pages or fragments that allow both static markup and native code
  to build response pages, compiled into a function.
- sample template
  #+BEGIN_SRC elixir
    <h1>Listing Users</h1>
    <table>
      <%= for user <- @users do %>
        <tr>
          <td><b><%= first_name(user) %></b> (<%= user.id %>)</td>
          <td><%= link "View", to: Routes.user_path(@conn, :show, user.id) %></td>
        </tr>
      <% end %>
    </table>
  #+END_SRC
  At runtime, Phoenix will translate this template to a function using
  this strategy. EEx executes Elixir code that’s within ~<%= %>~ tags,
  injecting the result into the template. EEx evaluates code within ~<% %>~
  tags without injecting the result, meaning we’ll use them for
  code with side effects. Since we generally try to keep side effects
  out of views wherever possible, we’ll use mostly the ~<%= %>~ form.
- Using Helpers
  #+BEGIN_SRC elixir
    iex> Phoenix.HTML.Link.link("Home", to: "/home") |> Phoenix.HTML.safe_to_string()
    "<a href=\"/home\">Home</a>"
  #+END_SRC
  ~Phoenix.HTML~ is responsible for the HTML functionality in views,
  from generating links to working with forms. ~Phoenix.HTML~ also
  provides HTML safety: by default, applications are safe from
  cross-site scripting (XSS) attacks, because only the markup
  generated by ~Phoenix.HTML~ functions is considered safe. That’s why
  the link function returns a tuple. The first element of the
  tuple—the ~:safe~ atom—indicates that the content in the second
  element is known to be safe
**** Showing a User
-
  #+BEGIN_SRC elixir
  get "/users/:id", UserController, :show
  #+END_SRC
  On a request to ~/users/:id~, where ~:id~ is part of the inbound URL,
  the router will add at least two things we’ll need to ~conn~,
  including the ~:id~ that’s part of the URL, and the action name,
  ~:show~. Then, the router will call the plugs in our pipeline, and
  then the ~UserController~. To show a single user using this request,
  we need a controller action, which we add to
  ~lib/rumbl_web/controllers/user_controller.ex~:
  #+BEGIN_SRC elixir
    def show(conn, %{"id" => id}) do
      user = Accounts.get_user(id)
      render(conn, "show.html", user: user)
    end
  #+END_SRC

*** Naming Conventions
- When Phoenix renders templates from a controller, it infers the name
  of the view module, ~RumblWeb.UserView~, from the name of the
  controller module, ~RumblWeb.UserController~. The view modules infer
  their template locations from the view module name. In our example,
  our ~RumblWeb.UserView~ would look for templates in the
  ~web/templates/user/~ directory.

*** Nesting Templates
- create a user template in
  ~lib/rumbl_web/templates/user/user.html.eex~:
  #+BEGIN_SRC elixir
  <strong><%= first_name(@user) %></strong> (<%= @user.id %>)
  #+END_SRC
- We created another template to render a user. Then, whenever we
  build tables or listings of users, we can re-use this template. Now,
  change your ~show.html.eex~ template to render it:
  #+BEGIN_SRC elixir
    <h1>Showing User</h1>
    <%= render "user.html", user: @user %>
  #+END_SRC

- *NOTE*: it’s worth emphasizing that a view in Phoenix is just
  a module,x and templates are just functions.
  + When we add a template named
    ~lib/rumbl_web/templates/user/user.html.eex~, the view extracts the
    template from the filesystem and makes it a function in the view
    itself.
  + example
    #+BEGIN_SRC elixir
      iex(1)> user = Rumbl.Accounts.get_user("1")
      %Rumbl.Accounts.User{id: "1", name: "José", username: "josevalim"}

      iex(2)> RumblWeb.UserView.render("user.html", user: user) |> Phoenix.HTML.safe_to_string
      "<strong>José</strong> (1)\n"
    #+END_SRC
    We fetch a user from the repository and then render the template
    directly. Because Phoenix has the notion of HTML safety, we can
    see that render returns a tuple, tagged as :safe just as we saw
    with our link helper. Likewise, the contents are also stored in an
    IO List for performance.
- Each template in our application becomes a ~render(template_name, assigns)~
  clause in its respective view. So, rendering a template is
  a combination of pattern matching on the template name and executing
  the function.
- The ~assigns~ argument is simply a holding hash for user-defined
  values containing values set by plugs and controller functions.
- Because the rendering contract is so simple, nothing is stopping
  developers from defining render clauses directly on the view module,
  skipping the whole template.
  + For example, in your ~RumblWeb.ErrorView~, you could respond to 404
    or 500 status codes with basic error messages by simply
    implementing the following functions:
    #+BEGIN_SRC elixir
      def render("404.html", _assigns) do
        "Page not found"
      end
      def render("500.html", _assigns) do
        "Internal server error"
      end
    #+END_SRC
- The ~Phoenix.View~ module—the one used to define the views
  themselves—also provides functions for rendering views, including a
  function to ~render~ and convert the rendered template into a string
  in one pass:
  #+BEGIN_SRC elixir
    iex> user = Rumbl.Accounts.get_user("1")
    %Rumbl.Accounts.User{...}

    iex> Phoenix.View.render(RumblWeb.UserView, "user.html", user: user)
    {:safe, [[[[["" | "<strong>"] | "José"] | "</strong> ("] | "1"] | ")\n"]}

    iex> Phoenix.View.render_to_string(RumblWeb.UserView, "user.html", user: user)
    "<strong>José</strong> (1)\n"
  #+END_SRC
  Behind the scenes, ~Phoenix.View~ calls render in the given view and
  adds some small conveniences, like wrapping our templates in layouts
  whenever one is available.

*** Layouts
- When we call ~render~ in our controller, instead of rendering the
  desired view directly, the controller first renders the layout view,
  which then renders the actual template in a predefined markup.
- This allows developers to provide a consistent markup across all
  pages without duplicating it over and over again.
- Layouts are regular views with templates, In particular, each
  template receives a couple of special assigns when rendering, namely
  ~@view_module~ and ~@view_template~.

   /lib/rumbl_web/templates/layout/app.html.eex
  #+BEGIN_SRC html
    <main role="main" class="container">
      <p class="alert alert-info" role="alert">
        <%= get_flash(@conn, :info) %>
      </p>
      <p class="alert alert-danger" role="alert">
        <%= get_flash(@conn, :error) %>
      </p>
      <%= render @view_module, @view_template, assigns %>
    </main>
  #+END_SRC

- When you call render in your controller, you’re actually rendering
  with the ~:layout~ option set by default.
** Ecto and Changesets
*** Defining the User Schema and Migration
- At its core, Ecto lets you specify a struct that ties individual
  fields to the fields in database tables through a DSL.
  #+BEGIN_SRC elixir
    defmodule Rumbl.Accounts.User do
      use Ecto.Schema
      import Ecto.Changeset

      schema "users" do
        field :name, :string
        field :username, :string

        timestamps()
      end
    end
  #+END_SRC
  + The ~schema~ and ~field~ macros let us specify both the underlying
    database table and the Elixir struct at the same time. Each field
    corresponds to both a field in the database and a field in our
    local ~Accounts.User~ struct.
  + By default, ~Ecto~ defines the primary key called ~:id~
    automatically. From the ~schema~ definition, ~Ecto~ automatically
    defines an Elixir struct for us, which we can create by calling
    ~%Rumbl.Accounts.User{}~ as we did before.
- to generate a migration
  #+BEGIN_SRC
  mix ecto.gen.migration create_users
  #+END_SRC
*** resource
- ~resources "/users", UserController~ is equivalent to
  #+BEGIN_SRC elixir
    get "/users", UserController, :index
    get "/users/:id/edit", UserController, :edit
    get "/users/new", UserController, :new
    get "/users/:id", UserController, :show
    post "/users", UserController, :create
    patch "/users/:id", UserController, :update
    put "/users/:id", UserController, :update
    delete "/users/:id", UserController, :delete
  #+END_SRC

- If at any time you want to see all available routes, you can run the
  phx.routes Mix task, like this:
  #+BEGIN_SRC sh
    $ mix phx.routes

    page_path GET / RumblWeb.PageController :index
    user_path GET /users RumblWeb.UserController :index
    user_path GET /users/new RumblWeb.UserController :new
    user_path GET /users/:id RumblWeb.UserController :show
    user_path POST /users RumblWeb.UserController :create
  #+END_SRC
*** form
- schema
  #+BEGIN_SRC elixir
    defmodule Rumbl.Accounts.User do
      use Ecto.Schema
      import Ecto.Changeset

      schema "users" do
        field :name, :string
        field :username, :string

        timestamps()
      end

      def changeset(user, attrs) do
        user
        |> cast(attrs, [:name, :username])
        |> validate_required([:name, :username])
        |> validate_length(:username, min: 1, max: 20)
      end
    end
  #+END_SRC

- context
  #+BEGIN_SRC elixir
    defmodule Rumbl.Accounts do
      @moduledoc """
      The Accounts context.
      """
      alias Rumbl.Accounts.User
      alias Rumbl.Repo

      def get_user(id) do
        Repo.get(User, id)
      end

      def get_user!(id) do
        Repo.get!(User, id)
      end

      def get_user_by(params) do
        Repo.get_by(User, params)
      end

      def list_users do
        Repo.all(User)
      end

      def change_user(%User{} = user) do
        User.changeset(user, %{})
      end
    end
  #+END_SRC

- router
  #+BEGIN_SRC elixir
    scope "/" do
      pipe_through :browser

      resources "/users", RumblWeb.UserController, only: [:index, :show, :new, :create]
    end
  #+END_SRC

- controller
  #+BEGIN_SRC elixir
      def new(conn, _params) do
        changeset = Accounts.change_user(%User{})
        render(conn, "new.html", changeset: changeset)
      end
  #+END_SRC

- template
  #+BEGIN_SRC html
    <h1>New User</h1>

    <%= form_for @changeset, Routes.user_path(@conn, :create), fn f -> %>
    <div>
      <%= text_input f, :name, placeholder: "Name" %>
    </div>
    <div>
      <%= text_input f, :username, placeholder: "Username" %>
    </div>
    <%= submit "Create User" %>
    <% end %>
  #+END_SRC
  + We use a function, rather than HTML tags, to build the form,
    giving it an anonymous function. ~form_for~ provides conveniences
    like security, UTF-8 encoding, and more. The function takes three
    arguments: a changeset, a path, and an anonymous function. That
    function takes one argument, the form data we’re labeling ~f~. We’re
    asking the template engine to build a function returning
    everything in the template between ~fn f ->~ and ~end~. You can see
    the additional functions in play as well. These build two input
    fields and a ~submit~ tag.
  + Similar to ~link~, all those functions are documented in the
    ~Phoenix.HTML~ library.
  + the generated markup
    #+BEGIN_SRC html
      <form accept-charset="UTF-8" action="/users" method="post">
        <input name="_csrf_token"
               type="hidden"
               value="MFgTPhAieHUgGzJ2OiRDXXw3Luc7wV7h/reiiA==">
        <input name="_utf8" type="hidden" value="✓">
        <div>
          <input id="user_name"
                 name="user[name]"
                 placeholder="Name"
                 type="text">
        </div>
        <div>
          <input id="user_username"
                 name="user[username]"
                 placeholder="Username"
                 type="text">
        </div>
        <button type="submit" value="Create User"></button>
      </form>
    #+END_SRC

*** router helpers
-  In some places, we’re going to need to refer to specific routes in
  the application. Generally, these get automatically generated, and
  you can access them from the YourApplication.Router.Helpers
  module. That’s a lot to type each time you need a route. In the
  auto-generated rumbl_web file, you’ll find the following snippet:

  rumbl_web.ex
  #+BEGIN_SRC elixir
    def controller do
      quote do
        use Phoenix.Controller, namespace: RumblWeb
        import Plug.Conn
        import RumblWeb.Gettext
        alias RumblWeb.Router.Helpers, as: Routes # <-- this
      end
    end
  #+END_SRC
  The line ~alias RumblWeb.Router.Helpers, as: Routes~ gives us
  exactly what we need. Here’s why. Phoenix automatically generates
  the ~Helpers~ inside your router which contains named helpers to help
  developers generate and keep their routes up to date. Routes is a
  simple alias for ~Router.Helpers~. That’s why you can get any route
  through ~Routes.some_path~!

*** form errors
- controller
  #+BEGIN_SRC elixir
    def create(conn, %{"user" => user_params}) do
      case Accounts.create_user(user_params) do
        {:ok, user} ->
          conn
          |> put_flash(:info, "#{user.name} created!")
          |> redirect(to: Routes.user_path(conn, :index))
        {:error, %Ecto.Changeset{} = changeset} ->
          render(conn, "new.html", changeset: changeset)
      end
    end
  #+END_SRC
- template
  #+BEGIN_SRC html
    <h1>New User</h1>

    <%= form_for @changeset, Routes.user_path(@conn, :create), fn f -> %>
    <%= if @changeset.action do %>                                  <!-- this -->
    <div class="alert alert-danger">
      <p>Oops, something went wrong! please check the errors below.</p>
    </div>
    <% end %>
    <div>
      <%= text_input f, :name, placeholder: "Name" %>
      <%= error_tag f, :name %>                                     <!-- this -->
    </div>
    <div>
      <%= text_input f, :username, placeholder: "Username" %>
      <%= error_tag f, :username %>                                 <!-- this -->
    </div>
    <%= submit "Create User" %>
    <% end %>
  #+END_SRC
  + The ~:action~ field of a changeset indicates an action we tried to
    perform on it, such as ~:insert~. When we build a new changeset,
    the field is ~nil~.
  + we use the ~error_tag~ function defined in
    ~lib/rumbl_web/views/error_helpers.ex~ to display an error tag next
    to each form input with the validation error for each field.
  + In addition to validation errors, the changesets also track
    changes!
    #+BEGIN_SRC shell
      iex> alias Rumbl.Accounts.User

      iex> changeset = User.changeset(%User{username: "eric"}, %{})
      %Ecto.Changeset{changes: %{}, ...}

      iex> import Ecto.Changeset
      Ecto.Changeset

      iex> changeset = put_change(changeset, :username, "ericmj")
      %Ecto.Changeset{changes: %{username: "ericmj"}, ...}

      iex> changeset.changes
      %{username: "ericmj"}

      iex> get_change(changeset, :username)
      "ericmj"
    #+END_SRC
    Ecto is using changesets as a bucket to hold everything related to
    a database change, before and after persistence.
** auth
- changeset
  #+BEGIN_SRC elixir
    def changeset(user, attrs) do
      user
      |> cast(attrs, [:name, :username])
      |> validate_required([:name, :username])
      |> validate_length(:username, min: 1, max: 20)
    end
  #+END_SRC
  The ~Ecto.Changeset.cast~ function converts a raw map of user input to
  a changeset, accepting only the ~:name~ and ~:username~ keys.

- hash
  #+BEGIN_SRC elixir
    defmodule Rumbl.Accounts.User do
      use Ecto.Schema
      import Ecto.Changeset

      schema "users" do
        field :name, :string
        field :username, :string
        field :password, :string, virtual: true
        field :password_hash, :string

        timestamps()
      end

      def changeset(user, attrs) do
        user
        |> cast(attrs, [:name, :username])
        |> validate_required([:name, :username])
        |> validate_length(:username, min: 1, max: 20)
      end

      def registration_changeset(user, params) do
        user
        |> changeset(params)
        |> cast(params, [:password])
        |> validate_required([:password])
        |> validate_length(:password, min: 6, max: 100)
        |> put_pass_hash()
      end

      defp put_pass_hash(changeset) do
        case changeset do
          %Ecto.Changeset{valid?: true, changes: %{password: pass}} ->
            put_change(changeset, :password_hash, Pbkdf2.hash_pwd_salt(pass))

          _ ->
            changeset
        end
      end
    end
  #+END_SRC
  Here you can see how easy it is to compose with changesets. We used
  our base ~User.changeset~ function to cast and validate the ~name~ and
  ~username~ parameters. Then we validated our virtual password field
  inside our registration changeset. Notice that it’s trivial to
  validate our virtual password field, though we’re not actually
  storing that value in the database! Persistence is not strongly
  coupled to our change policies
  :NOTE:
    for real world scenarios use the guild-lines in the following documents
    https://github.com/OWASP/CheatSheetSeries
  :END:
  #+BEGIN_SRC shell
    iex> changeset = User.registration_changeset(%User{}, %{
    ...> username: "max", name: "Max", password: "asecret"
    ...> })
    #Ecto.Changeset<
        action: nil,
        changes: %{
            name: "Max",
            username: "max",
            password: "asecret",
            password_hash: "$pbkdf2-sha512$r7zRM4aQgSUGlOy4483cFe1UouMC/9emcOI75MhgDQ6A9WNWBpfr."
        },
        errors: [],
        data: #Rumbl.Accounts.User<>,
        valid?: true
    >

    iex> changeset.valid?
    true

    iex> changeset.changes
    %{
        name: "Max",
        username: "max",
        password: "asecret",
        password_hash:
        "$pbkdf2-sha512$r7zRM4aQgSUGlOy4483cFe1UouMC/9emcOI75MhgDQ6A9WNWBpfr."
    }
  #+END_SRC

*** The Anatomy of a Plug
- There are two kinds of plugs:
  1. module plugs: A module plug is a module that provides two
     functions with some configuration details.
     #+BEGIN_SRC
     plug Plug.RequestId
     #+END_SRC
  2. function plugs: A function plug is a single function
     #+BEGIN_SRC
     plug :protect_from_forgery
     #+END_SRC
- You specify a function plug with the name of the function as an
  atom. Because a module is just a collection of functions, it
  strengthens the idea that plugs are just functions
- Sometimes you might want to share a plug across more than one
  module. In that case, you can use a module plug.
- To satisfy the Plug specification, a module plug must have two
  functions, named ~init~ and ~call~
- The simplest possible module plug returns the given options on ~init~
  and the given connection on ~call~. This plug does nothing:
  #+BEGIN_SRC elixir
    defmodule NothingPlug do
      def init(opts) do
        opts
      end
      def call(conn, _opts) do
        conn
      end
    end
  #+END_SRC
  + Sometimes, you might want to let the programmer change the
    behavior of a plug. We can do that work in the second argument to
    ~call~, options. In our ~NothingPlug~, we don’t need any more
    information to do our job, so we ignore the options.
- Sometimes, you might need Phoenix to do some heavy lifting to
  transform options. That’s the job of the ~init~ function. Plug uses
  the result of init as the second argument to call. In development
  mode, Phoenix calls init at runtime, but in production mode, init is
  called only once, at compile time. This strategy makes init the
  perfect place to validate and transform options without slowing down
  every request so call can be as fast as possible. Since call is the
  workhorse of Plug, we want it to do as little work as possible.

- For both module and function plugs, the request interface is the
  same. conn, the first argument, is the data we pass through every
  plug. It has the details for any request, and we morph it in tiny
  steps until we eventually send a response. All plugs take a conn and
  return a conn.
**** Plug.Conn Fields
- [[https://hexdocs.pm/plug/Plug.Conn.html#module-request-fields][Request fields]]
  + ~host~
  + ~method~
  + ~path_info~
  + ~req_headers~
  + ~scheme~
- fetchable fields
  + A fetchable field is empty until you explicitly request it
  + These fields require a little time to process, so they’re left out
    of the connection by default until you want to explicitly fetch
    them
  + ~cookies~
  + ~params~
    - These are the request parameters. Some plugs help to parse these
      parameters from the query string, or from the request body.
- Next are a series of fields that are used to process web requests
  and keep information about the plug pipeline. Here are some of the
  fields you’ll encounter:
  + ~assigns~
    * This user-defined map contains anything you want to put in
      it. For instance, this is where we will keep the authenticated
      user for the current request.
  + ~halted~
    * Sometimes a connection must be halted, such as a failed
      authorization. In this case, the halting plug sets this flag.
- Since the Plug framework handles the whole life cycle of a request,
  including both the request and the response, Plug.Conn provides
  fields for the response:
  + ~resp_body~
    * nitially an empty string, the response body will contain the
      HTTP response string when it’s available.
  + ~resp_cookies~
    * The resp_cookies has the outbound cookies for the response.
  + ~resp_headers~
    * These headers follow the HTTP specification and contain
      information such as the response type and caching rules.
  + ~status~
    * The response code generally contains 200–299 for success,
      300–399 for redirects, 400–499 for bad client requests such as
      not-found, and 500+ for server errors.
- Finally, Plug supports some private fields reserved for the adapter
  and frameworks:
  + ~adapter~
    * Information about the underlying web server is stored here.
  + ~private~
    * This field has a map for the private use of frameworks.
*** Writing an Authentication Plug
- ~lib/rumbl_web/controllers/auth.ex~
  #+BEGIN_SRC elixir
    defmodule RumblWeb.Auth do
      import Plug.Conn

      def init(opts), do: opts

      def call(conn, _opts) do
        user_id = get_session(conn, :user_id)
        user = user_id && Rumbl.Accounts.get_user(user_id)
        assign(conn, :current_user, user)
      end
    end
  #+END_SRC
-  router.ex
  #+BEGIN_SRC elixir
    defmodule RumblWeb.Router do
      use RumblWeb, :router

      pipeline :browser do
        plug :accepts, ["html"]
        plug :fetch_session
        plug :fetch_flash
        plug :protect_from_forgery
        plug :put_secure_browser_headers
        plug RumblWeb.Auth                  # <-- use the plug
      end

      # ...
      # ...
      # ...
    end
  #+END_SRC
- Restricting Access
  #+BEGIN_SRC elixir
    defmodule RumblWeb.UserController do
      use RumblWeb, :controller
      alias Rumbl.Accounts
      alias Rumbl.Accounts.User
      plug :authenticate when action in [:index, :show] # <-- restriction

      def index(conn, _params) do
      # ...
      end

      def show(conn, %{"id" => id}) do
      # ...
      end

      def new(conn, _params) do
      # ...
      end

      def create(conn, %{"user" => user_params}) do
      # ...
      end

      defp authenticate(conn, _opts) do
        if conn.assigns.current_user do
          conn
        else
          conn
          |> put_flash(:error, "you must be logged in to acess that page")
          |> redirect(to: Routes.page_path(conn, :index))
          |> halt()
        end
      end
    end
  #+END_SRC

- Elixir macro expansion
  #+BEGIN_SRC elixir
    plug :one
    plug Two
    plug :three, some: :option

    # It would compile to:

    case one(conn, []) do
      %Plug.Conn{halted: true} = conn -> conn
      conn ->
        case Two.call(conn, Two.init([])) do
          %Plug.Conn{halted: true} = conn -> conn
          conn ->
            case three(conn, some: :option) do
              %Plug.Conn{halted: true} = conn -> conn
              conn -> conn
            end
        end
    end
  #+END_SRC

*** Implementing Login and Logout
- in our context
  #+BEGIN_SRC elixir
    def authenticate_by_username_and_pass(username, given_pass) do
      user = get_user_by(username: username)

      cond do
        user && Pbkdf2.verify_pass(given_pass, user.password_hash) ->
          {:ok, user}

        user ->
          {:error, :unauthorized}

        true ->
          Pbkdf2.no_user_verify() # <- to simulate a password check with variable timing.
          {:error, :not_found}
      end
    end
  #+END_SRC
- router
  #+BEGIN_SRC elixir
  resources("/sessions", RumblWeb.SessionController, only: [:new, :create, :delete])
  #+END_SRC
- session controller
  #+BEGIN_SRC elixir
    defmodule RumblWeb.SessionController do
      use RumblWeb, :controller

      def new(conn, _) do
        render(conn, "new.html")
      end

      def create(conn, %{"session" => %{"username" => username, "password" => pass}}) do
        case Rumbl.Accounts.authenticate_by_username_and_pass(username, pass) do
          {:ok, user} ->
            conn
            |> RumblWeb.Auth.login(user)
            |> put_flash(:info, "Welcome back")
            |> redirect(to: Routes.page_path(conn, :index))

          {:error, _reason} ->
            conn
            |> put_flash(:error, "Invalid username/password combination")
            |> render("new.html")
        end
      end

      def delete(conn, _) do
        conn
        |> RumblWeb.Auth.logout()
        |> redirect(to: Routes.page_path(conn, :index))
      end
    end
  #+END_SRC

- auth
  #+BEGIN_SRC elixir
    defmodule RumblWeb.Auth do
      import Plug.Conn

      def init(opts), do: opts

      def call(conn, _opts) do
        user_id = get_session(conn, :user_id)
        user = user_id && Rumbl.Accounts.get_user(user_id)
        assign(conn, :current_user, user)
      end

      def login(conn, user) do
        conn
        |> assign(:current_user, user)
        |> put_session(:user_id, user.id)
        |> configure_session(renew: true)
      end

      def logout(conn) do
        # also would be possible by delete_session(conn, :user_id)
        configure_session(conn, drop: true)
      end
    end
  #+END_SRC
- login template
  #+BEGIN_SRC html
    <h1>Login</h1>
    <%= form_for @conn,
        Routes.session_path(@conn, :create),
        [as: :session],
        fn f -> %>
    <div>
      <%= text_input f, :username, placeholder: "Username" %>
    </div>
    <div>
      <%= password_input f, :password, placeholder: "Password" %>
    </div>
    <%= submit "Log in" %>
    <% end %>
  #+END_SRC
- app layout template for logout
  #+BEGIN_SRC html
    <section>
      <nav>
        <ul>
          <%= if @current_user do %>
          <li><%= @current_user.username %></li>
          <li>
            <%= link "Log out",
                to: Routes.session_path(@conn, :delete, @current_user),
                method: "delete" %>
          </li>
          <% else %>
          <li><%= link "Register", to: Routes.user_path(@conn, :new) %></li>
          <li><%= link "Log in", to: Routes.session_path(@conn, :new) %></li>
          <% end %>
        </ul>
      </nav>
    </section>
  #+END_SRC
** Generators and Relationships
- possibilities
  + ~mix phx.gen.html Multimedia Category categories name:string~.
    This command generates a controller, view, and
    template on the front end. On the back end, it generates a
    ~Multimedia~ context, a ~Multimedia.Category~ schema, and a
    migration. This generator, and the similar ~mix phx.gen.json~
    generator, are typically used when we want to define all
    conveniences to expose a resource over the web interface.

  + ~mix phx.gen.context Multimedia Category categories name:string~.
    This command makes a ~Multimedia~ context, a
    ~Multimedia.Category~ schema and the associated migration. This
    generator is useful for generating a resource with all of its
    context functions without exposing that resource via the web
    interface. Note that if the context already exists, which is the
    case for ~Multimedia~, the generator will inject the new category
    functions into the existing context.

  + ~mix phx.gen.schema Multimedia.Category categories name:string~.
    This command creates a schema with a migration. It’s
    useful for creating a resource when you want to define the context
    functions yourself.

  + ~mix ecto.gen.migration create_categories~. This generator builds
    a new empty migration. Useful when the schema and context are
    already laid out, and all you need is to update the database


- ~phx.gen.html~ creates a simple HTTP scaffold with HTML pages
  + e.g.
    #+BEGIN_SRC shell
      $ mix phx.gen.html \
                        Multimedia \    # the name of the context
                        Video \         # module defining schema
                        videos \        # plural form of the schema name
                        user_id:references:users url:string title:string description:text # Each field, with some type information

      * creating lib/rumbl_web/controllers/video_controller.ex
      * creating lib/rumbl_web/templates/video/edit.html.eex
      * creating lib/rumbl_web/templates/video/form.html.eex
      * creating lib/rumbl_web/templates/video/index.html.eex
      * creating lib/rumbl_web/templates/video/new.html.eex
      * creating lib/rumbl_web/templates/video/show.html.eex
      * creating lib/rumbl_web/views/video_view.ex
      * creating test/rumbl_web/controllers/video_controller_test.exs
      * creating lib/rumbl/multimedia/video.ex
      * creating priv/repo/migrations/20190916073249_create_videos.exs
      * creating lib/rumbl/multimedia.ex
      * injecting lib/rumbl/multimedia.ex
      * creating test/rumbl/multimedia_test.exs
      * injecting test/rumbl/multimedia_test.exs

      Add the resource to your browser scope in lib/rumbl_web/router.ex:

          resources "/videos", VideoController


      Remember to update your repository by running migrations:

          $ mix ecto.migrate

    #+END_SRC
    * we give it
      - The name of the context: ~Multimedia~
      - The name of the module that defines the schema: ~Video~
      - The plural form of the schema name: ~videos~
      - Each field, with some type information
- They give you a simple scaffold for a traditional web-based
  application with CRUD (create, read, update, and delete)
  operations. You get migrations, a basic context, controllers, and
  templates for simple CRUD operations of a resource, as well as tests
** Constraints
- we use constraints to manage change in a way that combines the harsh
  protections of the database with Ecto’s gentle guiding hand to
  report errors without crashing
- Relational databases deal with relationships between tables. A
  database constraint is a mechanism for restricting data in a table
  based on the needs of an application. For example, a given user_id
  must exist as the id field in a users table, or an email field must
  be unique. Ensuring data is consistent across records is a critical
  job that all database-backed applications need to handle.

*** constraint
- An explicit database constraint. This might be a uniqueness
  constraint on an index, or an integrity constraint between primary
  and foreign keys.
*** constraint error
- The ~Ecto.ConstraintError~. This happens when Ecto identifies a
  constraint problem, such as trying to insert a record without
  specifying a required key.
*** changeset constraint
- A constraint annotation added to the changeset that allows Ecto to
  convert constraint errors into changeset error messages.

*** changeset error messages
- Beautiful error messages for the consumption of  humans.

**** how Ecto manages constraints

***** ~unique_constraint~
  + validating unique data
    #+BEGIN_SRC elixir
      def changeset(user, attrs) do
        user
        |> cast(attrs, [:name, :username])
        |> validate_required([:name, :username])
        |> validate_length(:username, min: 1, max: 20)
        |> unique_constraint(:username)                   # constraint
      end
    #+END_SRC

***** Validating Foreign Keys with ~assoc_constraint~
  #+BEGIN_SRC elixir
    def changeset(video, attrs) do
      video
      |> cast(attrs, [:url, :title, :description, :category_id])
      |> validate_required([:url, :title, :description])
      |> assoc_constraint(:category)                                # constraint
    end
  #+END_SRC
  ~assoc_constraint~ converts foreign-key constraint errors into
  human-readable error messages and guarantees that a video is created
  only if the category exists in the database.
  #+BEGIN_SRC shell
    iex> import Ecto.Query
    iex> alias Rumbl.Repo
    iex> alias Rumbl.Multimedia.{Video, Category}

    iex> category = Repo.get_by(Category, name: "Drama")
    %Rumbl.Multimedia.Category{...}

    iex> video = Repo.one(from v in Video, limit: 1)
    ...
    %Rumbl.Multimedia.Video{...}


    iex> changeset = Video.changeset(video, %{category_id: category.id})
    iex> Repo.update(changeset)
    ...
    {:ok, %Rumbl.Multimedia.Video{...}}


    iex> changeset = Video.changeset(video, %{category_id: 12345})
    iex> Repo.update(changeset)
    ...
    {:error, %Ecto.Changeset{}}

    iex> {:error, changeset} = v(-1)
    iex> changeset.errors
    [category: {"does not exist", []}
  #+END_SRC
  As with ~unique_constraint~, when we set up ~assoc_constraint~, we no
  longer get ~Ecto.ConstraintError~. Instead, they’re converted into
  changeset error messages.

***** On Delete
- Our constraints have helped us insert and update database data
  safely. They should also apply when we remove data. Let’s open up
  IEx once more:
  #+BEGIN_SRC elixir
    iex> alias Rumbl.Repo
    iex> alias Rumbl.Multimedia.Category

    iex> category = Repo.get_by(Category, name: "Drama")
    %Rumbl.Multimedia.Category{...}

    iex> Repo.delete(category)
    ,** (Ecto.ConstraintError) constraint error when attempting to delete
    struct
  #+END_SRC
- We pick the ~Drama~ category because we added a video to it in the
  previous section. A video is tied to the category, so we can’t
  delete the category because it would leave orphaned records.

- ~foreign_key_constraint~
  #+BEGIN_SRC elixir
    iex> import Ecto.Changeset
    iex> changeset = change(category)
    iex> changeset = foreign_key_constraint(changeset, :videos,
    name: :videos_category_id_fkey, message: "still exist")

    iex> Repo.delete(changeset)
     {:error,
     #Ecto.Changeset<
     ...,
     errors: [videos: {"still exist", []}],
     valid?: false
     >}
  #+END_SRC
- you could configure the database references to either cascade the
  deletions or simply make the ~videos.category_id~ columns ~NULL~ on
  delete.
  #+BEGIN_SRC elixir
  add :category_id, references(:categories)
  #+END_SRC
  The ~references~ function accepts the ~:on_delete~ option, such as
  ~references(:categories, on_delete: :nothing)~, with one of the
  following:
  + ~:nothing~: The default.
  + ~:delete_all~: When the category is deleted, all videos in that
    category are deleted.
  + ~:nilify_all~: When a category is deleted, the ~category_id~ of all
    associated videos is set to NULL
