- Notes from Phoenix documentation

* Endpoint
- the start and end of the request lifecycle
- handles all aspects of requests up until the point where the router
  takes over
- provides a core set of plugs to apply to all requests
- dispatches requests into a designated router

* Router
- parses incoming requests and dispatches them to the correct
  controller/action, passing parameters as needed
- provides helpers to generate route paths or urls to resources
- defines named pipelines through which we may pass our requests
- Pipelines - allow easy application of groups of plugs to a set of
  routes

* Controllers
- provide functions, called /actions/, to handle requests
- actions:
  + prepare data and pass it into views
  + invoke rendering via views
  + perform redirects

* Views
- render templates
- act as a presentation layer
- define helper functions, available in templates, to decorate data
  for presentation

* Templates
- files containing the contents that will be served in a response
- provide the basic structure for a response, and allow dynamic data
  to be substituted in
- are precompiled and fast

* Channels
- manage sockets for easy realtime communication
- are analogous to controllers except that they allow bi-directional
  communication with persistent connections

* PubSub
- underlies the channel layer and allows clients to subscribe to
  topics
- abstracts the underlying pubsub adapter for third-party pubsub
  integration

* built on top of
**  Plug
- Plug is a specification for constructing composable modules to build
  web applications. Plugs are reusable modules or functions built to
  that specification. They provide discrete behaviors - like request
  header parsing or logging. Because the Plug API is small and
  consistent, plugs can be defined and executed in a set order, like a
  pipeline. They can also be re-used within a project or across
  projects.
**  Ecto
- Ecto is a language integrated query composition tool and database
  wrapper for Elixir. With Ecto, we can read and write to different
  databases, model our domain data, write complex queries in a
  type-safe way, protect against attack vectors - including SQL
  injection, and much more.
- Ecto is built around four main abstractions:
  + Repo - A repository represents a connection to an individual
    database. Every database operation is done via the repository.
  + Schema - Schemas are our data definitions. They define table names
    and fields as well as each fieldâ€™s type. Schemas also define
    associations - the relationships between our resources.
  + Query - Queries tie both schemas and repositories together,
    allowing us to elegantly retrieve data from the repository and
    cast it into the schemas themselves.
  + Changeset - Changesets declare transformations we need to perform
    on our data before our application can use it. These include type
    casting, validations, and more.
