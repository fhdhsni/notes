- Notes from Phoenix documentation

* Endpoint
- the start and end of the request lifecycle
- handles all aspects of requests up until the point where the router
  takes over
- provides a core set of plugs to apply to all requests
- dispatches requests into a designated router

- Phoenix applications start the ~HelloWeb.Endpoint~ as a supervised
  process. By default, the Endpoint is added to the supervision tree
  in ~lib/hello/application.ex~ as a supervised process. Each request
  begins and ends its lifecycle inside your application in an
  endpoint. The endpoint handles starting the web server and
  transforming requests through several defined plugs before calling
  the ~Router~.
- Endpoints gather together common functionality and serve as entrance
  and exit for all of the HTTP requests to your application. The
  endpoint holds plugs that are common to all requests coming into
  your application.

- Faults in the different parts of the supervision tree, such as the
  Ecto Repo, will not immediately impact the main application. The
  supervisor is therefore able to restart those processes separately
  after unexpected faults. It is also possible for an application to
  have multiple endpoints, each with its own supervision tree.
- There are many functions defined in the endpoint module, read the
  [[https://hexdocs.pm/phoenix/Phoenix.Endpoint.html][Endpoint doc]]
**  Using SSL
- To prepare an application to serve requests over SSL, we need to add
  a little bit of configuration and two environment variables. In
  order for SSL to actually work, we’ll need a key file and
  certificate file from a certificate authority. The environment
  variables that we’ll need are paths to those two files.
- If we add the ~otp_app:~ key whose value is the name of our
  application, Plug will begin to look for them at the root of our
  application. We can then put those files in our ~priv~ directory and
  set the paths to ~priv/our_keyfile.key~ and ~priv/our_cert.crt~.
  Here’s an example configuration from ~config/prod.exs~.
  #+BEGIN_SRC elixir
    use Mix.Config

    config :hello, HelloWeb.Endpoint,
      http: [port: {:system, "PORT"}],
      url: [host: "example.com"],
      cache_static_manifest: "priv/static/cache_manifest.json",
      https: [
        port: 443,
        otp_app: :hello,
        keyfile: System.get_env("SOME_APP_SSL_KEY_PATH"),
        certfile: System.get_env("SOME_APP_SSL_CERT_PATH"),
        # OPTIONAL Key for intermediate certificates:
        cacertfile: System.get_env("INTERMEDIATE_CERTFILE_PATH")
      ]
  #+END_SRC
  Without the ~otp_app:~ key, we need to provide absolute paths to the
  files wherever they are on the filesystem in order for Plug to find
  them.
  #+BEGIN_SRC
  Path.expand("../../../some/path/to/ssl/key.pem", __DIR__)
  #+END_SRC
- [[*~mix phx.*~][SSL in development]]
- Force SSL
  + This can be accomplished by setting the ~:force_ssl~ option in your
    endpoint configuration. It expects a list of options which are
    forwarded to ~Plug.SSL~. By default it sets the
    “strict-transport-security” header in HTTPS requests, forcing
    browsers to always use HTTPS. If an unsafe (HTTP) request is sent,
    it redirects to the HTTPS version using the ~:host~ specified in the
    ~:url~ configuration. For example:
    #+BEGIN_SRC elixir
      config :my_app, MyApp.Endpoint,
        force_ssl: [rewrite_on: [:x_forwarded_proto]]
    #+END_SRC
    + To dynamically redirect to the host of the current request, set
      ~:host~ in the ~:force_ssl~ configuration to ~nil~.
      #+BEGIN_SRC elixir
        config :my_app, MyApp.Endpoint,
          force_ssl: [rewrite_on: [:x_forwarded_proto], host: nil]
      #+END_SRC
- [[https://hexdocs.pm/phoenix/endpoint.html#hsts][HSTS]] or “strict-transport-security” is a mechanism that allows a
  website to declare itself as only accessible via a secure connection
  (HTTPS). But it does have other consequenses. RFC6797 which defines
  HSTS also specifies that the browser should keep track of the policy
  of a host and apply it until it expires. It also specifies that
  traffic on any port other than 80 is assumed to be encrypted as per
  the policy.

* Router
- parses incoming requests and dispatches them to the correct
  controller/action, passing parameters as needed
- provides helpers to generate route paths or urls to resources
- defines named pipelines through which we may pass our requests
- Pipelines - allow easy application of groups of plugs to a set of
  routes
- ~resources "/users", UserController~ expands out to eight clauses of
  the ~match/5~ function.
  #+BEGIN_SRC elixir
    user_path  GET     /users           HelloWeb.UserController :index
    user_path  GET     /users/:id/edit  HelloWeb.UserController :edit
    user_path  GET     /users/new       HelloWeb.UserController :new
    user_path  GET     /users/:id       HelloWeb.UserController :show
    user_path  POST    /users           HelloWeb.UserController :create
    user_path  PATCH   /users/:id       HelloWeb.UserController :update
               PUT     /users/:id       HelloWeb.UserController :update
    user_path  DELETE  /users/:id       HelloWeb.UserController :delete
  #+END_SRC
  if you don't all of 'em
  #+BEGIN_SRC
  resources "/posts", PostController, only: [:index, :show]
  #+END_SRC
  or exclude some of 'em
  #+BEGIN_SRC
  resources "/comments", CommentController, except: [:delete]
  #+END_SRC
** Forward
- The ~Phoenix.Router.forward/4~ macro can be used to send all requests
  that start with a particular path to a particular plug.

  #+BEGIN_SRC elixir
    defmodule HelloWeb.Router do
      use HelloWeb, :router
      ...
      scope "/" do
        pipe_through [:authenticate_user, :ensure_admin]
        forward "/jobs", BackgroundJob.Plug # <<----
      end
    end
  #+END_SRC

  #+BEGIN_SRC elixir
    defmodule BackgroundJob.Plug do
      def init(opts), do: opts

      def call(conn, opts) do
        conn
        |> Plug.Conn.assign(:name, Keyword.get(opts, :name, "Background Job"))
        |> BackgroundJob.Router.call(opts)
      end
    end

    defmodule BackgroundJob.Router do
      use Plug.Router

      plug(:match)
      plug(:dispatch)

      get("/", do: send_resp(conn, 200, "Welcome to #{conn.assigns.name}"))
      get("/active", do: send_resp(conn, 200, "5 Active Jobs"))
      get("/pending", do: send_resp(conn, 200, "3 Pending Jobs"))
      match(_, do: send_resp(conn, 404, "Not found"))
    end
  #+END_SRC

** Path Helpers
- Path helpers are functions which are dynamically defined on the
  ~Router.Helpers~ module for an individual application. For us, that is
  ~HelloWeb.Router.Helpers~. Their names are derived from the name of
  the controller used in the route definition. Our controller is
  ~HelloWeb.PageController~, and ~page_path~ is the function which will
  return the path to the root of our application.

  router.ex
  #+BEGIN_SRC elixir
      scope "/", HelloWeb do
        pipe_through(:browser)

        get("/", PageController, :index)
        get("/hello", HelloController, :index)
        get("/hello/:messenger", HelloController, :show)
      end
  #+END_SRC

  ~iex -S mix~
  #+BEGIN_SRC text
    iex> HelloWeb.Router.Helpers.page_path(HelloWeb.Endpoint, :index)
    "/"

    iex> HelloWeb.Router.Helpers.hello_path(HelloWeb.Endpoint, :index)
    "/hello"


    iex> HelloWeb.Router.Helpers.hello_path(HelloWeb.Endpoint, :show, :farhad)
    "/hello/farhad"

    iex> HelloWeb.Router.Helpers.hello_url(HelloWeb.Endpoint, :show, :farhad)
    "http://localhost:4000/hello/farhad"

    iex(7)> HelloWeb.Router.Helpers.hello_url(HelloWeb.Endpoint, :show, :farhad, hey: :yo)
    "http://localhost:4000/hello/farhad?hey=yo"
  #+END_SRC
** Nested Resources
- Let’s say we also have a ~posts~ resource which has a many-to-one
  relationship with ~users~
  #+BEGIN_SRC elixir
    resources "/users", UserController do
      resources "/posts", PostController
    end
  #+END_SRC

  ~mix phx.routes~
  #+BEGIN_SRC elixir
    user_path  GET     /users                          HelloWeb.UserController :index
    user_path  GET     /users/:id/edit                 HelloWeb.UserController :edit
    user_path  GET     /users/new                      HelloWeb.UserController :new
    user_path  GET     /users/:id                      HelloWeb.UserController :show
    user_path  POST    /users                          HelloWeb.UserController :create
    user_path  PATCH   /users/:id                      HelloWeb.UserController :update
               PUT     /users/:id                      HelloWeb.UserController :update
    user_path  DELETE  /users/:id                      HelloWeb.UserController :delete
    user_post_path  GET     /users/:user_id/posts           HelloWeb.PostController :index
    user_post_path  GET     /users/:user_id/posts/:id/edit  HelloWeb.PostController :edit
    user_post_path  GET     /users/:user_id/posts/new       HelloWeb.PostController :new
    user_post_path  GET     /users/:user_id/posts/:id       HelloWeb.PostController :show
    user_post_path  POST    /users/:user_id/posts           HelloWeb.PostController :create
    user_post_path  PATCH   /users/:user_id/posts/:id       HelloWeb.PostController :update
                    PUT     /users/:user_id/posts/:id       HelloWeb.PostController :update
    user_post_path  DELETE  /users/:user_id/posts/:id       HelloWeb.PostController :delete
  #+END_SRC
** Scoped Routes
- Scopes are a way to group routes under a common path prefix and
  scoped set of plug middleware.
- Let’s say we have user generated reviews on a site, and that those
  reviews first need to be approved by an admin. The semantics of
  these resources are quite different, and they might not share the
  same controller. Scopes enable us to segregate these routes.
  #+BEGIN_SRC elixir
    scope "/", HelloWeb do
      pipe_through :browser
      ...
      resources "/reviews", ReviewController
      ...
    end

    scope "/admin", as: :admin do # <-- as: admin to fix path helpers, generates admin_review_path
      resources "/reviews", HelloWeb.Admin.ReviewController
    end
  #+END_SRC
  ~mix phx.routes~
  #+BEGIN_SRC text
    ...
    review_path  GET     /reviews                        HelloWeb.ReviewController :index
    review_path  GET     /reviews/:id/edit               HelloWeb.ReviewController :edit
    review_path  GET     /reviews/new                    HelloWeb.ReviewController :new
    review_path  GET     /reviews/:id                    HelloWeb.ReviewController :show
    review_path  POST    /reviews                        HelloWeb.ReviewController :create
    review_path  PATCH   /reviews/:id                    HelloWeb.ReviewController :update
                 PUT     /reviews/:id                    HelloWeb.ReviewController :update
    review_path  DELETE  /reviews/:id                    HelloWeb.ReviewController :delete

    ...
    admin_review_path  GET     /admin/reviews                  HelloWeb.Admin.ReviewController :index
    admin_review_path  GET     /admin/reviews/:id/edit         HelloWeb.Admin.ReviewController :edit
    admin_review_path  GET     /admin/reviews/new              HelloWeb.Admin.ReviewController :new
    admin_review_path  GET     /admin/reviews/:id              HelloWeb.Admin.ReviewController :show
    admin_review_path  POST    /admin/reviews                  HelloWeb.Admin.ReviewController :create
    admin_review_path  PATCH   /admin/reviews/:id              HelloWeb.Admin.ReviewController :update
                       PUT     /admin/reviews/:id              HelloWeb.Admin.ReviewController :update
    admin_review_path  DELETE  /admin/reviews/:id              HelloWeb.Admin.ReviewController :delete
  #+END_SRC
- the use of nested scopes is generally discouraged because it can
  sometimes make our code confusing and less clear. That being said,
  suppose that we had a versioned API:
  #+BEGIN_SRC elixir
    scope "/api", HelloWeb.Api, as: :api do
      pipe_through :api

      scope "/v1", V1, as: :v1 do
        resources "/images",  ImageController
        resources "/reviews", ReviewController
        resources "/users",   UserController
      end
    end
  #+END_SRC
  ~mix phx.routes~ gives up
  #+BEGIN_SRC elixir
     api_v1_image_path  GET     /api/v1/images            HelloWeb.Api.V1.ImageController :index
     api_v1_image_path  GET     /api/v1/images/:id/edit   HelloWeb.Api.V1.ImageController :edit
     api_v1_image_path  GET     /api/v1/images/new        HelloWeb.Api.V1.ImageController :new
     api_v1_image_path  GET     /api/v1/images/:id        HelloWeb.Api.V1.ImageController :show
     api_v1_image_path  POST    /api/v1/images            HelloWeb.Api.V1.ImageController :create
     api_v1_image_path  PATCH   /api/v1/images/:id        HelloWeb.Api.V1.ImageController :update
                        PUT     /api/v1/images/:id        HelloWeb.Api.V1.ImageController :update
     api_v1_image_path  DELETE  /api/v1/images/:id        HelloWeb.Api.V1.ImageController :delete
    api_v1_review_path  GET     /api/v1/reviews           HelloWeb.Api.V1.ReviewController :index
    api_v1_review_path  GET     /api/v1/reviews/:id/edit  HelloWeb.Api.V1.ReviewController :edit
    api_v1_review_path  GET     /api/v1/reviews/new       HelloWeb.Api.V1.ReviewController :new
    api_v1_review_path  GET     /api/v1/reviews/:id       HelloWeb.Api.V1.ReviewController :show
    api_v1_review_path  POST    /api/v1/reviews           HelloWeb.Api.V1.ReviewController :create
    api_v1_review_path  PATCH   /api/v1/reviews/:id       HelloWeb.Api.V1.ReviewController :update
                        PUT     /api/v1/reviews/:id       HelloWeb.Api.V1.ReviewController :update
    api_v1_review_path  DELETE  /api/v1/reviews/:id       HelloWeb.Api.V1.ReviewController :delete
      api_v1_user_path  GET     /api/v1/users             HelloWeb.Api.V1.UserController :index
      api_v1_user_path  GET     /api/v1/users/:id/edit    HelloWeb.Api.V1.UserController :edit
      api_v1_user_path  GET     /api/v1/users/new         HelloWeb.Api.V1.UserController :new
      api_v1_user_path  GET     /api/v1/users/:id         HelloWeb.Api.V1.UserController :show
      api_v1_user_path  POST    /api/v1/users             HelloWeb.Api.V1.UserController :create
      api_v1_user_path  PATCH   /api/v1/users/:id         HelloWeb.Api.V1.UserController :update
                        PUT     /api/v1/users/:id         HelloWeb.Api.V1.UserController :update
      api_v1_user_path  DELETE  /api/v1/users/:id         HelloWeb.Api.V1.UserController :delete
  #+END_SRC
** Pipelines
- Pipelines are simply plugs stacked up together in a specific order
  and given a name. They allow us to customize behaviors and
  transformations related to the handling of requests. Phoenix
  provides us with some default pipelines for a number of common
  tasks. In turn we can customize them as well as create new pipelines
  to meet our needs.
*** The Endpoint Plugs
- Endpoints organize all the plugs common to every request, and apply
  them before dispatching into the router(s) with their underlying
  ~:browser~, ~:api~, and custom pipelines. The default Endpoint plugs do
  quite a lot of work. Here they are in order.
- ~Plug.Static~ - serves static assets. Since this plug comes before the
  logger, serving of static assets is not logged
- ~Phoenix.CodeReloader~ - a plug that enables code reloading for all
  entries in the web directory. It is configured directly in the
  Phoenix application
- ~Plug.RequestId~ - generates a unique request id for each request.
- ~Plug.Logger~ - logs incoming requests
- ~Plug.Parsers~ - parses the request body when a known parser is
  available. By default parsers parse urlencoded, multipart and json
  (with jason). The request body is left untouched when the request
  content-type cannot be parsed
- ~Plug.MethodOverride~ - converts the request method to PUT, PATCH or
  DELETE for POST requests with a valid _method parameter
- ~Plug.Head~ - converts HEAD requests to GET requests and strips the
  response body
- ~Plug.Session~ - a plug that sets up session management. Note that
  fetch_session/2 must still be explicitly called before using the
  session as this plug just sets up how the session is fetched
- ~Plug.Router~ - plugs a router into the request cycle

*** The ~:browser~ and ~:api~ Pipelines
- Phoenix defines two other pipelines by default, ~:browser~ and
  ~:api~. The router will invoke these after it matches a route,
  assuming we have called~ pipe_through/1~ with them in the enclosing
  scope.
- The router invokes a pipeline on a route defined within a scope. If
  no scope is defined, the router will invoke the pipeline on all the
  routes in the router.
- If we know that our application only renders views for the browser,
  we can simplify our router quite a bit by removing the ~api~ stuff as
  well as the scopes:
  #+BEGIN_SRC elixir
    defmodule HelloWeb.Router do
      use HelloWeb, :router

      pipeline :browser do
        plug :accepts, ["html"]
        plug :fetch_session
        plug :fetch_flash
        plug :protect_from_forgery
        plug :put_secure_browser_headers
      end

      pipe_through :browser

      get "/", HelloWeb.PageController, :index

      resources "/reviews", HelloWeb.ReviewController
    end
  #+END_SRC
  Removing all scopes forces the router to invoke the ~:browser~
  pipeline on all routes.

*** Creating New Pipelines
- Phoenix allows us to create our own custom pipelines anywhere in the
  router. To do so, we call the ~pipeline/2~ macro with these arguments:
  an atom for the name of our new pipeline and a block with all the
  plugs we want in it.
  #+BEGIN_SRC elixir
    defmodule HelloWeb.Router do
      use HelloWeb, :router

      pipeline :browser do
        plug :accepts, ["html"]
        plug :fetch_session
        plug :fetch_flash
        plug :protect_from_forgery
        plug :put_secure_browser_headers
      end

      pipeline :review_checks do
        plug :ensure_authenticated_user
        plug :ensure_user_owns_review
      end

      scope "/reviews", HelloWeb do
        pipe_through :review_checks

        resources "/", ReviewController
      end
    end
  #+END_SRC

*** Channel Routes
- Channels handle incoming and outgoing messages broadcast over a
  socket for a given topic. Channel routes, then, need to match
  requests by socket and topic in order to dispatch to the correct
  channel.

  lib/hello_web/endpoint.ex
  #+BEGIN_SRC elixir
    defmodule HelloWeb.Endpoint do
      use Phoenix.Endpoint, otp_app: :hello

      socket "/socket", HelloWeb.UserSocket,
        websocket: true,
        longpoll: false
      ...
    end
  #+END_SRC
  Next, we need to open our ~lib/hello_web/channels/user_socket.ex~
  file and use the ~channel/3~ macro to define our channel routes.
  The routes will match a topic pattern to a channel to handle
  events. If we have a channel module called ~RoomChannel~ and a topic
  called ~"rooms:*"~
  #+BEGIN_SRC elixir
    defmodule HelloWeb.UserSocket do
      use Phoenix.Socket

      channel "rooms:*", HelloWeb.RoomChannel
      ...
    end
  #+END_SRC
  Each socket can handle requests for multiple channels.
  #+BEGIN_SRC elixir
  channel "rooms:*", HelloWeb.RoomChannel
  channel "foods:*", HelloWeb.FoodChannel
  #+END_SRC
  We can mount multiple socket handlers in our endpoint:
  #+BEGIN_SRC elixir
  socket "/socket", HelloWeb.UserSocket
  socket "/admin-socket", HelloWeb.AdminSocket
  #+END_SRC

* Controllers
- provide functions, called /actions/, to handle requests
- actions:
  + prepare data and pass it into views
  + invoke rendering via views
  + perform redirects
- Phoenix controllers act as intermediary modules. Their functions -
  called actions - are invoked from the router in response to HTTP
  requests. The actions, in turn, gather all the necessary data and
  perform all the necessary steps before invoking the view layer to
  render a template or returning a JSON response.
** Actions
- some convention to follow for our actions
  + ~index~ - renders a list of all items of the given resource type
  + ~show~ - renders an individual item by id
  + ~new~ - renders a form for creating a new item
  + ~create~ - receives params for one new item and saves it in a datastore
  + ~edit~ - retrieves an individual item by id and displays it in a form for editing
  + ~update~ - receives params for one edited item and saves it to a datastore
  + ~delete~ - receives an id for an item to be deleted and deletes it from a datastore
- Each action takes two parameters, which will be provided by Phoenix
  behind the scenes.
  + The first parameter is always ~conn~, a struct which holds
    information about the request such as the host, path elements,
    port, query string, and much more. conn, comes to Phoenix via
    Elixir’s Plug middleware framework. [[https://hexdocs.pm/plug/Plug.Conn.html][Plug’s documentation]]
  + The second parameter is ~params~. Not surprisingly, this is a map
    which holds any parameters passed along in the HTTP request.
** Flash Messages
- The ~Phoenix.Controller~ module provides the ~put_flash/3~ and
  ~get_flash/2~ functions to help us set and retrieve flash messages
  as a key value pair. (There's also a ~clear_flash/1~)
  #+BEGIN_SRC elixir
    defmodule HelloWeb.PageController do
      ...
      def index(conn, _params) do
        conn
        |> put_flash(:info, "Welcome to Phoenix, from flash info!")
        |> put_flash(:error, "Let's pretend we have an error.")
        |> render("index.html")
      end
    end
  #+END_SRC
** Rendering
- ~text/2~
- ~json/2~
- ~html/2~
- ~render/3~
  + ~render/3~ is defined in the ~Phoenix.View~ module instead of
    ~Phoenix.Controller~, but it is aliased in ~Phoenix.Controller~ for
    convenience.
    #+BEGIN_SRC elixir
      defmodule HelloWeb.HelloController do
        use HelloWeb, :controller

        def show(conn, %{"messenger" => messenger}) do
          render(conn, "show.html", messenger: messenger)
        end

        # same as above
        # def show(conn, %{"messenger" => messenger}) do
        #   conn
        #   |> assign(:messenger, messenger)   # Plug.Conn.assign/3
        #   |> render("show.html")
        # end
      end
    #+END_SRC
    In order for the ~render/3~ function to work correctly, the
    controller must have the same root name as the individual
    view. The individual view must also have the same root name as the
    template directory where the ~show.html.eex~ template lives. In
    other words, the ~HelloController~ requires ~HelloView~, and ~HelloView~
    requires the existence of the ~lib/hello_web/templates/hello~
    directory, which must contain the ~show.html.eex~ template.
    #+BEGIN_SRC
      lib
      ├── hello/
      ├── hello.ex
      ├── hello_web
      │  ├── channels/
      │  ├── controllers
      │  │  ├── hello_controller.ex # <-- controller
      │  │  └── page_controller.ex
      │  ├── endpoint.ex
      │  ├── gettext.ex
      │  ├── router.ex
      │  ├── templates
      │  │  ├── hello                # <-- directory
      │  │  │  ├── index.html.eex
      │  │  │  └── show.html.eex    # <-- template
      │  │  ├── layout
      │  │  │  └── app.html.eex
      │  │  └── page/
      │  └── views
      │     ├── error_helpers.ex
      │     ├── error_view.ex
      │     ├── hello_view.ex         # <-- view
      │     ├── layout_view.ex
      │     └── page_view.ex
      └── hello_web.ex
    #+END_SRC
  + Providing defaults: we can use plugs and transform
    ~conn~ on its way towards the controller action.
    #+BEGIN_SRC elixir
      plug :assign_welcome_message, "Welcome Back"

      def index(conn, _params) do
        conn
        |> assign(:message, "Welcome Forward")
        |> render("index.html")
      end

      defp assign_welcome_message(conn, msg) do
        assign(conn, :message, msg)
      end
    #+END_SRC
  + How to apply a plug only to specific actions
    #+BEGIN_SRC elixir
      defmodule HelloWeb.PageController do
        use HelloWeb, :controller

        plug :assign_welcome_message, "Hi!" when action in [:index, :show]
      ...
    #+END_SRC
  + By default, the results of the template render will be inserted
    into a layout, which will also be rendered.
*** Sending responses directly
- send a response with a status of “201” and no body whatsoever. We
  can use ~send_resp/3~ function.
  #+BEGIN_SRC elixir
    def index(conn, _params) do
      conn
      |> send_resp(201, "")
    end
  #+END_SRC
- ~put_resp_content_type/2~
  #+BEGIN_SRC elixir
    def index(conn, _params) do
      conn
      |> put_resp_content_type("text/plain")
      |> send_resp(201, "")
    end
  #+END_SRC

*** Assigning Layouts
- Layouts are just a special subset of templates. They live in
  ~lib/hello_web/templates/layout~. Phoenix created one for us when we
  generated our app. It’s called ~app.html.eex~, and it is the layout
  into which all templates will be rendered by default.

- Since layouts are really just templates, they need a view to render
  them. This is the ~LayoutView~ module defined in
  ~lib/hello_web/views/layout_view.ex~. Since Phoenix generated this
  view for us, we won’t have to create a new one as long as we put the
  layouts we want to render inside the ~lib/hello_web/templates/layout~
  directory.
- without layout
  #+BEGIN_SRC elixir
    defmodule HelloWeb.PageController do
      use HelloWeb, :controller

      def index(conn, _params) do
        conn
        |> put_layout(false)
        |> render("index.html")
      end
    end
  #+END_SRC
- select a layout
  #+BEGIN_SRC elixir
    defmodule HelloWeb.PageController do
      use HelloWeb, :controller

      def index(conn, _params) do
        conn
        |> put_layout("admin.html")
        |> render("index.html")
      end
    end
  #+END_SRC
  #+BEGIN_SRC text
    lib
    ├── hello/
    ├── hello.ex
    ├── hello_web
    │  ├── channels/
    │  ├── controllers
    │  │  └── page_controller.ex  # <-- controller
    │  ├── endpoint.ex
    │  ├── gettext.ex
    │  ├── router.ex
    │  ├── templates
    │  │  ├── layout
    │  │  │  ├── admin.html.eex # <-- layout
    │  │  │  └── app.html.eex
    │  │  └── page
    │  │     └── index.html.eex # <-- template
    │  └── views
    │     ├── error_helpers.ex
    │     ├── error_view.ex
    │     ├── layout_view.ex
    │     └── page_view.ex      # <-- view
    └── hello_web.ex

  #+END_SRC

*** Setting the Content Type
- setting mime
  #+BEGIN_SRC elixir
  def index(conn, _params) do
    conn
    |> put_resp_content_type("text/xml")
    |> render("index.xml", content: some_xml_content)
  end
  #+END_SRC
- [[https://github.com/elixir-plug/mime/blob/master/priv/mime.types][mime.types]]

*** Setting the HTTP Status
- ~Plug.Conn~ module, imported into all controllers, has a
  ~put_status/2~ function to do this.
- ~Plug.Conn.put_status/2~ takes ~conn~ as the first parameter and as
  the second parameter either an integer or a “friendly name” used as
  an atom for the status code we want to set. The list of status code
  atom representations can be found in ~Plug.Conn.Status.code/1~
  documentation.
  #+BEGIN_SRC elixir
    def index(conn, _params) do
      conn
      |> put_status(202)            # same as put_status(:accepted)
      |> render("index.html")
    end
  #+END_SRC
  :NOTE:
   :continue - 100
   :switching_protocols - 101
   :processing - 102
   :early_hints - 103
   :ok - 200
   :created - 201
   :accepted - 202
   :non_authoritative_information - 203
   :no_content - 204
   :reset_content - 205
   :partial_content - 206
   :multi_status - 207
   :already_reported - 208
   :im_used - 226
   :multiple_choices - 300
   :moved_permanently - 301
   :found - 302
   :see_other - 303
   :not_modified - 304
   :use_proxy - 305
   :switch_proxy - 306
   :temporary_redirect - 307
   :permanent_redirect - 308
   :bad_request - 400
   :unauthorized - 401
   :payment_required - 402
   :forbidden - 403
   :not_found - 404
   :method_not_allowed - 405
   :not_acceptable - 406
   :proxy_authentication_required - 407
   :request_timeout - 408
   :conflict - 409
   :gone - 410
   :length_required - 411
   :precondition_failed - 412
   :request_entity_too_large - 413
   :request_uri_too_long - 414
   :unsupported_media_type - 415
   :requested_range_not_satisfiable - 416
   :expectation_failed - 417
   :im_a_teapot - 418
   :misdirected_request - 421
   :unprocessable_entity - 422
   :locked - 423
   :failed_dependency - 424
   :unordered_collection - 425
   :upgrade_required - 426
   :precondition_required - 428
   :too_many_requests - 429
   :request_header_fields_too_large - 431
   :unavailable_for_legal_reasons - 451
   :internal_server_error - 500
   :not_implemented - 501
   :bad_gateway - 502
   :service_unavailable - 503
   :gateway_timeout - 504
   :http_version_not_supported - 505
   :variant_also_negotiates - 506
   :insufficient_storage - 507
   :loop_detected - 508
   :not_extended - 510
   :network_authentication_required - 511
  :END:
  #+BEGIN_SRC elixir
    def index(conn, _params) do
      conn
      |> put_status(:not_found)
      |> put_view(HelloWeb.ErrorView)
      |> render("404.html")
    end
  #+END_SRC

*** Redirection
- ~redirect/2~
  #+BEGIN_SRC elixir
    def index(conn, _params) do
      redirect(conn, to: "/redirect_test")
      # or for external links: redirect(conn, external: "https://elixir-lang.org/")
    end
  #+END_SRC
- Phoenix differentiates between redirecting to a path within the
  application and redirecting to a url - either within our application
  or external to it.

*** Action Fallback
- Action Fallback allows us to centralize error handling code in plugs
  which are called when a controller action fails to return a
  ~Plug.Conn.t~. These plugs receive both the ~conn~ which was originally
  passed to the controller action along with the return value of the
  action.
- usecase
  + instead of
    #+BEGIN_SRC elixir
      defmodule HelloWeb.MyController do
        use Phoenix.Controller
        alias Hello.{Authorizer, Blog}
        alias HelloWeb.ErrorView

        def show(conn, %{"id" => id}, current_user) do
          with {:ok, post} <- Blog.fetch_post(id),
               :ok <- Authorizer.authorize(current_user, :view, post) do

            render(conn, "show.json", post: post)
          else
            {:error, :not_found} ->
              conn
              |> put_status(:not_found)
              |> put_view(ErrorView)
              |> render(:"404")
            {:error, :unauthorized} ->
              conn
              |> put_status(403)
              |> put_view(ErrorView)
              |> render(:"403")
          end
        end
      end
    #+END_SRC
    Many times - especially when implementing controllers for an API -
    error handling in the controllers like this results in a lot of
    repetition. Instead we can define a plug which knows how to handle
    these error cases.
    #+BEGIN_SRC elixir
      defmodule HelloWeb.MyFallbackController do
        use Phoenix.Controller
        alias HelloWeb.ErrorView

        def call(conn, {:error, :not_found}) do
          conn
          |> put_status(:not_found)
          |> put_view(ErrorView)
          |> render(:"404")
        end

        def call(conn, {:error, :unauthorized}) do
          conn
          |> put_status(403)
          |> put_view(ErrorView)
          |> render(:"403")
        end
      end
    #+END_SRC
    and to use is
    #+BEGIN_SRC elixir
      defmodule HelloWeb.MyController do
        use Phoenix.Controller
        alias Hello.{Authorizer, Blog}

        action_fallback HelloWeb.MyFallbackController # <-- specify action fallback

        def show(conn, %{"id" => id}, current_user) do
          with {:ok, post} <- Blog.fetch_post(id),
               :ok <- Authorizer.authorize(current_user, :view, post) do

            render(conn, "show.json", post: post)
          end
        end
      end
    #+END_SRC

*** Halting the Plug Pipeline
- Controllers are plugs…. specifically plugs which are called toward
  the end of the plug pipeline. At any step of the pipeline we might
  have cause to stop processing - typically because we’ve redirected
  or rendered a response. ~Plug.Conn.t~ has a ~:halted~ key - setting it
  to true will cause downstream plugs to be skipped. We can do that
  easily using ~Plug.Conn.halt/1~.
  #+BEGIN_SRC elixir
       ...
        case Blog.get_post(conn.params["id"]) do
          {:ok, post} ->
            assign(conn, :post, post)
          {:error, :notfound} ->
            conn
            |> send_resp(404, "Not found")
            |> halt()
        end
  #+END_SRC
- ~halt/1~ simply sets the ~:halted~ key on ~Plug.Conn.t~ to ~true~

* Views
- render templates
- act as a presentation layer
- define helper functions, available in templates, to decorate data
  for presentation

- Phoenix views have two main jobs. First and foremost, they render
  templates (this includes layouts). The core function involved in
  rendering, ~render/3~, is defined in Phoenix itself in the
  ~Phoenix.View~ module. ~Views~ also provide functions which take raw
  data and make it easier for templates to consume. Similar to
  decorators or the facade pattern

- Naming convention: The ~PageController~ requires a ~PageView~ to render
  templates in the ~lib/hello_web/templates/page~

- change the directory Phoenix considers to be the template root:
  + Phoenix provides a ~view/0~ function in the ~HelloWeb~ module defined
    in ~lib/hello_web.ex~. The first line of ~view/0~ allows us to change
    our root directory by changing the value assigned to the ~:root~
    key.

- “templates” in Phoenix are really just function definitions on their
  view module. At compile-time, Phoenix precompiles all ~*.html.eex~
  templates and turns them into ~render/2~ function clauses on their
  respective view modules. At runtime, all templates are already
  loaded in memory. There’s no disk reads, complex file caching, or
  template engine computation involved. This is also why we are able
  to define functions in our views and they are immediately available
  inside the templates (also remember layouts are just templates) –
  the call to those functions are just local function calls.

- When we ~use HelloWeb, :view~, we get other conveniences as
  well. Since ~view/0~ aliases ~HelloWeb.Router.Helpers~ as ~Routes~ (look
  in ~lib/hello_web.ex~), we can simply call these helpers by using
  ~Routes.*_path~ in templates.
  #+BEGIN_SRC html
  <p><a href="<%= Routes.page_path(@conn, :index) %>">Link back to this page</a></p>
  #+END_SRC

  ~hello/lib/hello_web/views/page_view.ex~
  #+BEGIN_SRC elixir
    defmodule HelloWeb.PageController do
      use HelloWeb, :controller

      def index(conn, _params) do
        render(conn, "index.html")
      end
    end
  #+END_SRC

  ~hello/lib/hello_web/views/page_view.ex~
  #+BEGIN_SRC elixir
    defmodule HelloWeb.PageView do
      use HelloWeb, :view

      def render("index.html", assigns) do
        "rendering with assigns #{inspect(Map.keys(assigns))}"
      end
    end
  #+END_SRC

- The ~Phoenix.View~ module gains access to template behavior via the
  ~use Phoenix.Template~ line in its ~__using__/1~ macro
- ~Phoenix.View.render/3~

   ~lib/hello_web/views/page_view.ex~
  #+BEGIN_SRC elixir
    defmodule HelloWeb.PageView do
      use HelloWeb, :view

      def message do
        "Hello from the view!"
      end
    end
  #+END_SRC

  ~lib/hello_web/templates/page/test.html.eex~
  #+BEGIN_SRC html
  This is the message: <%= message() %>
  #+END_SRC

  ~iex -S mix~
  #+BEGIN_SRC
  iex> Phoenix.View.render(HelloWeb.PageView, "test.html", %{})
  {:safe, [["" | "This is the message: "] | "Hello from the view!"]}
  #+END_SRC

- layout
  + Layouts are just templates. They have a view, just like other
    templates.

- Rendering JSON
  + The view’s job is not only to render HTML templates. Views are
    about data presentation. Given a bag of data, the view’s purpose
    is to present that in a meaningful way given some format, be it
    HTML, JSON, CSV, or others.
  + It is possible to respond with JSON back directly from the
    controller and skip the ~View~. However, if we think about a
    controller as having the responsibilities of receiving a request
    and fetching data to be sent back, data manipulation and
    formatting don’t fall under those responsibilities.

    ~lib/hello_web/controllers/page_controller.ex~
    #+BEGIN_SRC elixir
      defmodule HelloWeb.PageController do
        use HelloWeb, :controller

        def show(conn, _params) do
          page = %{title: "foo"}

          render(conn, "show.json", page: page)
        end

        def index(conn, _params) do
          pages = [%{title: "foo"}, %{title: "bar"}]

          render(conn, "index.json", pages: pages)
        end
      end
    #+END_SRC

    ~lib/hello_web/views/page_view.ex~
    #+BEGIN_SRC elixir
      defmodule HelloWeb.PageView do
        use HelloWeb, :view

        def render("index.json", %{pages: pages}) do
          %{data: render_many(pages, HelloWeb.PageView, "page.json")}
        end

        def render("show.json", %{page: page}) do
          %{data: render_one(page, HelloWeb.PageView, "page.json")}
        end


        # in %{page: page}, the key `page` comes from the name of the View,
        # so if it was HelloWeb.ShitView, the would've been `shit`
        def render("page.json", %{page: page}) do
          %{title: page.title}
        end
      end
    #+END_SRC
    The ~render/2~ matching "~index.json~" will respond with JSON as
    you would expect:
    #+BEGIN_SRC text
      {
        "data": [
          {
           "title": "foo"
          },
          {
           "title": "bar"
          },
       ]
      }
    #+END_SRC
    And the ~render/2~ matching "~show.json~":
    #+BEGIN_SRC text
      {
        "data": {
          "title": "foo"
        }
      }
    #+END_SRC
    The name used in assigns is determined from the view. For example
    the ~PageView~ will use ~%{page: page}~ and the ~AuthorView~ will use
    ~%{author: author}~. This can be overridden with the ~as~
    option. Let’s assume that the author view uses ~%{writer: writer}~
    instead of ~%{author: author}~:
    #+BEGIN_SRC elixir
      def render("page_with_authors.json", %{page: page}) do
        %{title: page.title,
          authors: render_many(page.authors, AuthorView, "author.json", as: :writer)}
      end
    #+END_SRC

* Templates
- files containing the contents that will be served in a response
- provide the basic structure for a response, and allow dynamic data
  to be substituted in
- are precompiled and fast
- Templates are files into which we pass data to form complete HTTP
  responses. For a web application these responses would typically be
  full HTML documents. For an API, they would most often be JSON or
  possibly XML.
- templates live in the ~lib/hello_web/templates~ directory, organized
  into directories named after a view. Each directory has its own view
  module to render the templates in it.
- Phoenix generates a ~lib/hello_web.ex~ file that serves as place to
  group common imports and aliases. All declarations here within the
  view block apply to all your templates.
- Templates are just function calls, so like regular code, composing
  your greater template by small, purpose-built functions can lead to
  clearer design
- The way we pass data into a template is by the ~assigns~ map, and the
  way we get the values out of the assigns map is by referencing the
  keys with a preceding ~@~. ~@~ is actually a macro that translates ~@key~
  to ~Map.get(assigns, :key)~.
- template within template

  controller
  #+BEGIN_SRC elixir
    defmodule HelloWeb.PageController do
      use HelloWeb, :controller

      def test(conn, _params) do
        render(conn, "test.html")
      end
    end
  #+END_SRC

  view
  #+BEGIN_SRC elixir
    defmodule HelloWeb.PageView do
      use HelloWeb, :view

      def connection_keys(conn) do
        conn
        |> Map.from_struct()
        |> Map.keys()
      end
    end
  #+END_SRC

  ~key.html.eex~
  #+BEGIN_SRC
  <p><%= @key %></p>
  #+END_SRC

  ~test.html.eex~
  #+BEGIN_SRC html
    <div class="phx-hero">
      <%= for key <- connection_keys(@conn) do %>

        <!-- render a template within another template, that's how layout works -->
        <%= render("key.html", key: key) %>
        <!-- same as
        <%= render(HelloWeb.PageView, "key.html", key: key) %>
        -->
      <% end %>
    </div>
  #+END_SRC

* Channels
- manage sockets for easy realtime communication
- are analogous to controllers except that they allow bi-directional
  communication with persistent connections
- Clients connect and subscribe to one or more topics, whether
  that’s ~public_chat~ or ~updates:user1~. Any message sent on a topic,
  whether from the server or from a client, is sent to all clients
  subscribed to that topic
  #+BEGIN_SRC text
                                                                      +----------------+
                                                         +--Topic X-->| Mobile Client  |
                                                         |            +----------------+
                                  +-------------------+  |
    +----------------+            |                   |  |            +----------------+
    | Browser Client |--Topic X-->| Phoenix Server(s) |--+--Topic X-->| Desktop Client |
    +----------------+            |                   |  |            +----------------+
                                  +-------------------+  |
                                                         |            +----------------+
                                                         +--Topic X-->|   IoT Client   |
                                                                      +----------------+
  #+END_SRC
- To start communicating:
  1. a client connects to a node (a Phoenix server)
  2. joins one or more channels using that single network connection
  3. *One channel server process is created per client, per topic*
  4. The appropriate socket handler initializes a ~%Phoenix.Socket~ for
     the channel server (possibly after authenticating the client)
  5. The channel server then holds onto the ~%Phoenix.Socket{}~ and can
     maintain any state it needs within its ~socket.assigns~
  6. Once the connection is established, each incoming message from a
     client is routed, based on its topic, to the correct channel
     server. If the channel server asks to broadcast a message, that
     message is sent to the local PubSub, which sends it out to any
     clients connected to the same server and subscribed to that
     topic.
     #+BEGIN_SRC text
                                        Channel   +-------------------------+      +--------+
                                         route    | Sending Client, Topic 1 |      | Local  |
                                     +----------->|     Channel.Server      |----->| PubSub |--+
       +----------------+            |            +-------------------------+      +--------+  |
       | Sending Client |-Transport--+                                                  |      |
       +----------------+                         +-------------------------+           |      |
                                                  | Sending Client, Topic 2 |           |      |
                                                  |     Channel.Server      |           |      |
                                                  +-------------------------+           |      |
                                                                                        |      |
                                                  +-------------------------+           |      |
       +----------------+                         | Browser Client, Topic 1 |           |      |
       | Browser Client |<-------Transport--------|     Channel.Server      |<----------+      |
       +----------------+                         +-------------------------+                  |
                                                                                               |
                                                                                               |
                                                                                               |
                                                  +-------------------------+                  |
       +----------------+                         |  Phone Client, Topic 1  |                  |
       |  Phone Client  |<-------Transport--------|     Channel.Server      |<-+               |
       +----------------+                         +-------------------------+  |   +--------+  |
                                                                               |   | Remote |  |
                                                  +-------------------------+  +---| PubSub |<-+
       +----------------+                         |  Watch Client, Topic 1  |  |   +--------+  |
       |  Watch Client  |<-------Transport--------|     Channel.Server      |<-+               |
       +----------------+                         +-------------------------+                  |
                                                                                               |
                                                                                               |
                                                  +-------------------------+      +--------+  |
       +----------------+                         |   IoT Client, Topic 1   |      | Remote |  |
       |   IoT Client   |<-------Transport--------|     Channel.Server      |<-----| PubSub |<-+
       +----------------+                         +-------------------------+      +--------+
     #+END_SRC
** endpoint
- In your Phoenix app’s ~Endpoint~ module, a ~socket~ declaration
  specifies which socket handler will receive connections on a given
  URL.
  #+BEGIN_SRC elixir
    socket "/socket", HelloWeb.UserSocket,
      websocket: true,
      longpoll: false
  #+END_SRC
** Socket Handlers
- Socket handlers, such as ~HelloWeb.UserSocket~, are called when
  Phoenix is setting up a channel connection.
- Connections to a given URL will all use the same socket handler,
  based on your endpoint configuration. But that handler can be used
  for setting up connections on any number of topics.
- Within the handler, you can authenticate and identify a socket
  connection and set default socket assigns.
** Channel Routes
- Channel routes are defined in socket handlers, such as
  ~HelloWeb.UserSocket~. They match on the topic string and dispatch
  matching requests to the given Channel module.
** Channels
- Channels handle events from clients, so they are similar to
  Controllers, but there are two key differences:
  1. Channel events can go both directions - incoming and outgoing
  2. Channel connections also persist beyond a single request/response
     cycle.
- Each Channel will implement one or more clauses of each of these
  four callback functions:
  + ~join/3~
    * To authorize the socket to join a topic, we return ~{:ok, socket}~
      or ~{:ok, reply, socket}~. To deny access, we return ~{:error, reply}~.
  + ~terminate/2~

  + ~handle_in/3~
    * We handle incoming events with ~handle_in/3~
      #+BEGIN_SRC elixir
        def handle_in("new_msg", %{"body" => body}, socket) do
          broadcast!(socket, "new_msg", %{body: body})
          {:noreply, socket}
        end
      #+END_SRC
  + ~handle_out/3~
    * ~handle_out/3~ isn’t a required callback, but it allows us to
      customize and filter broadcasts before they reach each client.
    * e.g.
      #+BEGIN_SRC elixir
        defmodule HelloWeb.RoomChannel do
          use Phoenix.Channel
          intercept(["new_msg"])

          def join("room:lobby", _message, socket) do
            {:ok, socket}
          end

          def join("room:" <> _private_room_id, _params, _socket) do
            {:error, %{reason: "unauthorized"}}
          end

          def handle_in("new_msg", %{"body" => body}, socket) do
            broadcast!(socket, "new_msg", %{body: body})
            {:noreply, socket}
          end

          def handle_out("new_msg", msg, socket) do
            push(socket, "new_msg", %{"body" => String.upcase(msg.body)})
            {:noreply, socket}
          end
        end
      #+END_SRC

** Topics
- Topics are string identifiers - names that the various layers use in
  order to make sure messages end up in the right place
** Messages
- The ~[[https://hexdocs.pm/phoenix/Phoenix.Socket.Message.html][Phoenix.Socket.Message]]~ module defines a struct with the
  following keys which denotes a valid message:
  + ~topic~ - The string topic or "~topic:subtopic~" pair namespace,
    such as "~messages~" or "~messages:123~"
  + ~event~ - The string event name, for example "phx_join"
  + ~payload~ - The message payload
  + ~ref~ - The unique string ref
** PubSub
- ~PubSub~ consists of the ~[[https://hexdocs.pm/phoenix_pubsub/1.1.0/Phoenix.PubSub.html][Phoenix.PubSub]]~ module and a variety of
  modules for different adapters and their GenServers. These modules
  contain functions which are the nuts and bolts of organizing Channel
  communication - subscribing to topics, unsubscribing from topics,
  and broadcasting messages on a topic.

** Socket Assigns
- Similar to connection structs, ~%Plug.Conn{}~, it is possible to
  assign values to a channel socket. [[https://hexdocs.pm/phoenix/Phoenix.Socket.html#assign/3][Phoenix.Socket.assign/3]] is
  conveniently imported into a channel module as ~assign/3~:
  #+BEGIN_SRC elixir
  socket = assign(socket, :user, msg["user"])
  #+END_SRC
  Sockets store assigned values as a map in ~socket.assigns~.

* PubSub
- underlies the channel layer and allows clients to subscribe to
  topics
- abstracts the underlying pubsub adapter for third-party pubsub
  integration

* Built on top of
**  Plug
- Plug is a specification for constructing composable modules to build
  web applications. Plugs are reusable modules or functions built to
  that specification. They provide discrete behaviors - like request
  header parsing or logging. Because the Plug API is small and
  consistent, plugs can be defined and executed in a set order, like a
  pipeline. They can also be re-used within a project or across
  projects.

- The core Phoenix components like Endpoints, Routers, and Controllers
  are all just Plugs internally

- Plug is a specification for composable modules in between web
  applications. It is also an abstraction layer for connection
  adapters of different web servers. The basic idea of Plug is to
  unify the concept of a “connection” that we operate on. This differs
  from other HTTP middleware layers such as Rack, where the request
  and response are separated in the middleware stack.

*** function plugs
- In order to act as a plug, a function simply needs to accept a
  connection struct (~%Plug.Conn{}~) and options. It also needs to
  return a connection struct. Any function that meets those criteria
  will do.
  #+BEGIN_SRC elixir
    def put_headers(conn, key_values) do
      Enum.reduce key_values, conn, fn {k, v}, conn ->
        Plug.Conn.put_resp_header(conn, to_string(k), v)
      end
    end
  #+END_SRC
  and we use them to compose a series of transformations on our
  connection in Phoenix
  #+BEGIN_SRC elixir
    defmodule HelloWeb.MessageController do
      use HelloWeb, :controller

      plug :put_headers, %{content_encoding: "gzip", cache_control: "max-age=3600"}
      plug :put_layout, "bare.html"

      ...
    end
  #+END_SRC
  e.g
  #+BEGIN_SRC elixir
    defmodule HelloWeb.MessageController do
      use HelloWeb, :controller

      plug :authenticate
      plug :fetch_message
      plug :authorize_message

      def show(conn, params) do
        render(conn, :show, page: find_message(params["id"]))
      end

      defp authenticate(conn, _) do
        case Authenticator.find_user(conn) do
          {:ok, user} ->
            assign(conn, :user, user)
          :error ->
            conn |> put_flash(:info, "You must be logged in") |> redirect(to: "/") |> halt()
        end
      end

      defp fetch_message(conn, _) do
        case find_message(conn.params["id"]) do
          nil ->
            conn |> put_flash(:info, "That message wasn't found") |> redirect(to: "/") |> halt()
          message ->
            assign(conn, :message, message)
        end
      end

      defp authorize_message(conn, _) do
        if Authorizer.can_access?(conn.assigns[:user], conn.assigns[:message]) do
          conn
        else
          conn |> put_flash(:info, "You can't access that page") |> redirect(to: "/") |> halt()
        end
      end
    end
  #+END_SRC

*** module plugs
- Module plugs are another type of Plug that let us define a
  connection transformation in a module. The module only needs to
  implement two functions:
  + ~init/1~ which initializes any arguments or options to be passed
    to ~call/2~
  + ~call/2~ which carries out the connection transformation. ~call/2~
    is just a function plug that we saw earlier
  + e.g.
    #+BEGIN_SRC elixir
      defmodule HelloWeb.Plugs.Locale do
        import Plug.Conn

        @locales ["en", "fr", "de"]

        def init(default), do: default

        def call(%Plug.Conn{params: %{"locale" => loc}} = conn, _default) when loc in @locales do
          assign(conn, :locale, loc)
        end
        def call(conn, default), do: assign(conn, :locale, default)
      end

      defmodule HelloWeb.Router do
        use HelloWeb, :router

        pipeline :browser do
          plug :accepts, ["html"]
          plug :fetch_session
          plug :fetch_flash
          plug :protect_from_forgery
          plug :put_secure_browser_headers
          plug HelloWeb.Plugs.Locale, "en"
        end
        ...
    #+END_SRC

**  Ecto
- Ecto is a language integrated query composition tool and database
  wrapper for Elixir. With Ecto, we can read and write to different
  databases, model our domain data, write complex queries in a
  type-safe way, protect against attack vectors - including SQL
  injection, and much more.
- Ecto is built around four main abstractions:
  + *Repo* - A repository represents a connection to an individual
    database. Every database operation is done via the repository.

  + *Schema* - Schemas are our data definitions. They define table names
    and fields as well as each field’s type. Schemas also define
    associations - the relationships between our resources.

  + *Query* - Queries tie both schemas and repositories together,
    allowing us to elegantly retrieve data from the repository and
    cast it into the schemas themselves.

  + *Changeset* - Changesets declare transformations we need to perform
    on our data before our application can use it. These include type
    casting, validations, and more.
*** Repo
- Ecto Repos are the interface into a storage system, be it a Database
  like PostgreSQL or an external service like a RESTful API.

- sample
  #+BEGIN_SRC elixir
    defmodule Hello.Repo do
      use Ecto.Repo,
        otp_app: :hello,
        adapter: Ecto.Adapter.Postgres
    end
  #+END_SRC

- repo has three main tasks
  1. to bring in all the common query functions from ~Ecto.Repo~

  2. to set the ~otp_app~ name equal to our application name

  3. to configure our database adapter.

- [[https://hexdocs.pm/ecto/Ecto.Query.html#content][Ecto.Query documentation]]

*** Schema
- Ecto schemas are responsible for mapping Elixir values to external
  data sources, as well as mapping external data back into Elixir
  data-structures.
- We can also define relationships to other schemas in our
  applications.
- Ecto schemas at their core are simply Elixir structs.

- Generate a schema
  #+BEGIN_SRC
   $ mix phx.gen.schema User users name:string email:string bio:string number_of_pets:integer

   * creating ./lib/hello/user.ex
   * creating priv/repo/migrations/20170523151118_create_users.exs

   Remember to update your repository by running migrations:

   $ mix ecto.migrate
  #+END_SRC
- defined schema
  #+BEGIN_SRC elixir
    defmodule Hello.User do
      use Ecto.Schema
      import Ecto.Changeset
      alias Hello.User


      schema "users" do
        field :bio, :string
        field :email, :string
        field :name, :string
        field :number_of_pets, :integer

        timestamps()
      end

      @doc false
      def changeset(%User{} = user, attrs) do
        user
        |> cast(attrs, [:name, :email, :bio, :number_of_pets])
        |> validate_required([:name, :email, :bio, :number_of_pets])
      end
    end
  #+END_SRC
  +  Our ~schema~ block is what tells Ecto how to cast our ~%User{}~
    struct fields to and from the external ~users~ table.

*** Query

*** Changeset
- Ecto also handles data validation and type casting with changesets,
- Often, the ability to simply cast data to and from the database
  isn’t enough and extra data validation is required. This is where
  Ecto Changesets come in.
- Changesets define a pipeline of transformations our data needs to
  undergo before it will be ready for our application to use. These
  transformations might include type-casting, user input validation,
  and filtering out any extraneous parameters
- Often we’ll use changesets to validate user input before writing it
  to the database
- Ecto Repos are also changeset-aware, which allows them not only to
  refuse invalid data, but also perform the minimal database updates
  possible by inspecting the changeset to know which fields have
  changed.
- sample changeset
  #+BEGIN_SRC elixir
    def changeset(%User{} = user, attrs) do
      user
      |> cast(attrs, [:name, :email, :bio, :number_of_pets])
      |> validate_required([:name, :email, :bio, :number_of_pets])
      |> validate_length(:bio, min: 2)
      |> validate_length(:bio, max: 140)
      |> validate_format(:email, ~r/@/)
    end
  #+END_SRC
  + ~cast/3~
    1. first takes a struct
    2. then the parameters (the proposed updates)
    3. the final field is the list of columns to be updated.
  + ~validate_required/3~
    * checks that this list of fields is present in the changeset that
      ~cast/3~ returns.
- [[https://hexdocs.pm/ecto/Ecto.Changeset.html][Ecto.Changeset]]

*** Data Persistence


* Miscellaneous
- All of our application’s static assets like js, css, and image files
  live in assets, which are built into ~priv/static~ by webpack
- Our application file is at ~lib/hello/application.ex~
- Ecto Repo in ~lib/hello/repo.ex~
- Phoenix will look for the template in a directory named after our
  controller, so for ~HelloWeb.HelloController~ it looks for the
  template inside ~lib/hello_web/templates/hello~
  #+BEGIN_SRC elixir
    defmodule HelloWeb.HelloController do
      use HelloWeb, :controller

      def index(conn, _params) do
        render(conn, "index.html")
      end
    end
  #+END_SRC
- modules responsible for rendering are views
- In order to render any templates for our ~HelloController~, we need a
  ~HelloView~. The names are significant here - the first part of the
  names of the view and controller must match. ~hello/lib/hello_web/views/hello_view.ex~
- Templates are scoped to a view, which are scoped to
  controller. Phoenix creates a ~lib/hello_web/templates~ directory
  where we can put all these.
- ~<%= %>~. Notice that the initial tag has an equals sign like this:
  ~<%=~ . That means that any Elixir code that goes between those tags
  will be executed, and the resulting value will replace the tag. If
  the equals sign were missing, the code would still be executed, but
  the value would not appear on the page.

* ~phx.*~
- ~phx.routes~
- ~phx.gen.cert~
  + generate a self-signed certificates to be used in development
- ~phx.gen.presence~
  + generate a presence module
- ~phx.gen.schema~
  + generate an Ecto schema
