- Plug is:
  + A specification for composable modules between web applications
  + Connection adapters for different web servers in the Erlang VM
- sample
  #+BEGIN_SRC elixir
    defmodule MyPlug do
      import Plug.Conn

      def init(options) do
        # initialize options

        options
      end

      def call(conn, _opts) do
        conn
        |> put_resp_content_type("text/plain")
        |> send_resp(200, "Hello world")
      end
    end
  #+END_SRC
  #+BEGIN_SRC text
  # iex
    iex> {:ok, _} = Plug.Cowboy.http MyPlug, []
    {:ok, #PID<...>}

  # shell
  $ curl http://localhost:4000
  Hello world
  #+END_SRC
* The ~Plug.Conn~ struct
- function plug
  + A function plug receives a connection and a set of options as
    arguments and returns the connection:
    #+BEGIN_SRC elixir
      def hello_world_plug(conn, _opts) do
        conn
        |> put_resp_content_type("text/plain")
        |> send_resp(200, "Hello world")
      end
    #+END_SRC

- module plug
  + implements an ~init/1~ function to initialize the options and a ~call/2~
    function which receives the connection and initialized options and
    returns the connection:
    #+BEGIN_SRC elixir
      defmodule MyPlug do
        def init([]), do: false
        def call(conn, _opts), do: conn
      end
    #+END_SRC

- a connection is represented by the ~Plug.Conn~ struct:
  #+BEGIN_SRC elixir
    %Plug.Conn{host: "www.example.com",
               path_info: ["bar", "baz"],
               ...}
  #+END_SRC
  + Manipulating the connection often happens with the use of the
    functions defined in the ~Plug.Conn~ module. Like
    ~put_resp_content_type/2~ and ~send_resp/3~ that we used above.
  + a connection is a direct interface to the underlying web
    server. When you call ~send_resp/3~, it will immediately send
    the given status and body back to the client. This makes features
    like streaming easy work with.
* Plug.Router
  - To write a "router" plug that dispatches based on the path and
    method of incoming requests, Plug provides ~Plug.Router~:
    #+BEGIN_SRC elixir
      defmodule MyRouter do
        use Plug.Router

        plug :match
        plug :dispatch

        get "/hello" do
          send_resp(conn, 200, "world")
        end

        forward "/users", to: UsersRouter

        match _ do
          send_resp(conn, 404, "oops")
        end
      end
    #+END_SRC
    #+BEGIN_SRC
      $ curl http://localhost:4001/foo
      oops%

      $ curl http://localhost:4001/hello
      world%
    #+END_SRC
  - The router is a plug. Not only that: it contains its own plug
    pipeline too.
  - The example above says that when the router is invoked, it will
    invoke the ~:match~ plug, represented by a local (imported) ~match/2~
    function, and then call the ~:dispatch~ plug which will execute the
    matched code.
  - Plug ships with many plugs that you can add to the router plug
    pipeline, allowing you to plug something before a route matches or
    before a route is dispatched to.
    #+BEGIN_SRC elixir
      plug Plug.Logger
      plug :match
      plug :dispatch
    #+END_SRC
  - ~Plug.Router~ compiles all of your routes into a single function
    and relies on the Erlang VM to optimize the underlying routes into
    a tree lookup
  - Each route needs to return the connection as per the Plug
    specification.
* Supervised handlers
- to start your Plug pipeline under your application’s supervision
  tree, Plug provides the ~child_spec/3~ function
  #+BEGIN_SRC elixir
    defmodule MyApp do
      @moduledoc false

      use Application

      def start(_type, _args) do
        children = [
          Plug.Cowboy.child_spec(scheme: :http, plug: MyRouter, options: [port: 4001])
        ]

        opts = [strategy: :one_for_one, name: MyApp.Supervisor]
        Supervisor.start_link(children, opts)
      end
    end
  #+END_SRC
* Testing plugs
- ~Plug.Test~ module that makes testing your plugs easy
- Sample
  #+BEGIN_SRC elixir
    defmodule MyPlugTest do
      use ExUnit.Case, async: true
      use Plug.Test

      @opts MyRouter.init([])

      test "returns hello world" do
        # Create a test connection
        conn = conn(:get, "/hello")

        # Invoke the plug
        conn = MyRouter.call(conn, @opts)

        # Assert the response and status
        assert conn.state == :sent
        assert conn.status == 200
        assert conn.resp_body == "world"
      end
    end
  #+END_SRC
* Available plugs

- ~Plug.CSRFProtection~ - adds Cross-Site Request Forgery protection
  to your application. Typically required if you are using
  ~Plug.Session~;

- ~Plug.Head~ - converts HEAD requests to GET requests;

- ~Plug.Logger~ - logs requests;

- ~Plug.MethodOverride~ - overrides a request method with one
  specified in the request parameters;

- ~Plug.Parsers~ - responsible for parsing the request body given its
  content-type;

- ~Plug.RequestId~ - sets up a request ID to be used in logs;

- ~Plug.Session~ - handles session management and storage;

- ~Plug.SSL~ - enforces requests through SSL;

- ~Plug.Static~ - serves static files;
* Helper modules
- Modules that can be used after you use ~Plug.Router~ or ~Plug.Builder~
  to help development:
  + ~Plug.Debugger~ - shows a helpful debugging page every time there
    is a failure in a request;
  + ~Plug.ErrorHandler~ - allows developers to customize error pages
    in case of crashes instead of sending a blank one;
* Plug behaviour
- Function plugs
  + A function plug is any function that receives a connection and a set
    of options and returns a connection. Its type signature must be:
    #+BEGIN_SRC elixir
    (Plug.Conn.t, Plug.opts) :: Plug.Conn.t
    #+END_SRC
- Module plugs
  + A module plug is an extension of the function plug. It is a module
    that must export:
    * a ~call/2~ function with the same signature as a function plug
    * an ~init/1~ function which takes a set of options and initializes it.
- Examples
  + a function plug:
    #+BEGIN_SRC elixir
      def json_header_plug(conn, opts) do
        Plug.Conn.put_resp_content_type(conn, "application/json")
      end
    #+END_SRC
  + a module plug:
    #+BEGIN_SRC elixir
      defmodule JSONHeaderPlug do
        import Plug.Conn

        def init(opts) do
          opts
        end

        def call(conn, _opts) do
          put_resp_content_type(conn, "application/json")
        end
      end
    #+END_SRC
- The Plug pipeline
  + The ~Plug.Builder~ module provides conveniences for building plug
    pipelines.
* Plug.Builder
- Conveniences for building plugs.
- This module can be ~use~-d into a module in order to build a plug
  pipeline:
  #+BEGIN_SRC elixir
    defmodule MyApp do
      use Plug.Builder

      plug Plug.Logger
      plug :hello, upper: true

      # A function from another module can be plugged too, provided it's
      # imported into the current module first.
      import AnotherModule, only: [interesting_plug: 2]
      plug :interesting_plug

      def hello(conn, opts) do
        body = if opts[:upper], do: "WORLD", else: "world"
        send_resp(conn, 200, body)
      end
    end
  #+END_SRC
  + The plugs in the pipeline will be executed in the order they’ve
    been added through the ~plug/2~ macro
  + ~Plug.Builder~ also imports the ~Plug.Conn~ module, making functions
    like ~send_resp/3~ available.
** Options
- When used, the following options are accepted by ~Plug.Builder~:
  + ~:log_on_halt~ - accepts the level to log whenever the request is
    halted
  + ~:init_mode~ - the environment to initialize the plug’s options,
    one of ~:compile~ or ~:runtime~. Defaults ~:compile~.
** Plug behaviour
- Internally, ~Plug.Builder~ implements the Plug behaviour, which means
  both the ~init/1~ and ~call/2~ functions are defined.
- By implementing the Plug API, ~Plug.Builder~ guarantees this module is
  a plug and can be handed to a web server or used as part of another
  pipeline.
** Overriding the default Plug API functions
- both the ~init/1~ and ~call/2~ functions defined by Plug.Builder can
  be manually overridden.
  #+BEGIN_SRC elixir
    defmodule PlugWithCustomOptions do
      use Plug.Builder
      plug Plug.Logger

      def init(opts) do
        opts
      end
    end
  #+END_SRC
  + The ~call/2~ function that ~Plug.Builder~ provides is used internally
    to execute all the plugs listed using the ~plug~ macro, so
    overriding the ~call/2~ function generally implies using ~super~ in
    order to still call the plug chain:
    #+BEGIN_SRC elixir
      defmodule PlugWithCustomCall do
        use Plug.Builder
        plug Plug.Logger
        plug Plug.Head

        def call(conn, opts) do
          conn
          |> super(opts) # calls Plug.Logger and Plug.Head
          |> assign(:called_all_plugs, true)
        end
      end
    #+END_SRC
** Halting a plug pipeline
- A plug pipeline can be halted with ~Plug.Conn.halt/1~.
- The builder will prevent further plugs downstream from being invoked
  and return the current connection.
  #+BEGIN_SRC elixir
    defmodule PlugUsingHalt do
      use Plug.Builder

      plug :stopper
      plug Plug.Logger

      def stopper(conn, _opts) do
        halt(conn)
      end
    end
  #+END_SRC
  ~Plug.Logger~ plug never gets called
** Functions
- ~builder_opts()~
  + Annotates a plug will receive the options given to the current
    module itself as arguments.
  + sample
    #+BEGIN_SRC elixir
      defmodule MyPlug do
        use Plug.Builder

        plug :inspect_opts, builder_opts()

        defp inspect_opts(conn, opts) do
          IO.inspect(opts)
          conn
        end
      end
    #+END_SRC
    When plugged as:
    #+BEGIN_SRC elixir
    plug MyPlug, custom: :options
    #+END_SRC
    It will print ~[custom: :options]~
  + Note you only pass ~builder_opts()~ to function plugs. You cannot
    use ~builder_opts()~ with module plugs because their options are
    evaluated at compile time.
    * do *NOT* do this:
      #+BEGIN_SRC elixir
      plug Plug.Parsers, builder_opts()
      #+END_SRC
      instead
      #+BEGIN_SRC elixir
        plug :custom_plug_parsers, builder_opts()

        defp custom_plug_parsers(conn, opts) do
          Plug.Parsers.call(conn, Plug.Parsers.init(opts))
        end
      #+END_SRC
- ~compile(env, pipeline, builder_opts)~
  + Compiles a plug pipeline.
  + Each element of the plug pipeline has the form: ~{plug_name, options, guards}~
  + Note that this function expects a reversed pipeline
  + Example
    #+BEGIN_SRC elixir
      Plug.Builder.compile(env, [
        {Plug.Logger, [], true}, # no guards, as added by the Plug.Builder.plug/2 macro
        {Plug.Head, [], quote(do: a when is_binary(a))}
      ], [])
    #+END_SRC
- ~plug(plug, opts \\ [])~
  + A macro that stores a new plug. ~opts~ will be passed unchanged to
    the new plug.
  + This macro doesn’t add any guards when adding the new plug to the
    pipeline; for adding plugs with guards see ~compile/1~.
  + Example
    #+BEGIN_SRC elixir
      plug Plug.Logger               # plug module
      plug :foo, some_options: true  # plug function
    #+END_SRC
* Plug.Conn
- This module defines a ~Plug.Conn~ struct and the main functions for
  working with Plug connections.
- Note request headers are normalized to lowercase and response
  headers are expected to have lowercase keys.
** Request fields
- These fields contain request information:
  + ~host~
    * the requested host as a binary, example: ~"www.example.com"~

  + ~method~
    * the request method as a binary, example: ~"GET"~

  + ~path_info~
    * the path split into segments, example: ~["hello", "world"]~

  + ~script_name~
    * the initial portion of the URL’s path that corresponds to the
      application routing, as segments, example: ~["sub","app"]~

  + ~request_path~
    * the requested path, example: ~/trailing/and//double//slashes/~

  + ~port~
    * the requested port as an integer, example: ~80~

  + ~remote_ip~
    * the IP of the client, example: ~{151, 236, 219, 228}~. This field
      is meant to be overwritten by plugs that understand e.g. the
      ~X-Forwarded-For~ header or HAProxy’s PROXY protocol. It defaults
      to peer’s IP

  + ~req_headers~ - the request headers as a list, example:
    ~[{"content-type", "text/plain"}]~. Note all headers will be
    downcased

  + ~scheme~ - the request scheme as an atom, example: ~:http~

  + ~query_string~ - the request query string as a binary, example:
    ~"foo=bar"~
** Fetchable fields
- The request information in these fields is not populated until it is
  fetched using the associated ~fetch_*~ function. For example, the
  cookies field uses ~fetch_cookies/2~.
- If you access these fields before fetching them, they will be
  returned as ~Plug.Conn.Unfetched~ structs.
- fields
  ~cookies-~
    + the request cookies with the response cookies
  ~body_params~
    + the request body params, populated through a ~Plug.Parsers~ parser.
  ~query_params~
    + the request query params, populated through ~fetch_query_params/2~
  ~path_params~
    + the request path params, populated by routers such as ~Plug.Router~
  ~params~ -
    + the request params, the result of merging the ~:body_params~ and
      ~:query_params~ with :~path_params~
  ~req_cookies~
    + the request cookies (without the response ones)
** Response fields
- These fields contain response information:
  + ~resp_body~
    * the response body, by default is an empty string. It is set to
      ~nil~ after the response is sent, except for test connections.
  + ~resp_charset~
    * the response charset, defaults to “utf-8”
  + ~resp_cookies~
    * the response cookies with their name and options
  + ~resp_headers~
    * the response headers as a list of tuples, by default
      ~cache-control~ is set to ~"max-age=0, private, must-revalidate"~.
      Note, response headers are expected to have lowercase keys.
  + ~status~
    * the response status
  + Furthermore, the ~before_send~ field stores callbacks that are
    invoked before the connection is sent. Callbacks are invoked in
    the reverse order they are registered (callbacks registered first
    are invoked last) in order to reproduce a pipeline ordering.
** Connection fields
- ~assigns~
  + shared user data as a map
- ~owner~
  + the Elixir process that owns the connection
- ~halted~
  + the boolean status on whether the pipeline was halted
- ~secret_key_base~
  + a secret key used to verify and encrypt cookies. the field must be set manually whenever one of those features are used. This data must be kept in the connection and never used directly, always use Plug.Crypto.KeyGenerator.generate/3 to derive keys from it
- ~state~
  + the connection state
  + The connection state is used to track the connection lifecycle.
  + It starts as ~:unset~ but is changed to
    * ~:set~ (via ~resp/3~)
    * ~:set_chunked~ (used only for ~before_send~ callbacks by ~send_chunked/2~)
    * ~:file~ (when invoked via ~send_file/3~).
  + Its final result is ~:sent~, ~:file~ or ~:chunked~ depending on the response model.
** Private fields
- These fields are reserved for libraries/framework usage.
  + ~adapter~ - holds the adapter information in a tuple
  + ~private~ - shared library data as a map
** Custom status codes
- Plug allows status codes to be overridden or added in order to allow
  new codes not directly specified by Plug or its adapters.
- Adding or overriding a status code is done through the Mix
  configuration of the ~:plug~ application.
  #+BEGIN_SRC elixir
    config :plug, :statuses, %{
      404 => "Actually This Was Found",
      998 => "Not An RFC Status Code"
    }
  #+END_SRC
  Plug will need to be recompiled for the changes to take place:
  #+BEGIN_SRC
  mix deps.clean --build plug
  #+END_SRC
  Now we can use the atoms that can be used in place of the status
  code in many functions
  #+BEGIN_SRC elixir
    put_status(conn, :not_found)                     # 404
    put_status(conn, :actually_this_was_found)       # 404
    put_status(conn, :not_an_rfc_status_code)        # 998

    send_resp(conn, :not_an_rfc_status_code, body)
  #+END_SRC
** functions
- ~assign(conn, key, value)~
  + Assigns a value to a key in the connection
  + The "assigns" storage is meant to be used to store values in the
    connection so that other plugs in your plug pipeline can access
    them. The assigns storage is a map.
  + eg
    #+BEGIN_SRC elixir
      iex> conn.assigns[:hello]
      nil

      iex> conn = assign(conn, :hello, :world)

      iex> conn.assigns[:hello]
      :world
    #+END_SRC
- ~chunk(conn, chunk)~
  + Sends a chunk as part of a chunked response
  + It expects a connection with state ~:chunked~ as set by
    ~send_chunked/2~. It returns ~{:ok, conn}~ in case of success,
    otherwise ~{:error, reason}~.
  + e.g
    #+BEGIN_SRC elixir
          conn = send_chunked(conn, 200)

          Enum.reduce_while(~w(each chunk as a word), conn, fn chunk, conn ->
            case Plug.Conn.chunk(conn, chunk <> " ") do
              {:ok, conn} ->
                {:cont, conn}

              {:error, :closed} ->
                {:halt, conn}
            end
          end)
    #+END_SRC
- ~clear_session(conn)~
  + Clears the entire session
  + This function removes every key from the session, clearing the
    session.
  + Note that, even if ~clear_session/1~ is used, the session is still
    sent to the client. If the session should be effectively dropped,
    ~configure_session/2~ should be used with the ~:drop~ option set to
    ~true~.
- ~configure_session(conn, opts)~
  + Configures the session
  + Options
    * ~:renew~ - generates a new session id for the cookie
    * ~:drop~ - drops the session, a session cookie will not be
      included in the response
    * ~:ignore~ - ignores all changes made to the session in this
      request cycle
- ~delete_req_header(conn, key)~
  + Deletes a request header if present
  + Raises a ~Plug.Conn.AlreadySentError~ if the connection has
    already been ~:sent~ or ~:chunked~.
  + e.g.
    #+BEGIN_SRC elixir
    Plug.Conn.delete_req_header(conn, "content-type")
    #+END_SRC
- ~delete_resp_cookie(conn, key, opts \\ [])~
  + Deletes a response cookie
  + Deleting a cookie requires the same options as to when the cookie
    was put. Check ~put_resp_cookie/4~
- ~delete_resp_header(conn, key)~
  + Deletes a response header if present
  + Raises a ~Plug.Conn.AlreadySentError~ if the connection has
    already been ~:sent~ or ~:chunked~.
  + Examples
    #+BEGIN_SRC elixir
    Plug.Conn.delete_resp_header(conn, "content-type")
    #+END_SRC
- ~delete_session(conn, key)~
  + Deletes the session for the given ~key~
  + The ~key~ can be a string or an atom, where atoms are
    automatically converted to strings.
- ~fetch_cookies(conn, opts \\ [])~
  + Fetches cookies from the request headers
- ~fetch_query_params(conn, opts \\ [])~
  + Fetches query parameters from the query string
  + Params are decoded as ~"x-www-form-urlencoded"~ in which key/value
    pairs are separated by ~&~ and keys are separated from values by ~=~.
  + This function does not fetch parameters from the body. To fetch
    parameters from the body, use the ~Plug.Parsers~ plug.
  + ~opts~
    * ~:length~ - the maximum query string length. Defaults to ~1_000_000~ bytes.
- ~fetch_session(conn, opts \\ [])~
  + Fetches the session from the session store. Will also fetch cookies
- ~get_http_protocol(conn)~
  + Returns the HTTP protocol and version
  + e.g.
    #+BEGIN_SRC elixir
      iex> get_http_protocol(conn)
      :"HTTP/1.1"
    #+END_SRC
- ~get_peer_data(conn)~
  + Returns the request peer data if one is present
- ~get_req_header(conn, key)~
  + Returns the values of the request header specified by key
- ~get_resp_header(conn, key)~
  + Returns the values of the response header specified by ~key~
  + e.g.
    #+BEGIN_SRC elixir
      iex> conn = %{conn | resp_headers: [{"content-type", "text/plain"}]}
      iex> get_resp_header(conn, "content-type")
      ["text/plain"]
    #+END_SRC
- ~get_session(conn, key)~
  + Returns session value for the given ~key~. If ~key~ is not set,
    ~nil~ is returned
  + The key can be a string or an atom, where atoms are automatically converted to strings.
- ~halt(conn)~
  + Halts the Plug pipeline by preventing further plugs downstream
    from being invoked. See the docs for ~Plug.Builder~
- ~inform!(conn, status, headers \\ [])~
  + Sends an information response to a client but raises if the
    adapter does not support inform
- ~inform(conn, status, headers \\ [])~
  + Sends an informational response to the client
  + An informational response, such as an early hint, must happen
    prior to a response being sent. If an informational request is
    attempted after a response is sent then a
    ~Plug.Conn.AlreadySentError~ will be raised. Only status codes from
    100-199 are valid.
  + To use inform for early hints send one or more informs with a status of 103.
  + If the adapter does not support informational responses then this is a noop.
  + Most HTTP/1.1 clients do not properly support informational
    responses but some proxies require it to support server push for
    HTTP/2. You can call ~get_http_protocol/1~ to retrieve the protocol
    and version.
- ~merge_assigns(conn, keyword)~
  + Assigns multiple values to keys in the connection
  + Equivalent to multiple calls to ~assign/3~.
  + e.g.
    #+BEGIN_SRC elixir
      iex> conn.assigns[:hello]
      nil

      iex> conn = merge_assigns(conn, hello: :world)

      iex> conn.assigns[:hello]
      :world
    #+END_SRC
- ~merge_private(conn, keyword)~
  + Assigns *multiple* private keys and values in the connection
  + Equivalent to multiple ~put_private/3~ calls
  + e.g.
    #+BEGIN_SRC elixir
      iex> conn.private[:my_plug_hello]
      nil

      iex> conn = merge_private(conn, my_plug_hello: :world)

      iex> conn.private[:my_plug_hello]
      :world
    #+END_SRC
- ~merge_resp_headers(conn, headers)~
  + Merges a series of response headers into the connection
  + e.g.
    #+BEGIN_SRC elixir
    Plug.Conn.merge_resp_headers(conn, [{"content-type", "text/plain"}, {"X-1337", "5P34K"}])
    #+END_SRC
- ~prepend_resp_headers(conn, headers)~
  + Prepends the list of headers to the connection response headers
  + Similar to ~put_resp_header~ this functions adds a new response
    header (~key~) but rather then replacing the existing one it
    prepends another header with the same ~key~.
  + It is recommended for header keys to be in lowercase
  + Raises a ~Plug.Conn.AlreadySentError~ if the connection has
    already been ~:sent~ or ~:chunked~.
  + Raises a ~Plug.Conn.InvalidHeaderError~ if the header value contains
    control feed (~\r~) or newline (~\n~) characters.
  + e.g.
    #+BEGIN_SRC elixir
      Plug.Conn.prepend_resp_headers([{"content-type", "bar"}, {"content-type", "kar"}])
      # content-type will be `content-type: bar, kar`
    #+END_SRC
- ~push!(conn, path, headers \\ [])~
  + Pushes a resource to the client but raises if the adapter does not support server push
- ~push(conn, path, headers \\ [])~
  + Pushes a resource to the client
  + Server pushes must happen prior to a response being sent. If a
    server push is attempted after a response is sent then a
    ~Plug.Conn.AlreadySentError~ will be raised.
- ~put_private(conn, key, value)~
  + Assigns a new *private* key and value in the connection
  + This storage is meant to be used by libraries and frameworks to
    avoid writing to the user storage (the ~:assigns~ field). It is
    recommended for libraries/frameworks to prefix the keys with the
    library name.
  + For example, if a plug called ~my_plug~ needs to store a ~:hello~ key,
    it would store it as ~:my_plug_hello~:
    #+BEGIN_SRC elixir
      iex> conn.private[:my_plug_hello]
      nil

      iex> conn = put_private(conn, :my_plug_hello, :world)

      iex> conn.private[:my_plug_hello]
      :world
    #+END_SRC
- ~put_req_header(conn, key, value)~
  + Adds a new request header (~key~) if not present, otherwise
    replaces the previous value of that header with ~value~
  + It is recommended for header keys to be in lowercase,
  + Raises a ~Plug.Conn.AlreadySentError~ if the connection has already
    been ~:sent~ or ~:chunked~.
  + e.g.
    #+BEGIN_SRC elixir
      Plug.Conn.put_req_header(conn, "accept", "application/json")
    #+END_SRC
- ~put_resp_content_type(conn, content_type, charset \\ "utf-8")~
  + Sets the value of the ~"content-type"~ response header taking into
    account the ~charset~
  + If charset is ~nil~, the value of the ~"content-type"~ response
    header won’t specify a ~charset~.
  + e.g.
    #+BEGIN_SRC elixir
      conn = put_resp_content_type(conn, "application/json")
      get_resp_header(conn, "content-type")
      ["application/json; charset=utf-8"]
    #+END_SRC
- ~put_resp_cookie(conn, key, value, opts \\ [])~
  + Puts a response cookie in the connection
  + The cookie value is not automatically escaped. Therefore, if you
    want to store values with comma, quotes, and so on, you need to
    explicitly escape them or use a function such as
    ~Base.encode64(value, padding: false)~ when writing and
    ~Base.decode64(encoded, padding: false)~ when reading the
    cookie. Padding needs to be disabled since ~=~ is not a valid
    character in cookie values.
  + ~opts~
    * ~:domain~ - the domain the cookie applies to
    * ~:max_age~ - the cookie max-age, in seconds. Providing a value
      for this option will set both the max-age and expires cookie
      attributes
    * ~:path~ - the path the cookie applies to
    * ~:http_only~ - when false, the cookie is accessible beyond HTTP
    * ~:secure~ - if the cookie must be sent only over https. Defaults
      to true when the connection is HTTPS
    * ~:extra~ - string to append to cookie. Use this to take
      advantage of non-standard cookie attributes.
- ~put_resp_header(conn, key, value)~
  + Adds a new response header (~key~) if not present, otherwise
    replaces the previous value of that header with ~value~
  + It is recommended for header keys to be in lowercase
  + Raises a ~Plug.Conn.AlreadySentError~ if the connection has already
    been ~:sent~ or ~:chunked~.
  + Raises a ~Plug.Conn.InvalidHeaderError~ if the header value
    contains control feed (~\r~) or newline (~\n~) characters.
  + e.g.
    #+BEGIN_SRC elixir
    Plug.Conn.put_resp_header(conn, "content-type", "application/json")
    #+END_SRC
- ~put_session(conn, key, value)~
  + Puts the specified ~value~ in the session for the given ~key~
  + The key can be a string or an atom, where atoms are automatically
    converted to strings. Can only be invoked on unsent ~conn~s. Will
    raise otherwise.
- ~put_status(conn, status)~
  + Stores the given status code in the connection
  + The status code can be ~nil~, an integer, or an atom. The list of
    allowed atoms is available in ~Plug.Conn.Status~.
    ~:continue~ - 100
    ~:switching_protocols~ - 101
    ~:processing~ - 102
    ~:early_hints~ - 103
    ~:ok~ - 200
    ~:created~ - 201
    ~:accepted~ - 202
    ~:non_authoritative_information~ - 203
    ~:no_content~ - 204
    ~:reset_content~ - 205
    ~:partial_content~ - 206
    ~:multi_status~ - 207
    ~:already_reported~ - 208
    ~:im_used~ - 226
    ~:multiple_choices~ - 300
    ~:moved_permanently~ - 301
    ~:found~ - 302
    ~:see_other~ - 303
    ~:not_modified~ - 304
    ~:use_proxy~ - 305
    ~:switch_proxy~ - 306
    ~:temporary_redirect~ - 307
    ~:permanent_redirect~ - 308
    ~:bad_request~ - 400
    ~:unauthorized~ - 401
    ~:payment_required~ - 402
    ~:forbidden~ - 403
    ~:not_found~ - 404
    ~:method_not_allowed~ - 405
    ~:not_acceptable~ - 406
    ~:proxy_authentication_required~ - 407
    ~:request_timeout~ - 408
    ~:conflict~ - 409
    ~:gone~ - 410
    ~:length_required~ - 411
    ~:precondition_failed~ - 412
    ~:request_entity_too_large~ - 413
    ~:request_uri_too_long~ - 414
    ~:unsupported_media_type~ - 415
    ~:requested_range_not_satisfiable~ - 416
    ~:expectation_failed~ - 417
    ~:im_a_teapot~ - 418
    ~:misdirected_request~ - 421
    ~:unprocessable_entity~ - 422
    ~:locked~ - 423
    ~:failed_dependency~ - 424
    ~:unordered_collection~ - 425
    ~:upgrade_required~ - 426
    ~:precondition_required~ - 428
    ~:too_many_requests~ - 429
    ~:request_header_fields_too_large~ - 431
    ~:unavailable_for_legal_reasons~ - 451
    ~:internal_server_error~ - 500
    ~:not_implemented~ - 501
    ~:bad_gateway~ - 502
    ~:service_unavailable~ - 503
    ~:gateway_timeout~ - 504
    ~:http_version_not_supported~ - 505
    ~:variant_also_negotiates~ - 506
    ~:insufficient_storage~ - 507
    ~:loop_detected~ - 508
    ~:not_extended~ - 510
    ~:network_authentication_required~ - 511
  + e.g.
    #+BEGIN_SRC elixir
      Plug.Conn.put_status(conn, :not_found)
      Plug.Conn.put_status(conn, 200)
    #+END_SRC
- ~read_body(conn, opts \\ [])~
  + Reads the request body
  + This function reads a chunk of the request body up to a given
    length (specified by the ~:length~ option).
  + If there is more data to be read, then ~{:more, partial_body, conn}~
    is returned. Otherwise ~{:ok, body, conn}~ is returned.
  + In case of an error reading the socket, ~{:error, reason}~ is
    returned as per ~:gen_tcp.recv/2~.
  + Like all functions in this module, the ~conn~ returned by ~read_body~
    must be passed to the next stage of your pipeline and should not
    be ignored.
  + In order to, for instance, support slower clients you can tune the
    ~:read_length~ and ~:read_timeout~ options. These specify how much
    time should be allowed to pass for each read from the underlying
    socket.
  + Because the request body can be of any size, reading the body will
    only work once, as Plug will not cache the result of these
    operations.
  + If you need to access the body multiple times, it is your
    responsibility to store it.
  + keep in mind some plugs like ~Plug.Parsers~ may read the body, so
    the body may be unavailable after being accessed by such plugs.
  + ~opts~
    * ~:length~ - sets the maximum number of bytes to read from the
      body on every call, defaults to ~8_000_000~ bytes

    * ~:read_length~ - sets the amount of bytes to read at one time
      from the underlying socket to fill the chunk, defaults to
      ~1_000_000~ bytes

    * ~:read_timeout~ - sets the timeout for each socket read,
      defaults to ~15_000~ milliseconds
  + Example
    #+BEGIN_SRC elixir
    {:ok, body, conn} = Plug.Conn.read_body(conn, length: 1_000_000)
    #+END_SRC
- ~read_part_body(conn, opts)~
  + Reads the body of a multipart request
  + Returns ~{:ok, body, conn}~ if all body has been read, ~{:more, binary, conn}~
    otherwise, and ~{:done, conn}~ if there is no more body.
  + It accepts the same options as ~read_body/2~.
  + HTTP multipart formposts
    * A multipart formpost is what an HTTP client sends when an HTML
      form is submitted with enctype set to "multipart/form-data".
    * It is an HTTP POST request sent with the request body specially
      formatted as a series of "parts", separated with MIME
      boundaries.
    * An example piece of HTML would look like this:
      #+BEGIN_SRC html
        <form action="submit.cgi" method="post" enctype="multipart/form-data">
           Name: <input type="text" name="person"><br>
           File: <input type="file" name="secret"><br>
           <input type="submit" value="Submit">
        </form>
      #+END_SRC
    * [[https://ec.haxx.se/http-multipart.html][Read More]]
- ~read_part_headers(conn, opts \\ [])~
  + Reads the headers of a multipart request
  + It returns ~{:ok, headers, conn}~ with the headers or ~{:done, conn}~
    if there are no more parts.
  + Once ~read_part_headers/2~ is invoked, you may call ~read_part_body/2~
    to read the body associated to the headers. If ~read_part_headers/2~
    is called instead, the body is automatically skipped until the
    next part headers.
  + ~opts~
    * ~:length~ - sets the maximum number of bytes to read from the
      body for each chunk, defaults to 64_000 bytes
    * ~:read_length~ - sets the amount of bytes to read at one time
      from the underlying socket to fill the chunk, defaults to ~64_000~
      bytes
    * ~:read_timeout~ - sets the timeout for each socket read,
      defaults to ~5_000~ milliseconds
- ~register_before_send(conn, callback)~
  + Registers a callback to be invoked before the response is sent
  + Callbacks are invoked in the reverse order they are defined
    (callbacks defined first are invoked last).
  + Example
    * To log the status of requests being sent:
      #+BEGIN_SRC elixir
        require Logger

        Plug.Conn.register_before_send(conn, fn conn ->
          Logger.info("Sent a #{conn.status} response")
          conn
        end)
      #+END_SRC
- ~request_url(conn)~
  + Returns the full request URL
- ~resp(conn, status, body)~
  + Sets the response to the given ~status~ and ~body~
  + It sets the connection state to ~:set~ (if not already ~:set~) and
    raises ~Plug.Conn.AlreadySentError~ if it was already ~:sent~.
  + If you also want to send the response, use ~send_resp/1~ after this
    or use ~send_resp/3~.
  + e.g.
    #+BEGIN_SRC elixir
    conn
    |> Plug.Conn.resp(404, "Not found")
    |> Plug.Conn.send_resp()
    #+END_SRC
- ~send_chunked(conn, status)~
  + Sends the response headers as a chunked response
  + It expects a connection that has not been ~:sent~ yet and sets its
    state to ~:chunked~ afterwards.
  + After ~send_chunked/2~ is called, chunks can be sent to the client
    via the ~chunk/2~ function.
  + HTTP/2 does not support chunking and will instead stream the
    response without a transfer encoding.
  + When using HTTP/1.1, the Cowboy adapter will stream the response
    instead of emitting chunks if the ~content-length~ header has been
    set before calling ~send_chunked/2~.
- ~send_file(conn, status, file, offset \\ 0, length \\ :all)~
  + Sends a file as the response body with the given ~status~ and
    optionally starting at the given offset until the given length
  + If available, the file is sent directly over the socket using the
    operating system ~sendfile~ operation.
  + It expects a connection that has not been ~:sent~ yet and sets its
    state to ~:file~ afterwards. Otherwise raises
    ~Plug.Conn.AlreadySentError~.
  + e.g.
    #+BEGIN_SRC elixir
      Plug.Conn.send_file(conn, 200, "README.md")
    #+END_SRC
- ~send_resp(conn)~
  + Sends a response to the client
  + It expects the connection state to be ~:set~, otherwise raises an
    ~ArgumentError~ for ~:unset~ connections or a
    ~Plug.Conn.AlreadySentError~ for already ~:sent~ connections.
  + At the end sets the connection state to ~:sent~.
  + Note that this function does not halt the connection, so if
    subsequent plugs try to send another response, it will error
    out. Use ~halt/1~ after this function if you want to halt the plug
    pipeline.
  + e.g.
    #+BEGIN_SRC elixir
      conn
      |> Plug.Conn.resp(404, "Not found")
      |> Plug.Conn.send_resp()
    #+END_SRC

- ~send_resp(conn, status, body)~
  + Sends a response with the given status and body
  + This is equivalent to setting the status and the body and then
    calling ~send_resp/1~
  + Note that this function does not halt the connection, so if
    subsequent plugs try to send another response, it will error
    out. Use ~halt/1~ after this function if you want to halt the plug
    pipeline.
  + e.g.
    #+BEGIN_SRC elixir
      Plug.Conn.send_resp(conn, 404, "Not found")
    #+END_SRC

- ~update_req_header(conn, key, initial, fun)~
  + Updates a request header if present, otherwise it sets it to an initial value
  + Raises a ~Plug.Conn.AlreadySentError~ if the connection has
    already been ~:sent~ or ~:chunked~.
  + Only the first value of the header key is updated if present.
  + e.g.
    #+BEGIN_SRC elixir
      Plug.Conn.update_req_header(
        conn,
        "accept",
        "application/json; charset=utf-8",
        &(&1 <> "; charset=utf-8")
      )
    #+END_SRC

- ~update_resp_header(conn, key, initial, fun)~
  + Updates a response header if present, otherwise it sets it to an
    initial value
  + Raises a ~Plug.Conn.AlreadySentError~ if the connection has already
    been ~:sent~ or ~:chunked~.
  + Only the first value of the header ~key~ is updated if present.
  + e.g.
    #+BEGIN_SRC elixir
      Plug.Conn.update_resp_header(
        conn,
        "content-type",
        "application/json; charset=utf-8",
        &(&1 <> "; charset=utf-8")
      )
    #+END_SRC
* Plug.Debugger
- A module (not a plug) for debugging in development.
- This module is commonly used within a ~Plug.Builder~ or a ~Plug.Router~
  and it wraps the ~call/2~ function.
- Notice ~Plug.Debugger~ does not catch errors, as errors should still
  propagate so that the Elixir process finishes with the proper
  reason.
- This module does not perform any logging either, as all logging is
  done by the web server handler.
- If this module is used with ~Plug.ErrorHandler~, only one of
  them will effectively handle errors. For this reason, it is
  recommended that ~Plug.Debugger~ is used before ~Plug.ErrorHandler~ and
  only in particular environments, like ~:dev~.
- e.g.
  #+BEGIN_SRC elixir
    defmodule MyApp do
      use Plug.Builder

      if Mix.env == :dev do
        use Plug.Debugger, otp_app: :my_app
      end

      plug :boom

      def boom(conn, _) do
        # Error raised here will be caught and displayed in a debug page
        # complete with a stacktrace and other helpful info.
        raise "oops"
      end
    end
  #+END_SRC
  + ~opts~
    * ~:otp_app~ - the OTP application that is using Plug. This option
      is used to filter stacktraces that belong only to the given
      application.
    * ~:style~ - custom styles
    * ~:banner~ - the optional MFA which receives exception details
      and returns banner contents to appear at the top of the
      page. May be any string, including markup.
** Custom styles
- You may pass a ~:style~ option to customize the look of the HTML
  page.
  #+BEGIN_SRC elixir
    use Plug.Debugger, style:
      [primary: "#c0392b", logo: "data:image/png;base64,..."]
  #+END_SRC
  The following keys are available:
    ~:primary~ - primary color
    ~:accent~ - accent color
    ~:logo~ - logo URI, or ~nil~ to disable. The ~:logo~ is preferred to be a base64-encoded data URI
** Custom Banners
- You may pass an MFA (~{module, function, args}~) to be invoked when an
  error is rendered which provides a custom banner at the top of the
  debugger page. The function receives the following arguments, with
  the passed ~args~ concentated at the end:
  #+BEGIN_SRC elixir
  [conn, status, kind, reason, stacktrace]
  #+END_SRC
  For example, the following ~:banner~ option:
  #+BEGIN_SRC elixir
  use Plug.Debugger, banner: {MyModule, :debug_banner, []}
  #+END_SRC
  would invoke the function:
  #+BEGIN_SRC elixir
  MyModule.debug_banner(conn, status, kind, reason, stacktrace)
  #+END_SRC
** Links to the text editor
- If a ~PLUG_EDITOR~ environment variable is set, ~Plug.Debugger~ will
  use it to generate links to your text editor. The variable should be
  set with ~__FILE__~ and ~__LINE__~ placeholders which will be correctly
  replaced.

* Plug.ErrorHandler
- A module to be used in your existing plugs in order to provide error handling.
- once this module is used, a callback named ~handle_errors/2~ should be
  defined in your plug
- ~handle_errors/2~ callback should accept a connection and a map
  containing:
  + the exception kind (~:throw~, ~:error~ or ~:exit~),
  + the reason (an exception for errors or a term for others)
  + the stacktrace
- e.g.
  #+BEGIN_SRC elixir
    defmodule AppRouter do
      use Plug.Router
      use Plug.ErrorHandler

      plug :match
      plug :dispatch

      get "/hello" do
        send_resp(conn, 200, "world")
      end

      def handle_errors(conn, %{kind: _kind, reason: _reason, stack: _stack}) do
        send_resp(conn, conn.status, "Something went wrong")
      end
    end
  #+END_SRC
- After the callback is invoked, the error is re-raised.
- It is advised to do as little work as possible when handling errors
  and avoid accessing data like parameters and session, as the parsing
  of those is what could have led the error to trigger in the first
  place.
- Also notice that these pages are going to be shown in production. If
  you are looking for error handling to help during development,
  consider using ~Plug.Debugger~.
- *Note*: If this module is used with ~Plug.Debugger~, it must be used
  after ~Plug.Debugger~.
* Plug.Exception protocol
- A protocol that extends exceptions to be status-code aware.
- By default, it looks for an implementation of the protocol,
  otherwise checks if the exception has the ~:plug_status~ field or
  simply returns 500.
** Functions
- ~status(exception)~
  + Receives an exception and returns its HTTP status code.
* Plug.HTML
- Conveniences for generating HTML.
** Functions
- ~html_escape(data)~
  + Escapes the given HTML to string
  + e.g.
    #+BEGIN_SRC elixir
      iex> Plug.HTML.html_escape("foo")
      "foo"

      iex> Plug.HTML.html_escape("<foo>")
      "&lt;foo&gt;"

      iex> Plug.HTML.html_escape("quotes: \" & \'")
      "quotes: &quot; &amp; &#39;"
    #+END_SRC

- ~html_escape_to_iodata(data)~
  + Escapes the given HTML to iodata
  + e.g.
    #+BEGIN_SRC elixir
      iex> Plug.HTML.html_escape_to_iodata("foo")
      "foo"

      iex> Plug.HTML.html_escape_to_iodata("<foo>")
      [[[] | "&lt;"], "foo" | "&gt;"]

      iex> Plug.HTML.html_escape_to_iodata("quotes: \" & \'")
      [[[[], "quotes: " | "&quot;"], " " | "&amp;"], " " | "&#39;"]
    #+END_SRC
* Plug.Router
- A DSL to define a routing algorithm that works with Plug.
- It provides a set of macros to generate routes. For example:
  #+BEGIN_SRC elixir
    defmodule AppRouter do
      use Plug.Router

      plug :match
      plug :dispatch

      get "/hello" do
        send_resp(conn, 200, "world")
      end

      match _ do
        send_resp(conn, 404, "oops")
      end
    end
  #+END_SRC
- Each route receives a ~conn~ variable containing a ~Plug.Conn~ struct
  and it needs to return a connection, as per the Plug spec.
- A catch-all match is recommended to be defined, otherwise routing
  fails with a function clause error.
- The router is itself a plug, which means it can be invoked as:
  #+BEGIN_SRC elixir
  AppRouter.call(conn, AppRouter.init([]))
  #+END_SRC
- Each ~Plug.Router~ has a plug pipeline, defined by ~Plug.Builder~, and
  by default it requires two plugs: ~:match~ and ~:dispatch~.
- ~:match~ is responsible for finding a matching route which is then
  forwarded to ~:dispatch~.
  * This means users can easily hook into the router mechanism and add
    behaviour before match, before dispatch, or after both.
- All of the options given to use ~Plug.Router~ are forwarded to
  ~Plug.Builder~.
** Routes
- e.g.
   #+BEGIN_SRC elixir
     get "/hello" do
       send_resp(conn, 200, "world")
     end
   #+END_SRC
  a request will only match if it is a ~GET~ request and the route is
  ~/hello~. The supported HTTP methods are ~get~, ~post~, ~put~, ~patch~,
  ~delete~ and ~options~.
- A route can also specify parameters which will then be available in
  the function body:
  #+BEGIN_SRC elixir
    get "/hello/:name" do
      send_resp(conn, 200, "hello #{name}")
    end
  #+END_SRC
  The ~:name~ parameter will also be available in the function body as
  ~conn.params["name"]~ and ~conn.path_params["name"]~.
- globbing
  + a glob can’t be followed by other segments
  + e.g.
    #+BEGIN_SRC elixir
      get "/hello/*_rest" do
        send_resp(conn, 200, "matches all routes starting with /hello")
      end
    #+END_SRC
    or if you want to use it
    #+BEGIN_SRC elixir
      get "/hello/*glob" do
        send_resp(conn, 200, "route after /hello: #{inspect glob}")
      end
    #+END_SRC
- match
  + A ~match~ will match any route regardless of the HTTP method.
  + e.g.
    #+BEGIN_SRC elixir
      match "/hello" do
        send_resp(conn, 200, "world")
      end
    #+END_SRC
** Parameter Parsing
- Handling request data can be done through the ~Plug.Parsers~ plug.
- It provides support for parsing
  1. URL-encoded
  2. form-data
  3. JSON
- It provides a behaviour that others parsers can adopt
- Example of ~Plug.Parsers~ can be used in a ~Plug.Router~ router to parse
  the JSON-encoded body of a POST reques
  #+BEGIN_SRC elixir
    defmodule AppRouter do
      use Plug.Router

      plug :match
      plug Plug.Parsers, parsers: [:json],
                         pass:  ["application/json"],
                         json_decoder: Jason
      plug :dispatch

      post "/hello" do
        IO.inspect conn.body_params # Prints JSON POST body
        send_resp(conn, 200, "Success!")
      end
    end
  #+END_SRC
  + It is important that ~Plug.Parsers~ is placed before the
    ~:dispatch~ plug in the pipeline, otherwise the matched clause
    route will not receive the parsed body in its ~Plug.Conn~ argument
    when dispatched.
  + ~Plug.Parsers~ can also be plugged between ~:match~ and
    ~:dispatch~: this means that ~Plug.Parsers~ will run only if there
    is a matching route. This can be useful to perform actions such as
    authentication before parsing the body, which should only be
    parsed if a route matches afterwards.
** Passing data between routes and plugs
- It is also possible to assign data to the ~Plug.Conn~ that will be
  available to any plug invoked after the ~:match~ plug. This is very
  useful if you want a matched route to customize how later plugs will
  behave.
  + You can use ~:assigns~ (which contains user data) or ~:private~ (which
    contains library/framework data) for this. For example:
    #+BEGIN_SRC elixir
      get "/hello", assigns: %{an_option: :a_value} do
        send_resp(conn, 200, "world")
      end
    #+END_SRC
    It basically calls ~assign(conn, :an_option, :a_value)~. so
    ~conn.assigns[:an_option]~ will be available to all plugs invoked
    after ~:match~. Such plugs can read from ~conn.assigns~ (or
    ~conn.private~) to configure their behaviour based on the matched
    route.

** Routes compilation
- All routes are compiled to a match function that receives three
  arguments: the method, the request path split on ~/~ and the
  connection.
  #+BEGIN_SRC elixir
    match "/foo/bar", via: :get do
      send_resp(conn, 200, "hello world")
    end
  #+END_SRC
  It is compiled to:
  #+BEGIN_SRC elixir
  defp match("GET", ["foo", "bar"], conn) do
    send_resp(conn, 200, "hello world")
  end
  #+END_SRC
  This means guards can be given to ~match~:
  #+BEGIN_SRC elixir
    match "/foo/bar/:baz" when byte_size(baz) <= 3, via: :get do
      send_resp(conn, 200, "hello world")
    end
  #+END_SRC
  After a match is found, the block given as ~do/end~ is stored as a
  function in the connection. This function is then retrieved and
  invoked in the ~dispatch~ plug.
** Routes options
- Sometimes you may want to customize how a route behaves during
  dispatch. This can be done by accessing the ~opts~ variable inside
  the route:
  #+BEGIN_SRC elixir
    defmodule AppRouter do
      use Plug.Router

      plug :match
      plug :dispatch, content: "hello world"

      get "/hello" do
        send_resp(conn, 200, opts[:content])
      end

      match _ do
        send_resp(conn, 404, "oops")
      end
    end
  #+END_SRC
  - useful when used with ~Plug.Builder.builder_opts/0~. ~builder_opts/0~
    allows us to pass options received when initializing ~AppRouter~ to
    a specific plug, such as dispatch itself. So if instead of:
    #+BEGIN_SRC elixir
    plug :dispatch, content: "hello world"
    #+END_SRC
    we do:
    #+BEGIN_SRC elixir
    plug :dispatch, builder_opts()
    #+END_SRC
    now the content can be given when starting the router, like this:
    #+BEGIN_SRC elixir
    Plug.Cowboy.http AppRouter, [content: "hello world"]
    #+END_SRC
    Or as part of a pipeline like this:
    #+BEGIN_SRC elixir
    plug AppRouter, content: "hello world"
    #+END_SRC
    ~builder_opts()~ allows us to pass the options given when
    initializing the router to a dispatch.
** Functions
- ~delete(path, options, contents \\ [])~
  + Dispatches to the path only if the request is a DELETE
    request. See ~match/3~

- ~forward(path, options)~
  + Forwards requests to another Plug. The ~path_info~ of the forwarded
    connection will exclude the portion of the path specified in the
    call to ~forward~.
  + If the path contains any parameters, those will be available in
    the target Plug in ~conn.params~ and ~conn.path_params~
  + ~options~
    * ~:to~ - a Plug the requests will be forwarded to.
    * ~:init_opts~ - the options for the target Plug.
      - If ~:init_opts~ is undefined, then all remaining options are
        passed to the target plug.
    * ~:host~ - a string representing the host or subdomain, exactly like in ~match/3~.
    * ~:private~ - values for conn.private, exactly like in ~match/3~.
    * ~:assigns~ - values for conn.assigns, exactly like in ~match/3~.

  + e.g.
    #+BEGIN_SRC elixir
    forward "/users", to: UserRouter
    #+END_SRC
    a request to ~/users/sign_in~ will be forwarded to the ~UserRouter~
    plug, which will receive what it will see as a request to
    ~/sign_in~.
  + e.g.
    #+BEGIN_SRC elixir
    forward "/foo/:bar/qux", to: FooPlug
    #+END_SRC
    a request to ~/foo/BAZ/qux~ will be forwarded to the ~FooPlug~ plug,
    which will receive what it will see as a request to ~/~, and
    ~conn.params["bar"]~ will be set to ~"BAZ"~.
  + e.g.
    #+BEGIN_SRC elixir
    forward "/foo/bar", to: :foo_bar_plug, host: "foobar."
    forward "/baz", to: BazPlug, init_opts: [plug_specific_option: true]
    #+END_SRC

- ~get(path, options, contents \\ [])~
  + Dispatches to the path only if the request is a GET request. See
    ~match/3~

- ~match(path, options, contents \\ [])~
  + Main API to define routes
  + It accepts an expression representing the path and many options
    allowing the match to be configured.
  + The route can dispatch either to a function body or a Plug module.
  + e.g.
    #+BEGIN_SRC elixir
      match "/foo/bar", via: :get do
        send_resp(conn, 200, "hello world")
      end

      match "/baz", to: MyPlug, init_opts: [an_option: :a_value]
    #+END_SRC
  + ~options~
    ~match/3~ and the other route macros accept the following options:
    * ~:host~ - the host which the route should match. Defaults to
      ~nil~, meaning no host match, but can be a string like
      ~"example.com"~ or a string ending with ~"."~, like ~subdomain.~ for
      a subdomain match.
    * ~:private~ - assigns values to ~conn.private~ for use in the match
    * ~:via~ - matches the route against some specific HTTP method
      (specified as an atom, like ~:get~ or ~:put~)
    * ~:do~ - contains the implementation to be invoked in case the route matches.
    * ~:to~ - a Plug that will be called in case the route matches.
      - A route should specify only one of ~:do~ or ~:to~ options.
    * ~:init_opts~ - the options for the target Plug given by ~:to~.

- ~match_path(conn)~
  + Returns the path of the route that the request was matched to

- ~options(path, options, contents \\ [])~
  + Dispatches to the path only if the request is an OPTIONS
    request. See ~match/3~

- ~patch(path, options, contents \\ [])~
  + Dispatches to the path only if the request is a PATCH request. See
    ~match/3~

- ~post(path, options, contents \\ [])~
  + Dispatches to the path only if the request is a POST request. See
    ~match/3~

- ~put(path, options, contents \\ [])~
  + Dispatches to the path only if the request is a PUT request. See
    ~match/3~
* Plug.Test
- Conveniences for testing plugs
- This module can be used in your test cases, like this:
  #+BEGIN_SRC elixir
  use ExUnit.Case, async: true
  use Plug.Test
  #+END_SRC
- Using this module will:
  + import all the functions from this module
  + import all the functions from the ~Plug.Conn~ module
- By default, Plug tests checks for invalid header keys, e.g. header
  keys which include uppercase letters, and raises a
  ~Plug.Conn.InvalidHeaderError~ when it finds one. To disable it, set
  ~:validate_header_keys_during_test~ to ~false~ on the app config.
** Functions
- ~conn(method, path, params_or_body \\ nil)~
  + Creates a test connection
  + The request ~method~ and ~path~ are required arguments. method may be
    any value that implements ~to_string/1~ and it will properly
    converted and normalized (e.g., ~:get~ or ~"post"~).
  + The ~params_or_body~ field must be one of:
    * ~nil~ - meaning there is no body;
    * a binary - containing a request body. For such cases, ~:headers~
      must be given as option with a ~content-type~;
    * a map or list - containing the parameters which will
      automatically set the ~content-type~ to multipart. The map or list
      may contain other lists or maps and all entries will be
      normalized to string keys;
  + e.g.
    #+BEGIN_SRC elixir
      conn(:get, "/foo?bar=10")
      conn(:get, "/foo", %{bar: 10})
      conn(:post, "/")
      conn("patch", "/", "") |> put_req_header("content-type", "application/json")
    #+END_SRC

- ~delete_req_cookie(conn, key)~
  + Deletes a request cookie

- ~init_test_session(conn, session)~
  + Initializes the session with the given contents
  + If the session has already been initialized, the new contents will
    be merged with the previous ones.

- ~put_http_protocol(conn, http_protocol)~
  + Puts the http protocol
  + This function copies the cookie information in ~old_conn~ into
    ~new_conn~, emulating multiple requests done by clients where
    cookies are always passed forward, and returns the new version of
    ~new_conn~.

- ~put_peer_data(conn, peer_data)~
  + Puts the peer data

- ~put_req_cookie(conn, key, value)~
  + Puts a request cookie

- ~recycle_cookies(new_conn, old_conn)~
  + Moves cookies from a connection into a new connection for
    subsequent requests

- ~sent_informs(conn)~
  + Return the informational requests that have been sent

- ~sent_pushes(conn)~
  + Return the assets that have been pushed

- ~sent_resp(conn)~
  + Returns the sent response
* Plug.Upload
- A server (a ~GenServer~ specifically) that manages uploaded files.
- Uploaded files are stored in a temporary directory and removed from
  that directory after the process that requested the file dies.
- During the request, files are represented with a ~Plug.Upload~ struct
  that contains three fields:
  + ~:path~ - the path to the uploaded file on the filesystem
  + ~:content_type~ - the content type of the uploaded file
  + ~:filename~ - the filename of the uploaded file given in the request
- Note: as mentioned in the documentation for ~Plug.Parsers~, the ~:plug~
  application has to be started in order to upload files and use the
  ~Plug.Upload~ module.
** Functions
- ~child_spec(init_arg)~
  + Returns a specification to start this module under a supervisor

- ~init(atom)~
  + Invoked when the server is started. ~start_link/3~ or ~start/3~ will
    block until it returns
  + ~init_arg~ is the argument term (second argument) passed to
    ~start_link/3~.
  + Returning ~{:ok, state}~ will cause ~start_link/3~ to return
    ~{:ok, pid}~ and the process to enter its loop.
  +

- ~random_file!(prefix)~
  + Requests a random file to be created in the upload directory with
    the given prefix. Raises on failure

- ~random_file(prefix)~
  + Requests a random file to be created in the upload directory with
    the given prefix

- ~start_link()~
  + Starts the upload handling server
* Plugs
** Plug.CSRFProtection
- Plug to protect from cross-site request forgery.
- For this plug to work, it expects a session to have been previously
  fetched.
- It will compare the token stored in the session with the one
  sent by the request to determine the validity of the request. For an
  invalid request the action taken is based on the ~:with~ option.
- The token may be sent by the request either via the params with key
  ~"_csrf_token"~ or a header with name ~"x-csrf-token"~.
- GET requests are not protected, as they should not have any
  side-effect or change your application state.
  + JavaScript requests are an exception: by using a script tag,
    external websites can embed server-side generated JavaScript,
    which can leak information. For this reason, this plug also
    forbids any GET JavaScript request that is not XHR (or AJAX).
- Note that it is recommended to enable ~CSRFProtection~ whenever a
  session is used, even for JSON requests.
*** Token generation
- This plug won’t generate tokens automatically. Instead, tokens will
  be generated only when required by calling ~get_csrf_token/0~.
- In case you are generating the token for certain specific URL, you
  should use ~get_csrf_token_for/1~ as that will avoid tokens from being
  leaked to other applications.
- Once a token is generated, it is cached in the process
  dictionary. The CSRF token is usually generated inside forms which
  may be isolated from ~Plug.Conn~.
  + Storing them in the process dictionary allows them to be generated
    as a side-effect only when necessary,
*** Cross-host protection
- If you are sending data to a full URI, such as
  ~//subdomain.host.com/path~ or ~//external.com/path~, instead of a
  simple path such as ~/path~, you may want to consider using
  ~get_csrf_token_for/1~, as that will encode the host in the CSRF
  token. Once received, Plug will only consider the CSRF token to be
  valid if the ~host~ encoded in the token is the same as the one in
  ~conn.host~.
  + You can pass the ~:allow_hosts~ option to control any host that you
    may want to allow. The values in ~:allow_hosts~ may either be a full
    host name or a host suffix. For example: ~["www.example.com", ".subdomain.example.com"]~
    will allow the exact host of ~"www.example.com"~ and any host that ends with ~".subdomain.example.com"~.
*** Options
- ~:session_key~ - the name of the key in session to store the token under
- ~:allow_hosts~ - a list with hosts to allow on cross-host tokens
- ~:with~ - should be one of :exception or :clear_session. Defaults to ~:exception~.
  + ~:exception~ - for invalid requests, this plug will raise
    ~Plug.CSRFProtection.InvalidCSRFTokenError~.
  + ~:clear_session~ - for invalid requests, this plug will set an
    empty session for only this request. Also any changes to the
    session during this request will be ignored.
*** Disabling
- You may disable this plug by doing ~Plug.Conn.put_private(conn,
  :plug_skip_csrf_protection, true)~.
- This was made available for disabling ~Plug.CSRFProtection~ in tests
  and not for dynamically skipping ~Plug.CSRFProtection~ in production
  code.
-  If you want specific routes to skip ~Plug.CSRFProtection~, then use a
  different stack of plugs for that route that does not include
  ~Plug.CSRFProtection~.
*** Examples
    #+BEGIN_SRC elixir
      plug Plug.Session, ...
      plug :fetch_session
      plug Plug.CSRFProtection
    #+END_SRC
*** Functions
- ~call(conn, arg)~
  + Callback implementation for ~Plug.call/2~

- ~delete_csrf_token()~
  + Deletes the CSRF token from the process dictionary
  + This will force the token to be deleted once the response is sent.

- ~get_csrf_token()~
  + Gets the CSRF token
  + Generates a token and stores it in the process dictionary if one does not exist.

- ~get_csrf_token_for(url)~
  + Gets the CSRF token for the associated URL (as a string or a URI struct)
  + If the URL has a host, a CSRF token that is tied to that host will
    be generated. If it is a relative path URL, a simple token emitted
    with ~get_csrf_token/0~ will be used.
- ~init(opts)~
  + Callback implementation for ~Plug.init/1~
** Plug.Head
- A Plug to convert ~HEAD~ requests to ~GET~ requests.
- e.g.
  #+BEGIN_SRC elixir
    Plug.Head.call(conn, [])
  #+END_SRC
** Plug.Logger
- A plug for logging basic request information in the format:
  #+BEGIN_SRC
  GET /index.html
  Sent 200 in 572ms
  #+END_SRC
- To use it, just plug it into the desired module.
  #+BEGIN_SRC elixir
  plug Plug.Logger, log: :debug
  #+END_SRC
- Options
  + ~:log~ - The log level at which this plug should log its request
    info. Default is ~:info~.
** Plug.MethodOverride
- This plug overrides the request’s ~POST~ method with the method
  defined in the ~_method~ request parameter.
- The ~POST~ method can be overridden only by these HTTP methods:
  + ~PUT~
  + ~PATCH~
  + ~DELETE~
- This plug expects the body parameters to be already parsed and
  fetched. Those can be fetched with ~Plug.Parsers~.
-  Examples
  #+BEGIN_SRC elixir
  Plug.MethodOverride.call(conn, [])
  #+END_SRC
** Plug.Parsers behaviour
- A plug for parsing the request body.
- This module also specifies a behaviour that all the parsers to be
  used with Plug should adopt.
- This plug also fetches query params in the connection through
  ~Plug.Conn.fetch_query_params/2~.
- Once a connection goes through this plug, it will have ~:body_params~
  set to the map of params parsed by one of the parsers listed in
  ~:parsers~ and ~:params~ set to the result of merging the ~:body_params~
  and ~:query_params~.
- This plug will raise ~Plug.Parsers.UnsupportedMediaTypeError~ by
  default if the request cannot be parsed by any of the given types
  and the MIME type has not been explicitly accepted with the ~:pass~
  option.
- ~Plug.Parsers.RequestTooLargeError~ will be raised if the request
  goes over the given limit.
- Parsers may raise a ~Plug.Parsers.ParseError~ if the request has a
  malformed body.
- This plug only parses the body if the request method is one of the
  following:
  + ~POST~
  + ~PUT~
  + ~PATCH~
  + ~DELETE~
  + For requests with a different request method, this plug will only
    fetch the query params.
*** Options
- ~:parsers~ - a list of modules or atoms of built-in parsers to be
  invoked for parsing. These modules need to implement the behaviour
  outlined in this module.
- ~:pass~ - an optional list of MIME type strings that are allowed to
  pass through. Any mime not handled by a parser and not explicitly
  listed in ~:pass~ will raise ~UnsupportedMediaTypeError~. For example:
  ~["*/*"]~ - never raises
  ~["text/html", "application/*"]~ - doesn’t raise for those values
  ~[]~ - always raises (default)
- ~:query_string_length~ - the maximum allowed size for query strings
- ~:body_reader~ - an optional replacement (or wrapper) for
  ~Plug.Conn.read_body/2~ to provide a function that gives access to the
  raw body before it is parsed and discarded. It is in the standard
  format of ~{Module, :function, [args]}~ (MFA) and defaults to
  ~{Plug.Conn, :read_body, []}~.
*** Examples
#+BEGIN_SRC elixir
plug Plug.Parsers, parsers: [:urlencoded, :multipart]

plug Plug.Parsers, parsers: [:urlencoded, :json],
                   pass: ["text/*"],
                   json_decoder: Jason
#+END_SRC
- Each parser also accepts options to be given directly to it by using
  tuples. For example, to support file uploads it is common to pass
  the ~:length~, ~:read_length~ and ~:read_timeout~ option to the multipart
  parser:
  #+BEGIN_SRC elixir
    plug Plug.Parsers,
         parsers: [
           :url_encoded,
           {:multipart, length: 20_000_000} # Increase to 20MB max upload
         ]
  #+END_SRC
*** Built-in parsers
- Plug ships with the following parsers:
  + ~Plug.Parsers.URLENCODED~ - parses
    ~application/x-www-form-urlencoded~ requests (can be used as
    ~:urlencoded~ as well in the ~:parsers~ option)

  + ~Plug.Parsers.MULTIPART~ - parses ~multipart/form-data~ and
    ~multipart/mixed~ requests (can be used as ~:multipart~ as well in the
    ~:parsers~ option)

  + ~Plug.Parsers.JSON~ - parses ~application/json~ requests with the
    given ~:json_decoder~ (can be used as ~:json~ as well in the ~:parsers~
    option)
*** File handling
- If a file is uploaded via any of the parsers, Plug will stream the
  uploaded contents to a file in a temporary directory in order to
  avoid loading the whole file into memory. For such, the ~:plug~
  application needs to be started in order for file uploads to work.
- Read [[https://hexdocs.pm/plug/Plug.Upload.html][Plug.Upload]]
- When a file is uploaded, the request parameter that identifies that
  file will be a Plug.Upload struct with information about the
  uploaded file (e.g. filename and content type) and about where the
  file is stored.
- The temporary directory where files are streamed to can be
  customized by setting the ~PLUG_TMPDIR~ environment variable on the
  host system. If ~PLUG_TMPDIR~ isn’t set, Plug will look at some
  environment variables which usually hold the value of the system’s
  temporary directory (like ~TMPDIR~ or ~TMP~). If no value is found in
  any of those variables, ~/tmp~ is used as a default.
*** Custom body reader
- Sometimes you may want to customize how a parser reads the body from
  the connection. For example, you may want to cache the body to
  perform verification later, such as HTTP Signature
  Verification. This can be achieved with a custom body reader that
  would read the body and store it in the connection, such as:
  #+BEGIN_SRC elixir
    defmodule CacheBodyReader do
      def read_body(conn, opts) do
        {:ok, body, conn} = Plug.Conn.read_body(conn, opts)
        conn = update_in(conn.assigns[:raw_body], &[body | (&1 || [])])
        {:ok, body, conn}
      end
    end
  #+END_SRC
  which could then be set as:
  #+BEGIN_SRC elixir
    plug Plug.Parsers,
      parsers: [:urlencoded, :json],
      pass: ["text/*"],
      body_reader: {CacheBodyReader, :read_body, []},
      json_decoder: Jason
  #+END_SRC
*** Callbacks
- ~init(opts)~
- ~parse(conn, type, subtype, params, opts)~
  + Attempts to parse the connection’s request body given the
    content-type type, subtype, and its parameters.
  + The arguments are:
    * the ~Plug.Conn~ connection

    * ~type~, the content-type type (e.g., ~"x-sample"~ for the
      ~"x-sample/json"~ content-type)

    * ~subtype~, the content-type subtype (e.g., ~"json"~ for the
      ~"x-sample/json"~ content-type)

    * ~params~, the content-type parameters (e.g., ~%{"foo" => "bar"}~
      for the ~"text/plain; foo=bar"~ content-type)
- This function should return:
  + ~{:ok, body_params, conn}~ if the parser is able to handle the
    given content-type; ~body_params~ should be a map

  + ~{:next, conn}~ if the next parser should be invoked

  + ~{:error, :too_large, conn}~ if the request goes over the given
    limit

** Plug.RequestId
- A plug for generating a unique request id for each request.
- The generated request id will be in the format
  "uq8hs30oafhj5vve8ji5pmp7mtopc08f".
- If a request id already exists as the "x-request-id" HTTP request
  header, then that value will be used assuming it is between 20 and
  200 characters. If it is not, a new request id will be generated.
- The request id is added to the Logger metadata as ~:request_id~ and
  the response as the "x-request-id" HTTP header. To see the request
  id in your log output, configure your logger backends to include the
  ~:request_id~ metadata:
  #+BEGIN_SRC elixir
    config :logger, :console, metadata: [:request_id]
  #+END_SRC
- It is recommended to include this metadata configuration in your
  production configuration file.
- To use it
  #+BEGIN_SRC elixir
  plug Plug.RequestId
  #+END_SRC
*** Options
- ~:http_header~ - The name of the HTTP request header to check for
  existing request ids. This is also the HTTP response header that
  will be set with the request id. Default value is "x-request-id"
  #+BEGIN_SRC elixir
  plug Plug.RequestId, http_header: "custom-request-id"
  #+END_SRC
** Plug.SSL
- A plug to force SSL connections and enable HSTS.
- If the scheme of a request is ~https~, it’ll add a
  ~strict-transport-security~ header to enable HTTP Strict Transport
  Security by default.
- Otherwise, the request will be redirected to a corresponding
  location with the ~https~ scheme by setting the ~location~ header of the
  response. The status code will be 301 if the method of ~conn~ is ~GET~
  or ~HEAD~, or 307 in other situations.
*** x-forwarded-proto
- If your Plug application is behind a proxy that handles HTTPS, you
  will need to tell Plug to parse the proper protocol from the
  ~x-forwarded-proto~ header. This can be done using the ~:rewrite_on~
  option:
  #+BEGIN_SRC elixir
    plug Plug.SSL, rewrite_on: [:x_forwarded_proto]
  #+END_SRC
  The command above will effectively change the value of ~conn.scheme~
  to the one sent in ~x-forwarded-proto~.
- Since rewriting the scheme based on ~x-forwarded-proto~ can open up
  security vulnerabilities, only provide the option above if:
  + your app is behind a proxy
  + your proxy strips ~x-forwarded-proto~ headers from all incoming requests
  + your proxy sets the ~x-forwarded-proto~ and sends it to Plug
*** Options
- ~:rewrite_on~ - rewrites the scheme to https based on the given
  headers

- ~:hsts~ - a boolean on enabling HSTS or not, defaults to ~true~

- ~:expires~ - seconds to expires for HSTS, defaults to ~7884000~ (three
  months)

- ~:preload~ - a boolean to request inclusion on the HSTS preload list
  (see: [[hstspreload.org][Chromium HSTS submission site]] and [[https://blog.mozilla.org/security/2012/11/01/preloading-hsts/][Firefox]]), defaults to ~false~

- ~:subdomains~ - a boolean on including subdomains or not in HSTS,
  defaults to ~false~

- ~:exclude~ - exclude the given hosts from redirecting to the ~https~
  scheme. Defaults to ~["localhost"]~

- ~:host~ - a new host to redirect to if the request’s scheme is
  ~http~, defaults to ~conn.host~. It may be set to a binary or a
  tuple ~{module, function, args}~ that will be invoked on demand

- ~:log~ - The log level at which this plug should log its request
  info. Default is ~:info~. Can be ~false~ to disable logging.
***  Port
- It is not possible to directly configure the port in ~Plug.SSL~
  because HSTS expects the port to be 443 for SSL. If you are not
  using HSTS and want to redirect to HTTPS on another port, you can
  sneak it alongside the host, for example: host: ~"example.com:443"~.
** Plug.Session
- A plug to handle session cookies and session stores.
- The session is accessed via functions on ~Plug.Conn~. Cookies and
  session have to be fetched with ~Plug.Conn.fetch_session/1~ before the
  session can be accessed.
- Consider using ~Plug.CSRFProtection~ when using ~Plug.Session~.
*** Session stores
- See ~[[https://hexdocs.pm/plug/Plug.Session.Store.html][Plug.Session.Store]]~ for the specification session stores are
  required to implement.
- Plug ships with the following session stores:
  + ~Plug.Session.ETS~
  + ~Plug.Session.COOKIE~
*** Options
- ~:store~ - session store module (required);
- ~:key~ - session cookie key (required);
- ~:domain~ - see ~[[https://hexdocs.pm/plug/Plug.Conn.html#put_resp_cookie/4][Plug.Conn.put_resp_cookie/4]]~;
- ~:max_age~ - see ~[[https://hexdocs.pm/plug/Plug.Conn.html#put_resp_cookie/4][Plug.Conn.put_resp_cookie/4]]~;
- ~:path~ - see ~[[https://hexdocs.pm/plug/Plug.Conn.html#put_resp_cookie/4][Plug.Conn.put_resp_cookie/4]]~;
- ~:secure~ - see ~[[https://hexdocs.pm/plug/Plug.Conn.html#put_resp_cookie/4][Plug.Conn.put_resp_cookie/4]]~;
- ~:http_only~ - see ~[[https://hexdocs.pm/plug/Plug.Conn.html#put_resp_cookie/4][Plug.Conn.put_resp_cookie/4]]~;
- ~:extra~ - see ~[[https://hexdocs.pm/plug/Plug.Conn.html#put_resp_cookie/4][Plug.Conn.put_resp_cookie/4]]~;
- Additional options can be given to the session store,

*** Examples
#+BEGIN_SRC elixir
plug Plug.Session, store: :ets, key: "_my_app_session", table: :session
#+END_SRC

*** Plug.Session.ETS
- Stores the session in an in-memory ETS table.
- This store does not create the ETS table; it expects that an
  existing named table with public properties is passed as an
  argument.
- We don’t recommend using this store in production as every session
  will be stored in ETS and never cleaned until you create a task
  responsible for cleaning up old entries.
- Also, since the store is in-memory, it means sessions are not shared
  between servers. If you deploy to more than one machine, using this
  store is again not recommended.
- This store, however, can be used as an example for creating custom
  storages, based on Redis, Memcached, or a database itself.
**** Options
- ~:table~ - ETS table name (required)
**** Storage
- The data is stored in ETS in the following format:
  #+BEGIN_SRC elixir
  {sid :: String.t, data :: map, timestamp :: :erlang.timestamp}
  #+END_SRC
  + The timestamp is updated whenever there is a read or write to the
    table and it may be used to detect if a session is still active.
**** Examples
#+BEGIN_SRC elixir
# Create an ETS table when the application starts
:ets.new(:session, [:named_table, :public, read_concurrency: true])

# Use the session plug with the table name
plug Plug.Session, store: :ets, key: "sid", table: :session
#+END_SRC

**** Functions
- ~delete(conn, sid, table)~
  + Removes the session associated with given session id from the
    store
  + Callback implementation for ~Plug.Session.Store.delete/3~.

- ~get(conn, sid, table)~
  + Parses the given cookie
  + Returns a session id and the session contents. The session id is
    any value that can be used to identify the session by the store.
  + The session id may be ~nil~ in case the cookie does not identify any
    value in the store. The session contents must be a map.
  + Callback implementation for ~Plug.Session.Store.get/3~.

- ~init(opts)~
  + Initializes the store
  + The options returned from this function will be given to ~get/3~,
    ~put/4~ and ~delete/3~.
  + Callback implementation for ~Plug.Session.Store.init/1~.

- ~put(conn, sid, data, table)~
  + Stores the session associated with given session id
  + If ~nil~ is given as id, a new session id should be generated and
    returned.
  + Callback implementation for ~Plug.Session.Store.put/4~.
*** Plug.Session.COOKIE
- Stores the session in a cookie.
- This cookie store is based on ~Plug.Crypto.MessageVerifier~ and
  ~Plug.Crypto.MessageEncryptor~ which encrypts and signs each cookie to
  ensure they can’t be read nor tampered with.
- Since this store uses crypto features, it requires you to set the
  ~:secret_key_base~ field in your connection. This can be easily
  achieved with a plug:
  #+BEGIN_SRC elixir
  def put_secret_key_base(conn, _) do
    put_in conn.secret_key_base, "-- LONG STRING WITH AT LEAST 64 BYTES --"
  end
  #+END_SRC
**** Options
- ~:encryption_salt~ - a salt used with ~conn.secret_key_base~ to
  generate a key for encrypting/decrypting a cookie, can be either a
  binary or an MFA returning a binary;

- ~:signing_salt~ - a salt used with ~conn.secret_key_base~ to generate
  a key for signing/verifying a cookie, can be either a binary or an
  MFA returning a binary;

- ~:key_iterations~ - option passed to ~Plug.Crypto.KeyGenerator~ when
  generating the encryption and signing keys. Defaults to 1000;

- ~:key_length~ - option passed to ~Plug.Crypto.KeyGenerator~ when
  generating the encryption and signing keys. Defaults to 32;

- ~:key_digest~ - option passed to ~Plug.Crypto.KeyGenerator~ when
  generating the encryption and signing keys. Defaults to ~:sha256~;

- ~:serializer~ - cookie serializer module that defines ~encode/1~ and
  ~decode/1~ returning an ~{:ok, value}~ tuple. Defaults to
  ~:external_term_format~.

- ~:log~ - Log level to use when the cookie cannot be
  decoded. Defaults to ~:debug~, can be set to ~false~ to disable it.
**** example
#+BEGIN_SRC elixir
  defmodule MyPlug do
    use Plug.Router
    use Plug.Debugger
    use Plug.ErrorHandler
    plug(Plug.Logger)

    plug(:match)
    plug(:put_secret_key_base)    # <---------

    plug(Plug.Session,            # <---------
      store: :cookie,
      key: "_cookie_key_stored_in_browser",
      encryption_salt: "cookie store encryption salt",
      signing_salt: "cookie store signing salt",
      key_length: 64,
      log: :debug
    )

    plug(:dispatch)

    get "/hello" do

      # conn                        # <--------- put in session
      # |> fetch_session()
      # |> put_session("foo", "barzoo")
      # |> send_resp(200, "hi")

      value =                             # # <--------- read from session
        conn
        |> fetch_session()
        |> get_session("foo")

      send_resp(conn, 200, value)
    end

    match _ do
      send_resp(conn, 404, "oops")
    end

    def put_secret_key_base(conn, _) do     # <---------
      put_in(
        conn.secret_key_base,
        "e90d979e-26cc-4f38-9383-a7370bcc90b4fc1aad45-462f-4bed-806b-b608dcff302c"
      )
    end

    defp handle_errors(conn, %{kind: _kind, reason: _reason, stack: _stack}) do
      send_resp(conn, conn.status, "Something went wrong")
    end
  end
#+END_SRC
**** Functions
- ~delete(conn, sid, opts)~
  + Removes the session associated with given session id from the store.
  + Callback implementation for ~Plug.Session.Store.delete/3~.

- ~get(conn, cookie, opts)~
  + Parses the given cookie.
  + Returns a session id and the session contents. The session id is
    any value that can be used to identify the session by the store.
  + The session id may be nil in case the cookie does not identify any
    value in the store. The session contents must be a map.
  + Callback implementation for ~Plug.Session.Store.get/3~.

- ~init(opts)~
  + Initializes the store.
  + The options returned from this function will be given to ~get/3~,
    ~put/4~ and ~delete/3~.
  + Callback implementation for ~Plug.Session.Store.init/1~.

- ~put(conn, sid, term, opts)~
  + Stores the session associated with given session id.
  + If ~nil~ is given as id, a new session id should be generated and
    returned.
  + Callback implementation for ~Plug.Session.Store.put/4~.




*** Plug.Session.Store behaviour
**** Callbacks
- ~delete(arg0, sid, arg2)~
  + Removes the session associated with given session id from the store

- ~get(arg0, cookie, arg2)~
  + Parses the given cookie
  + Returns a session id and the session contents. The session id is
    any value that can be used to identify the session by the store.
  + The session id may be ~nil~ in case the cookie does not identify any
    value in the store. The session contents must be a map.

- ~init(arg0)~
  + Initializes the store
  + The options returned from this function will be given to ~get/3~,
    ~put/4~ and ~delete/3~.

- ~put(arg0, sid, any, arg3)~
  + Stores the session associated with given session id
  + If ~nil~ is given as id, a new session id should be generated and
    returned.

** Plug.Static
- A plug for serving static assets.
- It requires two options:
  + ~:at~ - the request path to reach for static assets. It must be a
    string.
  + ~:from~ - the file system path to read static assets from. It can
    be either: a string containing a file system path, an atom
    representing the application name (where assets will be served
    from ~priv/static~), or a tuple containing the application name and
    the directory to serve assets from (besides ~priv/static~).
- The preferred form is to use ~:from~ with an atom or tuple, since it
  will make your application independent from the starting
  directory. For example, if you pass:
  #+BEGIN_SRC elixir
  plug Plug.Static, from: "priv/app/path"
  #+END_SRC
  ~Plug.Static~ will be unable to serve assets if you build releases or
  if you change the current directory. Instead do:
  #+BEGIN_SRC elixir
  plug Plug.Static, from: {:app_name, "priv/app/path"}
  #+END_SRC
- If a static asset cannot be found, ~Plug.Static~ simply forwards the
  connection to the rest of the pipeline.
*** Cache mechanisms
- Plug.Static uses etags for HTTP caching.
- The cache-control for etags is specified by the
  ~cache_control_for_etags~ option and defaults to ~"public"~.
- ~Plug.Static~ also supports direct cache control by using versioned
  query strings. If the request query string starts with ~"?vsn="~,
  ~Plug.Static~ assumes the application is versioning assets and does
  not set the ~ETag~ header, meaning the cache behaviour will be
  specified solely by the ~cache_control_for_vsn_requests~ config, which
  defaults to ~"public, max-age=31536000"~.
*** Options
- ~:gzip~
 + given a request for ~FILE~, serves ~FILE.gz~ if it exists in the static
   directory and if the ~accept-encoding~ header is set to allow gzipped
   content (defaults to ~false~).

- ~:brotli~
 + given a request for ~FILE~, serves ~FILE.br~ if it exists in the static
   directory and if the ~accept-encoding~ header is set to allow
   brotli-compressed content (defaults to ~false~). ~FILE.br~ is checked
   first and dominates ~FILE.gz~ due to the better compression ratio.

- ~:cache_control_for_etags~
 + sets the cache header for requests that use etags. Defaults to
   ~"public"~.

- ~:etag_generation~
 + specify a ~{module, function, args}~ to be used to generate an
   etag. The ~path~ of the resource will be passed to the function, as
   well as the ~args~. If this option is not supplied, etags will be
   generated based off of file size and modification time.

- ~:cache_control_for_vsn_requests~
 + sets the cache header for requests starting with “?vsn=” in the
   query string. Defaults to ~"public, max-age=31536000"~.

- ~:only~
 + filters which requests to serve. This is useful to avoid file
   system traversals on every request when this plug is mounted at ~"/"~.
   For example, if ~only: ["images", "favicon.ico"]~ is specified,
   only files in the “images” directory and the exact “favicon.ico”
   file will be served by ~Plug.Static~. Defaults to ~nil~ (no filtering).

- ~:only_matching~
 + a relaxed version of ~:only~ that will serve any request as long as
   one of the given values matches the given path. For example,
   ~only_matching: ["images", "favicon"]~ will match any request that
   starts at “images” or “favicon”, be it “/images/foo.png”,
   “/images-high/foo.png”, “/favicon.ico” or “/favicon-high.ico”. Such
   matches are useful when serving digested files at the
   root. Defaults to ~nil~ (no filtering).

- ~:headers~
 + other headers to be set when serving static assets.

- ~:content_types~
 + custom MIME type mapping. As a map with filename as key and content
   type as value. For example: content_types:
   ~%{"apple-app-site-association" => "application/json"}~.
*** Examples
- This plug can be mounted in a ~Plug.Builder~ pipeline as follows:
#+BEGIN_SRC elixir
defmodule MyPlug do
  use Plug.Builder

  plug Plug.Static,
    at: "/public",
    from: :my_app,
    only: ~w(images robots.txt)
  plug :not_found

  def not_found(conn, _) do
    send_resp(conn, 404, "not found")
  end
end-
#+END_SRC
