- Plug is:
  + A specification for composable modules between web applications
  + Connection adapters for different web servers in the Erlang VM
- sample
  #+BEGIN_SRC elixir
    defmodule MyPlug do
      import Plug.Conn

      def init(options) do
        # initialize options

        options
      end

      def call(conn, _opts) do
        conn
        |> put_resp_content_type("text/plain")
        |> send_resp(200, "Hello world")
      end
    end
  #+END_SRC
  #+BEGIN_SRC text
  # iex
    iex> {:ok, _} = Plug.Cowboy.http MyPlug, []
    {:ok, #PID<...>}

  # shell
  $ curl http://localhost:4000
  Hello world
  #+END_SRC
* The ~Plug.Conn~ struct
- function plug
  + A function plug receives a connection and a set of options as
    arguments and returns the connection:
    #+BEGIN_SRC elixir
      def hello_world_plug(conn, _opts) do
        conn
        |> put_resp_content_type("text/plain")
        |> send_resp(200, "Hello world")
      end
    #+END_SRC

- module plug
  + implements an ~init/1~ function to initialize the options and a ~call/2~
    function which receives the connection and initialized options and
    returns the connection:
    #+BEGIN_SRC elixir
      defmodule MyPlug do
        def init([]), do: false
        def call(conn, _opts), do: conn
      end
    #+END_SRC

- a connection is represented by the ~Plug.Conn~ struct:
  #+BEGIN_SRC elixir
    %Plug.Conn{host: "www.example.com",
               path_info: ["bar", "baz"],
               ...}
  #+END_SRC
  + Manipulating the connection often happens with the use of the
    functions defined in the ~Plug.Conn~ module. Like
    ~put_resp_content_type/2~ and ~send_resp/3~ that we used above.
  + a connection is a direct interface to the underlying web
    server. When you call ~send_resp/3~, it will immediately send
    the given status and body back to the client. This makes features
    like streaming easy work with.
* Plug.Router
  - To write a "router" plug that dispatches based on the path and
    method of incoming requests, Plug provides ~Plug.Router~:
    #+BEGIN_SRC elixir
      defmodule MyRouter do
        use Plug.Router

        plug :match
        plug :dispatch

        get "/hello" do
          send_resp(conn, 200, "world")
        end

        forward "/users", to: UsersRouter

        match _ do
          send_resp(conn, 404, "oops")
        end
      end
    #+END_SRC
    #+BEGIN_SRC
      $ curl http://localhost:4001/foo
      oops%

      $ curl http://localhost:4001/hello
      world%
    #+END_SRC
  - The router is a plug. Not only that: it contains its own plug
    pipeline too.
  - The example above says that when the router is invoked, it will
    invoke the ~:match~ plug, represented by a local (imported) ~match/2~
    function, and then call the ~:dispatch~ plug which will execute the
    matched code.
  - Plug ships with many plugs that you can add to the router plug
    pipeline, allowing you to plug something before a route matches or
    before a route is dispatched to.
    #+BEGIN_SRC elixir
      plug Plug.Logger
      plug :match
      plug :dispatch
    #+END_SRC
  - ~Plug.Router~ compiles all of your routes into a single function
    and relies on the Erlang VM to optimize the underlying routes into
    a tree lookup
  - Each route needs to return the connection as per the Plug
    specification.
* Supervised handlers
- to start your Plug pipeline under your application’s supervision
  tree, Plug provides the ~child_spec/3~ function
  #+BEGIN_SRC elixir
    defmodule MyApp do
      @moduledoc false

      use Application

      def start(_type, _args) do
        children = [
          Plug.Cowboy.child_spec(scheme: :http, plug: MyRouter, options: [port: 4001])
        ]

        opts = [strategy: :one_for_one, name: MyApp.Supervisor]
        Supervisor.start_link(children, opts)
      end
    end
  #+END_SRC
* Testing plugs
- ~Plug.Test~ module that makes testing your plugs easy
- Sample
  #+BEGIN_SRC elixir
    defmodule MyPlugTest do
      use ExUnit.Case, async: true
      use Plug.Test

      @opts MyRouter.init([])

      test "returns hello world" do
        # Create a test connection
        conn = conn(:get, "/hello")

        # Invoke the plug
        conn = MyRouter.call(conn, @opts)

        # Assert the response and status
        assert conn.state == :sent
        assert conn.status == 200
        assert conn.resp_body == "world"
      end
    end
  #+END_SRC
* Available plugs

- ~Plug.CSRFProtection~ - adds Cross-Site Request Forgery protection
  to your application. Typically required if you are using
  ~Plug.Session~;

- ~Plug.Head~ - converts HEAD requests to GET requests;

- ~Plug.Logger~ - logs requests;

- ~Plug.MethodOverride~ - overrides a request method with one
  specified in the request parameters;

- ~Plug.Parsers~ - responsible for parsing the request body given its
  content-type;

- ~Plug.RequestId~ - sets up a request ID to be used in logs;

- ~Plug.Session~ - handles session management and storage;

- ~Plug.SSL~ - enforces requests through SSL;

- ~Plug.Static~ - serves static files;
* Helper modules
- Modules that can be used after you use ~Plug.Router~ or ~Plug.Builder~
  to help development:
  + ~Plug.Debugger~ - shows a helpful debugging page every time there
    is a failure in a request;
  + ~Plug.ErrorHandler~ - allows developers to customize error pages
    in case of crashes instead of sending a blank one;
* Plug behaviour
- Function plugs
  + A function plug is any function that receives a connection and a set
    of options and returns a connection. Its type signature must be:
    #+BEGIN_SRC elixir
    (Plug.Conn.t, Plug.opts) :: Plug.Conn.t
    #+END_SRC
- Module plugs
  + A module plug is an extension of the function plug. It is a module
    that must export:
    * a ~call/2~ function with the same signature as a function plug
    * an ~init/1~ function which takes a set of options and initializes it.
- Examples
  + a function plug:
    #+BEGIN_SRC elixir
      def json_header_plug(conn, opts) do
        Plug.Conn.put_resp_content_type(conn, "application/json")
      end
    #+END_SRC
  + a module plug:
    #+BEGIN_SRC elixir
      defmodule JSONHeaderPlug do
        import Plug.Conn

        def init(opts) do
          opts
        end

        def call(conn, _opts) do
          put_resp_content_type(conn, "application/json")
        end
      end
    #+END_SRC
- The Plug pipeline
  + The ~Plug.Builder~ module provides conveniences for building plug
    pipelines.
* Plug.Builder
- Conveniences for building plugs.
- This module can be ~use~-d into a module in order to build a plug
  pipeline:
  #+BEGIN_SRC elixir
    defmodule MyApp do
      use Plug.Builder

      plug Plug.Logger
      plug :hello, upper: true

      # A function from another module can be plugged too, provided it's
      # imported into the current module first.
      import AnotherModule, only: [interesting_plug: 2]
      plug :interesting_plug

      def hello(conn, opts) do
        body = if opts[:upper], do: "WORLD", else: "world"
        send_resp(conn, 200, body)
      end
    end
  #+END_SRC
  + The plugs in the pipeline will be executed in the order they’ve
    been added through the ~plug/2~ macro
  + ~Plug.Builder~ also imports the ~Plug.Conn~ module, making functions
    like ~send_resp/3~ available.
** Options
- When used, the following options are accepted by ~Plug.Builder~:
  + ~:log_on_halt~ - accepts the level to log whenever the request is
    halted
  + ~:init_mode~ - the environment to initialize the plug’s options,
    one of ~:compile~ or ~:runtime~. Defaults ~:compile~.
** Plug behaviour
- Internally, ~Plug.Builder~ implements the Plug behaviour, which means
  both the ~init/1~ and ~call/2~ functions are defined.
- By implementing the Plug API, ~Plug.Builder~ guarantees this module is
  a plug and can be handed to a web server or used as part of another
  pipeline.
** Overriding the default Plug API functions
- both the ~init/1~ and ~call/2~ functions defined by Plug.Builder can
  be manually overridden.
  #+BEGIN_SRC elixir
    defmodule PlugWithCustomOptions do
      use Plug.Builder
      plug Plug.Logger

      def init(opts) do
        opts
      end
    end
  #+END_SRC
  + The ~call/2~ function that ~Plug.Builder~ provides is used internally
    to execute all the plugs listed using the ~plug~ macro, so
    overriding the ~call/2~ function generally implies using ~super~ in
    order to still call the plug chain:
    #+BEGIN_SRC elixir
      defmodule PlugWithCustomCall do
        use Plug.Builder
        plug Plug.Logger
        plug Plug.Head

        def call(conn, opts) do
          conn
          |> super(opts) # calls Plug.Logger and Plug.Head
          |> assign(:called_all_plugs, true)
        end
      end
    #+END_SRC
** Halting a plug pipeline
- A plug pipeline can be halted with ~Plug.Conn.halt/1~.
- The builder will prevent further plugs downstream from being invoked
  and return the current connection.
  #+BEGIN_SRC elixir
    defmodule PlugUsingHalt do
      use Plug.Builder

      plug :stopper
      plug Plug.Logger

      def stopper(conn, _opts) do
        halt(conn)
      end
    end
  #+END_SRC
  ~Plug.Logger~ plug never gets called
** Functions
- ~builder_opts()~
  + Annotates a plug will receive the options given to the current
    module itself as arguments.
  + sample
    #+BEGIN_SRC elixir
      defmodule MyPlug do
        use Plug.Builder

        plug :inspect_opts, builder_opts()

        defp inspect_opts(conn, opts) do
          IO.inspect(opts)
          conn
        end
      end
    #+END_SRC
    When plugged as:
    #+BEGIN_SRC elixir
    plug MyPlug, custom: :options
    #+END_SRC
    It will print ~[custom: :options]~
  + Note you only pass ~builder_opts()~ to function plugs. You cannot
    use ~builder_opts()~ with module plugs because their options are
    evaluated at compile time.
    * do *NOT* do this:
      #+BEGIN_SRC elixir
      plug Plug.Parsers, builder_opts()
      #+END_SRC
      instead
      #+BEGIN_SRC elixir
        plug :custom_plug_parsers, builder_opts()

        defp custom_plug_parsers(conn, opts) do
          Plug.Parsers.call(conn, Plug.Parsers.init(opts))
        end
      #+END_SRC
- ~compile(env, pipeline, builder_opts)~
  + Compiles a plug pipeline.
  + Each element of the plug pipeline has the form: ~{plug_name, options, guards}~
  + Note that this function expects a reversed pipeline
  + Example
    #+BEGIN_SRC elixir
      Plug.Builder.compile(env, [
        {Plug.Logger, [], true}, # no guards, as added by the Plug.Builder.plug/2 macro
        {Plug.Head, [], quote(do: a when is_binary(a))}
      ], [])
    #+END_SRC
- ~plug(plug, opts \\ [])~
  + A macro that stores a new plug. ~opts~ will be passed unchanged to
    the new plug.
  + This macro doesn’t add any guards when adding the new plug to the
    pipeline; for adding plugs with guards see ~compile/1~.
  + Example
    #+BEGIN_SRC elixir
      plug Plug.Logger               # plug module
      plug :foo, some_options: true  # plug function
    #+END_SRC
* Plug.Conn
- This module defines a ~Plug.Conn~ struct and the main functions for
  working with Plug connections.
- Note request headers are normalized to lowercase and response
  headers are expected to have lowercase keys.
** Request fields
- These fields contain request information:
  + ~host~
    * the requested host as a binary, example: ~"www.example.com"~

  + ~method~
    * the request method as a binary, example: ~"GET"~

  + ~path_info~
    * the path split into segments, example: ~["hello", "world"]~

  + ~script_name~
    * the initial portion of the URL’s path that corresponds to the
      application routing, as segments, example: ~["sub","app"]~

  + ~request_path~
    * the requested path, example: ~/trailing/and//double//slashes/~

  + ~port~
    * the requested port as an integer, example: ~80~

  + ~remote_ip~
    * the IP of the client, example: ~{151, 236, 219, 228}~. This field
      is meant to be overwritten by plugs that understand e.g. the
      ~X-Forwarded-For~ header or HAProxy’s PROXY protocol. It defaults
      to peer’s IP

  + ~req_headers~ - the request headers as a list, example:
    ~[{"content-type", "text/plain"}]~. Note all headers will be
    downcased

  + ~scheme~ - the request scheme as an atom, example: ~:http~

  + ~query_string~ - the request query string as a binary, example:
    ~"foo=bar"~
** Fetchable fields
- The request information in these fields is not populated until it is
  fetched using the associated ~fetch_*~ function. For example, the
  cookies field uses ~fetch_cookies/2~.
- If you access these fields before fetching them, they will be
  returned as ~Plug.Conn.Unfetched~ structs.
- fields
  ~cookies-~
    + the request cookies with the response cookies
  ~body_params~
    + the request body params, populated through a ~Plug.Parsers~ parser.
  ~query_params~
    + the request query params, populated through ~fetch_query_params/2~
  ~path_params~
    + the request path params, populated by routers such as ~Plug.Router~
  ~params~ -
    + the request params, the result of merging the ~:body_params~ and
      ~:query_params~ with :~path_params~
  ~req_cookies~
    + the request cookies (without the response ones)
** Response fields
- These fields contain response information:
  + ~resp_body~
    * the response body, by default is an empty string. It is set to
      ~nil~ after the response is sent, except for test connections.
  + ~resp_charset~
    * the response charset, defaults to “utf-8”
  + ~resp_cookies~
    * the response cookies with their name and options
  + ~resp_headers~
    * the response headers as a list of tuples, by default
      ~cache-control~ is set to ~"max-age=0, private, must-revalidate"~.
      Note, response headers are expected to have lowercase keys.
  + ~status~
    * the response status
  + Furthermore, the ~before_send~ field stores callbacks that are
    invoked before the connection is sent. Callbacks are invoked in
    the reverse order they are registered (callbacks registered first
    are invoked last) in order to reproduce a pipeline ordering.
** Connection fields
- ~assigns~
  + shared user data as a map
- ~owner~
  + the Elixir process that owns the connection
- ~halted~
  + the boolean status on whether the pipeline was halted
- ~secret_key_base~
  + a secret key used to verify and encrypt cookies. the field must be set manually whenever one of those features are used. This data must be kept in the connection and never used directly, always use Plug.Crypto.KeyGenerator.generate/3 to derive keys from it
- ~state~
  + the connection state
  + The connection state is used to track the connection lifecycle.
  + It starts as ~:unset~ but is changed to
    * ~:set~ (via ~resp/3~)
    * ~:set_chunked~ (used only for ~before_send~ callbacks by ~send_chunked/2~)
    * ~:file~ (when invoked via ~send_file/3~).
  + Its final result is ~:sent~, ~:file~ or ~:chunked~ depending on the response model.
** Private fields
- These fields are reserved for libraries/framework usage.
  + ~adapter~ - holds the adapter information in a tuple
  + ~private~ - shared library data as a map
** Custom status codes
- Plug allows status codes to be overridden or added in order to allow
  new codes not directly specified by Plug or its adapters.
- Adding or overriding a status code is done through the Mix
  configuration of the ~:plug~ application.
  #+BEGIN_SRC elixir
    config :plug, :statuses, %{
      404 => "Actually This Was Found",
      998 => "Not An RFC Status Code"
    }
  #+END_SRC
  Plug will need to be recompiled for the changes to take place:
  #+BEGIN_SRC
  mix deps.clean --build plug
  #+END_SRC
  Now we can use the atoms that can be used in place of the status
  code in many functions
  #+BEGIN_SRC elixir
    put_status(conn, :not_found)                     # 404
    put_status(conn, :actually_this_was_found)       # 404
    put_status(conn, :not_an_rfc_status_code)        # 998

    send_resp(conn, :not_an_rfc_status_code, body)
  #+END_SRC
** functions
- ~assign(conn, key, value)~
  + Assigns a value to a key in the connection
  + The "assigns" storage is meant to be used to store values in the
    connection so that other plugs in your plug pipeline can access
    them. The assigns storage is a map.
  + eg
    #+BEGIN_SRC elixir
      iex> conn.assigns[:hello]
      nil

      iex> conn = assign(conn, :hello, :world)

      iex> conn.assigns[:hello]
      :world
    #+END_SRC
- ~chunk(conn, chunk)~
  + Sends a chunk as part of a chunked response
  + It expects a connection with state ~:chunked~ as set by
    ~send_chunked/2~. It returns ~{:ok, conn}~ in case of success,
    otherwise ~{:error, reason}~.
  + e.g
    #+BEGIN_SRC elixir
          conn = send_chunked(conn, 200)

          Enum.reduce_while(~w(each chunk as a word), conn, fn chunk, conn ->
            case Plug.Conn.chunk(conn, chunk <> " ") do
              {:ok, conn} ->
                {:cont, conn}

              {:error, :closed} ->
                {:halt, conn}
            end
          end)
    #+END_SRC
- ~clear_session(conn)~
  + Clears the entire session
  + This function removes every key from the session, clearing the
    session.
  + Note that, even if ~clear_session/1~ is used, the session is still
    sent to the client. If the session should be effectively dropped,
    ~configure_session/2~ should be used with the ~:drop~ option set to
    ~true~.
- ~configure_session(conn, opts)~
  + Configures the session
  + Options
    * ~:renew~ - generates a new session id for the cookie
    * ~:drop~ - drops the session, a session cookie will not be
      included in the response
    * ~:ignore~ - ignores all changes made to the session in this
      request cycle
- ~delete_req_header(conn, key)~
  + Deletes a request header if present
  + Raises a ~Plug.Conn.AlreadySentError~ if the connection has
    already been ~:sent~ or ~:chunked~.
  + e.g.
    #+BEGIN_SRC elixir
    Plug.Conn.delete_req_header(conn, "content-type")
    #+END_SRC
- ~delete_resp_cookie(conn, key, opts \\ [])~
  + Deletes a response cookie
  + Deleting a cookie requires the same options as to when the cookie
    was put. Check ~put_resp_cookie/4~
- ~delete_resp_header(conn, key)~
  + Deletes a response header if present
  + Raises a ~Plug.Conn.AlreadySentError~ if the connection has
    already been ~:sent~ or ~:chunked~.
  + Examples
    #+BEGIN_SRC elixir
    Plug.Conn.delete_resp_header(conn, "content-type")
    #+END_SRC
- ~delete_session(conn, key)~
  + Deletes the session for the given ~key~
  + The ~key~ can be a string or an atom, where atoms are
    automatically converted to strings.
- ~fetch_cookies(conn, opts \\ [])~
  + Fetches cookies from the request headers
- ~fetch_query_params(conn, opts \\ [])~
  + Fetches query parameters from the query string
  + Params are decoded as ~"x-www-form-urlencoded"~ in which key/value
    pairs are separated by ~&~ and keys are separated from values by ~=~.
  + This function does not fetch parameters from the body. To fetch
    parameters from the body, use the ~Plug.Parsers~ plug.
  + ~opts~
    * ~:length~ - the maximum query string length. Defaults to ~1_000_000~ bytes.
- ~fetch_session(conn, opts \\ [])~
  + Fetches the session from the session store. Will also fetch cookies
- ~get_http_protocol(conn)~
  + Returns the HTTP protocol and version
  + e.g.
    #+BEGIN_SRC elixir
      iex> get_http_protocol(conn)
      :"HTTP/1.1"
    #+END_SRC
- ~get_peer_data(conn)~
  + Returns the request peer data if one is present
- ~get_req_header(conn, key)~
  + Returns the values of the request header specified by key
- ~get_resp_header(conn, key)~
  + Returns the values of the response header specified by ~key~
  + e.g.
    #+BEGIN_SRC elixir
      iex> conn = %{conn | resp_headers: [{"content-type", "text/plain"}]}
      iex> get_resp_header(conn, "content-type")
      ["text/plain"]
    #+END_SRC
- ~get_session(conn, key)~
  + Returns session value for the given ~key~. If ~key~ is not set,
    ~nil~ is returned
  + The key can be a string or an atom, where atoms are automatically converted to strings.
- ~halt(conn)~
  + Halts the Plug pipeline by preventing further plugs downstream
    from being invoked. See the docs for ~Plug.Builder~
- ~inform!(conn, status, headers \\ [])~
  + Sends an information response to a client but raises if the
    adapter does not support inform
- ~inform(conn, status, headers \\ [])~
  + Sends an informational response to the client
  + An informational response, such as an early hint, must happen
    prior to a response being sent. If an informational request is
    attempted after a response is sent then a
    ~Plug.Conn.AlreadySentError~ will be raised. Only status codes from
    100-199 are valid.
  + To use inform for early hints send one or more informs with a status of 103.
  + If the adapter does not support informational responses then this is a noop.
  + Most HTTP/1.1 clients do not properly support informational
    responses but some proxies require it to support server push for
    HTTP/2. You can call ~get_http_protocol/1~ to retrieve the protocol
    and version.
- ~merge_assigns(conn, keyword)~
  + Assigns multiple values to keys in the connection
  + Equivalent to multiple calls to ~assign/3~.
  + e.g.
    #+BEGIN_SRC elixir
      iex> conn.assigns[:hello]
      nil

      iex> conn = merge_assigns(conn, hello: :world)

      iex> conn.assigns[:hello]
      :world
    #+END_SRC
- ~merge_private(conn, keyword)~
  + Assigns *multiple* private keys and values in the connection
  + Equivalent to multiple ~put_private/3~ calls
  + e.g.
    #+BEGIN_SRC elixir
      iex> conn.private[:my_plug_hello]
      nil

      iex> conn = merge_private(conn, my_plug_hello: :world)

      iex> conn.private[:my_plug_hello]
      :world
    #+END_SRC
- ~merge_resp_headers(conn, headers)~
  + Merges a series of response headers into the connection
  + e.g.
    #+BEGIN_SRC elixir
    Plug.Conn.merge_resp_headers(conn, [{"content-type", "text/plain"}, {"X-1337", "5P34K"}])
    #+END_SRC
- ~prepend_resp_headers(conn, headers)~
  + Prepends the list of headers to the connection response headers
  + Similar to ~put_resp_header~ this functions adds a new response
    header (~key~) but rather then replacing the existing one it
    prepends another header with the same ~key~.
  + It is recommended for header keys to be in lowercase
  + Raises a ~Plug.Conn.AlreadySentError~ if the connection has
    already been ~:sent~ or ~:chunked~.
  + Raises a ~Plug.Conn.InvalidHeaderError~ if the header value contains
    control feed (~\r~) or newline (~\n~) characters.
  + e.g.
    #+BEGIN_SRC elixir
      Plug.Conn.prepend_resp_headers([{"content-type", "bar"}, {"content-type", "kar"}])
      # content-type will be `content-type: bar, kar`
    #+END_SRC
- ~push!(conn, path, headers \\ [])~
  + Pushes a resource to the client but raises if the adapter does not support server push
- ~push(conn, path, headers \\ [])~
  + Pushes a resource to the client
  + Server pushes must happen prior to a response being sent. If a
    server push is attempted after a response is sent then a
    ~Plug.Conn.AlreadySentError~ will be raised.
- ~put_private(conn, key, value)~
  + Assigns a new *private* key and value in the connection
  + This storage is meant to be used by libraries and frameworks to
    avoid writing to the user storage (the ~:assigns~ field). It is
    recommended for libraries/frameworks to prefix the keys with the
    library name.
  + For example, if a plug called ~my_plug~ needs to store a ~:hello~ key,
    it would store it as ~:my_plug_hello~:
    #+BEGIN_SRC elixir
      iex> conn.private[:my_plug_hello]
      nil

      iex> conn = put_private(conn, :my_plug_hello, :world)

      iex> conn.private[:my_plug_hello]
      :world
    #+END_SRC
- ~put_req_header(conn, key, value)~
  + Adds a new request header (~key~) if not present, otherwise
    replaces the previous value of that header with ~value~
  + It is recommended for header keys to be in lowercase,
  + Raises a ~Plug.Conn.AlreadySentError~ if the connection has already
    been ~:sent~ or ~:chunked~.
  + e.g.
    #+BEGIN_SRC elixir
      Plug.Conn.put_req_header(conn, "accept", "application/json")
    #+END_SRC
- ~put_resp_content_type(conn, content_type, charset \\ "utf-8")~
  + Sets the value of the ~"content-type"~ response header taking into
    account the ~charset~
  + If charset is ~nil~, the value of the ~"content-type"~ response
    header won’t specify a ~charset~.
  + e.g.
    #+BEGIN_SRC elixir
      conn = put_resp_content_type(conn, "application/json")
      get_resp_header(conn, "content-type")
      ["application/json; charset=utf-8"]
    #+END_SRC
- ~put_resp_cookie(conn, key, value, opts \\ [])~
  + Puts a response cookie in the connection
  + The cookie value is not automatically escaped. Therefore, if you
    want to store values with comma, quotes, and so on, you need to
    explicitly escape them or use a function such as
    ~Base.encode64(value, padding: false)~ when writing and
    ~Base.decode64(encoded, padding: false)~ when reading the
    cookie. Padding needs to be disabled since ~=~ is not a valid
    character in cookie values.
  + ~opts~
    * ~:domain~ - the domain the cookie applies to
    * ~:max_age~ - the cookie max-age, in seconds. Providing a value
      for this option will set both the max-age and expires cookie
      attributes
    * ~:path~ - the path the cookie applies to
    * ~:http_only~ - when false, the cookie is accessible beyond HTTP
    * ~:secure~ - if the cookie must be sent only over https. Defaults
      to true when the connection is HTTPS
    * ~:extra~ - string to append to cookie. Use this to take
      advantage of non-standard cookie attributes.
- ~put_resp_header(conn, key, value)~
  + Adds a new response header (~key~) if not present, otherwise
    replaces the previous value of that header with ~value~
  + It is recommended for header keys to be in lowercase
  + Raises a ~Plug.Conn.AlreadySentError~ if the connection has already
    been ~:sent~ or ~:chunked~.
  + Raises a ~Plug.Conn.InvalidHeaderError~ if the header value
    contains control feed (~\r~) or newline (~\n~) characters.
  + e.g.
    #+BEGIN_SRC elixir
      Plug.Conn.put_resp_header(conn, "content-type", "application/json")
    #+END_SRC
- ~put_session(conn, key, value)~
  + Puts the specified ~value~ in the session for the given ~key~
  + The key can be a string or an atom, where atoms are automatically
    converted to strings. Can only be invoked on unsent ~conn~s. Will
    raise otherwise.
- ~put_status(conn, status)~
  + Stores the given status code in the connection
  + The status code can be ~nil~, an integer, or an atom. The list of
    allowed atoms is available in ~Plug.Conn.Status~.
    ~:continue~ - 100
    ~:switching_protocols~ - 101
    ~:processing~ - 102
    ~:early_hints~ - 103
    ~:ok~ - 200
    ~:created~ - 201
    ~:accepted~ - 202
    ~:non_authoritative_information~ - 203
    ~:no_content~ - 204
    ~:reset_content~ - 205
    ~:partial_content~ - 206
    ~:multi_status~ - 207
    ~:already_reported~ - 208
    ~:im_used~ - 226
    ~:multiple_choices~ - 300
    ~:moved_permanently~ - 301
    ~:found~ - 302
    ~:see_other~ - 303
    ~:not_modified~ - 304
    ~:use_proxy~ - 305
    ~:switch_proxy~ - 306
    ~:temporary_redirect~ - 307
    ~:permanent_redirect~ - 308
    ~:bad_request~ - 400
    ~:unauthorized~ - 401
    ~:payment_required~ - 402
    ~:forbidden~ - 403
    ~:not_found~ - 404
    ~:method_not_allowed~ - 405
    ~:not_acceptable~ - 406
    ~:proxy_authentication_required~ - 407
    ~:request_timeout~ - 408
    ~:conflict~ - 409
    ~:gone~ - 410
    ~:length_required~ - 411
    ~:precondition_failed~ - 412
    ~:request_entity_too_large~ - 413
    ~:request_uri_too_long~ - 414
    ~:unsupported_media_type~ - 415
    ~:requested_range_not_satisfiable~ - 416
    ~:expectation_failed~ - 417
    ~:im_a_teapot~ - 418
    ~:misdirected_request~ - 421
    ~:unprocessable_entity~ - 422
    ~:locked~ - 423
    ~:failed_dependency~ - 424
    ~:unordered_collection~ - 425
    ~:upgrade_required~ - 426
    ~:precondition_required~ - 428
    ~:too_many_requests~ - 429
    ~:request_header_fields_too_large~ - 431
    ~:unavailable_for_legal_reasons~ - 451
    ~:internal_server_error~ - 500
    ~:not_implemented~ - 501
    ~:bad_gateway~ - 502
    ~:service_unavailable~ - 503
    ~:gateway_timeout~ - 504
    ~:http_version_not_supported~ - 505
    ~:variant_also_negotiates~ - 506
    ~:insufficient_storage~ - 507
    ~:loop_detected~ - 508
    ~:not_extended~ - 510
    ~:network_authentication_required~ - 511
  + e.g.
    #+BEGIN_SRC elixir
      Plug.Conn.put_status(conn, :not_found)
      Plug.Conn.put_status(conn, 200)
    #+END_SRC
- ~read_body(conn, opts \\ [])~
  + Reads the request body
  + This function reads a chunk of the request body up to a given
    length (specified by the ~:length~ option).
  + If there is more data to be read, then ~{:more, partial_body, conn}~
    is returned. Otherwise ~{:ok, body, conn}~ is returned.
  + In case of an error reading the socket, ~{:error, reason}~ is
    returned as per ~:gen_tcp.recv/2~.
  + Like all functions in this module, the ~conn~ returned by ~read_body~
    must be passed to the next stage of your pipeline and should not
    be ignored.
  + In order to, for instance, support slower clients you can tune the
    ~:read_length~ and ~:read_timeout~ options. These specify how much
    time should be allowed to pass for each read from the underlying
    socket.
  + Because the request body can be of any size, reading the body will
    only work once, as Plug will not cache the result of these
    operations.
  + If you need to access the body multiple times, it is your
    responsibility to store it.
  + keep in mind some plugs like ~Plug.Parsers~ may read the body, so
    the body may be unavailable after being accessed by such plugs.
  + ~opts~
    * ~:length~ - sets the maximum number of bytes to read from the
      body on every call, defaults to ~8_000_000~ bytes

    * ~:read_length~ - sets the amount of bytes to read at one time
      from the underlying socket to fill the chunk, defaults to
      ~1_000_000~ bytes

    * ~:read_timeout~ - sets the timeout for each socket read,
      defaults to ~15_000~ milliseconds
  + Example
    #+BEGIN_SRC elixir
    {:ok, body, conn} = Plug.Conn.read_body(conn, length: 1_000_000)
    #+END_SRC
- ~read_part_body(conn, opts)~
  + Reads the body of a multipart request
  + Returns ~{:ok, body, conn}~ if all body has been read, ~{:more, binary, conn}~
    otherwise, and ~{:done, conn}~ if there is no more body.
  + It accepts the same options as ~read_body/2~.
  + HTTP multipart formposts
    * A multipart formpost is what an HTTP client sends when an HTML
      form is submitted with enctype set to "multipart/form-data".
    * It is an HTTP POST request sent with the request body specially
      formatted as a series of "parts", separated with MIME
      boundaries.
    * An example piece of HTML would look like this:
      #+BEGIN_SRC html
        <form action="submit.cgi" method="post" enctype="multipart/form-data">
           Name: <input type="text" name="person"><br>
           File: <input type="file" name="secret"><br>
           <input type="submit" value="Submit">
        </form>
      #+END_SRC
    * [[https://ec.haxx.se/http-multipart.html][Read More]]
- ~read_part_headers(conn, opts \\ [])~
  + Reads the headers of a multipart request
  + It returns ~{:ok, headers, conn}~ with the headers or ~{:done, conn}~
    if there are no more parts.
  + Once ~read_part_headers/2~ is invoked, you may call ~read_part_body/2~
    to read the body associated to the headers. If ~read_part_headers/2~
    is called instead, the body is automatically skipped until the
    next part headers.
  + ~opts~
    * ~:length~ - sets the maximum number of bytes to read from the
      body for each chunk, defaults to 64_000 bytes
    * ~:read_length~ - sets the amount of bytes to read at one time
      from the underlying socket to fill the chunk, defaults to ~64_000~
      bytes
    * ~:read_timeout~ - sets the timeout for each socket read,
      defaults to ~5_000~ milliseconds
- ~register_before_send(conn, callback)~
  + Registers a callback to be invoked before the response is sent
  + Callbacks are invoked in the reverse order they are defined
    (callbacks defined first are invoked last).
  + Example
    * To log the status of requests being sent:
      #+BEGIN_SRC elixir
        require Logger

        Plug.Conn.register_before_send(conn, fn conn ->
          Logger.info("Sent a #{conn.status} response")
          conn
        end)
      #+END_SRC
- ~request_url(conn)~
  + Returns the full request URL
- ~resp(conn, status, body)~
  + Sets the response to the given ~status~ and ~body~
  + It sets the connection state to ~:set~ (if not already ~:set~) and
    raises ~Plug.Conn.AlreadySentError~ if it was already ~:sent~.
  + If you also want to send the response, use ~send_resp/1~ after this
    or use ~send_resp/3~.
  + e.g.
    #+BEGIN_SRC elixir
    conn
    |> Plug.Conn.resp(404, "Not found")
    |> Plug.Conn.send_resp()
    #+END_SRC
- ~send_chunked(conn, status)~
  + Sends the response headers as a chunked response
  + It expects a connection that has not been ~:sent~ yet and sets its
    state to ~:chunked~ afterwards.
  + After ~send_chunked/2~ is called, chunks can be sent to the client
    via the ~chunk/2~ function.
  + HTTP/2 does not support chunking and will instead stream the
    response without a transfer encoding.
  + When using HTTP/1.1, the Cowboy adapter will stream the response
    instead of emitting chunks if the content-length header has been
    set before calling ~send_chunked/2~.


- ~send_file(conn, status, file, offset \\ 0, length \\ :all)~
  + Sends a file as the response body with the given status and optionally starting at the given offset until the given length

- ~send_resp(conn)~
  + Sends a response to the client

- ~send_resp(conn, status, body)~
  + Sends a response with the given status and body

- ~update_req_header(conn, key, initial, fun)~
  + Updates a request header if present, otherwise it sets it to an initial value

- ~update_resp_header(conn, key, initial, fun)~
  + Updates a response header if present, otherwise it sets it to an initial value
