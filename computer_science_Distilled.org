Mostly from “Computer Science Distilled” and Wikipedia

- Flowcharts
  + Write states and instruction steps inside rectangles.
  + Write decision steps, where the process may go different ways, inside diamonds.
  + Never mix an instruction step with a decision step.
  + Connect sequential steps with arrows.
  + Mark the start and end of the process.

- Mathematical Models
  + A *model* is a set of concepts that represents a problem and its characteristics.

- Boolean Algebra
  + *Associativity*
    * Parentheses are irrelevant for sequences of =AND= or =OR=
      operations. As sequences of sums or multiplications in
      elementary algebra, they can be calculated in any order.
      #+BEGIN_SRC
          A AND (B AND C) = (A AND B) AND C
          A OR (B OR C) = (A OR B) OR C
      #+END_SRC
  + *Distributively*
    * In elementary algebra we factor multiplicative terms from sums:
      a × (b + c) = (a × b) + (a × c). Likewise in logic, ANDing
      after an OR is equivalent to ORing results of ANDs, and vice
      versa:
      #+BEGIN_SRC
      A AND (B OR C) = (A AND B) OR (A AND C).
      A OR (B AND C) = (A OR B) AND (A OR C).
     #+END_SRC
  + *DeMorgan's Law*
    * It can’t be summer and winter at once, so it’s either not summer
      or not winter. And it’s not summer and not winter if and only if
      it’s not the case it’s either summer or winter. Following this
      reasoning, ANDs can be transformed into ORs and vice versa:
      #+BEGIN_SRC
      !(A AND B) = !A OR !B,
      !A AND !B = !(A OR B).
      #+END_SRC
- Probability
  + *Independent Events*: When the outcome of an event does not
    influence the outcome of another event, they are independent. The
    probability that two independent events will happen is the product
    of their individual probabilities.

  + *mutually exclusive*: When two events cannot happen
    simultaneously, they are mutually exclusive. If you need any of
    the mutually exclusive events to happen, just sum their individual
    probabilities.
  + When two mutually exclusive events cover all possible outcomes,
    they are complementary. The sum of individual probabilities of
    complementary events is thus 100%.
- Complexity
  + When an algorithm can have different values of =T(n)= for the same value of =n=, we resort to cases:
    1. BEST CASE: when the input requires the minimum number of
       operations for any input of that size. In sorting, it happens
       when the input is already sorted.

    2. WORST CASE: when the input requires the maximum number of
       operations for any input of that size. In many sorting
       algorithms, that’s when the input was given in reverse order.

  + AVERAGE CASE: refers to the average number of operations
    required for typical inputs of that size. For sorting, an input
    in random order is usually considered.

  We can approximate T(n) by its fastest-growing term, called the *dominant term*

  + *Space complexity*: The measure for the working storage an algorithm
    needs is called space complexity. Space complexity analysis is
    similar to time complexity analysis. The difference is that we
    count computer memory, and not computing operations.
- Strategy
  + *iteration*
  + *nested loops*
  + *recursion*
  + *brute force*
  + *backtracking*
    Backtracking works best in problems where the solution is a se-
    quence of choices and making a choice restrains subsequent choices.
    It identifies as soon as possible the choices you’ve made cannot give
    you the solution you want, so you can sooner step back and try
    something else. Fail early, fail often.
  + *heuristic*
    A heuristic method, or simply a heuristic, is a method that leads
    to a solution without guaranteeing it is the best or optimal one.
    * greedy
  + Divide and Conquer
    Problems with optimal substructure can be divided into similar but
    smaller subproblems.
  + *Dynamic Programming*
  + *Branch and Bound*
    * Upper and Lower Bounds
      1. Divide the problem into subproblems,
      2. Find upper and lower bounds of each new subproblem,
      3. Compare subproblem bounds of all branches,
      4. Return to step 1 with the most promising subproblem.
    With branch and bound, we predict which paths are worst and we
    avoid wasting energy exploring them.
- Data
  + Abstractions
    1. Data Types
       In computer science and computer programming, a data type or
       simply type is an attribute of data which tells the compiler or
       interpreter how the programmer intends to use the data. Most
       programming languages support common data types of real,
       integer and boolean. A data type constrains the values that an
       expression, such as a variable or a function, might take. This
       data type defines the operations that can be done on the data,
       the meaning of the data, and the way values of that type can be
       stored. A type of value from which an expression may take its
       value.

    2. Abstract Data Types
       An Abstract Data Type (ADT) is the specification of a group of
       operations that make sense for a given data type.
       In computer science, an abstract data type (ADT) is a
       mathematical model for data types, where a data type is defined
       by its behavior (semantics) from the point of view of a user of
       the data, specifically in terms of possible values, possible
       operations on data of this type, and the behavior of these
       operations. This contrasts with data structures, which are
       concrete representations of data, and are the point of view of
       an implementer, not a user.
