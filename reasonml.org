* BuckleScript
** Cheatsheet

 - Raw JS
   #+BEGIN_SRC reason
     let add = [%raw "a + b"];
     [%%raw "var a = 1"];
     let myFunction = [%raw (a, b) => "return a + b"];
   #+END _SRC
 - String Unicode & Interpolation
   #+BEGIN_SRC reason
     Js.log({js|你好，
     世界|js});

     let world = "world";
     let helloWorld = {j|hello, $world|j};
   #+END_SRC
 - Global Value
   #+BEGIN_SRC reason
   [@bs.val] external setTimeout : (unit => unit, int) => float = "setTimeout";
   #+END_SRC
 - Global Module
   #+BEGIN_SRC reason
     [@bs.val] [@bs.scope "Math"] external random : unit => float = "random";
     let someNumber = random();

     [@bs.val] [@bs.scope ("window", "location", "ancestorOrigins")] external length : int = "length";
   #+END_SRC
 - Nullable
   #+BEGIN_SRC reason
     let a = Some(5); /* compiles to 5 */
     let b = None; /* compiles to undefined */
   #+END_SRC

   Handling a value that can be ~undefined~ and ~null~, by ditching the
   ~option~ type and using ~Js.Nullable.t~:
   #+BEGIN_SRC reason
     let jsNull = Js.Nullable.null;
     let jsUndefined = Js.Nullable.undefined;

     let result1: Js.Nullable.t(string) = Js.Nullable.return("hello");
     let result2: Js.Nullable.t(int) = Js.Nullable.fromOption(Some(10));
     let result3: option(int) = Js.Nullable.toOption(Js.Nullable.return(10));
   #+END_SRC
 - Hash Map Mode
   #+BEGIN_SRC reason
   let myMap = Js.Dict.empty();
   Js.Dict.set(myMap, "Allison", 10);
   #+END_SRC
 - Record Mode
   #+BEGIN_SRC reason
     [@bs.deriving abstract]
     type person = {
       [@bs.optional] name: string,
       age: int,
       mutable job: string,
     };

     [@bs.send] external getNickname : person => string = "getNickname";

     [@bs.val] external john : person = "john";

     let age = john->ageGet;
     john->jobSet("Accountant");
     let nick = john->getNickname;
   #+END_SRC
 - New Instance
   #+BEGIN_SRC reason
     type t;
     [@bs.new] external createDate : unit => t = "Date";
   #+END_SRC
 - Object Method & Chaining
   #+BEGIN_SRC reason
     [@bs.send] external map : (array('a), 'a => 'b) => array('b) = "";
     [@bs.send] external filter : (array('a), 'a => 'b) => array('b) = "";

     /* 2, 4 */
     [|1, 2, 3|]
     ->map(a => a + 1)
     ->filter(a => a mod 2 == 0)
     ->Js.log;
   #+END_SRC
 - Variadic (was bs.splice prior to version 4.08)
   #+BEGIN_SRC reason
     [@bs.module "path"] [@bs.variadic]
     external join : array(string) => string = "";
   #+END_SRC
   - [[*Variadic Function Arguments][read]]
 - Polymorphic Function
   - [[*Trick 2: Polymorphic Variant + ~bs.unwrap~][read]]
   #+BEGIN_SRC reason
     [@bs.module "Drawing"] external drawCat: unit => unit = "draw";
     [@bs.module "Drawin2g"] external drawDog: (~giveName: string) => unit = "draw";

     drawCat();
     drawDog(~giveName="foo");
   #+END_SRC
   #+BEGIN_SRC reason
     [@bs.val]
     external padLeft:
       (string, [@bs.unwrap] [ | `Str(string) | `Int(int)]) => string =
       "";

     padLeft("Hello World", `Int(4));
     padLeft("Hello World", `Str("foo"));

   #+END_SRC
 - curry/uncurry
   #+BEGIN_SRC reason
     let add = (. x, y, z) => x + y + z;
     let six = add(. 1, 2, 3);
   #+END_SRC
 - Module
   #+BEGIN_SRC reason
   [@bs.module "path"] external dirname : string => string = "dirname";
   #+END_SRC
   which outputs to
   #+BEGIN_SRC javascript
     'use strict';
     var Path = require("path");
     Path.dirname("blah");
   #+END_SRC
 - Import Default
   #+BEGIN_SRC reason
   [@bs.module] external a_func: string => unit = "./foo";

   a_func("jafar");
   #+END_SRC
   while foo.js is
   #+BEGIN_SRC js
     function blah(name) {
       console.log("hello " + name);
     }

     module.exports = blah;
   #+END_SRC
   + Import ES6 default compiled from Babel:

     foo.js
     #+BEGIN_SRC js
       function blah(name) {
         console.log("hello " + name);
       }

       export default blah;
     #+END_SRC

     foo.compiled.js
     #+BEGIN_SRC js
       "use strict";

       Object.defineProperty(exports, "__esModule", {
         value: true
       });
       exports.default = void 0;

       function blah(name) {
         console.log("hello " + name);
       }

       var _default = blah;
       exports.default = _default;
     #+END_SRC

     Play.re
     #+BEGIN_SRC reason
     [@bs.module "./foo.compiled"] external a_func: string => unit = "default";
     a_func("Farhad");
     #+END_SRC

     #+BEGIN_SRC shell
     node Play.bs.js # hello Farhad
     #+END_SRC
 - Export ES6 default
   Play.re
   #+BEGIN_SRC reason
   let default = "Bob";
   #+END_SRC
   foo.js
   #+BEGIN_SRC js
     import blah from "./Play.bs.js"

     console.log(blah); // Bob
   #+END_SRC
 - named import
   Play.re
   #+BEGIN_SRC reason
     [@bs.module "./foo.js"] external shout: string => unit = "func";

     shout("hi");
   #+END_SRC
   foo.js
   #+BEGIN_SRC reason
     module.exports = {
       func(str) {
         console.log(str.toUpperCase());
       }
     };
   #+END_SRC
   output
   #+BEGIN_SRC javascript
     'use strict';
     var FooJs = require("./foo.js");
     function shout(prim) {
       FooJs.func(prim);
       return /* () */0;
     }
     FooJs.func("hi");
     exports.shout = shout;
   #+END_SRC
** Embed Raw JavaScript
 - sample
   #+BEGIN_SRC reason
     let add = [%raw {|
       function(a, b) {
         console.log("hello from raw JavaScript!");
         return a + b
       }
     |}];

     Js.log(add(1, 2));
   #+END_SRC

 - ~[%raw foo]~ allows you to embed an expression. For top-level
    declarations in OCaml/Reason, use ~[%%raw foo]~ (two ~%~):
   #+BEGIN_SRC reason
     [%%raw "var a = 1"];

     let f = [%raw "function() {return 1}"];
   #+END_SRC
 - You can also pass a function declaration with a string body in raw:
   #+BEGIN_SRC reason
   let f: (int, int) => int = [%raw (a, b) => "{return a + b}"];
   #+END_SRC
*** Debugger
    #+BEGIN_SRC reason
      let f = (x, y) => {
        [%debugger];
        x + y;
      };
    #+END_SRC
*** Detect Global Variables
    #+BEGIN_SRC reason
      switch ([%external __filename]) {
      | Some(f) => Js.log(f)
      | None => Js.log("non-node environment")
      };
    #+END_SRC

    Output:
    #+BEGIN_SRC js
      var match = typeof (__filename) === "undefined" ? undefined : (__filename);

      if (match !== undefined) {
        console.log(match);
      } else {
        console.log("non-node environment");
      }
    #+END_SRC
** Common Data Types
*** Shared Data Types
 - Unicode Support
   + OCaml string is an immutable byte sequence. If the user types some unicode:
     #+BEGIN_SRC reason
     Js.log("你好")
     #+END_SRC
     It'll compile to the following JS:
     #+BEGIN_SRC javascript
     console.log("\xe4\xbd\xa0\xe5\xa5\xbd");
     #+END_SRC
     To rectify this,
     #+BEGIN_SRC reason
       Js.log({js|你好，
       世界|js})
     #+END_SRC
     will compile to
     #+BEGIN_SRC javascript
     console.log("你好，\n世界");
     #+END_SRC
 - Interpolation
   #+BEGIN_SRC reason
     let a = 8;
     let b = 9;
     let res = a + b;

     Js.log({j|$a + $b is $res|j});
   #+END_SRC

 - [[https://bucklescript.github.io/bucklescript/api/Js.Float.html][float]]
 - [[https://bucklescript.github.io/bucklescript/api/Js.Int.html][Int]]
   + Ints are 32-bits! Be careful, you can potentially treat them as JS
     numbers and vice-versa, but if the number's large, then you better
     treat JS numbers as floats. For example, we bind to ~Js.Date~ using
     floats.
 - Array
   + Idiomatic OCaml arrays are supposed to be fix-sized. This
     constraint is relaxed on the BuckleScript size. You can change its
     length using the usual [[https://bucklescript.github.io/bucklescript/api/Js.Array.html#VALdefault][JS Array API]]. BuckleScript's own [[https://reasonml.github.io/api/Array.html][Array API]]
     is here.
 - Tuple
   + OCaml tuples are compiled to JS arrays. Convenient when you're
     interop-ing with a JS array that contains heterogeneous values,
     but happens to have a fixed length. Model it as a tuple on the BS
     side!

 - Bool

*** Non-shared Data Types
 - Record, variant (including ~option~ and ~list~), object and others can
   be exported as well, but you should not rely on their internal
   representation on the JS side. Aka, don't grab a BS list and start
   manipulating its structure on the JS side.
 - However:
   + for record and variant, we provide [[https://bucklescript.github.io/docs/en/generate-converters-accessors][generation of converters and accessors]].
     Once you convert e.g. a record to a JS object, you can naturally use them on the JS side.
   + For list, use ~Array.of_list~ and ~Array.to_list~ in the Array module.
*** Cheat Sheet
 - [[https://bucklescript.github.io/docs/en/common-data-types#shared][Shared]]
 - [[https://bucklescript.github.io/docs/en/common-data-types#non-shared][Non-shared]]
** [[https://bucklescript.github.io/bucklescript/api/Belt.html][Belt]]
** Intro to External
 - external is a keyword for declaring a value in
   BuckleScript/OCaml/Reason:
   #+BEGIN_SRC reason
   external myCFunction : int => string = "theCFunctionName";
   #+END_SRC
*** Bind to Global Values
 - First, make sure the value you'd like to model doesn't already exist
   in our provided API. For a quick search of values, see the [[https://bucklescript.github.io/bucklescript/api/index_values.html][index of values]].
 - Then, make sure it's not already on https://github.com/reasonml-community or NPM.
 - Now, here's how you bind to a JS value:
   #+BEGIN_SRC reason
     [@bs.val] external setTimeout : (unit => unit, int) => float = "setTimeout";
     [@bs.val] external clearTimeout : float => unit = "clearTimeout";
     /* or */
     [@bs.val] external clearTimeout : float => unit = "";
   #+END_SRC
 - Abstract Type
   + The above still isn't ideal. See how ~setTimeout~ returns a ~float~
     and ~clearTimeout~ accepts one. There's no guarantee that you're
     passing the float created by ~setTimeout~ into ~clearTimeout~!
   + Let's leverage a popular feature to solve this problem: abstract types.
     #+BEGIN_SRC reason
       type timerId;
       [@bs.val] external setTimeout : (unit => unit, int) => timerId = "setTimeout";
       [@bs.val] external clearTimeout : timerId => unit = "clearTimeout";
     #+END_SRC
*** Global Modules
 - If you want to bind to a value inside a global module,
   e.g. ~Math.random~, attach a ~bs.scope~ to your ~bs.val~ external:
   #+BEGIN_SRC reason
     [@bs.scope "Math"] [@bs.val] external random : unit => float = "random";
     let someNumber = random();

     [@bs.val] [@bs.scope ("window", "location", "ancestorOrigins")] external length : int = "length";
     /* window.location.ancestorOrigins.length. */
   #+END_SRC

** Null, Undefined & Option
   Here's its definition from the standard library:
   #+BEGIN_SRC reason
   type option('a) = None | Some('a)
   #+END_SRC
 - The ~Option~ helper module is [[https://bucklescript.github.io/bucklescript/api/Belt.Option.html][here]].

*** Interoperate with JavaScript undefined and null
 - The option type is common enough that we special-case it when
   compiling to JavaScript: ~Some(5)~ simply compiles down to 5, and
   ~None~ compiles to ~undefined~! If you've got e.g. a string in
   JavaScript that you know might be ~undefined~, type it as
   ~option(string)~ and you're done! Likewise, you can send a ~Some(5)~ or
   ~None~ to the JS side and expect it to be interpreted correctly.
**** Caveat 1
 - The option-to-undefined translation isn't perfect, because on our
   side, option values can be composed:
   ~Some(Some(Some(5)))~ This still compiles to 5, but this gets troublesome:
   #+BEGIN_SRC
   Some(None)
   #+END_SRC
   This is compiled into the following JS:
   #+BEGIN_SRC
   Js_primitive.some(undefined);
   #+END_SRC
   What's this ~Js_primitive~ thing? Why can't this compile to ~undefined~?
   Long story short, when dealing polymorphic ~option~ type (aka
   ~option('a)~, for any ~'a~), many operations become tricky if we don't
   mark the value with some special annotation. If this doesn't make
   sense, don't worry; just remember the following rule:
   + Never, EVER, pass a nested option value (e.g. ~Some(Some(Some(5)))~)
     into the JS side.
   + Never, EVER, annotate a value coming from JS as ~option('a)~. Always
     give the concrete, non-polymorphic type.
**** Caveat 2
 - lots of times, your JavaScript value might be both ~null~ or
   ~undefined~. In that case, you unfortunately can't type such value as
   e.g. ~option(int)~, since our option type only checks for ~undefined~
   and *not null* when dealing with a ~None~.

 - *Solution*: More Sophisticated ~undefined~ & ~null~ Interop To solve
   this
   + we provide access to more elaborate ~null~ and ~undefined~ helpers
     through the ~Js.Nullable~ module. This somewhat works like an ~option~
     type, but is different from it.
**** Examples
 - To create a JS ~null~, use the value ~Js.Nullable.null~.
 - To create a JS ~undefined~, use ~Js.Nullable.undefined~
   + you can naturally use ~None~ too, but that's not the point here; the
     ~Js.Nullable.*~ helpers wouldn't work with it.
 - If you're receiving, for example, a JS string that can be ~null~ and
   ~undefined~, type it as:
   #+BEGIN_SRC reason
   [@bs.module "MyConstant"] external myId: Js.Nullable.t(string) = "myId"
   #+END_SRC
 - To create such a nullable string from our side (presumably to pass
   it to the JS side, for interop purpose), do:
   #+BEGIN_SRC reason
   [@bs.module "MyIdValidator"] external validate: Js.Nullable.t(string) => bool = "validate";
   let personId: Js.Nullable.t(string) = Js.Nullable.return("abc123");

   let result = validate(personId);
   #+END_SRC
   The ~return~ part "wraps" a string into a nullable string, to make the
   type system understand and track the fact that, as you pass this
   value around, it's not just a string, but a string that can be ~null~
   or ~undefined~.
 - Convert to/from option
   + ~Js.Nullable.fromOption~ converts from a option to
     ~Js.Nullable.t~. ~Js.Nullable.to~Option does the opposite.
** Object
 - As a hash map (or "dictionary"), where keys can be dynamically
   added/removed and where values are of the same type.

   for e.g. a use-case would be:
   #+BEGIN_SRC
   {"John": 10, "Allison": 20, "Jimmy": 15}
   #+END_SRC
 - As a record, where fields are fixed (though still maybe sometimes
   optional) and where values can be of different types.

   for e.g. a a use-case would be:
   #+BEGIN_SRC
   {name: "John", age: 10, job: "CEO"}
   #+END_SRC
*** Hash Map Mode
 - when
   + might or might not add/remove arbitrary keys (it's mutable)
   + values might or might not be accessed using a dynamic/computed key
   + *values are all of the same type*
 - sample
   #+BEGIN_SRC reason
     let myMap = Js.Dict.empty();
     Js.Dict.set(myMap, "Allison", 25); /* did mutate myMap */

     /* Js.Dict.set(myMap, "job", "Programmer");  error, because value is a string  */
   #+END_SRC
 - sample_2
   #+BEGIN_SRC reason
     %raw
     "var student = {Joe: 25}";

     /* Use an existing JS object */
     [@bs.val] external studentAges: Js.Dict.t(int) = "student"; /* to values are all int */
     switch (Js.Dict.get(studentAges, "Joe")) {
     | None => Js.log("Joe can't be found")
     | Some(age) => Js.log("Joe is " ++ string_of_int(age))
     };
   #+END_SRC

*** Record Mode
 - If your JS object:
   + has a known, fixed set of fields
   + might or might not contain values of different types
 - in BuckleScript is modeled with the ~bs.deriving abstract~ feature:
   #+BEGIN_SRC reason
     [@bs.deriving abstract]
     type person = {
       name: string,
       age: int,
       job: string,
     };

     [@bs.val] external john : person = "john";
   #+END_SRC

**** creation
 - use the creation function of the same name as the record type,
   implicitly generated by the ~bs.deriving abstract~ annotation:
   #+BEGIN_SRC reason
     [@bs.deriving abstract]
     type person = {
       name: string,
       age: int,
       job: string,
     };

     let joe = person(~name="Joe", ~age=20, ~job="teacher")
   #+END_SRC

 - Rename Fields
   + Sometimes you might be binding to a JS object with field names
     that are invalid in BuckleScript/Reason. Two examples would be
     ~{type: "foo"}~ (reserved keyword in BS/Reason) and ~{"aria-checked": true}~.
     Choose a valid field name then use ~[@bs.as]~ to circumvent this:
     #+BEGIN_SRC reason
       [@bs.deriving abstract]
       type data = {
         [@bs.as "type"]
         type_: string,
         [@bs.as "aria-label"]
         aria_label: string,
       };

       let d = data(~type_="htmlElement", ~aria_label="awesome");
     #+END_SRC

 - Optional Labels
   #+BEGIN_SRC reason
     [@bs.deriving abstract]
     type person = {
       [@bs.optional] name: string,
       age: int,
       job: string,
     };

     let joe = person(~age=20, ~job="teacher", ());
   #+END_SRC
   + Note: now that your creation function contains optional fields, we
     mandate an unlabeled ~()~ at the end to indicate that you've
     finished applying the function.
**** Accessors
 - Again, since ~bs.deriving abstract~ hides the actual record shape, you
   can't access a field using e.g. ~joe.age~. We remediate this by
   generating getter and setters.
 - read
   + One getter function is generated per ~bs.deriving abstract~ record
     type field. In the above example, you'd get 3 functions: ~nameGet~,
     ~ageGet~, ~jobGet~. They take in a ~person~ value and return ~string~,
     ~int~, ~string~ respectively:
     #+BEGIN_SRC reason
       [@bs.deriving abstract]
       type person = {
         name: string,
         age: int,
         job: string,
       };

       let joe = person(~age=28, ~job="no job", ~name="Joe");

       let age = joe->ageGet; // or ageGet(joe)
     #+END_SRC
 - write
   + A ~bs.deriving abstract~ value is immutable by default. To mutate
     such value, you need to first mark one of the abstract record
     field as ~mutable~, the same way you'd mark a normal record as
     mutable:
     #+BEGIN_SRC reason
       [@bs.deriving abstract]
       type person = {
         name: string,
         mutable age: int,
         job: string,
       };

       let joe = person(~age=28, ~job="no job", ~name="Joe");

       ageSet(joe, 29);                /* or joe->ageSet(29) */
     #+END_SRC
 - Mutability
   + You can mark a field as mutable in the implementation (~ml~ / ~re~)
     file, while hiding such mutability in the interface file:
     #+BEGIN_SRC reason
       /* test.re */
       [@bs.deriving abstract]
       type cord = {
         [@bs.optional] mutable x: int,
         y: int,
       };
     #+END_SRC
     #+BEGIN_SRC reason
       /* test.rei */
       [@bs.deriving abstract]
       type cord = {
         [@bs.optional] x: int,
         y: int,
       };
     #+END_SRC
 - Hide the Creation Function
   + Mark the record as private to disable the creation function:
     #+BEGIN_SRC reason
       [@bs.deriving abstract]
       type cord = pri {               /* <-- pri */
         [@bs.optional] x: int,
         y: int,
       };
     #+END_SRC
     * The accessors are still there, but you can no longer create such
       data structure. Great for binding to a JS object while
       preventing others from creating more such object!

** Object 2 (Js.t)
 - When:
   + You don't want to declare a type beforehand
   + You want your object to be "structural", e.g. your function wants
     to accept "any object with the field ~age~, not just a particular
     object whose type definition is declared above".

 - read [[https://reasonml.github.io/docs/en/object][here]] and [[https://bucklescript.github.io/docs/en/object-2][here]]

*** ReasonML
**** Type Declaration
- An object doesn't need a type declaration, though it can have
  one. It looks like a record, except with a ~.~:
  + one dot
    #+BEGIN_SRC reason
      type tesla = {
        .
        color: string
      };
    #+END_SRC
    * The dot at the beginning indicates that this is a "closed"
      object type, which means that an object based on this type must
      have exactly this shape.

  + two dot
    #+BEGIN_SRC reason
      type car('a) = {
        ..
        color: string
      } as 'a;
    #+END_SRC
    * Two dots, also called an elision, indicate that this is an
      "open" object type, and therefore can also contain other values
      and methods. An open object is also polymorphic and therefore
      requires a parameter.
**** creation
  - sample 1
     #+BEGIN_SRC reason
       type tesla = {
         .
         color: string,
       };

       let obj: tesla = {
         val red = "Red";
         pub color = red;
       };

       Js.log(obj#color) /* "Red" */
     #+END_SRC
    + Here we have a simple object with the method ~color~ and the
      property ~red~. This method takes no arguments and returns the
      private property ~red~. Because the method color is a public method
      we can access it using object notation.
      *Remember, objects only export methods and all properties are private.*
  - sample 2
    #+BEGIN_SRC reason
      type tesla = {.
        drive: int => int
      };

      let obj: tesla = {
        val hasEnvy = ref(false);
        pub drive = (speed) => {
          this#enableEnvy(true);
          speed
        };
        pri enableEnvy = (envy) => hasEnvy := envy
      };
    #+END_SRC
    + This object is of object type ~tesla~ and has a public method
      ~drive~. It also contains a private method ~enableEnvy~ that is only
      accessible from within the object.

    + A Reason object can also access ~this~. JavaScript object's ~this~
      behavior can be quirky; Reason ~this~ always points to the object
      itself correctly.
  - sample 3
    #+BEGIN_SRC reason
      type tesla('a) = {
        ..
        drive: int => int
      } as 'a;

      let obj: tesla({. drive: int => int, doYouWant: unit => bool}) = {
        val hasEnvy = ref(false);
        pub drive = (speed) => {
          this#enableEnvy(true);
          speed
        };
        pub doYouWant = () => hasEnvy^;
        pri enableEnvy = (envy) => hasEnvy := envy
      };
    #+END_SRC
    The above example shows an open object type which uses a type
    as parameter. The object type parameter is required to implement
    all the methods of the open object type.
    You can use the above object like so:
    #+BEGIN_SRC reason
    obj#doYouWant();
    #+END_SRC

*** BuckleScript
**** Pitfall
   + First, note that we cannot use the ordinary OCaml/Reason object
     type, like this:
     #+BEGIN_SRC reason
       type person = {
         .
         name: string,
         age: int,
         job: string
       };
     #+END_SRC

     You can still use this feature, but this OCaml/Reason object type
     does not compile to a clean JavaScript object! Unfortunately, this
     is because OCaml/Reason objects work a bit too differently from JS
     objects.

     for e.g.
     #+BEGIN_SRC reason
       type tesla = {
         .
         color: string,
       };

       let obj: tesla = {
         val red = "Red";
         pub color = red;
       };

       Js.log(obj#color) /* "Red" */
     #+END_SRC
     which compiles to
     #+BEGIN_SRC javascript
       // Generated by BUCKLESCRIPT VERSION 4.0.6, PLEASE EDIT WITH CARE
       'use strict';
       var Caml_oo_curry = require("./stdlib/caml_oo_curry.js");
       var CamlinternalOO = require("./stdlib/camlinternalOO.js");
       var shared = ["color"];
       var $$class = CamlinternalOO.create_table(shared);
       var ids = CamlinternalOO.new_methods_variables($$class, shared, ["red"]);
       var color = ids[0];
       var red = ids[1];
       CamlinternalOO.set_methods($$class, /* array */[
             color,
             1,
             red
           ]);
       function obj_init() {
         var self = CamlinternalOO.create_object_opt(0, $$class);
         self[red] = "Red";
         return self;
       }
       CamlinternalOO.init_class($$class);
       var obj = obj_init(0);
       console.log(Caml_oo_curry.js1(-899911325, 4, obj));
       exports.obj = obj;
       /* class Not a pure module */
     #+END_SRC
**** Actual Solution
   + BuckleScript wraps the regular OCaml/Reason object type with Js.t,
     in order to control and track a subset of operations and types
     that we know would compile cleanly to JavaScript. This is how it
     looks like:
     #+BEGIN_SRC reason
       [%%raw "var farhad = {name: 'farhad', age: 27, job: 'web_dev'}"];

       type person = Js.t({
         .
         name: string,
         age: int,
         job: string
       });

       [@bs.val] external farhad : person = "farhad";


       Js.log(farhad##job);
     #+END_SRC
     which compiles to clean js:
     #+BEGIN_SRC javascript
       // Generated by BUCKLESCRIPT VERSION 5.0.0, PLEASE EDIT WITH CARE
       'use strict';
       var farhad = {name: 'farhad', age: 27, job: 'web_dev'} ;

       console.log(farhad.job);
       /*  Not a pure module */
     #+END_SRC
   + Because object types are used often, Reason gives it a nicer
     sugar. ~Js.t({. name: string})~ will format to ~{. "name": string}~.
**** Accessors
 - Read
   + To access a field, use ~##~:
   #+BEGIN_SRC reason
   let farhad_name = farhad##name.
   #+END_SRC
 - write
   + To modify a field, you need to first mark a field as ~mutable~. By
     default, the ~Js.t~ object type is immutable.
     #+BEGIN_SRC reason
       %raw
       "var farhad = {name: 'farhad', age: 27, job: 'web_dev'}";

       type person = {
         .
         "name": string,
         [@bs.set] "age": int,
         "job": string,
       };

       [@bs.val] external farhad: person = "farhad";

       Js.log(farhad##age); /* 27 */

       farhad##age #= 28;

       Js.log(farhad##age); /* 28 */

     #+END_SRC
     Note: you can't use dynamic/computed keys in this paradigm.
**** Call
   + To call a method of a field, mark the function signature as
     ~[@bs.meth]~:
     #+BEGIN_SRC reason
       %raw
       {|
          var farhad = {
               name: 'farhad',
               age: 27,
               job: 'web_dev',
               upit: name => name.toUpperCase()
          };
       |};

       type person = {. [@bs.meth] "upit": string => string};

       [@bs.val] external farhad: person = "farhad";

       Js.log(farhad##upit("foo")); // FOO
     #+END_SRC
**** Creation
 - Literal
   + You can use ~[%bs.obj putAnOCamlRecordHere]~ DSL to create a ~Js.t~
     object:
     #+BEGIN_SRC reason
       let bucklescript = [%bs.obj {
         info: {author: "Bob"}
       }];

       let name = bucklescript##info##author;
     #+END_SRC
     which refmt formats to
     #+BEGIN_SRC reason
       let bucklescript = {
         "info": {
           author: "Bob",
         },
       };

       let name = bucklescript##info##author;
     #+END_SRC
   + Note: there's no syntax sugar for creating an empty object in
     OCaml nor Reason (aka this doesn't work: ~[%bs.obj {}]~. use
     ~Js.Obj.empty()~ for that purpose
   + The created object will have an inferred type, no type declaration
     needed! The above example will infer as:
     #+BEGIN_SRC reason
       {. "info": {. "author": string}} /* not the quotes */
     #+END_SRC
   + Note: since the value has its type inferred, don't accidentally do
     this:
     #+BEGIN_SRC reason
       type person = {. "age": int};
       let jane = {"age": "hi"};
     #+END_SRC
     * We've declared a ~person~ type, but ~jane~ is inferred as its own
       type, so person is ignored and no error happens! To give ~jane~ an
       explicit type, simply annotate it: ~let jane: person = ....~ This
       will then error correctly.
**** Function
 - You can declare an external function that, when called, will
   evaluate to a ~Js.t~ object with fields corresponding to the
   function's parameter labels. This is very handy because you can make
   some of those labelled parameters optional and if you don't pass
   them in, the output object won't include the corresponding
   fields. Thus you can use it to dynamically create objects with the
   subset of fields you need at runtime.
 - For example, suppose you need a JavaScript object like this:
   #+BEGIN_SRC javascript
     var homeRoute = {
       method: "GET",
       path: "/",
       action: () => console.log("Home"),
       // options: ...
     };

   #+END_SRC
   But only the first three fields are required; the ~options~ field is
   optional. You can declare the binding function like so
   #+BEGIN_SRC reason
     [@bs.obj] external route: (
       ~_method:string,
       ~path:string,
       ~action:(list(string) => unit),
       ~options:Js.t({..})=?,
       unit
     ) => _ = "";
   #+END_SRC
   This function has four labelled parameters (the fourth one
   optional), one unlabelled parameter at the end (which we mandate for
   functions with optional parameters), and one parameter (~_method~)
   that requires an underscore prefix to avoid confusion with the
   OCaml/Reason keyword ~method~.

   Also of interest is the return type: ~_~, which tells BuckleScript to
   automatically infer the full type of the ~Js.t~ object, sparing you
   the hassle of writing down the type manually!

   The function is called like so:
   #+BEGIN_SRC reason
     let homeRoute = route(~_method="GET", ~path="/", ~action=(_ => Js.log("Home")), ());
   #+END_SRC
   This generates the desired JavaScript object–but you'll notice that
   the ~options~ parameter was left out. As expected, the generated
   object won't include the ~options~ field.
** Class
*** new
 - sample
   #+BEGIN_SRC reason
   type t;
   [@bs.new] external createDate : unit => t = "Date";

   let date = createDate();
   #+END_SRC
   Output:
   #+BEGIN_SRC javascript
   var date = new Date();
   #+END_SRC
 - sample 2
   + You can chain ~bs.new~ and ~bs.module~ if the JS module you're
     importing is itself a class:

     #+BEGIN_SRC reason
     type t;
     [@bs.new] [@bs.module] external book : unit => t = "Book";
     let bookInstance = book();
     #+END_SRC

     Output:
     #+BEGIN_SRC reason
       var Book = require("Book");
       var bookInstance = new Book();
     #+END_SRC
*** Bind to JS Classes
 - OCaml having classes really helps with modeling JS classes. Just add
   a ~[@bs]~ to a class type to turn them into a ~Js.t~ class:
   #+BEGIN_SRC reason
     %bs.raw
     "var foo = {heigh: 18, width: 20, draw: () => console.log(`drawing`)}";

     class type _rect =
       [@bs]
       {
         [@bs.set]
         pub height: int;
         [@bs.set]
         pub width: int;
         pub draw: unit => unit;
       };

     type rect = Js.t(_rect);

     [@bs.val] external bar: rect = "foo";

     Js.log(bar##width);
   #+END_SRC
   + For ~Js.t~ classes, methods with arrow types are treated as real
     methods (automatically annotated with ~[@bs.meth]~) while methods
     with non-arrow types are treated as properties. Adding ~bs.set~ to
     those methods will make them mutable, which enables you to set
     them using ~#=~ later. Dropping the ~bs.set~ attribute makes the
     method/property immutable. Basically like the object section's
     features.
** Function
 - Modeling a JS function is like modeling a normal value:
   #+BEGIN_SRC reason
   [@bs.val] external encodeURI: string => string = "encodeURI";
   let result = encodeURI("hello");
   #+END_SRC

*** Labeled Arguments
 - OCaml has labeled arguments (that are potentially optional). These
   work on an ~external~ too! You'd use them to fix a JS function's
   unclear usage. Assuming we're using this:

   foo.js
   #+BEGIN_SRC javascript
     module.exports = function draw(x, y, border) {
       console.log(`x is ${x}`);
       console.log(`y is ${y}`);
       console.log(`border is ${border}`);
     };
   #+END_SRC
   we can
   Play.re
   #+BEGIN_SRC reason
     [@bs.module]
     external draw: (~x: int, ~y: int, ~border: bool=?, unit) => unit = "./foo.js";

     draw(~x=10, ~y=20, ~border=true, ());
     draw(~x=10, ~y=20, ());
   #+END_SRC
*** Object Method
 - Functions attached to a JS objects require a special way of binding
   to them, using ~bs.send~:
   #+BEGIN_SRC reason
     type document; /* abstract type for a document object */
     [@bs.send] external getElementById: (document, string) => Dom.element = "getElementById";
     [@bs.val] external doc : document = "document";

     let el = getElementById(doc, "myId");
   #+END_SRC
   output:
   #+BEGIN_SRC javascript
     var el = document.getElementById("myId");
   #+END_SRC
   In a ~bs.send~, the object is always the first argument.

*** Chaining
    # todo
*** Variadic Function Arguments
 - You might have JS functions that take an arbitrary amount of
   arguments. BuckleScript supports modeling those, under the condition
   that the arbitrary arguments part is homogenous (aka of the same
   type). If so, add ~bs.variadic~ (was ~bs.splice~ prior to version 4.08)
   to your ~external~.
   #+BEGIN_SRC reason
     [@bs.module "path"] [@bs.variadic]
     external join: array(string) => string = "join";

     let v = join([|"/foo", "bar", "zoo"|]);

     Js.log(v); /* '/foo/bar/zoo' */
   #+END_SRC
   output:
   #+BEGIN_SRC javascript
     'use strict';
     var Path = require("path");
     var v = Path.join("/foo", "bar", "zoo");
     console.log(v);
     exports.v = v;
   #+END_SRC
*** Modeling Polymorphic Function
 - JS function in general are often arbitrary overloaded in terms of
   argument types and number. How would you bind to those?
**** Trick 1: Multiple externals
 - If you can exhaustively enumerate the many forms an overloaded JS
   function can take, simply bind to each differently:
   #+BEGIN_SRC reason
     [@bs.module "Drawing"] external drawCat: unit => unit = "draw";
     [@bs.module "Drawing"] external drawDog: (~giveName: string) => unit = "draw";
     [@bs.module "Drawing"] external draw: (string, ~useRandomAnimal: bool) => unit = "draw";
   #+END_SRC
   Note how all three externals bind to the same JS function, ~draw~.
**** Trick 2: Polymorphic Variant + ~bs.unwrap~
 - If you have the irresistible urge of saying "if only this JS
   function argument was a variant instead of informally being either
   ~string~ or ~int~", then good news: we do provide such ~external~
   features through annotating a parameter as a polymorphic variant!
   Assuming you have the following JS function you'd like to bind to:

   #+BEGIN_SRC reason
     function padLeft(value, padding) {
       if (typeof padding === "number") {
         return Array(padding + 1).join(" ") + value;
       }
       if (typeof padding === "string") {
         return padding + value;
       }
       throw new Error(`Expected string or number, got '${padding}'.`);
     }

     module.exports = padLeft;
   #+END_SRC
   Here, ~padding~ is really conceptually a variant. Let's model it as
   such.
   #+BEGIN_SRC reason
     [@bs.module]
     external pad_left:
       (string, [@bs.unwrap] [ | `Str(string) | `Int(int)]) => string =
       "./foo.js";

     pad_left("Hello World", `Int(4));
     pad_left("Hello World", `Str("Message from BS: "));
   #+END_SRC
   we're just piggy backing on poly variants' type checking and
   syntax. The secret is the ~[@bs.unwrap]~ annotation on the type. It
   strips the variant constructors and compile to just the payload's
   value. Output:

   #+BEGIN_SRC javascript
     FooJs("Hello World", 4);
     FooJs("Hello World", "Message from BS: ");
   #+END_SRC

*** Constrain Arguments Better
 - Consider the Node ~fs.readFileSync~'s second argument. It can take a
   string, but really only a defined set: ~"ascii"~, ~"utf8"~, etc. You can
   still bind it as a ~string~, but we can use poly variants + ~bs.string~
   to ensure that our usage's more correct:
   #+BEGIN_SRC reason
     [@bs.module "fs"]
     external readFileSync:
       (~name: string, [@bs.string] [ | `utf8 | [@bs.as "ascii"] `useAscii]) =>
       string =
       "";

     readFileSync(~name="foo.js", `useAscii);
     readFileSync(~name"foo.js", `utf8);
   #+END_SRC
   output
   #+BEGIN_SRC reason
   var Fs = require("fs");
   Fs.readFileSync("xx.txt", "ascii");
   #+END_SRC
   1. Attaching ~[@bs.string]~ to the whole poly variant type makes its
      constructor compile to a string of the same name.
   2. Attaching a ~[@bs.as "foo"]~ to a constructor lets you customize
      the final string.

 - Aside from string, you can also compile an argument to an int, using
   ~bs.int~ instead of ~bs.string~ in a similar way:
   #+BEGIN_SRC reason
     [@bs.val]
     external test_int_type: (
       [@bs.int] [
         | `on_closed
         | [@bs.as 20] `on_open
         | `in_bin
       ])
       => int = "test_int_type";

     test_int_type(`in_bin);
   #+END_SRC
   ~on_closed~ will compile to 0, ~on_open~ to 20 and ~in_bin~ to 21.

*** Special-case: Event Listeners
    #+BEGIN_SRC reason
      type readline;

      [@bs.send]
      external on: (
          readline,
          [@bs.string] [ | `close(unit => unit) | `line(string => unit)]
        )
        => readline = "on";

      let register = rl =>
        rl
        ->on(`close(event => ()))
        ->on(`line(line => print_endline(line)));
    #+END_SRC
    output:
    #+BEGIN_SRC javascript
      function register(rl) {
        return rl.on("close", (function () {
                    return /* () */0;
                  }))
                  .on("line", (function (line) {
                    console.log(line);
                    return /* () */0;
                  }));
      }
    #+END_SRC
*** Fixed Arguments
 - Sometimes it's convenient to bind to a function using an ~external~,
   while passing predetermined argument values to the JS function:
   #+BEGIN_SRC reason
     [@bs.val]
     external process_on_exit: (
       [@bs.as "exit"] _,
       int => unit
     ) => unit = "process.on";

     let () = process_on_exit(exit_code =>
       Js.log("error code: " ++ string_of_int(exit_code))
     );
   #+END_SRC
   Output:
   #+BEGIN_SRC javascript
     process.on("exit", function (exit_code) {
       console.log("error code: " + exit_code);
       return /* () */0;
     });
   #+END_SRC
   The ~[@bs.as "exit"]~ and the placeholder ~_~ argument together
   indicates that you want the first argument to compile to the string
   ~"exit"~. You can also use any JSON literal with bs.as: ~[@bs.as {json|true|json}]~,
   ~[@bs.as {json|{"name": "John"}|json}]~, etc
*** Curry & Uncurry
 - sample
   #+BEGIN_SRC reason
     let add = (x, y, z) => x + y + z;
     let addFive = add(5);
     let twelve = addFive(3, 4);
   #+END_SRC
   Type signatures:
   #+BEGIN_SRC reason
     let add: (int, int, int) => int;
     let addFive: (int, int) => int;
     let twelve: int;
   #+END_SRC
**** Drawback
 1. When all the arguments of a function are supplied (aka no
    currying), BS does its best to to compile e.g. a 3-arguments call
    into a plain JS call with 3 arguments.
 2. If it's too hard to detect whether a function application is
    complete*, BS will use a runtime mechanism (the ~Curry~ module) to
    curry as many args as we can and check whether the result is fully
    applied.

 3. Some JS APIs like ~throttle~, ~debounce~ and ~promise~ might mess with
    context, aka use the function ~bind~ mechanism, carry around ~this~,
    etc. Such implementation clashes with the previous currying logic.

 - BS tries to do #1 as much as it can. Even when it bails and uses
   #2's currying mechanism, it's usually harmless.

 - *However*, if you encounter #3, heuristics are not good enough: you
   need a guaranteed way of fully applying a function, without
   intermediate currying steps. We provide such guarantee through the
   use of the ~[@bs]~ "uncurrying" annotation on a function declaration &
   call site.
**** Solution: Guaranteed Uncurrying
 - If you annotate a function declaration signature on an ~external~ or
   ~let~ with a ~[@bs]~ (or, in Reason syntax, annotate the start of the
   parameters with a dot), you'll turn that function into an
   similar-looking one that's guaranteed to be uncurried:
   #+BEGIN_SRC reason
     type timer_id;

     [@bs.val]
     external set_timeout: ((. unit) => unit, int) => timer_id = "setTimeout";

     let id = set_timeout((.) => Js.log("hi"), 1000);
   #+END_SRC
   Note: both the declaration site and the call site need to have the
   uncurry annotation. That's part of the guarantee/requirement.
 - When you try to curry such a function, you'll get a type error:
   #+BEGIN_SRC reason
   let add = (. x, y, z) => x + y + z;
   let addFiveOops = add(5);
   #+END_SRC
   Error:
   #+BEGIN_SRC
   This is an uncurried BuckleScript function. It must be applied with a dot.
   #+END_SRC
***** Extra Solution
 - The above solution is safe, guaranteed, and performant, but
   sometimes visually a little burdensome. We provide an alternative
   solution if:
     1. you're using ~external~
     2. the ~external~ function takes in an argument that's another function
     3. you want the user not to need to annotate the call sites with ~[@bs]~ or the dot in Reason
   Then try ~[@bs.uncurry]~:

   #+BEGIN_SRC reason
     [@bs.send] external map: (array('a), [@bs.uncurry] ('a => 'b)) => array('b) = "map";
     map([|1, 2, 3|], x => x + 1);
   #+END_SRC

****** pitfall
  - If you try to do this:
    #+BEGIN_SRC reason
    let id: (. 'a) => 'a = (. v) => v;
    #+END_SRC
    You’ll get this cryptic error message:
    #+BEGIN_SRC
    Error: The type of this expression, ('_a -> '_a [@bs]),
         contains type variables that cannot be generalized
    #+END_SRC
    - The issue here isn’t that the function is polymorphic. You can use
      polymorphic uncurried functions as inline callbacks, but you can’t
      export them (and lets are exposed by default unless you hide it
      with an interface file).
    - The issue here is a combination of the uncurried call,
      polymorphism and exporting the function. It’s an unfortunate
      limitation of how OCaml’s type system incorporates side-effects,
      and how BS handles uncurrying.
    - The simplest solution is in most cases to just not export it, by
      adding an interface to the module.
    - Alternatively, if you really need to export it, you can do so in
      its curried form, and then wrap it in an uncurried lambda at the
      call site. E.g.:
      #+BEGIN_SRC reason
      map(v => id(. v));
      #+END_SRC
****** Design Decisions
 - In general, ~bs.uncurry~ is recommended; the compiler will do lots
   of optimizations to resolve the currying to uncurrying at compile
   time. However, there are some cases the compiler can't optimize
   it. In these cases, it will be converted to a runtime check.
 - This means ~[@bs]~ are completely static behavior (no runtime cost),
   while ~[@bs.uncurry]~ is more convenient for end users but, in some
   rare cases, might be slower than ~[@bs]~.

*** Modeling this-based Callbacks
 - Many JS libraries have callbacks which rely on ~this~ (the source),
   for example:
   #+BEGIN_SRC javascript
     x.onload = function(v) {
       console.log(this.response + v)
     }
   #+END_SRC
   Here, ~this~ would point to ~x~ (actually, it depends on how onload is
   called, but we digress). It's not correct to declare ~x.onload~ of
   type ~unit → unit [@bs]~. Instead, we introduced a special attribute,
   ~bs.this~, which allows us to type ~x~ as so:
   #+BEGIN_SRC reason
     type x;
     [@bs.val] external x: x = "x";
     [@bs.set] external set_onload: (x, [@bs.this] ((x, int) => unit)) => unit = "onload";
     [@bs.get] external resp: x => int = "response";

     set_onload(x, [@bs.this] ((o, v) => Js.log(resp(o) + v)));
   #+END_SRC
   Output:
   #+BEGIN_SRC javascript
     x.onload = (function (v) {
         var o = this;
         console.log(o.response + v | 0);
         return /* () */0;
       });
   #+END_SRC
   ~bs.this~ is the same as ~bs~, except that its first parameter is
   reserved for ~this~ and for arity of 0, there is no need for a
   redundant ~unit~ type.
** Import & Export
*** Export
 - BuckleScript allows compiling to:
   + CommonJS (~require('myFile')~)
   + ES6 modules (~import * from 'myFile'~)
   + AMD (~define(['myFile'], ...)~)

 - By default, every ~let~ binding is exported. If their values are safe
   to use on the JS side, you can directly require the generated JS
   file and use them.
 - To only export a few selected ~let~s, simply add an interface file
   that hides some of the ~let~ bindings.
*** Export an ES6 default value
 - If your JS project is using ES6 modules, you're likely exporting & importing some default values:
   #+BEGIN_SRC javascript
     // student.js
     export default name = "Al";

     // teacher.js
     import studentName from 'student.js';
   #+END_SRC
 - Technically, since a BuckleScript file maps to a module, there's no
   such thing as "default" export, only named ones. However, we've made
   an exception to support default module when you do the following:
   #+BEGIN_SRC reason
   /* FavoriteStudent.re */
   let default = "Bob"
   #+END_SRC

   You can then require the default as normal JS side:
   #+BEGIN_SRC javascript
   // teacher2.js
   import studentName from 'FavoriteStudent.js';
   #+END_SRC
   Note: the above JS snippet only works if you're using that ES6
   import/export syntax in JS. If you're still using require, you'd
   need to do:
   #+BEGIN_SRC js
   let studentName = require('FavoriteStudent').default;
   #+END_SRC

*** import
 - Use ~bs.module~. It's like a ~bs.val~ that accepts a string that's
   the module name or path.
   #+BEGIN_SRC reason
   [@bs.module "path"] external dirname : string => string = "dirname";
   let root = dirname("/User/chenglou");
   #+END_SRC
   Output:
   #+BEGIN_SRC javascript
     var Path = require("path");
     var root = Path.dirname("/User/chenglou");
   #+END_SRC
   Note: the string inside bs.module can be anything: ~"./src/myJsFile"~,
   "~@myNpmNamespace/myLib~", etc.

*** Import a Default Value
 - By omitting the payload to ~bs.module~, you bind to the whole JS
   module:
   #+BEGIN_SRC reason
   [@bs.module] external leftPad : string => int => string = "./leftPad";
   let paddedResult = leftPad("hi", 5);
   #+END_SRC
   Output:
   #+BEGIN_SRC javascript
     var LeftPad = require("./leftPad");
     var paddedResult = LeftPad("hi", 5);
   #+END_SRC

**** Import an ES6 Default Value
 - If your JS project is using ES6, you're likely using Babel to
   compile it to regular JavaScript. Babel's ES6 default export
   actually exports the default value under the name ~default~. You'd
   bind to it like this:
   #+BEGIN_SRC reason
   [@bs.module "./student"] external studentName : string = "default";
   Js.log(studentName);
   #+END_SRC
   output:
   #+BEGIN_SRC js
   var Student = require("./student");

   console.log(Student.default);
   #+END_SRC

** Regular Expression
 - Creation
   + We have a shorthand for creating the regex:
   #+BEGIN_SRC reason
   let f = [%bs.re "/b/g"]
   #+END_SRC

   Output:
   #+BEGIN_SRC javascript
   var f = /b/g
   #+END_SRC
** Exceptions
 - In the JS world, exception could be any data, while an OCaml
   exception is a structured data format and supports pattern matching.
 - Catching an OCaml exception on JS side therefore doesn't work as
   intended.
 - JS exceptions can be raised from the BuckleScript side by using the
   ~JS.Exn.raise*~ functions, and can be caught as a BS exception of the
   type ~Js.Exn.Error~ with the JS exception as its payload, typed as
   ~Js.Exn.t~.
 - The JS Exception can then either be manipulated with the accessor
   functions in ~Js.Exn~, or casted to a more appropriate type.
   #+BEGIN_SRC reason
     try (
       Js.Exn.raiseError("oops!")
     ) {
     | Js.Exn.Error(e) =>
       switch (Js.Exn.message(e)) {
       | Some(message) => Js.log({j|Error: $message|j})
       | None => Js.log("An unknown error occurred")
       }
     };

   #+END_SRC
 - Usage
   + Take promise for example:
     #+BEGIN_SRC reason
       exception UnhandledPromise;

       let handlePromiseFailure =
         [@bs.open]
         (
           fun
           | Not_found => {
               Js.log("Not found");
               Js.Promise.resolve()
             }
         );

       Js.Promise.reject(Not_found)
         |> Js.Promise.catch(
            (error) =>
              switch (handlePromiseFailure(error)) {
              | Some(x) => x
              | None => raise(UnhandledPromise)
              }
          );
     #+END_SRC
** JSON
*** Unsafe Conversion
 - This emulates JavaScript's JSON conversion.
**** Parse
 - Simply use the (last resort) special [[https://bucklescript.github.io/docs/en/intro-to-external#special-identity-external][identity external]]:
   #+BEGIN_SRC reason
     [@bs.deriving abstract]
     type data = {name: string};

     [@bs.scope "JSON"] [@bs.val]
       external parseIntoMyData : string => data = "parse";

     let result = parseIntoMyData("{\"name\": \"Luke\"}");
     let n = nameGet(result);
   #+END_SRC

   Output:
   #+BEGIN_SRC javascript
   var result = JSON.parse("{\"name\": \"Luke\"}");
   var n = result.name;
   #+END_SRC
   Where ~data~ can be any type you assume the JSON is. As you can see,
   this compiles to a straightforward ~JSON.parse~ call. As with regular
   JS, this is convenient, but has no guarantee that e.g. the data is
   correctly shaped, or even syntactically valid.
**** Stringify
 - Since ~JSON.stringify~ is slightly safer than ~JSON.parse~, we've
   provided it out of the box in ~Js.Json~. It compiles to
   ~JSON.stringify~.
   #+BEGIN_SRC reason
     let dict = Js.Dict.empty();
     Js.Dict.set(dict, "name", Js.Json.string("free name"));
     Js.Dict.set(dict, "age", Js.Json.number(float_of_int(30)));
     Js.Dict.set(
       dict,
       "likes",
       Js.Json.stringArray([|"bucklescript", "ocaml", "js"|]),
     );

     Js.Json.stringify(Js.Json.object_(dict));
   #+END_SRC
*** Properly Use ~Js.Json~
 - Technically, the correct way to handle JSON is to recursively parse
   each field, and handle invalid data accordingly. ~Js.Json~ provides
   such low-level building blocks. See the examples in the API docs.

*** Higher-level Helpers
 - pseudo-official JSON helper library called [[https://github.com/reasonml-community/bs-json][bs-json]].
 - https://github.com/state-machine-systems/JsonCodec
** Fast Pipe
 - sample
   #+BEGIN_SRC reason
   a
   ->foo(b)
   ->bar
   #+END_SRC
   is equal to
   #+BEGIN_SRC reason
   bar(foo(a, b))
   #+END_SRC
 - Method Chaining
   #+BEGIN_SRC javascript
     const result = [1, 2, 3].map(a => a + 1).filter(a => a % 2 === 0);

     asyncRequest().setWaitDuration(4000).send();
   #+END_SRC
   we can
   #+BEGIN_SRC reason
     [@bs.send] external map : (array('a), 'a => 'b) => array('b) = "map";
     [@bs.send] external filter : (array('a), 'a => 'b) => array('b) = "filter";

     type request;
     external asyncRequest: unit => request = "asyncRequest";
     [@bs.send] external setWaitDuration: (request, int) => request = "setWaitDuration";
     [@bs.send] external send: request => unit = "send";


     let result = [|1, 2, 3|]
       ->map(a => a + 1)
       ->filter(a => a mod 2 === 0);

     asyncRequest()->setWaitDuration(400)->send;
   #+END_SRC
 - all the pipes
   1. ~->~ is the same as ~|.~ which pipes the value to the first arugument of the function
   1. ~|>~ pipes the value to the last arugument of the function

 - Pipe Into Variants
   + This works:
     #+BEGIN_SRC reason
     let result = name->preprocess->Some
     #+END_SRC
     We turn this into:
     #+BEGIN_SRC reason
     let result = Some(preprocess(name))
     #+END_SRC
** Generate Converters & Helpers
 - Sometimes, you might want to generate e.g. function accessors from a
   variant declaration, or a ~Js.t~ object + converter functions from a
   record definition. BuckleScript comes with a few annotations that
   allow you to generate those.
*** Functions & Plain Values for Variant
 - Use ~accessors~.
   #+BEGIN_SRC reason
     [@bs.deriving accessors]
     type action =
       | Click
       | Submit(string)
       | Cancel;
   #+END_SRC
   + output:
     #+BEGIN_SRC javascript
       Output:

       function submit(param_0) {
         return /* Submit */[param_0];
       }

       var click = /* Click */0;

       var cancel = /* Cancel */1;

       exports.click  = click;
       exports.submit = submit;
       exports.cancel = cancel;
     #+END_SRC
   + Variants constructors with payloads generate functions,
     payload-less constructors generate plain integers.
   + Note:
     1. The generated accessors are lower-cased.
     2. You can now use these helpers on the JavaScript side! But don't
        rely on their actual values please.
     3. Doesn't work with polymorphic variants yet.
 - Usage
   #+BEGIN_SRC reason
   let s = submit("hello"); /* gives Submit("hello") */
   #+END_SRC
   + This is useful:
     + When you're passing the accessor function as a higher-order
       function (which plain variant constructors aren't).
     + When you'd like the JS side to use these values & functions
       opaquely and pass you back a variant constructor (since JS has
       no such thing).

*** Convert Between ~Js.t~ Object and Record
 - use ~jsConverter~
    #+BEGIN_SRC reason
      [@bs.deriving jsConverter]
      type coordinates = {
        x: int,
        y: int
      };
    #+END_SRC
    Generates 2 functions of the following types:
    #+BEGIN_SRC reason
      let coordinatesToJs: coordinates => {. "x": int, "y": int};

      let coordinatesFromJs: {.. "x": int, "y": int} => coordinates;
    #+END_SRC
    Note:
   + ~coordinatesFromJs~ uses an open object type that accepts more
     fields, just to be more permissive.
   + The converters are shallow. They don't recursively drill into the
     fields and convert them. This preserves the speed and simplicity
     of output while satisfying 80% of use-cases.
 - Usage
   + This exports a ~jsCoordinates~ JS object (not a record!) for JS
     files to use:
     #+BEGIN_SRC reason
     let jsCoordinates = coordinatesToJs({x: 1, y: 2});
     #+END_SRC

   + This binds to a ~jsCoordinates~ record (not a JS object!) that
     exists on the JS side, presumably created by JS calling the
     function ~coordinatesFromJs~:
     #+BEGIN_SRC reason
     [@bs.module "myGame"] external jsCoordinates : coordinates = "jsCoordinates";
     #+END_SRC

**** More Safety
  - The above generated functions use ~Js.t~ object types. You can also
    hide this implementation detail by making the object type abstract
    by passing the ~newType~ option to the ~jsConverter~ plugin:
    #+BEGIN_SRC reason
      [@bs.deriving {jsConverter: newType}]
      type coordinates = {
        x: int,
        y: int
      };
    #+END_SRC

    Generates 2 functions of the following types:
    #+BEGIN_SRC reason
      let coordinatesToJs: coordinates => abs_coordinates;

      let coordinatesFromJs: abs_coordinates => coordinates;
    #+END_SRC

  - Usage
    + Using ~newType~, you've now prevented consumers from inadvertently doing the following:
      #+BEGIN_SRC reason
        let myCoordinates = {
          x: 10,
          y: 20
        };
        let jsCoords = coordinatesToJs(myCoordinates);

        let x = jsCoords##x; /* disallowed! Don't access the object's internal details */
      #+END_SRC
*** Convert between JS Integer Enum and BS Variant
 - Use ~jsConverter~.
   #+BEGIN_SRC reason
     [@bs.deriving jsConverter]
     type fruit =
       | Apple
       | Orange
       | Kiwi
       | Watermelon;
   #+END_SRC
   This option causes ~jsConverter~ to, again, generate functions of
   the following types:
   #+BEGIN_SRC reason
     let fruitToJs: fruit => int;

     let fruitFromJs: int => option(fruit);
   #+END_SRC
   + For ~fruitToJs~, each fruit variant constructor would map into an
     integer, starting at 0, in the order they're declared.
   + For ~fruitFromJs~, the return value is an ~option~, because not
     every int maps to a constructor.
   + You can also attach a ~[@bs.as alternativeIntValue]~ to each
     constructor to customize their output.
 - Usage
   #+BEGIN_SRC reason
     [@bs.deriving jsConverter]
     type fruit =
       | Apple
       | [@bs.as 10] Orange
       | [@bs.as 100] Kiwi
       | Watermelon;

     let zero = fruitToJs(Apple); /* 0 */

     switch (fruitFromJs(100)) {
     | Some(Kiwi) => Js.log("this is Kiwi")
     | _ => Js.log("received something wrong from the JS side")
     };
   #+END_SRC
   Note: by using ~bs.as~ here, all subsequent number encoding
   changes. ~Apple~ is still ~0~, ~Orange~ is ~10~, ~Kiwi~ is ~100~ and ~Watermelon~
   is ~101~!

**** More Safety
 - Similar to the JS object <-> record deriving, you can hide the fact
   that the JS enum are ints by passing the same ~newType~ option to the
   ~jsConverter~ plugin:
   #+BEGIN_SRC reason
     [@bs.deriving {jsConverter: newType}]
     type fruit =
       | Apple
       | [@bs.as 100] Kiwi
       | Watermelon;
   #+END_SRC
   This option causes ~jsConverter~ to generate functions of the following types:
   #+BEGIN_SRC reason
     let fruitToJs: fruit => abs_fruit;
     let fruitFromJs: abs_fruit => fruit;
   #+END_SRC
   For ~fruitFromJs~, the return value, unlike the previous non-abstract
   type case, doesn't contain an ~option~, because there's no way a bad
   value can be passed into it; the only creator of ~abs_fruit~ values is
   ~fruitToJs~!
 - Usage
   #+BEGIN_SRC reason
     [@bs.deriving {jsConverter: newType}]
     type fruit =
       | Apple
       | [@bs.as 100] Kiwi
       | Watermelon;

     let opaqueValue = fruitToJs(Apple);

     [@bs.module "myJSFruits"] external jsKiwi : abs_fruit = "iSwearThisIsAKiwi";
     let kiwi = fruitFromJs(jsKiwi);

     let error = fruitFromJs(100); /* nope, can't take a random int */
   #+END_SRC
*** Convert between JS String Enum and BS Polymorphic Variant
 - Similar to previous section, except polymorphic variants are
   converted to ~string~ instead of ~int~.
 - Usage
   #+BEGIN_SRC reason
     [@bs.deriving jsConverter]
     type fruit = [
       | `Apple
       | [@bs.as "miniCoconut"] `Kiwi
       | `Watermelon
     ];

     let appleString = fruitToJs(`Apple); /* "Apple" */
     let kiwiString = fruitToJs(`Kiwi); /* "miniCoconut" */
   #+END_SRC
   Deriving converters with abstract type through ~newType~ also still works.
** Better Data Structures Printing (Debug Mode)
 - to retain record fields names, variant tags, exception names, module
   names, etc, add ~-bs-g~ to ~bsb~
 - Usage
   1. Add ~"bsc-flags": ["-bs-g"]~ to your ~bsconfig.json~.
   2. In the BuckleScript/Reason file you'd like to debug, add ~[%%debugger.chrome]~ at the top.
      * The extension ~[%%debugger.chrome]~ conditionally turns on the
        debugger support. Feel free to keep it on at all time; it will
        not generate any extra garbage code unless you have ~-bs-g~ flag
        turned on above.
   3. If you're on Node.js, run: ~node --inspect-brk MyCompiledFile.js~ and open this URL in Chrome: ~chrome://inspect~.
   4. Make sure you've got Chrome custom formatter enabled.
   5. Click on inspect, then step through code as you would usually:

 - Note: you need to restart node every time your files changes.
 - Note: don't forget to remove ~-bs-g~ from your ~bsconfig.json~ for production!
** NodeJS Special Variables
 - NodeJS has several file local variables: ~__dirname~, ~__filename~,
   ~_module~, and ~require~. Their semantics are more like macros instead
   of functions.

   ~bs.node~ exposes support for these.
   #+BEGIN_SRC reason
     let dirname: option(string) = [%bs.node __dirname];
     let filename: option(string) = [%bs.node __filename];
     let _module: option(Node.node_module) = [%bs.node _module];
     let require: option(Node.node_require) = [%bs.node require];
   #+END_SRC
** Miscellaneous
*** Composing ~bs~ Attributes
   + most ~bs.*~ attributes can be used together.
     #+BEGIN_SRC reason
       [@bs.val] [@bs.scope "global"] [@bs.variadic]
         external draw : ([@bs.as "dog"] _, array(int)) => unit = "draw";

       draw([|1, 2|]);
     #+END_SRC
     Output:
     #+BEGIN_SRC javascript
     global.draw("dog", 1, 2);
     #+END_SRC
*** Safe External Data Handling
 - In some cases, the data could either come from JS or BS; it's very
   hard to give precise type information because of this. For example,
   for an external promise whose creation could come from the JS API,
   its failed value caused by ~Promise.reject~ could be of any shape.

 - BuckleScript provides a solution, ~bs.open~, to filter out OCaml
   structured exception data from the mixed data source. It preserves
   type safety while allowing you to deal with mixed source. It makes
   use of OCaml’s extensible variant, so that users can mix values of
   type exn with JS data.
   #+BEGIN_SRC reason
     let handleData = [@bs.open] (
       /* fun | leaving this here for seaching */
       fun
       | Invalid_argument(_) => 0
       | Not_found => 1
       | Sys_error(_) => 2
     );

     /* handleData is 'a => option(int) */
   #+END_SRC
 - For any input source, as long as it matches the exception pattern
   (nested pattern match supported), the matched value is returned,
   otherwise return ~None~.
** Build System
*** bsconfig.json
 - The complete configuration schema is [[https://bucklescript.github.io/bucklescript/docson/#build-schema.json][here]].
 - ~package-specs~
   + Output to either CommonJS (the default), ES6 modules or
     AMD. Example:
     #+BEGIN_SRC json
       {
         "package-specs": {
           "module": "commonjs",
           "in-source": true
         }
       }
     #+END_SRC
   + ~"module": "es6-global"~ resolves ~node_modules~ using relative
     paths. Good for development-time usage of ES6 in conjunction with
     browsers like Safari and Firefox that support ES6 modules
     today. No more dev-time bundling!
   + ~"in-source": true~ generates output alongside source files. If
     you omit it, it'll generate the artifacts into ~lib/js~. The output
     directory is not configurable otherwise.
   + This configuration only applies to you, when you develop the
     project. When the project is used as a third-party library, the
     consumer's own ~bsconfig.json~ ~package-specs~ overrides the
     configuration here, logically.
*** Automatic Interface Generation
 - "Interface files" (~.mli~, ~.rei~ files) are the "public description" of
   their corresponding "implementation files" (~.ml~, ~.re~), exposed as
   documentation, and containing nothing but type declarations. Since a
   file is a module, an interface file is essentially a module
   signature.
**** Tips & Tricks
 - You don't have to explicitly write an interface file; by default,
   one will be inferred from the implementation file and every
   binding from the file will be exported.
 - After you finish iterating on your project:
   + Explicitly add interface files to the files meant to be public
   + Add docblock comments on top of each binding to serve as documentation
   + Make some types abstract, and simply don't expose every binding
     from the interface file
 - Some types will have to be copy pasted from the implementation file,
   which gets tedious. This is why we let you automatically generate
   interface files, after which you can tweak whatever you want.
   #+BEGIN_SRC reason
     bsc -bs-re-out lib/bs/src/MyUtils-MyProject.cmi
     /* e.g: */
     bsc -bs-re-out lib/bs/src/Go-ReactTemplate.cmi
   #+END_SRC
   Where ~MyProject~ is your project's ~namespace~.

 - Note: the generated boilerplate might contain the strings
   "~BS-EXTERNAL~" or "~BuckleScript External~". This happens when you've
   used ~@bs~ externals in your implementation file. It's a temporary
   flaw; you need to manually turn these "~BS-EXTERNAL~" back into the
   right ~@bs~ externals for now. We'll correct this in the future.

* ReasonML
** Types
- You can also wrap any expression in parentheses and annotate it:
  #+BEGIN_SRC reason
    let myInt = 5;
    let myInt: int = 5;
    let myInt = (5: int) + (4: int);
    let add = (x: int, y: int) : int => x + y;
    let drawCircle = (~radius as r: int) : unit => ...;
  #+END_SRC
- Aliases
  + You can refer to a type by a different name. They'll be
    equivalent:
    #+BEGIN_SRC reason
      type scoreType = int;
      let x: scoreType = 10;
    #+END_SRC

*** Type Argument!
- Types can accept parameters, akin to generics in other
  languages. It's as if a type is a function that takes in arguments
  and returns a new type! The parameters need to start with ~'~.

- The use-case of a parameterized type is to kill
  duplications. Before:
  + without
    #+BEGIN_SRC reason
      /* this is a tuple of 3 items, explained next */
      type intCoordinates = (int, int, int);
      type floatCoordinates = (float, float, float);

      let buddy: intCoordinates = (10, 20, 20);
    #+END_SRC
  + with
    #+BEGIN_SRC reason
      type coordinates('a) = ('a, 'a, 'a);

      /* apply the coordinates "type function" and return the type (int, int, int) */
      type intCoordinatesAlias = coordinates(int);

      let buddy: intCoordinatesAlias = (10, 20, 20);

      /* or, more commonly, write it inline */
      let buddy: coordinates(float) = (10.5, 20.5, 20.5);
    #+END_SRC
    In practice, types are inferred for you. So the more concise
    version of the above example would be nothing but:
    #+BEGIN_SRC reason
    let buddy = (10, 20, 20);
    #+END_SRC
- Types can receive more arguments, and be composable.
  #+BEGIN_SRC reason
    type result('a, 'b) =
      | Ok('a)
      | Error('b);

    type myPayload = {data: string};

    type myPayloadResults('errorType) = list(result(myPayload, 'errorType));

    let payloadResults: myPayloadResults(string) = [
      Ok({data: "hi"}),
      Ok({data: "bye"}),
      Error("Something wrong happened!")
    ];
  #+END_SRC
*** Mutually Recursive Types
- Just like functions, types can be mutually recursive through and:
  #+BEGIN_SRC reason
  type student = {taughtBy: teacher}
  and teacher = {students: list(student)};
  #+END_SRC
- Note that there's no semicolon ending the first line and no type on the second line.

** String & Char
- Quoted String
  + multiline string just like before
  + no special character escaping
  + hooks for special pre-processors
    #+BEGIN_SRC reason
      let greetingAndOneSlash = {|Hello
      World
      \
      Hehe...
      |};
    #+END_SRC
- interpolation
  #+BEGIN_SRC reason
    let world = {js|世界|js}; /* Supports Unicode characters */
    let helloWorld = {j|你好，$world|j}; /* Supports Unicode and interpolation variables */
  #+END_SRC

*** Char
- Reason has a type for a string with a single letter:
  #+BEGIN_SRC reason
  let firstLetterOfAlphabet = 'a';
  #+END_SRC
- Note: Char doesn't support Unicode or UTF-8.
- A character compiles to an integer ranging from 0 to 255, for extra
  speed. You can also pattern-match on it:
  #+BEGIN_SRC reason
    let isVowel = (theChar) =>
      switch (theChar) {
      | 'a' | 'e' | 'i' | 'o' | 'u' | 'y' => true
      | _ => false
      };
  #+END_SRC
- To convert a String to a Char, use ~"a".[0]~. To convert a Char to a
  String, use ~String.make(1, 'a')~.

** Boolean
A boolean has the type bool and can be either true or false. Common operations:

- &&: logical and

- ||: logical or

- !: logical not.

- <=, >=, <, >

- ~==~: structural equal, compares data structures deeply:
  #+BEGIN_SRC reason
  (1, 2) == (1, 2)
  #+END_SRC
  is true. Convenient, but use with caution

- ~===~: referential equal, compares shallowly.
  #+BEGIN_SRC reason
  (1, 2) === (1, 2)
  #+END_SRC
  is false.
  #+BEGIN_SRC reason
  let myTuple = (1, 2);
  myTuple === myTuple
  #+END_SRC
  is true.

- !=: structural unequal

- !==: referential unequal
** Integer & Float
- Careful when you bind to JavaScript numbers! Long ones might be
  truncated. Bind JS number as float instead.
** Tuple
- immutable
- ordered
- fix-sized at creation time
- heterogeneous (can contain different types of values)
- A Reason tuple is typed "structurally". This means that even if you
  don't annotate your data with an explicit type, the compiler can
  still deduce it by looking at its content, its usage, etc.
-
  #+BEGIN_SRC reason
    let ageAndName = (24, "Lil' Reason");
    let my3dCoordinates = (20.0, 30.5, 100.0);

    let ageAndName: (int, string) = (24, "Lil' Reason");
    /* a tuple type alias */
    type coord3d = (float, float, float);
    let my3dCoordinates: coord3d = (20.0, 30.5, 100.0);
  #+END_SRC
*** Usage
- The standard library provides ~fst~ and ~snd~ ([[https://reasonml.github.io/api/Pervasives.html][here]], under "Pair operations"),
-
  #+BEGIN_SRC reason
  let (_, y, _) = my3dCoordinates;
  #+END_SRC
- Tuples aren't meant to be updated mutatively; you'd create new ones
  by destructuring the old ones.
- A *tuple type* might also be called a "product type", and ~(string, int)~
  is written as ~string * int~ in some places.
- The idea is that a tuple is really a "cartesian product"; imagine a
  2D grid, with ~string~ on the x axis and ~int~ on the y axis!
** Record
- Records are like JavaScript objects but are
  + lighter
  + immutable by default
  + fixed in field names and types
  + very fast
  + a bit more rigidly typed
- sample
  #+BEGIN_SRC reason
    Type (mandatory):

    type person = {
      age: int,
      name: string
    };

  #+END_SRC

  Value (this will be inferred to be of type ~person~):
  #+BEGIN_SRC reason
  let me = {
    age: 5,
    name: "Big Reason"
  };
  #+END_SRC

  Access (the familiar dot notation):
  #+BEGIN_SRC reason
  let name = me.name;
  #+END_SRC
*** Record Needs an Explicit Definition
- If you only write ~{age: 5, name: "Baby Reason"}~ without an explicit
  declaration somewhere above, the type system will give you an
  error. If the type definition resides in another file, you need to
  explicitly indicate which file it is:
  #+BEGIN_SRC reason
  /* School.re */

  type person = {age: int, name: string};
  #+END_SRC

  #+BEGIN_SRC reason
    /* example.re */

    let me: School.person = {age: 20, name: "Big Reason"};
    /* or */
    let me = School.{age: 20, name: "Big Reason"};
    /* or */
    let me = {School.age: 20, name: "Big Reason"};
  #+END_SRC
*** Immutable Update
- New records can be created from old records with the ~...~ spread
  operator. The original record isn't mutated.
  #+BEGIN_SRC reason
  let meNextYear = {...me, age: me.age + 1};
  #+END_SRC

- Note: spread cannot add new fields, as a record's shape is fixed by
  its type.

*** Mutable Update
- Record fields can optionally be mutable. This allows you to update
  those fields in-place with the ~=~ operator.
  #+BEGIN_SRC reason
    type person = {
      name: string,
      mutable age: int
    };

    let baby = {name: "Baby Reason", age: 5};
    baby.age = baby.age + 1; /* alter `baby`. Happy birthday! */
  #+END_SRC

*** Syntax shorthand
- To reduce redundancy, we provide *punning* for a record's types and
  values. Punning refers to the syntax shorthand you can use when the
  name of a field matches the name of its value/type:
  #+BEGIN_SRC reason
    type horsePower = {power: int, metric: bool};

    let metric = true;
    let someHorsePower = {power: 10, metric};
    /* same as the value {power: 10, metric: metric}; */

    type car = {name: string, horsePower};
    /* same as the type {name: string, horsePower: horsePower}; */
  #+END_SRC
- Note that there's no punning for a single record field! ~{foo}~
  doesn't do what you expect (it's a block that returns the value
  foo).
*** Record Types Are Found By Field Name
- With records, you cannot say "I'd like this function to take any
  record type, as long as they have the field ~age~". The following
  works, but not as expected:
  #+BEGIN_SRC reason
    type person = {age: int, name: string};
    type monster = {age: int, hasTentacles: bool};

    let getAge = (entity) => entity.age;
  #+END_SRC
  The last line's function will infer that the parameter ~entity~ must
  be of type ~monster~. The following code's last line fails:
  #+BEGIN_SRC reason
    let kraken = {age: 9999, hasTentacles: true};
    let me = {age: 5, name: "Baby Reason"};

    getAge(kraken);
    getAge(me);
  #+END_SRC
  + The type system will complain that ~me~ is a ~person~, and that ~getAge~
    only works on ~monster~. If you need such capability, use Reason
    [[https://reasonml.github.io/docs/en/object][objects]].
** Variant!

#+BEGIN_SRC reason
type myResponseVariant =
  | Yes
  | No
  | PrettyMuch;

let areYouCrushingIt = Yes;
#+END_SRC

- ~Yes~, ~No~ and ~PrettyMuch~ aren't strings, nor references, nor some
  special data type. They're called "constructors" (or "tag"). The ~|~
  bar separates each constructor.
- Note: a variant's constructors need to be capitalized.
- ~switch~
  #+BEGIN_SRC reason
    let message =
      switch (areYouCrushingIt) {
      | No => "No worries. Keep going!"
      | Yes => "Great!"
      | PrettyMuch => "Nice!"
      };
    /* message is "Great!" */
  #+END_SRC
*** Variant Needs an Explicit Definition
- If the variant you're using is in a different file, bring it into
  scope like you'd do for a record:
  #+BEGIN_SRC reason
  /* Zoo.re */
  type animal = Dog | Cat | Bird;
  #+END_SRC
  #+BEGIN_SRC reason
  /* example.re */

  let pet: Zoo.animal = Dog; /* preferred */
  /* or */
  let pet = Zoo.Dog;
  #+END_SRC

*** Constructor Arguments
- A variant's constructors can hold extra data separated by comma.
  #+BEGIN_SRC reason
    type account =
      | None
      | Instagram(string)
      | Facebook(string, int);
  #+END_SRC
  + Here, Instagram holds a string, and Facebook holds a string and an int. Usage:
    #+BEGIN_SRC reason
      let myAccount = Facebook("Josh", 26);
      let friendAccount = Instagram("Jenny");
    #+END_SRC
- Notice how using a constructor is like calling a function? It's as
  if ~Facebook~ was a function that accepts two arguments. This isn't a
  coincidence; there's a reason why a constructor's data is called
  "constructor argument".
- Using switch, you can pattern-match a constructor's arguments:
  #+BEGIN_SRC reason
    let greeting =
      switch (myAccount) {
      | None => "Hi!"
      | Facebook(name, age) => "Hi " ++ name ++ ", you're " ++ string_of_int(age) ++ "-year-old."
      | Instagram(name) => "Hello " ++ name ++ "!"
      };
  #+END_SRC
*** ~option~
#+BEGIN_SRC reason
type option('a) = None | Some('a);
#+END_SRC

*** ~list~
#+BEGIN_SRC reason
type list('a) = Empty | Head('a, list('a)); /* Not the actual type definition. Just an illustration. */
#+END_SRC
- Reason gave list a syntax sugar. ~[1, 2, 3]~ is conceptually
  equivalent to ~Head(1, Head(2, Head(3, Empty)))~. Once again, ~switch~
  forces you to handle every case of this variant, including Empty
  (aka []). This eliminates another big category of access bugs.

*** Variants Must Have constructors
- You might be tempted to try ~type foo = int | string~. This isn't
  possible in Reason; you'd have to give each branch a constructor:
  ~type foo = Int(int) | String(string)~. Though usually, needing this
  might be an anti-pattern

*** Interop with JavaScript
- suppose there's a ~myLibrary.draw~ JS function that takes in either a
  ~number~ or a ~string~. You might be tempted to bind it like so:
  #+BEGIN_SRC reason
    /* reserved for internal usage */
    [@bs.module "myLibrary"] external draw : 'a => unit = "draw";

    type animal =
      | MyFloat(float)
      | MyString(string);

    let betterDraw = (animal) =>
      switch (animal) {
      | MyFloat(f) => draw(f)
      | MyString(s) => draw(s)
      };
  #+END_SRC
  + You could definitely do that, but there are better ways! For
    example, simply two externals that both compile to the same JS
    call:
    #+BEGIN_SRC reason
      [@bs.module "myLibrary"] external drawFloat : float => unit = "draw";
      [@bs.module "myLibrary"] external drawString : string => unit = "draw";
    #+END_SRC
  + BuckleScript also provides [[*Modeling Polymorphic Function][a few other ways]] to do this.

** Null, Undefined & Option
- The ~Option~ helper module is [[https://bucklescript.github.io/bucklescript/api/Belt.Option.html][here]].
*** Interoperate with JavaScript ~undefined~ and ~null~
- The ~option~ type is common enough that we special-case it when
  compiling to JavaScript:
  #+BEGIN_SRC reason
  Some(5)
  #+END_SRC
  simply compiles down to 5, and
  #+BEGIN_SRC reason
  None
  #+END_SRC
  compiles to ~undefined~

- If you've got e.g. a ~string~ in JavaScript that you know might be
  ~undefined~, type it as ~option(string)~ and you're done! Likewise, you
  can send a ~Some(5)~ or ~None~ to the JS side and expect it to be
  interpreted correctly.

**** Caveat 1
- The option-to-undefined translation isn't perfect, because on our
  side, option values can be composed:
  #+BEGIN_SRC reason
  Some(Some(Some(5)))
  #+END_SRC
  This still compiles to ~5~, but this gets troublesome:
  #+BEGIN_SRC reason
  Some(None)
  #+END_SRC
  This is compiled into the following JS:
  #+BEGIN_SRC reason
  Js_primitive.some(undefined);
  #+END_SRC
  + What's this ~Js_primitive~ thing? Why can't this compile to
    ~undefined~? Long story short, when dealing polymorphic option type
    (aka ~option('a)~, for any ~'a~), many operations become tricky if we
    don't mark the value with some special annotation. If this doesn't
    make sense, don't worry; just remember the following rule:
    1. Never, EVER, pass a nested option value (e.g. ~Some(Some(Some(5)))~) into the JS side.
    1. Never, EVER, annotate a value coming from JS as
       ~option('a)~. Always give the concrete, non-polymorphic type.
**** Caveat 2
- Unfortunately, lots of times, your JavaScript value might be both
  ~null~ or ~undefined~. In that case, you unfortunately can't type such
  value as e.g. ~option(int)~, since our option type only checks for
  ~undefined~ and not ~null~ when dealing with a ~None~.
***** Solution: More Sophisticated ~undefined~ & null ~Interop~
- To solve this, we provide access to more elaborate ~null~ and
  ~undefined~ helpers through the [[https://bucklescript.github.io/bucklescript/api/Js.Nullable.html][Js.Nullable]] module. This somewhat
  works like an ~option~ type, but is different from it.
***** Examples
- To create a JS null, use the value ~Js.Nullable.null~.
- To create a JS ~undefined~, use ~Js.Nullable.undefined~ (you can
  naturally use ~None~ too, but that's not the point here; the
  ~Js.Nullable.*~ helpers wouldn't work with it).
- If you're receiving, for example, a JS string that can be ~null~ and
  ~undefined~, type it as:
  #+BEGIN_SRC reason
  [@bs.module "MyConstant"] external myId: Js.Nullable.t(string) = "myId"
  #+END_SRC
- To create such a ~nullable~ string from our side (presumably to pass
  it to the JS side, for interop purpose), do:
  #+BEGIN_SRC reason
    [@bs.module "MyIdValidator"] external validate: Js.Nullable.t(string) => bool = "validate";
    let personId: Js.Nullable.t(string) = Js.Nullable.return("abc123");

    let result = validate(personId);
  #+END_SRC
  + The ~return~ part "wraps" a string into a nullable string, to make
    the type system understand and track the fact that, as you pass
    this value around, it's not just a string, but a string that can
    be ~null~ or ~undefined~.
**** Convert to/from option
- ~Js.Nullable.fromOption~ converts from a ~option~ to
  ~Js.Nullable.t~. ~Js.Nullable.toOption~ does the opposite.
** List & Array
*** List
- Lists are:
  + homogeneous
  + immutable
  + fast at prepending items
    #+BEGIN_SRC reason
    let myList = [1, 2, 3];
    #+END_SRC
- Reason lists are simple, singly linked lists.
**** Usage
 - You'd use list for its resizability, its fast prepend (adding at the
   head), and its fast split, all of which are immutable yet efficient!

 - The standard lib provides a [[https://reasonml.github.io/api/List.html][List]] module (and its counterpart with
   labeled arguments, ~ListLabels~).

**** Immutable Prepend
 - Use the spread syntax
   #+BEGIN_SRC reason
   let myList: list(int) = [1, 2, 3];
   let anotherList = [0, ...myList];
   #+END_SRC
   ~myList~ didn't mutate. ~anotherList~ is now ~[0, 1, 2, 3]~. This is
   efficient (constant time, not linear). ~anotherList~'s last 3 elements
   are shared with ~myList~!
**** Access
 - ~switch~ is usually used to access list items:
   #+BEGIN_SRC reason
     let message =
       switch (myList) {
       | [] => "This list is empty"
       | [a, ...rest] => "The head of the list is the string " ++ string_of_int(a)
       };
   #+END_SRC

 - To access an arbitrary list item, use ~List.nth~.
*** Array
- Arrays are like lists, except they are:
  + mutable
  + fast at random access & updates
  + fix-sized on native (flexibly sized on JavaScript)
- You'd surround them with ~[|~ and ~|]~.
  #+BEGIN_SRC reason
  let myArray = [|"hello", "world", "how are you"|];
  #+END_SRC

- Standard library ~Array~ and ~ArrayLabel~ module. For JS compilation,
  you also have the familiar ~Js.Array~ API.

- Access & update an array item like so:
  #+BEGIN_SRC reason
    let myArray: array(string) = [|"hello", "world", "how are you"|];

    let firstItem = myArray[0]; /* "hello" */

    myArray[0] = "hey";
    /* now [|"hey", "world", "how are you"|] */
  #+END_SRC
  The above array access/update is just syntax sugar for ~Array.get~ and ~Array.set~.

- If you're compiling to JavaScript, know that Reason arrays map
  straightforwardly to JavaScript arrays, and vice-versa. Thus, even
  though arrays are fix-sized on native, you can still use the
  ~Js.Array~ API to resize them. This is fine.
** Function
*** Labeled Arguments
- In OCaml/Reason, you can attach labels to an argument by prefixing
  the name with the ~ symbol:
  #+BEGIN_SRC reason
    let addCoordinates = (~x, ~y) => {
      /* use x and y here */
    };
    /* ... */
    addCoordinates(~x=5, ~y=6);
  #+END_SRC

- You can also refer to the arguments inside the function body by a
  different name for conciseness:
  #+BEGIN_SRC reason
    let drawCircle = (~radius as r, ~color as c) => {
      setColor(c);
      startAt(r, r);
      /* ... */
    };

    drawCircle(~radius=10, ~color="red");
  #+END_SRC
  As a matter of fact, ~(~radius)~ is just a shorthand (called punning)
  for ~(~radius as radius)~.

- Here's the syntax for typing the arguments:
  #+BEGIN_SRC reason
  let drawCircle = (~radius as r: int, ~color as c: string) => ...;
  #+END_SRC
*** Optional Labeled Arguments
- Labeled function arguments can be made optional during
  declaration. You can then omit them when calling the function.
  #+BEGIN_SRC reason
    /* radius can be omitted */
    let drawCircle = (~color, ~radius=?, ()) => {
      setColor(color);
      switch (radius) {
      | None => startAt(1, 1)
      | Some(r_) => startAt(r_, r_)
      }
    };
  #+END_SRC
  - When given in this syntax, ~radius~ is wrapped in the standard
    library's ~option~ type, defaulting to ~None~. If provided, it'll be
    wrapped with a ~Some~. So ~radius~'s type value is either ~None~ or
    ~Some(int)~ here.
- Note the unit ~()~ at the end of ~drawCircle~. Writing this particular
  function without the unit ~()~ would lead to the following
  problem:
  + Because ~radius~ and ~color~ are both labeled, the function can be
    curried, and it can be applied out-of-order, it's unclear what the
    following means:
    #+BEGIN_SRC reason
    let whatIsThis = drawCircle(~color);
    #+END_SRC
    Is ~whatIsThis~ a curried ~drawCircle~ function, waiting for the
    optional ~radius~ to be applied? Or did it finish applying because
    the ~radius~ is optional? To address this confusion, append a
    positional (aka non-labeled) argument to ~drawCircle~
    (conventionally ~()~), and OCaml will, as a rule of thumb, presume
    the optional labeled argument is omitted when the positional
    argument is provided.
    * Because we don't supply the unit OCaml knows we want to curry the function.
      #+BEGIN_SRC reason
      let curriedFunction = drawCircle(~color);
      #+END_SRC
    * Because we do supply the unit OCaml knows we deliberately omit
      the ~radius~ parameter, and the function is executed.
      #+BEGIN_SRC reason
      let circle = drawCircle(~color, ());
      #+END_SRC
*** Explicitly Passed Optional
- Sometimes, you might want to forward a value to a function without
  knowing whether the value is ~None~ or ~Some(a)~. Naively, you'd do:
  #+BEGIN_SRC reason
    let result =
      switch (payloadRadius) {
      | None => drawCircle(~color, ())
      | Some(r) => drawCircle(~color, ~radius=r, ())
      };
  #+END_SRC
  + instead you can do
    #+BEGIN_SRC reason
      let result = drawCircle(~color, ~radius=?payloadRadius, ()); /* note the question mark ? */
    #+END_SRC
    This means "I understand ~radius~ is optional, and that when I pass
    it a value it needs to be an ~int~, but I don't know whether the
    value I'm passing is ~None~ or ~Some(val)~, so I'll pass you the whole
    ~option~ wrapper".

*** Optional with Default Value
- Optional labeled arguments can also be provided a default value. In
  this case, they aren't wrapped in an ~option~ type.
  #+BEGIN_SRC reason
    let drawCircle = (~radius=1, ~color, ()) => {
      setColor(color);
      startAt(radius, radius)
    };
  #+END_SRC
*** Recursive Functions
- By default, a value can't see a binding that points to it, but
  including the rec keyword in a let binding makes this possible. This
  allows functions to see and call themselves, giving us the power of
  recursion.
  #+BEGIN_SRC reason
  let rec neverTerminate = () => neverTerminate();
  #+END_SRC

*** Mutually Recursive Functions
- Mutually recursive functions start like a single recursive function
  using the rec keyword, and then are chained together with and:
  #+BEGIN_SRC reason
  let rec callSecond = () => callFirst()
  and callFirst = () => callSecond();
  #+END_SRC
- Note that there's no semicolon ending the first line and no ~let~ on
  the second line.

*** Cheat sheet for the function syntaxes
**** Declaration
     #+BEGIN_SRC reason
       /* anonymous function. Listed for completeness only */
       (x) => (y) => 1;
       /* sugar for the above */
       (x, y) => 1;
       /* assign to a name */
       let add = (x, y) => 1;

       /* labeled */
       let add = (~first as x, ~second as y) => x + y;
       /* with punning sugar */
       let add = (~first, ~second) => first + second;

       /* labeled with default value */
       let add = (~first as x=1, ~second as y=2) => x + y;
       /* with punning */
       let add = (~first=1, ~second=2) => first + second;

       /* optional */
       let add = (~first as x=?, ~second as y=?) => switch (x) {...};
       /* with punning */
       let add = (~first=?, ~second=?) => switch (first) {...};
     #+END_SRC
- With Type Annotation
     #+BEGIN_SRC reason
       /* anonymous function */
       (x: int) => (y: int): int => 1;
       /* sugar for the above */
       (x: int, y: int): int => 1;
       /* assign to a name */
       let add = (x: int, y: int): int => 1;

       /* labeled */
       let add = (~first as x: int, ~second as y: int) : int => x + y;
       /* with punning sugar */
       let add = (~first: int, ~second: int) : int => first + second;

       /* labeled with default value */
       let add = (~first as x: int=1, ~second as y: int=2) : int => x + y;
       /* with punning sugar */
       let add = (~first: int=1, ~second: int=2) : int => first + second;

       /* optional */
       let add = (~first as x: option(int)=?, ~second as y: option(int)=?) : int => switch (x) {...};
       /* with punning sugar */
       /* note that the caller would pass an `int`, not `option int` */
       /* Inside the function, `first` and `second` are `option int`. */
       let add = (~first: option(int)=?, ~second: option(int)=?) : int => switch (first) {...};
     #+END_SRC
**** Application
     #+BEGIN_SRC reason
       /* anonymous application. Listed for completeness only */
       add(x)(y);
       /* sugar for the above */
       add(x, y);

       /* labeled */
       add(~first=1, ~second=2);
       /* with punning sugar */
       add(~first, ~second);

       /* application with default value. Same as normal application */
       add(~first=1, ~second=2);

       /* explicit optional application */
       add(~first=?Some(1), ~second=?Some(2));
       /* with punning */
       add(~first?, ~second?);
     #+END_SRC
- With Type Annotation
  #+BEGIN_SRC reason
    /* anonymous application */
    add(x: int)(y: int);

    /* labeled */
    add(~first=1: int, ~second=2: int);
    /* with punning sugar */
    add(~first: int, ~second: int);

    /* application with default value. Same as normal application */
    add(~first=1: int, ~second=2: int);

    /* explicit optional application */
    add(~first=?Some(1): option(int), ~second=?Some(2): option(int));
    /* with punning sugar */
    add(~first: option(int)?, ~second: option(int)?);
  #+END_SRC
**** Standalone Type Signature
     #+BEGIN_SRC reason
       /* first arg type, second arg type, return type */
       type foo = int => int => int;
       /* sugar for the above */
       type foo = (int, int) => int;

       /* labeled */
       type foo = (~first: int, ~second: int) => int;

       /* labeled */
       type foo = (~first: int=?, ~second: int=?, unit) => int;
     #+END_SRC
**** In Interface Files
- To annotate a function from the implementation file (~.re~):
  #+BEGIN_SRC reason

  let add: int => int => int;
  /* sugar for the above */
  let add: (int, int) => int;
  #+END_SRC
- Same rules as the previous section, except replacing ~type foo = bar~
  with ~let add: bar~.

- Don't confuse this with actually exporting a type in the interface
  file. ~let add: bar~ annotates an existing value ~bar~ from the
  implementation file. ~type foo = bar~ exports a type of the same shape
  from the implementation file.
** Pipe First
- Example
  #+BEGIN_SRC reason
  [@bs.send] external map : (array('a), 'a => 'b) => array('b) = "map";
  [@bs.send] external filter : (array('a), 'a => 'b) => array('b) = "filter";

  type request;
  external asyncRequest: unit => request = "asyncRequest";
  [@bs.send] external setWaitDuration: (request, int) => request = "setWaitDuration";
  [@bs.send] external send: request => unit = "send";
  #+END_SRC

  You'd use them like this:
  #+BEGIN_SRC reason
  let result = filter(map([|1, 2, 3|], a => a + 1), a => a mod 2 == 0);

  send(setWaitDuration(asyncRequest(), 4000));
  #+END_SRC

  but this is more more readable
  #+BEGIN_SRC reason
  let result = [|1, 2, 3|]
    ->map(a => a + 1)
    ->filter(a => a mod 2 === 0);

  asyncRequest()->setWaitDuration(400)->send;
  #+END_SRC
*** Pipe Into Variants
- A variant's constructors, like ~Some~ or ~Student~, look like functions,
  but unfortunately aren't, due to historical reasons. Sometime, it'd
  still be nice to be able to use them as functions. Pipe First takes
  the occasion to enable that for you!
  #+BEGIN_SRC reason
  let result = name->preprocess->Some
  #+END_SRC

  which will be turned this into:
  #+BEGIN_SRC reason
  let result = Some(preprocess(name))
  #+END_SRC

*** Pipe Placeholders
- A placeholder is written as an underscore and it tells Reason that
  you want to fill in an argument of a function later. These two have
  equivalent meaning:
  #+BEGIN_SRC reason
    let addTo7 = (x) => add3(3, x, 4);
    /* same as */
    let addTo7 = add3(3, _, 4);
  #+END_SRC
- Sometimes you don't want to pipe the value you have into the first
  position. In these cases you can mark a placeholder value to show
  which argument you would like to pipe into.
  + Let's say you have a function ~namePerson~, which takes a ~person~
    then a ~name~ argument. If you are transforming a ~person~ then pipe
    will work as-is:
    #+BEGIN_SRC reason
      makePerson(~age=47, ())
        ->namePerson("Jane");
    #+END_SRC
  + If you have a ~name~ that you want to apply to a ~person~ object, you
    can use a placeholder:
    #+BEGIN_SRC reason
      getName(input)
        ->namePerson(personDetails, _);
    #+END_SRC
  + This allows you to pipe into any positional argument. It also
    works for named arguments:
    #+BEGIN_SRC reason
      getName(input)
        ->namePerson(~person=personDetails, ~name=_);
    #+END_SRC
** Destructuring
- The following binds variables: ~ten = 10~, ~twenty = 20~
  #+BEGIN_SRC reason
  let someInts = (10, 20);
  let (ten, twenty) = someInts;
  #+END_SRC

  The following binds variables: ~name = "Guy"~, ~age = 30~
  #+BEGIN_SRC reason
  type person = {name: string, age: int};
  let somePerson = {name: "Guy", age: 30};
  let {name, age} = somePerson;
  #+END_SRC
- When you pull out fields, you can optionally rename the fields. The
  following binds these instead: ~n = "Guy"~, ~a = 30~.
  #+BEGIN_SRC reason
  let {name: n, age: a} = somePerson;
  #+END_SRC
- Destructuring also allows type annotations.
  #+BEGIN_SRC reason
    let (ten: int, twenty: int) = someInts;
    let {name: (n: string), age: (a: int)} = somePerson;
  #+END_SRC
- Destructuring a function's labeled arguments is also possible.
  #+BEGIN_SRC reason
    type person = {
      name: string,
      age: int
    };

    let someFunction = (~person as {name}) => {
      /* you can use `name` here */
    };

    let otherFunction = (~person as {name} as thePerson) => {
      /* you can use both `name` and the whole record as `thePerson` here */
    };
  #+END_SRC
** Pattern Matching
- Sample
  #+BEGIN_SRC reason
    type payload =
      | BadResult(int)
      | GoodResult(string)
      | NoResult;

    let data = GoodResult("Product shipped!");

    let message =
      switch (data) {
      | GoodResult(theMessage) => "Success! " ++ theMessage
      | BadResult(errorCode) => "Something's wrong. The error code is: " ++ string_of_int(errorCode)
      | NoResult => "fuck"
      };
  #+END_SRC
- Sample 2
  #+BEGIN_SRC reason
    switch (myList) {
    | [] => print_endline("Empty list")
    | [a, ...theRest] => print_endline("list with the head value " ++ a)
    };

    switch (myArray) {
    | [|1, 2|] => print_endline("This is an array with item 1 and 2")
    | [||] => print_endline("This array has no element")
    | _ => print_endline("This is an array")
    };

    let reply =
      switch (message) {
      | "Reason's pretty cool" => "Yep"
      | "good night" => "See ya!"
      | "hello" | "hi" | "heya" | "hey" => "hello to you too!"
      | _ => "Nice to meet you!"
      };

    let message =
      switch (data) {
      | GoodResult(theMessage) => "Success! " ++ theMessage
      | BadResult(0 | 1 | 5) => "Something's wrong. It's a server side problem."
      | BadResult(errorCode) => "Unknown error occurred. Code: " ++ string_of_int(errorCode)
      | NoResult => "Things look fine"
      };
  #+END_SRC
- Note: you can only pass literals (i.e. concrete values) as a
  pattern, not let-binding names or other things. The following
  doesn't work as expected:
  #+BEGIN_SRC reason
    let myMessage = "Hello";
    switch (greeting) {
    | myMessage => print_endline("Hi to you")
    };
  #+END_SRC
  Instead, it'd assume you're matching on any string, and binding that
  to the name ~myMessage~ in that ~switch~ case, which is not what you
  wanted.

*** When clauses
- When you really need to use arbitrary logic with an otherwise clean
  pattern match, you can slip in some when clauses, which are
  basically if sugar:
    #+BEGIN_SRC reason
      let message =
        switch (data) {
        | GoodResult(theMessage) => ...
        | BadResult(errorCode) when isServerError(errorCode) => ...
        | BadResult(errorCode) => ... /* otherwise */
        | NoResult => ...
        };
    #+END_SRC
*** Match on Exceptions
- If the function throws an exception (covered later), you can also
  match on that, in addition to the function's normally returned
  values.
  #+BEGIN_SRC reason
    switch (List.find((i) => i === theItem, myItems)) {
    | item => print_endline(item)
    | exception Not_found => print_endline("No such item found!")
    };
  #+END_SRC
*** Nested Patterns
- Nested ~|~ work as intended:
  #+BEGIN_SRC reason
    switch (student) {
    | {name: "Jane" | "Joe"} => ...
    | {name: "Bob", Job: Programmer({fullTime: Yes | Maybe})} => ...
    };
  #+END_SRC
*** Patterns Everywhere
- You can put a pattern anywhere you'd put a normal "variable
  declaration":
  #+BEGIN_SRC reason
    type leftOrRight =
      | Left(int)
      | Right(int);

    let i = Left(1);

    /* magic! */
    let Left(v) | Right(v) = i;
  #+END_SRC
** Mutation
*** Mutate Let-binding
- Let-bindings are immutable, but you can wrap it with a ~ref~, which is
  like a box whose content can change:
  #+BEGIN_SRC reason
  let foo = ref(5);
  #+END_SRC
  You can get the actual value of a ~ref~ through the postfix ~^~
  operator:
  #+BEGIN_SRC reason
  let five = foo^; /* 5 */
  #+END_SRC
  Assign a new value to foo like so:
  #+BEGIN_SRC reason
  foo := 6;
  #+END_SRC
  Note that the previous binding ~five~ stays ~5~, since it got the
  underlying item on the ~ref~ box, not the ~ref~ itself.

- ~ref~ isn't actually a special feature! It's just an ordinary syntax
  sugar for a [[https://reasonml.github.io/api/Pervasives.html][predefined mutable record type called ~ref~ in the
  standard library]] (search "References" in that page). Here's the
  desugared version:
  #+BEGIN_SRC reason
    let foo = {contents: 5};
    let five = foo.contents;
    foo.contents = 6;
  #+END_SRC
  Before reaching for ~ref~, know that you can achieve lightweight,
  local "mutations" through overriding let bindings:
  #+BEGIN_SRC reason
    let foo = 10;
    let foo = someCondition ? foo + 5 : foo;
    print_int(foo); /* either 15 or 10 */
  #+END_SRC
** Imperative Loops
*** For Loops
- For loops iterate from a starting value up to (and including) the
  ending value.
  #+BEGIN_SRC reason
    for (myBinding in startValue to endValue) {
      {/* use myBinding here */};
    };

    let xStart = 1;
    let xEnd = 3;

    /* prints: 1 2 3 */
    for (x in xStart to xEnd) {
      print_int(x);
      print_string(" ");
    };
  #+END_SRC
- You can make the for loop count in the opposite direction by using downto.
  #+BEGIN_SRC reason
    for (myBinding in startValue downto endValue) {
      statements
    };

    let xStart = 3;
    let xEnd = 1;

    /* prints: 3 2 1 */
    for (x in xStart downto xEnd) {
      print_int(x);
      print_string(" ")
    };
  #+END_SRC

*** While Loops
- While loops execute a code block while some condition is true. The
  form of a while loop includes a single expression, the condition to
  test.
  #+BEGIN_SRC reason
    while (testCondition) {
      statements
    };
  #+END_SRC
**** break
- There's no loop-breaking ~break~ keyword (nor early ~return~ from
  functions, for that matter) in Reason. However, we can break out of
  a while loop easily through using a mutable binding.
  #+BEGIN_SRC reason
    Random.self_init();

    let break = ref(false);

    while (! break^) {
      if (Random.int(10) === 3) {
        break := true
      } else {
        print_endline("hello")
      }
    };
  #+END_SRC

** JSX
- Reason JSX isn't tied to ReactJS; they translate to normal function calls:
*** Capitalized Tag
#+BEGIN_SRC reason
<MyComponent foo={bar} />
#+END_SRC

becomes

#+BEGIN_SRC reason
([@JSX] MyComponent.createElement(~foo=bar, ~children=[], ()));
#+END_SRC

*** Uncapitalized Tag
#+BEGIN_SRC reason
<div foo={bar}> child1 child2 </div>;
#+END_SRC
becomes
#+BEGIN_SRC reason
([@JSX] div(~foo=bar, ~children=[child1, child2], ()));
#+END_SRC

*** Fragment
#+BEGIN_SRC reason
<> child1 child2 </>;
#+END_SRC
becomes
#+BEGIN_SRC reason
([@JSX] [child1, child2]);
#+END_SRC

*** Children
#+BEGIN_SRC reason
<MyComponent> foo bar </MyComponent>
#+END_SRC
- This is the syntax for passing a list of two items, foo and bar, to
  the children position. It desugars to a list containing foo and bar:
  #+BEGIN_SRC reason
  ([@JSX] MyComponent.createElement(~children=[foo, bar], ()));
  #+END_SRC
  + Note again that this isn't the transform for ReasonReact;
    ReasonReact turns the final list into an array. But the idea still
    applies.
- So naturally,
  #+BEGIN_SRC reason
  <MyComponent> foo </MyComponent>
  #+END_SRC
  desugars to:
  #+BEGIN_SRC reason
  ([@JSX] MyComponent.createElement(~children=[foo], ()))
  #+END_SRC
  I.e. whatever you do, the arguments passed to the children position
  will be wrapped in a list. What if you don't want that? What if you
  want to directly pass foo without an extra wrapping?
**** Children Spread
- To solve the above problem, we've introduced
  #+BEGIN_SRC reason
  <MyComponent> ...foo </MyComponent>
  #+END_SRC
  This passes the value ~foo~ without wrapping it in a list (or array,
  in the case of ReasonReact). Aka, this desugars to:
  #+BEGIN_SRC reason
  ([@JSX] MyComponent.createElement(~children=foo, ()));
  #+END_SRC
  This is extra useful in the cases where you are handled ~foo~ that is
  already a list of things, and want to forward that without wrapping
  it an extra time (which would be a type error) *. It also allows you
  to pass arbitrary data structures at children position (remember,
  JSX ~children~ is really just a totally normal prop):
  #+BEGIN_SRC reason
  <MyComponent> ...((theClassName) => <div className=theClassName />) </MyComponent>;
  <MyForm> ...("Hello", "Submit") </MyForm>;
  #+END_SRC
*** Usage
#+BEGIN_SRC reason
<MyComponent
  booleanAttribute={true}
  stringAttribute="string"
  intAttribute=1
  forcedOptional=?{Some("hello")}
  onClick={send(handleClick)}>
  <div> {ReasonReact.stringToElement("hello")} </div>
</MyComponent>
#+END_SRC
*** Departures From JS JSX
- Attributes and children don't mandate ~{}~, but we show them anyway
  for ease of learning. Once you ~refmt~ your file, some of them go away
  and some turn into parentheses.
- There is no support for JSX prop spread:~ <Foo {...bar} />~. Though
  we do have children spread, described above: ~<Foo> ...baz </Foo>~.
- Punning!
*** Punning
- "Punning" refers to the syntax shorthand for when a label and a
  value are the same. For example, in JavaScript, instead of doing
  ~return {name: name}~, you can do ~return {name}~.
- Reason JSX supports punning. ~<input checked />~ is just a shorthand
  for ~<input checked=checked />~. The formatter will help you format to
  the latter whenever possible. This is convenient in the cases where
  there are lots of props to pass down:
  #+BEGIN_SRC reason
  <MyComponent isLoading text onClick />
  #+END_SRC
  Consequently, a Reason JSX component can cram in a few more props
  before reaching for extra libraries solutions that avoids props
  passing.
** External
- Exceptions are just a special kind of variant, "thrown" in
  exceptional cases (don't abuse them!).
- Sample
  #+BEGIN_SRC reason
    let getItem = (theList) =>
      if (callSomeFunctionThatThrows()) {
        /* return the found item here */
      } else {
        raise(Not_found)
      };

    let result =
      try (getItem([1, 2, 3])) {
      | Not_found => 0 /* Default value if getItem throws */
      };
  #+END_SRC
  Note that the above is just for demonstration purposes; in reality,
  you'd return an ~option(int)~ directly from ~getItem~ and avoid the ~try~
  altogether.
- You can directly match on exceptions while getting another return
  value from a function:
  #+BEGIN_SRC reason
    switch (List.find((i) => i === theItem, myItems)) {
    | item => print_endline(item)
    | exception Not_found => print_endline("No such item found!")
    };
  #+END_SRC

- You can also make your own exceptions like you'd make a variant
  (exceptions need to be capitalized too).
  #+BEGIN_SRC reason
    exception InputClosed(string);
    ...
    raise(InputClosed("the stream has closed!"));
  #+END_SRC

- When you have ordinary variants, you often don't need
  exceptions. For example, instead of throwing when item can't be
  found in a collection, try to return an ~option(item)~ (~None~ in this
  case) instead.

- Newer standard library alternatives usually come with
  option-returning functions rather than exception-throwing ones. For
  example, ~List.find~ has the ~option~-returning counterpart
  ~List.find_opt~, which doesn't throw.

- Exceptions are actually just variants too. In fact, they all belong
  to a single variant type, called ~exn~. It's an extensible variant,
  meaning you can add new constructors to it, such as ~InputClosed~
  above. ~exception Foo~ is just a sugar for adding a constructor to
  ~exn~.
** [[*ReasonML][object]]
** Module
- Modules are like mini files! They can contain type definitions, ~let~
  bindings, nested modules, etc.
*** Creation
- To create a module, use the ~module~ keyword. The module name must
  start with a capital letter. Whatever you could place in a ~.re~ file,
  you may place inside a module definition's {} block.
  #+BEGIN_SRC reason
    module School = {
      type profession = Teacher | Director;

      let person1 = Teacher;
      let getProfession = (person) =>
        switch (person) {
        | Teacher => "A teacher"
        | Director => "A director"
        };
    };
  #+END_SRC
- A module's contents (including types!) can be accessed much like a
  record's, using the . notation. This demonstrates modules' utility
  for namespacing.
  #+BEGIN_SRC reason
    let anotherPerson: School.profession = School.Teacher;
    print_endline(School.getProfession(anotherPerson)); /* "A teacher" */
  #+END_SRC
- Nested modules work too.
  #+BEGIN_SRC reason
    module MyModule = {
      module NestedModule = {
        let message = "hello";
      };
    };

    let message = MyModule.NestedModule.message;
  #+END_SRC
*** ~open~ a module
- Constantly referring to a value/type in a module can be
  tedious. Instead, we can "open" a module and refer to its contents
  without always prepending them with the module's name. Instead of
  writing:
  #+BEGIN_SRC reason
  let p: School.profession = School.getProfession(School.person1);
  #+END_SRC
  We can write:
  #+BEGIN_SRC reason
  open School;
  let p: profession = getProfession(person1);
  #+END_SRC
  The content of ~School~ module are made visible (not copied into the
  file, but simply made visible!) in scope. ~profession~, ~getProfession~
  and ~person1~ will thus correctly be found.

- Use ~open~ this sparingly, it's convenient, but makes it hard to know
  where some values come from. You should usually use ~open~ in a local
  scope:
  #+BEGIN_SRC reason
    let p = {
      open School;
      getProfession(person1);
    };
    /* School's content isn't visible here anymore */
  #+END_SRC
- For an ~open~ followed by a single expression, we have a dedicated
  syntax sugar:
  #+BEGIN_SRC reason
  let p = School.(getProfession(person1));
  #+END_SRC
*** Extending modules
- Using ~include~ in a module statically "spreads" a module's content
  into a new one, thus often fulfill the role of "inheritance" or
  "mixin".
  #+BEGIN_SRC reason
    module BaseComponent = {
      let defaultGreeting = "Hello";
      let getAudience = (~excited) => excited ? "world!" : "world";
    };

    module ActualComponent = {
      /* the content is copied over */
      include BaseComponent;
      /* overrides BaseComponent.defaultGreeting */
      let defaultGreeting = "Hey";
      let render = () => defaultGreeting ++ " " ++ getAudience(~excited=true);
    };
  #+END_SRC
  + Note: ~open~ and ~include~ are very different! ~open~ brings a
    module's content into your current scope, so that you don't have
    to refer to a value by prefixing it with the module's name every
    time. ~include~ copies over the definition of a module
    statically, then also do an ~open~.
*** Every ~.re~ file is a module
- An OCaml/Reason file maps to a module; The file ~React.re~
  implicitly forms a module ~React~, which can be seen by other source
  files.
  #+BEGIN_SRC reason
    /* FileA.re. This typically compiles to module FileA below */
    let a = 1;
    let b = 2;

    /* FileB.re */
    /* Maps FileA's implementation to a new API */
    let alpha = FileA.a;
    let beta = FileA.b;
  #+END_SRC
  This contrived snippet expresses "copying" a file:
  #+BEGIN_SRC reason
    /* FileA.re. This typically compiles to module FileA below */
    let a = 1;
    let b = 2;

    /* FileB.re */
    /* compiles to exactly fileA.re's content with no runtime overhead! */
    include FileA;
  #+END_SRC
  Note: Because files are modules, file names should, by convention,
  be capitalized so they match their module names. Uncapitalized file
  names are not invalid, but will be transformed into a capitalized
  module name. I.e. ~file.re~ will be compiled into the module ~File~. To
  simplify and minimize the disconnect here, the convention is
  therefore to capitalize file names too.
*** Signatures
- A module's type is called a "signature", and can be written
  explicitly. If a module is like a ~.re~ (implementation) file, then a
  module's signature is like a ~.rei~ (interface) file.
**** Creation
- To create a signature, use the ~module type~ keyword. The signature
  name must start with a capital letter. Whatever you could place in a
  ~.rei~ file, you may place inside a signature definition's ~{}~ block.
  #+BEGIN_SRC reason
    /* Picking up previous section's example */
    module type EstablishmentType = {
      type profession;
      let getProfession: profession => string;
    };
  #+END_SRC
  This signature requires that a module:
  * Declare a type named ~profession~.
  * Must include a function that takes in a value of the type
    ~profession~ and returns a ~string~.

- A signature defines the list of requirements that a module must
  satisfy in order for that module to match the signature. Those
  requirements are of the form:
  + ~let x: int;~ requires a ~let~ binding named ~x~, of type ~int~.
  + ~type t = someType;~ requires a type field ~t~ to be equal to
    ~someType~.
  + ~type t;~ requires a type field ~t~, but without imposing any
    requirements on the actual, concrete type of ~t~. We'd use ~t~ in
    other entries in the signature to describe relationships,
    e.g. ~let makePair: t => (t, t)~ but we cannot, for example,
    assume that ~t~ is an ~int~. This gives us great, enforced abstraction
    abilities.
- Modules of the type ~EstablishmentType~ *can* contain more fields than
  the signature declares, just like the module ~School~ in the previous
  section (if we choose to assign it the type
  ~EstablishmentType~. Otherwise, ~School~ exposes every field). This
  effectively makes the ~person1~ field an enforced implementation
  detail! Outsiders can't access it, since it's not present in the
  signature; the signature constrained what others can access.

- The type ~EstablishmentType.profession~ is abstract: it doesn't have a
  concrete type; it's saying "I don't care what the actual type is,
  but it's used as input to ~getProfession~". This is useful to fit many
  modules under the same interface:
  #+BEGIN_SRC reason
    module Company: EstablishmentType = {
      type profession = CEO | Designer | Engineer | ...;

      let getProfession = (person) => ...;
      let person1 = ...;
      let person2 = ...;
    };
  #+END_SRC
  It's also useful to hide the underlying type as an implementation
  detail others can't rely on. If you ask what the type of
  ~Company.profession~ is, instead of exposing the variant, it'll only
  tell you "it's ~Company.profession~".
*** Extending module signatures
- Like modules themselves, module signatures can also be extended by
  other module signatures using ~include~:
  #+BEGIN_SRC reason
    module type BaseComponent = {
      let defaultGreeting: string;
      let getAudience: (~excited: bool) => string;
    };

    module type ActualComponent = {
      /* the BaseComponent signature is copied over */
      include BaseComponent;
      let render: unit => string;
    };
  #+END_SRC
  Note: ~BaseComponent~ is a module type, not an actual module itself!

- If you do not have a defined module type, you can extract it from an
  actual module using ~include (module type of ActualModuleName)~. For
  example, we can extend the ~List~ module from the OCaml standard
  library, which does not define a module type.
  #+BEGIN_SRC reason
    module type MyList = {
      include (module type of List);
      let myListFun: list('a) => list('a);
    };
  #+END_SRC
*** Every ~.rei~ file is a signature
- Similar to how a ~React.re~ file implicitly defines a module ~React~, a
  file ~React.rei~ implicitly defines a signature for ~React~.
- if ~React.rei~ isn't provided, the signature of ~React.re~ defaults to
  exposing all the fields of the module.
- Because they don't contain implementation files, ~.rei~ files are used
  in the ecosystem to also document the public API of their
  corresponding modules.
  #+BEGIN_SRC reason
    /* file React.re (implementation. Compiles to module React) */
    type state = int;
    let render = (str) => str;
  #+END_SRC
  #+BEGIN_SRC reason
  /* file React.rei (interface. Compiles to signature of module React) */
  type state = int;
  let render: str => str;
  #+END_SRC
*** Module Functions (functors)
- Modules can be passed to functions! It would be the equivalent of
  passing a file as a first-class item. However, modules are at a
  different "layer" of the language than other common concepts, so we
  can't pass them to regular functions. Instead, we pass them to
  special functions called "functors".
- The syntax for defining and using functors is very much like the
  syntax for defining and using regular functions. The primary
  differences are:
  + Functors use the ~module~ keyword instead of ~let~.
  + Functors take modules as arguments and return a module.
  + Functors require annotating arguments.
  + Functors must start with a capital letter (just like
    modules/signatures).
- Here's an example ~MakeSet~ functor, that takes in a module of the
  type ~Comparable~ and returns a new set that can contain such
  comparable items.
  #+BEGIN_SRC reason
    module type Comparable = {
      type t;
      let equal: (t, t) => bool;
    };

    module MakeSet = (Item: Comparable) => {
      /* let's use a list as our naive backing data structure */
      type backingType = list(Item.t);

      let empty = [];

      let add = (currentSet: backingType, newItem: Item.t) : backingType =>
        /* if item exists */
        if (List.exists((x) => Item.equal(x, newItem), currentSet)) {
          currentSet /* return the same (immutable) set (a list really) */
        } else {
          [
            newItem,
            ...currentSet /* prepend to the set and return it */
          ]
        };
    };
  #+END_SRC
  Functors can be applied using function application syntax. In this
  case, we're creating a set, whose items are pairs of integers.
  #+BEGIN_SRC reason
    module IntPair = {
      type t = (int, int);
      let equal = ((x1, y1), (x2, y2)) => x1 == x2 && y1 == y2;
      let create = (x, y) => (x, y);
    };

    /* IntPair abides by the Comparable signature required by MakeSet */
    module SetOfIntPairs = MakeSet(IntPair);
  #+END_SRC

*** Module functions types
- Like with module types, functor types also act to constrain and hide
  what we may assume about functors. The syntax for functor types are
  consistent with those for function types, but with types capitalized
  to represent the signatures of modules the functor accepts as
  arguments and return values. In the previous example, we're exposing
  the backing type of a set; by giving ~MakeSet~ a functor signature, we
  can hide the underlying data structure!
  #+BEGIN_SRC reason
    module type Comparable = ...

    module type MakeSetType = (Item: Comparable) => {
      type backingType;
      let empty: backingType;
      let add: (backingType, Item.t) => backingType;
    };

    module MakeSet: MakeSetType = (Item: Comparable) => {
      ...
    };
  #+END_SRC

** Promise
- Reason has built-in support for [[https://bucklescript.github.io/bucklescript/api/Js.Promise.html][JavaScript promises]] through
  BuckleScript. The 3 functions you generally need are:

  + ~Js.Promise.resolve: 'a => Js.Promise.t('a)~

  + ~Js.Promise.then_: ('a => Js.Promise.t('b), Js.Promise.t('a)) => Js.Promise.t('b)~

  + ~Js.Promise.catch: (Js.Promise.error => Js.Promise.t('a), Js.Promise.t('a)) => Js.Promise.t('a)~
- Additionally, here's how to create a JS promise on the Reason side:
  #+BEGIN_SRC reason
  Js.Promise.make: ( ( ~resolve: (. 'a) => unit, ~reject: (. exn) => unit ) => unit ) => Js.Promise.t('a)
  #+END_SRC
  This type signature means that ~make~ takes a callback that takes 2
  named arguments, ~resolve~ and ~reject~. Both arguments are themselves
  uncurried callbacks (they have a dot). ~make~ returns the created
  promise.

*** Usage
#+BEGIN_SRC reason
  let myPromise = Js.Promise.make((~resolve, ~reject) => resolve(. 2));

  myPromise
  |> Js.Promise.then_(value => {
       Js.log(value);
       Js.Promise.resolve(value + 2);
     })
  |> Js.Promise.then_(value => {
       Js.log(value);
       Js.Promise.resolve(value + 3);
     })
  |> Js.Promise.catch(err => {
       Js.log2("Failure!!", err);
       Js.Promise.resolve(-2);
     });
#+END_SRC
** Interop
- sample
  #+BEGIN_SRC reason
    Js.log("this is reason");

    [%bs.raw {| console.log('here is some javascript for you') |}];
  #+END_SRC
- sample 2
  #+BEGIN_SRC reason
    Js.log("this is reason");
    let x = [%bs.raw {| 'here is a string from javascript' |}];
    Js.log(x ++ " back in reason land"); /* ++ is the operator for string concat */
  #+END_SRC
- sample 3
  #+BEGIN_SRC reason
    let x: string = [%bs.raw {| 'well-typed' |}];
    Js.log(x ++ " back in reason land");
    /* ocaml will error out if you try to use x as anything other than a string */
  #+END_SRC
- sample 4
  #+BEGIN_SRC reason
    let jsCalculate: (array(int), int) => int = [%bs.raw
      {|
     function (numbers, scaleFactor) {
       var result = 0;
       numbers.forEach(number => {
         result += number;
       });
       return result * scaleFactor;
     }
    |}
    ];

    let calculate = (numbers, scaleFactor) => jsCalculate(Array.of_list(numbers), scaleFactor);

    Js.log(calculate([1, 2, 3], 10)); /* -> 60 */
  #+END_SRC
- sample 5
  #+BEGIN_SRC reason
    [@bs.val] external pi : float = "Math.PI";
    let tau = pi *. 2.0;
    [@bs.val] external alert : string => unit = "alert";
    alert("hello");
  #+END_SRC
- sample 6
  #+BEGIN_SRC reason
    type canvas;

    type context;

    /* we're leaving these types abstract, because we won't
     ,* be using them directly anywhere */
    [@bs.send] external getContext : (canvas, string) => context = "getContext";
    [@bs.send] external fillRect : (context, float, float, float, float) => unit = "fillRect";

    let myCanvas: canvas = [%bs.raw {| document.getElementById("mycanvas") |}];

    let ctx = getContext(myCanvas, "2d");
    fillRect(ctx, 0.0, 0.0, 100.0, 100.0);
  #+END_SRC

*** Using existing JavaScript libraries
- [[https://reasonml.github.io/docs/en/libraries][libraries]]
- [[https://redex.github.io/][Reason Package Index (Redex)]]
- [[bs-*][https://www.npmjs.com/search?q=keywords:bucklescript]]

* ReasonReact
** Creation, Props & Self
- ReasonReact doesn't use/need classes. The component creation API
  gives you a plain record, whose fields (like ~render~) you can
  override.
- The component template is created through
  ~ReasonReact.statelessComponent("TheComponentName")~. The string being
  passed is for debugging purposes (the equivalent of ReactJS'
  ~displayName~).
- As an example, here's the file ~Greeting.re~:
  #+BEGIN_SRC reason
    /* in Greeting.re */
    let component = ReasonReact.statelessComponent("Greeting");

    let make = (~name, _children) => {
      ...component, /* spread the template's other defaults into here  */
      render: _self => <div> {ReasonReact.string(name)} </div>
    };
  #+END_SRC
- The ~make~ function is what's called by ReasonReact's JSX.
  The JSX-less way of calling & rendering a component is:
  #+BEGIN_SRC reason
    ReasonReact.element(Greeting.make(~name="John", [||])) /* the `make` function in the module `Greeting` */
    /* equivalent to <Greeting name="John" /> */
  #+END_SRC
- ~make~ asks you to return the component record created above. You'd
  override a few fields, such as the familiar ~render~, ~initialState~,
  ~didMount~, etc.
*** Props
- Props are just the labeled arguments of the ~make~ function.
- They can also be optional and/or have defaults, e.g.
  #+BEGIN_SRC reason
    let make =
      (~name, ~age=?, ~className="box", _children) => /* ... */.
  #+END_SRC
  + You'd call that component in another file through ~<Foo name="Reason" />~.
   ~className~, if omitted, defaults to ~"box"~. ~age~ defaults to
    ~None~. If you'd like to explicitly pass ~age~, simply do so:
    ~<Foo name="Reason" age=20 />~.

- The last prop must be ~children~. If you don't use it, simply ignore
  it by naming it ~_~ or ~_children~.
- The prop name cannot be ~ref~ nor ~key~. Those are reserved, just
  like in ReactJS.
**** Neat Trick with Props Forwarding
- Sometimes in ReactJS, you're being given a prop from the owner that
  you'd like to forward directly to the child:
  #+BEGIN_SRC js
  <Foo name="Reason" age={this.props.age} />
  #+END_SRC
  + This is a source of bugs, because ~this.props.age~ might be
    accidentally changed to a nullable number while ~Foo~ doesn't expect
    it to be so, or vice-versa; it might be nullable before, and now
    it's not and ~Foo~ is left with a useless ~null~ check somewhere in
    the render.
  + In Reason, if you want to explicitly pass an optional ~myAge~
    (whose type is ~option(int)~, aka ~None | Some(int)~), the
    following wouldn't work:
    #+BEGIN_SRC reason
    <Foo name="Reason" age=myAge />
    #+END_SRC
  + Because the ~age~ label expects a normal ~int~ when you do call ~Foo~
    with it, not an ~option(int)~! Naively, you'd be forced to solve
    this like so:
    #+BEGIN_SRC reason
      switch (myAge) {
      | None => <Foo name="Reason" />
      | Some(nonOptionalAge) => <Foo name="Reason" age=nonOptionalAge />
      }
    #+END_SRC
    here's a better way to explicitly pass an optional value:
    #+BEGIN_SRC reason
    <Foo name="Reason" age=?myAge />
    #+END_SRC
    It says "I understand that ~myAge~ is optional and that I should
    either use the label ~age~ and pass an ~int~, or not use the label at
    all. But I'd like to forward an ~option~ al value explicitly to avoid
    the verbose ~switch~".

*** self
- It's a record that contains ~state~, ~handle~ and ~send~, which we pass
  around to the lifecycle events, ~render~ and a few others, when they
  need the bag of information.
** JSX
- Reason comes with the JSX syntax! ReasonReact transforms it from an
  agnostic function call into a ReasonReact-specific call through a
  macro.
*** Uncapitalized
-
  #+BEGIN_SRC reason
  <div foo={bar}> {child1} {child2} </div>
  #+END_SRC
  transforms into
  #+BEGIN_SRC reason
    ReactDOMRe.createElement("div", ~props=ReactDOMRe.props(~foo=bar, ()), [|child1, child2|]);
  #+END_SRC
  which compiles to the JS code:
  #+BEGIN_SRC js
    React.createElement('div', {foo: bar}, child1, child2)
  #+END_SRC
-
  Prop-less ~<div />~ transforms into
  #+BEGIN_SRC reason
    ReactDOMRe.createElement("div", [||]);
  #+END_SRC
  Which compiles to
  #+BEGIN_SRC reason
    React.createElement('div', undefined)
  #+END_SRC
- Note that ~ReactDOMRe.createElement~ is intended for internal use by
  the JSX transform. For escape-hatch scenarios, use
  ~ReasonReact.createDomElement~ instead
*** Capitalized
-
  #+BEGIN_SRC reason
   <MyReasonComponent key={a} ref={b} foo={bar} baz={qux}> {child1} {child2} </MyReasonComponent>
  #+END_SRC
  transforms into
  #+BEGIN_SRC reason
    ReasonReact.element(
         ~key=a,
         ~ref=b,
         MyReasonComponent.make(~foo=bar, ~baz=qux, [|child1, child2|])
       );
  #+END_SRC
  Prop-less ~<MyReasonComponent />~ transforms into
  #+BEGIN_SRC reason
    ReasonReact.element(MyReasonComponent.make([||]));
  #+END_SRC
- Note how ~ref~ and ~key~ have been lifted out of the JSX call into the
  ~ReasonReact.element~ call. ~ref~ and ~key~ are reserved in ReasonReact,
  just like in ReactJS. Don't use them as props in your component!

*** Fragment
-
  #+BEGIN_SRC reason
    <> child1 child2 </>;
  #+END_SRC
  transforms into
  #+BEGIN_SRC reason
    ReactDOMRe.createElement(ReasonReact.fragment, [|child1, child2|]);
  #+END_SRC
  Which compiles to
  #+BEGIN_SRC reason
    React.createElement(React.Fragment, undefined, child1, child2);
  #+END_SRC
*** Children
- ReasonReact children are fully typed, and you can pass any data
  structure to it (as long as the receiver component permits it). When
  you write:
  #+BEGIN_SRC reason
    <MyReasonComponent> <div /> <div /> </MyReasonComponent>
  #+END_SRC
 You're effectively passing the array ~[| <div />, <div /> |]~ to
 ~MyReasonComponent~'s children. But this also means that the following
 wouldn't work:
 #+BEGIN_SRC reason
 let theChildren = [| <div />, <div /> |];

 <MyReasonComponent> theChildren </MyReasonComponent>
 #+END_SRC
 Because this actually translates to:
 #+BEGIN_SRC reason
   let theChildren = [| <div />, <div /> |];
   ReasonReact.element(
     MyReasonComponent.make([|theChildren|])
   );
 #+END_SRC
  Which wraps the already wrapped ~theChildren~ in another layer of
  array. To solve this issue, Reason has a special children spread
  syntax:
  #+BEGIN_SRC reason
    let theChildren = [| <div />, <div /> |];
    <MyReasonComponent> ...theChildren </MyReasonComponent>
  #+END_SRC
  This simply passes ~theChildren~ without array wrapping. It becomes:
  #+BEGIN_SRC reason
    let theChildren = [| <div />, <div /> |];
    ReasonReact.element(
      MyReasonComponent.make(theChildren)
    );

  #+END_SRC
** Render
- render needs to return a ~ReasonReact.reactElement~: ~<div />~,
  ~<MyComponent />~, etc. Render takes the argument ~self~:
  #+BEGIN_SRC reason
    /* ... */
        render: (self) => <div />
    /* ... */
  #+END_SRC

- What if you want to return ~null~ from a ~render~? Or pass a string to a
  DOM component like div which only allows ~ReasonReact.reactElements~?
  + In ReactJS, you can easily do: ~<div> hello </div>~, ~<div> {1} </div>~,
    ~<div> {null} </div>~, etc. In Reason, the type system
    restricts you from passing arbitrary data like so; you can only
    return ~ReasonReact.reactElement~ from render.
- Fortunately, we special-case a few special elements of the type
  ~ReasonReact.reactElement~:
  + ~ReasonReact.null~: This is your ~null~ equivalent for ~render~'s
    return value. Akin to ~return null~ in ReactJS render.
  + ~ReasonReact.string~: Takes a string and converts it to a
    ~reactElement~. You'd use ~<div> {ReasonReact.string(string_of_int(10))} </div>~
     to display an int.
  + ~ReasonReact.array~: Takes an array and converts it to a ~reactElement~.

** Callback Handlers
- This section describes how ReactJS' ~<div onClick={this.handleClick} />~
   pattern translates into ReasonReact.
*** Callback Without State Update
**** Without Reading From ~self~
- ~self~ is ReasonReact's ~this~. It's a record that contains things
  like ~state~, ~send~ and others.
- If you're just forwarding a callback prop onto your child, you'd do
  exactly the same thing you'd have done in ReactJS:
  #+BEGIN_SRC reason
    let component = /* ... */;

    let make = (~name, ~onClick, _children) => {
      ...component,
      render: (self) => <button onClick=onClick />
    };
  #+END_SRC
- to pre-process a value before sending it back to the component's owner:
  #+BEGIN_SRC reason
    let component = /* ... */;

    let make = (~name, ~onClick, _children) => {
      let click = (event) => onClick(name); /* pass the name string up to the owner */
      {
        ...component,
        render: (self) => <button onClick=click />
      }
    };
  #+END_SRC
**** Reading From ~self~
- To access ~state~, ~send~ and the other items in ~self~ from a callback,
  you need to wrap the callback in an extra layer called ~self.handle~:
  #+BEGIN_SRC reason
    let component = /* ... */;

    let make = (~name, ~onClick, _children) => {
      let click = (event, self) => {
        onClick(event);
        Js.log(self.state);
      };
      {
        ...component,
        initialState: /* ... */,
        render: (self) => <button onClick={self.handle(click)} />
      }
    };
  #+END_SRC
  + Note how your ~click~ callback now takes the extra argument
    ~self~. Formally, ~self.handle~ expects a callback that
    * accepts the single payload you'd normally directly pass to e.g. ~handleClick~,
    * plus the argument ~self~,
    * returns "nothing" (aka, ~()~, aka, ~unit~).
  + Note 2: sometimes you might be forwarding ~handle~ to some helper
    functions. Pass the whole ~self~ instead and annotate it. This
    avoids a complex ~self~ record type behavior. [[https://reasonml.github.io/reason-react/docs/en/record-field-send-handle-not-found][See Record Field send/handle Not Found]].
    Also check [[https://reasonml.chat/t/unbound-record-field-send-in-event-handlers/204/6][this thread]]
  + Explanation
    * In reality, ~self.handle~ is just a regular function accepting two
      arguments, the first being the callback in question, and the
      second one being the payload that's intended to be passed to the
      callback.

    * Get it? Through Reason's natural language-level currying, we
      usually only ask you to pass the first argument. This returns a
      new function that takes in the second argument and executes the
      function body. The second argument being passed by the caller,
      aka the component you're rendering!
**** Callback Receiving Multiple Arguments
- Sometimes, the component you're calling is from JavaScript (using
  the ReasonReact<->ReactJS interop), and its callback prop asks you
  to pass a callback that receives more than one argument. In ReactJS,
  it'd look like:
  #+BEGIN_SRC js
    handleSubmit: function(username, password, event) {
      this.setState(...)
    }
    ...
    <MyForm onUserClickedSubmit={this.handleSubmit} />
  #+END_SRC
  + You cannot write such ~handleSubmit~ in ReasonReact, as handle
    expects to wrap around a function that only takes one
    argument. Here's the workaround:
    #+BEGIN_SRC reason
      let handleSubmitEscapeHatch = (username, password, event) =>
        self.handle(
          (tupleOfThreeItems, self) => doSomething(tupleOfThreeItems, self),
          (username, password, event),
        );
      ...
      <MyForm onUserClickedSubmit=(handleSubmitEscapeHatch) />
    #+END_SRC
    * Basically, you write a normal callback that:
      + takes those many arguments from the JS component callback prop,
      + packs them into a tuple and call ~self.handle~,
      + pass to ~handle~ the usual function that expects a single argument,
      + finish calling ~self.handle~ by passing the tuple directly yourself.
** State, Actions & Reducer
- Use ~ReasonReact.reducerComponent("MyComponentName")~.
- sample
  #+BEGIN_SRC reason
    type state = {
      count: int,
      show: bool,
    };

    type action =
      | Click
      | Toggle;

    let component = ReasonReact.reducerComponent("Example");

    let make = (~greeting, _children) => {
      ...component,

      initialState: () => {count: 0, show: true},

      reducer: (action, state) =>
        switch (action) {
        | Click => ReasonReact.Update({...state, count: state.count + 1})
        | Toggle => ReasonReact.Update({...state, show: !state.show})
        },

      render: self => {
        let message =
          "You've clicked this " ++ string_of_int(self.state.count) ++ " times(s)";
        <div>
          <button onClick=(_event => self.send(Click))>
            (ReasonReact.string(message))
          </button>
          <button onClick=(_event => self.send(Toggle))>
            (ReasonReact.string("Toggle greeting"))
          </button>
          (
            self.state.show
              ? ReasonReact.string(greeting)
              : ReasonReact.null
          )
        </div>;
      },
    };
  #+END_SRC
*** ~initialState~
*** Actions & Reducer
- A few things:
  + There's a user-defined type called ~action~, named so by
    convention. It's a variant of all the possible state transitions
    in your component. In state machine terminology, this'd be a
    "token".
  + A user-defined state type, and an ~initialState~. Nothing special.
  + The current ~state~ value is accessible through ~self.state~,
    whenever ~self~ is passed to you as an argument of some function.
  + A "reducer"! This pattern-matches on the possible actions and
    specifies what state update each action corresponds to. In state
    machine terminology, this'd be a "state transition".
  + In ~render~, instead of ~self.handle~ (which doesn't allow state
    updates), you'd use ~self.send~. ~send~ takes an action.
*** State Update Through Reducer
- Notice the return value of ~reducer~? The ~ReasonReact.Update~
  part. Instead of returning a bare new state, we ask you to return
  the state wrapped in this "update" variant. Here are its possible
  values:
  + ~ReasonReact.NoUpdate~: don't do a state update.
  + ~ReasonReact.Update(state)~: update the state.
  + ~ReasonReact.SideEffects(self => unit)~: no state update, but trigger a side-effect,
     e.g. ReasonReact.SideEffects(_self => Js.log("hello!")).
  + ~ReasonReact.UpdateWithSideEffects(state, self => unit)~: update the state, *then* trigger a side-effect.
*** Important Notes
- The action type's variants can carry a payload: ~onClick=(data => self.send(Click(data.foo)))~.
- Don't pass the whole event into the action variant's
  payload. ReactJS events are pooled; by the time you intercept the
  action in the ~reducer~, the event's already recycled.
- ~reducer~ must be pure! Aka don't do side-effects in them
  directly. You'll thank us when we enable the upcoming concurrent
  React (Fiber). Use ~SideEffects~ or ~UpdateWithSideEffects~ to enqueue a
  side-effect. The side-effect (the callback) will be executed after
  the state setting, but before the next render.
- If you need to do e.g. ~ReactEvent.BlablaEvent.preventDefault(event)~,
  do it in ~self.send~, before returning the action type. Again, ~reducer~
  must be pure.
- Feel free to trigger another action in ~SideEffects~ and
  ~UpdateWithSideEffects~, e.g. ~UpdateWithSideEffects(newState, (self) => self.send(Click))~.
- If your state only holds instance variables, it also means (by the
  convention in the instance variables section) that your component
  only contains ~self.handle~, no ~self.send~. You still need to specify a
  ~reducer~ like so: ~reducer: ((), _state) => ReasonReact.NoUpdate~.
  Otherwise you'll get a variable cannot be generalized type error.
*** Tip
- Cram as much as possible into ~reducer~. Keep your actual callback
  handlers (the ~self.send(Foo)~ part) dumb and small. This makes all
  your state updates & side-effects (which itself should mostly only
  be inside ~ReasonReact.SideEffects~ and
  ~ReasonReact.UpdateWithSideEffects~) much easier to scan through. Also
  more ReactJS fiber async-mode resilient.
*** Async State Setting
- In ReactJS, you could use setState inside a callback, like so:
  #+BEGIN_SRC javascript
  setInterval(() => this.setState(...), 1000);
  #+END_SRC
  In ReasonReact, you'd do something similar:
  #+BEGIN_SRC reason
  Js.Global.setInterval(() => self.send(Tick), 1000)
  #+END_SRC
** Lifecycles
- ReasonReact supports the familiar ReactJS lifecycle events.
  + ~didMount: self => unit~

  + ~willReceiveProps: self => state~

  + ~shouldUpdate: oldAndNewSelf => bool~

  + ~willUpdate: oldAndNewSelf => unit~

  + ~didUpdate: oldAndNewSelf => unit~

  + ~willUnmount: self => unit~
- Note:
  1. ~willReceiveProps~ asks for the return type to be ~state~, not update
     state (i.e. not NoUpdate/Update/SideEffects/UpdateWithSideEffects). We presume
     you'd always want to update the state in this lifecycle. If not,
     simply return the previous state exposed in the lifecycle
     argument.

  2. ~didUpdate~, ~willUnmount~ and ~willUpdate~ don't allow you to
     return a new state to be updated, to prevent infinite loops.

  3. ~willMount~ is unsupported. Use ~didMount~ instead.

  4. ~didUpdate~, ~willUpdate~ and ~shouldUpdate~ take in a
     ~oldAndNewSelf~ record, of type ~{oldSelf: self, newSelf: self}~.
     These two fields are the equivalent of ReactJS'
     ~componentDidUpdate~'s prevProps/prevState/ in conjunction with
     props/state. Likewise for ~willUpdate~ and ~shouldUpdate~.

- If you need to update state in a lifecycle event, simply send an
  action to reducer and handle it correspondingly:
  ~self.send(DidMountUpdate)~.
*** Access next or previous props: ~retainedProps~
- One pattern that's sometimes used in ReactJS is accessing a
  lifecycle event's ~prevProps~ (~componentDidUpdate~), ~nextProps~
  (~componentWillUpdate~), and so on. ReasonReact doesn't automatically
  keep copies of previous props for you. We provide the ~retainedProps~
  API for this purpose:
  #+BEGIN_SRC reason
    type retainedProps = {message: string};

    let component = ReasonReact.statelessComponentWithRetainedProps("RetainedPropsExample");

    let make = (~message, _children) => {
      ...component,
      retainedProps: {message: message},
      didUpdate: ({oldSelf, newSelf}) =>
        if (oldSelf.retainedProps.message !== newSelf.retainedProps.message) {
          /* do whatever sneaky imperative things here */
          Js.log("props `message` changed!")
        },
      render: (_self) => /* ... */
    };
  #+END_SRC
- We expose ~ReasonReact.statelessComponentWithRetainedProps~ and
  ~ReasonReact.reducerComponentWithRetainedProps~. Both work like their
  ordinary non-retained-props counterpart, and require you to specify
  a new field, ~retainedProps~ (of whatever type you'd like) in your
  component's spec in ~make~.

*** ~willReceiveProps~
- Traditional ReactJS ~componentWillReceiveProps~ takes in a
  ~nextProps~. We don't have ~nextProps~, since those are simply the
  labeled arguments in ~make~, available to you in the scope. To access
  the current props, however, you'd use the above ~retainedProps~ API:
  #+BEGIN_SRC reason
    type state = {someToggle: bool};

    let component = ReasonReact.reducerComponentWithRetainedProps("MyComponent");

    let make = (~name, _children) => {
      ...component,
      initialState: () => {someToggle: false},
      /* just like state, the retainedProps field can return anything! Here it retained the `name` prop's value */
      retainedProps: name,
      willReceiveProps: (self) => {
        if (self.retainedProps === name) {
          /* ... */
          /* previous ReactJS logic would be: if (props.name === nextProps.name) */
        };
        /* ... */
      }
    };
  #+END_SRC

*** ~willUpdate~
- ReactJS' ~componentWillUpdate's~ ~nextProps~ is just the labeled
  arguments in ~make~, and "current props" (aka ~this.props~) is the props
  you've copied into ~retainedProps~, accessible via ~{oldSelf}~:
  #+BEGIN_SRC reason
    {
      ...component,
      willUpdate: ({oldSelf, newSelf}) => /* ... */
    }
  #+END_SRC

*** ~didUpdate~
- ReactJS' ~prevProps~ is what you've synced in ~retainedProps~, under
  ~oldSelf~.

*** ~shouldUpdate~
- ReactJS' ~shouldComponentUpdate~ counterpart.
** Instance Variables
- A common pattern in ReactJS is to attach extra variables onto a
  component's spec:
  #+BEGIN_SRC reason
    const Greeting = React.createClass({
      intervalId: null,
      componentDidMount: () => this.intervalId = setInterval(...),
      render: ...
    });
  #+END_SRC
- In reality, this is nothing but a thinly veiled way to mutate a
  component's "state", without triggering a re-render. ReasonReact
  asks you to correctly put these instance variables into your
  component's ~state~, into Reason [[https://reasonml.github.io/docs/en/mutation.html][refs]].
  #+BEGIN_SRC reason
    type state = {
      someRandomState: option(string),
      intervalId: ref(option(int))
    };

    let component = /* ... */; /* remember, `component` needs to be close to `make`, and after `state` type declaration! */

    let make = (_children) => {
      ...component,
      initialState: () => {
        someRandomState: Some("hello"),
        intervalId: ref(None),
      },
      didMount: ({state}) => {
        /* mutate the value here */
        state.intervalId := Some(Js.Global.setInterval(/* ... */));
        /* no extra state update needed */
        ReasonReact.NoUpdate
      },
      render: /* ... */
    };
  #+END_SRC

- All your instance variables (subscriptions, refs, etc.) must be in
  state fields marked as a ~ref~. Don't directly use a mutable field on
  the state record, use an immutable field pointing to a Reason
  ~ref~. Why such constraint? To prepare for concurrent React which
  needs to manage side-effects & mutations more formally.
** React Ref
- A ReasonReact ~ref~ would be just another instance variable. You'd
  type it as ~ReasonReact.reactRef~ if it's attached to a custom
  component, and ~Dom.element~ if it's attached to a React DOM element.
  #+BEGIN_SRC reason
    type state = {
      isOpen: bool,
      mySectionRef: ref(option(ReasonReact.reactRef))
    };

    let setSectionRef = (theRef, {ReasonReact.state}) => {
      state.mySectionRef := Js.Nullable.toOption(theRef);
      /* wondering about Js.Nullable.toOption? See the note below */
    };

    let component = ReasonReact.reducerComponent("MyPanel");

    let make = (~className="", _children) => {
      ...component,
      initialState: () => {
        isOpen: false,
        mySectionRef: ref(None),
      },
      reducer: /* ... */,
      render: (self) => <Section1 ref={self.handle(setSectionRef)} />
    };
  #+END_SRC
  + Attaching to a React DOM element looks the same:
    ~state.mySectionRef = {myDivRef: Js.Nullable.toOption(theRef)}~.
  + Note how ReactJS refs can be null. Which is why ~theRef~ and
    ~myDivRef~ are converted from a JS nullable to an OCaml ~option~
    (Some/None). When you use the ~ref~, you'll be forced to handle the
    ~null~ case through a ~switch~, which prevents subtle errors!

- ReasonReact ~ref~ only accept callbacks. The string ref from ReactJS
  is deprecated.

- We also expose an escape hatch ~ReasonReact.refToJsObj~ of type
  ~ReasonReact.reactRef => Js.t {..}~, which turns your ref into a JS
  object you can freely use; this is only used to access ReactJS
  component class methods.
  #+BEGIN_SRC reason
    let handleClick = (event, self) =>
      switch (self.state.mySectionRef^) {
      | None => ()
      | Some(r) => ReasonReact.refToJsObj(r)##someMethod(1, 2, 3) /* I solemnly swear that I am up to no good */
      };
  #+END_SRC
** Talk to Existing ReactJS Code
- A ReasonReact component is not a ReactJS component. We provide hooks
  to communicate between the two.
- Whether you're using an existing ReactJS component or providing a
  ReasonReact component for consumption on the JS side, you need to
  establish the type of the JS props you'd convert from/to, by using
  [[https://bucklescript.github.io/docs/en/object.html][BuckleScript's bs.deriving abstract]]:
  #+BEGIN_SRC reason
    [@bs.deriving abstract]
    type jsProps = {
      /* some example fields */
      className: string,
      /* `type` is reserved in Reason. use `type_` and make it still compile to the
        JS key `type` */
      [@bs.as "type"] type_: string,
      value: Js.nullable(int),
    };

  #+END_SRC
  + This will generate the getters and the JS object creation function
    (of the same name, ~jsProps~) you'll need.
  + Note: you do not declare ~ref~ and ~key~ (the two special ReactJS
    "props"). We handle that for you, just like ReactJS does. They're
    not really props.
- ReasonReact using ReactJS
  Easy! Since other Reason components only need you to expose a ~make~ function, fake one up:
  #+BEGIN_SRC reason
     /*[@bs.module "./foo"] external my_js_react: ReasonReact.reactClass = "default"; */

    [@bs.module] external myJSReactClass: ReasonReact.reactClass = "./myJSReactClass";

    let make = (~className, ~type_, ~value=?, children) =>
      ReasonReact.wrapJsForReason(
        ~reactClass=myJSReactClass,
        ~props=jsProps(
          ~className,
          ~type_,
          ~value=Js.Nullable.fromOption(value),
        ),
        children,
      );
  #+END_SRC
  ~ReasonReact.wrapJsForReason~ is the helper we expose for this
  purpose. It takes in:
  + The reactClass you want to wrap
  + The ~props~ js object you'd create through the generated ~jsProps~
    function from the ~jsProps~ type you've declared above (with
    values properly converted from Reason data structures to JS)
  + The mandatory ~children~ you'd forward to the JS side.
  + ~props~ is mandatory. If you don't have any to pass, pass
    ~~props=Js.Obj.empty()~ instead.

- ReactJS Using ReasonReact
  + Eeeeasy. We expose a helper for the other direction,
    ~ReasonReact.wrapReasonForJs~:
    #+BEGIN_SRC reason
      let component = ...;
      let make ...;

      [@bs.deriving abstract]
      type jsProps = {
        name: string,
        age: Js.nullable(int),
      };

      let jsComponent =
        ReasonReact.wrapReasonForJs(~component, jsProps =>
          make(
            ~name=jsProps->nameGet,
            ~age=?Js.Nullable.toOption(jsProps->ageGet),
            [||],
          )
        );
    #+END_SRC
- The function takes in:
  + The labeled reason ~component~ you've created
  + A function that, given the JS props, asks you to call ~make~ while
    passing in the correctly converted parameters (~bs.deriving abstract~
    above generates a field accessor for every record field you've declared).
- You'd assign the whole thing to the name ~jsComponent~. The JS side
  can then import it:
  #+BEGIN_SRC javascript
    var MyReasonComponent = require('./myReasonComponent.bs').jsComponent;
    // make sure you're passing the correct data types!
    <MyReasonComponent name="John" />
  #+END_SRC
- Note: if you'd rather use a ~default~ import on the JS side, you can
  export such default from BuckleScript/ReasonReact:
  #+BEGIN_SRC reason
  let default = ReasonReact.wrapReasonForJs(...)
  #+END_SRC
  and then import it on the JS side with:
  #+BEGIN_SRC
  import MyReasonComponent from './myReasonComponent.bs';
  #+END_SRC
  BuckleScript default exports *only* works when the JS side uses ES6
  import/exports.
** Event
- ReasonReact events map cleanly to ReactJS [[https://reactjs.org/docs/events.html][synthetic events]]. More info in the [[https://github.com/reasonml/reason-react/blob/master/src/ReactEvent.rei#L1][inline docs]].
- If you're accessing fields on your event object, like
  ~event.target.value~, you'd use a combination of a ~ReactDOMRe~ helper
  and BuckleScript's ~##~ object access FFI:
  #+BEGIN_SRC reason
    ReactEvent.Form.target(event)##value;
  #+END_SRC
  Or, equivalently, using fast pipe:

  #+BEGIN_SRC reason
    event->ReactEvent.Form.target##value;
  #+END_SRC
** Style
- inline style
  #+BEGIN_SRC reason
    <div style=(
    ReactDOMRe.Style.make(~color="#444444", ~fontSize="68px", ())
    )/>
  #+END_SRC
  + It's a labeled (typed!) function call that maps to the familiar
    style object ~{color: '#444444', fontSize: '68px'}~. Note that make
    returns an opaque ~ReactDOMRe.style~ type that you can't read
    into. We also expose a ~ReactDOMRe.Style.combine~ that takes in two
    styles and combine them.
*** Escape Hatch: ~unsafeAddProp~
- The above ~Style.make~ API will safely type check every style field!
  However, we might have missed some more esoteric fields. If that's
  the case, the type system will tell you that the field you're trying
  to add doesn't exist. To remediate this, we're exposing a
  ~ReactDOMRe.Style.unsafeAddProp~ to dangerously add a field to a
  style:
  #+BEGIN_SRC reason
  let myStyle = ReactDOMRe.Style.make(~color="#444444", ~fontSize="68px", ());
  let newStyle = ReactDOMRe.Style.unsafeAddProp(myStyle, "width", "10px");
  #+END_SRC
** cloneElement
- Signature:
  #+BEGIN_SRC reason
  let cloneElement: (reactElement, ~props: Js.t({..})=?, 'anyChildrenType) => reactElement
  #+END_SRC
- Same as ReactJS' ~[[https://reactjs.org/docs/react-api.html#cloneelement][cloneElement]]~. However, adding extra props to a
  ReasonReact component doesn't make sense; you'd use a [[https://reactjs.org/docs/render-props.html][render prop]].
  Therefore, ~ReasonReact.cloneElement~ is only used in edge-cases
  to convert over existing code.
  #+BEGIN_SRC reason
    let clonedElement =
      ReasonReact.cloneElement(
        <div className="foo" />,
        ~props={"payload": 1},
        [||]
      );
  #+END_SRC
  + The ~props~ value is unsafe, be careful!
  + You can also use ~cloneElement~ to simulate [[https://reasonml.github.io/reason-react/docs/en/props-spread][prop spreading]], but this
    is discouraged in ReasonReact.

** children
- ~children~ props is basically like any other prop
- You can pass tuple, variant, record and others to children, However,
  due to syntactical and interoperability reasons, there are some
  small restrictions on ~children~:
  1. DOM elements such as ~div~, ~span~ and others mandate the children
     you pass to be ~array(reactElement)~. For example, ~<div> [1, 2, 3] </div>~ or
     ~<span> Some(10) </span>~ don't work, since the ~list~ and
     the ~option~ are forwarded to the underlying ReactJS ~div~ / ~span~ and
     such data types don't make sense in JS.
  2. User-defined elements, by default, also accept an array (of
     anything). This is due to a rather silly constraint of the JSX
     syntax.
*** Syntax Constraint
- Technically, if you've written a component that accepts a tuple as
  ~children~:
  #+BEGIN_SRC reason
    /* MyForm.re */
    type tuple2Children = (ReasonReact.reactElement, ReasonReact.reactElement);

    let make = (children: tuple2Children) => {
      ...component,
      render: _self => {
        <div>
          {fst(children)}
          <Separator />
          {snd(children)}
        </div>
      }
    };
  #+END_SRC
  Then you can expect the user to pass you a tuple:
  #+BEGIN_SRC reason
    <MyForm> (<div />, <div />) </MyForm>
  #+END_SRC
  This, however, will give you a type error:
  #+BEGIN_SRC reason
    This has type:
      array('a)
    But somewhere wanted:
      tuple2Children (defined as (ReasonReact.reactElement, ReasonReact.reactElement))
  #+END_SRC
  + It means that ~MyForm~ is expecting the tuple, but you're giving
    ~array~ instead! What's happening? Well, look at what JSX is
    transformed into:
    #+BEGIN_SRC reason
      <MyLayout> a b </MyLayout>
      <MyLayout> a </MyLayout>
    #+END_SRC
    These actually become:
    #+BEGIN_SRC reason
      ReasonReact.element(
        MyLayout.make([|a, b|])
      );
      ReasonReact.element(
        MyLayout.make([|a|])
      );
    #+END_SRC
    See how the second ~MyLayout~'s children is also wrapped in an
    array? We can't special-case ~<MyLayout> a </MyLayout>~ to pass a
    without the array wrapping (it'd give even more confusing
    errors). Since children is usually an array, we've decided to
    always wrap it with an array, no matter how many items we visually
    see in the JSX. But what if you really want to pass unwrapped
    data?

*** Children Spread
- Just use ~<MyLayout> ...a </MyLayout>~. This will simply transform
  into ~ReasonReact.element(MyLayout.make(a))~, aka without the array
  wrapping.

*** Tips & Tricks
- A layout component that mandates a tuple of 2 react element and
  shows them side-by-side:
  #+BEGIN_SRC reason
  <MyForm> ...(<div />, <div />) </MyForm>
  #+END_SRC
- A component that mandates a callback, no need for ReactJS' React.Children.only runtime check:
  #+BEGIN_SRC reason
    <Motion> ...((name) => <div className=name />) </Motion>
  #+END_SRC
- A layout helper that accepts a variant of ~TwoRows | ThreeRows | FourColumns~
  #+BEGIN_SRC reason
    <Layout> ...(ThreeRows(<div />, child2, child3)) </Layout>
  #+END_SRC

** Working with DOM
*** ReactDOM
- ReasonReact's ReactDOM module is called ~ReactDOMRe~. The module
  exposes helpers that work with familiar ReactJS idioms. For example,
  to access ~event.target.value~, you can do
  ~ReactEvent.Form.target(event)##value~
  + ~render~:
    #+BEGIN_SRC reason
      (ReasonReact.reactElement, Dom.element) => unit
    #+END_SRC

  + ~unmountComponentAtNode~:
    #+BEGIN_SRC reason
      Dom.element => unit
    #+END_SRC

  + ~findDOMNode~:
    #+BEGIN_SRC reason
      ReasonReact.reactRef => Dom.element
    #+END_SRC

  + hydrate:
    #+BEGIN_SRC reason
      (ReasonReact.reactElement, Dom.element) => unit
    #+END_SRC

  + objToDOMProps:
    #+BEGIN_SRC reason
      Js.t({..}) => ReactDOMRe.props (see use-case in Invalid Prop Name)
    #+END_SRC

  + createElement: the call that lower-case JSX turns into.
    #+BEGIN_SRC reason
      (string, ~props: ReactDOMRe.props=?, array(ReasonReact.reactElement)) => ReasonReact.reactElement
    #+END_SRC

  + createElementVariadic: same as above, but a less performant
    version, used when there's a children spread and not a static
    array at the call site: ~<div>...myChildren</div>~.

  + ~domElementToObj~: turns a DOM element into a Js object whose fields you can dangerously access. Usually not needed
    #+BEGIN_SRC reason
      Dom.element => Js.t({..})
    #+END_SRC

- And 4 convenience utilities:
  + ~renderToElementWithClassName~: finds the (first) element with the provided class name and render to it.
    #+BEGIN_SRC reason
      (ReasonReact.reactElement, string) => unit
    #+END_SRC

 + renderToElementWithId: finds the element with the provided id and render to it.
   #+BEGIN_SRC reason
     (ReasonReact.reactElement, string) => unit
   #+END_SRC

 + ~hydrateToElementWithClassName~, ~hydrateToElementWithId~: same.

*** ReactDOMServer
- ReasonReact's equivalent ~ReactDOMServerRe~ exposes:
  + ~renderToString~: ~ReactRe.reactElement => string~
  + ~renderToStaticMarkup~: ~ReactRe.reactElement => string~
** Subscriptions Helper
- In a large, heterogeneous app, you might often have legacy or
  interop data sources that come from outside of the React/ReasonReact
  tree, or a timer, or some browser event handling. You'd listen and
  react to these changes by, say, updating the state.
  #+BEGIN_SRC reason
    type state = {
      timerId: ref(option(Js.Global.intervalId))
    };

    let component = ReasonReact.reducerComponent("Todo");

    let make = _children => {
      ...component,
      initialState: () => {timerId: ref(None)},
      didMount: self => {
        self.state.timerId := Some(Js.Global.setInterval(() => Js.log("hello!"), 1000));
      },
      willUnmount: self => {
        switch (self.state.timerId^) {
        | Some(id) => Js.Global.clearInterval(id);
        | None => ()
        }
      },
      render: /* ... */
    };
  #+END_SRC
  + Notice a few things:
    * This is rather boilerplate-y.
    * Did you use a ~ref(option(foo))~ type correctly instead of a
      mutable field, as indicated by the [[https://reasonml.github.io/reason-react/docs/en/instance-variables][Instance Variables section]]?
    * Did you remember to free your timer subscription in ~willUnmount~?

- To solve the above problems and to codify a good practice,
  ~ReasonReact~ provides a helper field in ~self~, called ~onUnmount~. It
  asks for a callback of type ~unit => unit~ in which you free your
  subscriptions. It'll be called before the component unmounts.
  + Here's the previous example rewritten:
    #+BEGIN_SRC reason
      let component = ReasonReact.statelessComponent("Todo");

      let make = _children => {
        ...component,
        didMount: self => {
          let intervalId = Js.Global.setInterval(() => Js.log("hello!"), 1000);
          self.onUnmount(() => Js.Global.clearInterval(intervalId));
        },
        render: /* ... */
      };
    #+END_SRC
*** Design Decisions
- Why not just put some logic in the ~willUnmount~ lifecycle? Definitely
  do, whenever you could. But sometimes, folks forget to release their
  subscriptions inside callbacks:
  #+BEGIN_SRC reason
    let make = _children => {
      ...component,
      reducer: (action, state) => {
        switch (action) {
        | Click => ReasonReact.SideEffects(self => {
            fetchAsyncData(result => {
              self.send(Data(result))
            });
          })
        }
      },
      render: /* ... */
    };
  #+END_SRC
  If the component unmounts and then the ~fetchAsyncData~ calls the
  callback, it'll accidentally call ~self.send~.
  Using ~let cancel = fetchAsyncData(...); self.onUnmount(() => cancel())~ is much easier.

- Note: this is an interop helper. This isn't meant to be used as a
  shiny first-class feature for e.g. adding more flux stores into your
  app (for that purpose, please use local reducer). Every time you
  use ~self.onUnmount~, consider it as a simple, pragmatic and
  performant way to talk to the existing world.
** Router
- [[Https://github.com/reasonml/reason-react/blob/9e9e40ea4c7e8d55e56cba47a4d0188c26d0791e/src/ReasonReact.rei#L248-L276][Documented public interface]]

- ~ReasonReact.Router.push(string)~: takes a new path and update the
  URL.

- ~ReasonReact.Router.replace(string)~: like push, but replaces the
  current URL.

- ~ReasonReact.Router.watchUrl(f)~: start watching for URL
  changes. Returns a subscription token. Upon url change, calls the
  callback and passes it the ReasonReact.Router.url record.

- ~ReasonReact.Router.unwatchUrl(watcherID)~: stop watching for url
  changes.

- ~ReasonReact.Router.dangerouslyGetInitialUrl()~: get url record
  outside of watchUrl.

*** Match a Route
- There's no API! watchUrl gives you back a ~url~ record of the following shape:
  #+BEGIN_SRC reason
    type url = {
      /* path takes window.location.pathname, like "/book/title/edit" and turns it into `["book", "title", "edit"]` */
      path: list(string),

      /* the url's hash, if any. The # symbol is stripped out for you */
      hash: string,

      /* the url's query params, if any. The ? symbol is stripped out for you */
      search: string
    };
  #+END_SRC
- So the url ~www.hello.com/book/10/edit?name=Jane#author~ is given
  back as:
  #+BEGIN_SRC js
    {
      path: ["book", "10", "edit"],
      hash: "author",
      search: "name=Jane"
    }
  #+END_SRC
- At this point, you can simply pattern match your way to glory!
  #+BEGIN_SRC reason
    let watcherID = ReasonReact.Router.watchUrl(url => {
      switch (url.path) {
      | ["book", id, "edit"] => handleBookEdit(id)
      | ["book", id] => getBook(id)
      | ["book", id, _] => noSuchBookOperation()
      | [] => showMainPage()
      | ["shop"] | ["shop", "index"] => showShoppingPage()
      | ["shop", ...rest] =>
         /* e.g. "shop/cart/10", but let "cart/10" be handled by another function */
        nestedMatch(rest)
      | _ => showNotFoundPage()
      }
    });

    /* some time later */
    ReasonReact.Router.unwatchUrl(watcherID);
  #+END_SRC
  So you can match a path, match a subset of a path, defer part of a
  matching to a nested logic, etc.


*** Tips & Tricks
- Notice that this is just normal pattern matching. You can combine it
  with other features, such as tuple + ReasonReact features like
  subscriptions and reducer:
  #+BEGIN_SRC reason
    let component = ReasonReact.reducerComponent("TodoApp");

    let make = _children => {
      ...component,
      reducer: (action, state) =>
        switch (action) {
        /* router actions */
        | ShowAll => ReasonReact.Update({...state, nowShowing: AllTodos})
        | ShowActive => /* ... */
        /* todo actions */
        | ChangeTodo(text) => /* ... */
        },
      didMount: self => {
        let watcherID = ReasonReact.Router.watchUrl(url => {
          switch (url.hash, MyAppStatus.isUserLoggedIn) {
          | ("active", _) => self.send(ShowActive)
          | ("completed", _) => self.send(ShowCompleted)
          | ("shared", true) => self.send(ShowShared)
          | ("shared", false) when isSpecialUser => /* handle this state please */
          | ("shared", false) => /* handle this state please */
          | _ => self.send(ShowAll)
          }
        });
        self.onUnmount(() => ReasonReact.Router.unwatchUrl(watcherID));
      },
      render: ...
    }
  #+END_SRC




** ReactJS Idioms Equivalents
*** Invalid Prop Name
- Prop names like ~type~ (as in ~<input type="text" />~) aren't
  syntactically valid; ~type~ is a reserved keyword in Reason/OCaml. Use
  ~<input type_="text" />~ instead. This follows BuckleScript's [[https://bucklescript.github.io/docs/en/object.html#rename-fields][name constraint]].
- For ~aria-*~: use the camelCased ~ariaFoo~. E.g. ~ariaLabel~. For DOM
  components, we'll translate it to ~aria-label~ under the hood.
- For ~data-*~, this is a bit trickier; words with ~-~ in them aren't
  valid in Reason/OCaml. When you do want to write them, e.g. ~<div data-name="click me" />~, use the following:
  #+BEGIN_SRC reason
    ReactDOMRe.createElementVariadic(
      "div",
      ~props=(ReactDOMRe.objToDOMProps({"data-name": "click me"})),
      [||]
    )
  #+END_SRC
  For non-DOM components, you need to pick valid prop names.
*** Props Spread
- You can't. Props spreading is a big source of unpredictability and
  performance regression (think shouldComponentUpdate). Our API
  prevents this. If you reaaaaally need it for binding to existing
  ReactJS components, see [[https://reasonml.github.io/reason-react/docs/en/clone-element][this section]].
*** Component as Prop
- In ReactJS, ~<Menu banner=MyBanner />~ is easy; in ReasonReact, we
  can't trivially pass the whole component module (it wouldn't even be
  syntactically valid because a module resides in [[https://reasonml.github.io/docs/en/module.html][another layer]] of the
  language). Solution:
  #+BEGIN_SRC reason
      let bannerCallback = (prop1, prop2) => <MyBanner message=prop1 count=prop2 />;

      <Menu bannerFunc=bannerCallback />;
  #+END_SRC
*** Custom Class/Component Property
- Your ReactJS component might have extra properties attached onto it:
  #+BEGIN_SRC reason
    class HelloMessage extends React.Component {
      static getRandomNumber() {
        return 4;
      };

      getAnswerToLife() {
        return 42;
      };

      render() {
        ...
      }
    }
  #+END_SRC
- Since ReasonReact components are created from a record (which has
  fixed fields), you can't attach arbitrary fields onto it. Here are
  the solutions.
  #+BEGIN_SRC reason
    let component = /* ... */;
    let make = /* ... */;

    let getRandomNumber = () => 4;
  #+END_SRC
