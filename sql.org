* Anatomy of a Relational Database
According to the relational model, data in a relational database is
stored in /relations/, which are perceived by the user as tables. Each
relation is composed of tuples (records or rows) and attributes
(fields or columns).


* Tables
The logical order of records and fields within a table is of
absolutely no importance.

The subject that a given table represents can be either an *object* or
an *event*. When the subject is an object, the table represents
something that is tangible, such as a person, place, or
thing. Regardless of its type, every object has characteristics that
can be stored as data. Pilots, products, machines, students,
buildings, and equipment are all examples of objects that can be
represented by a table

When the subject of a table is an *event*, the table represents
something that occurs at a given point in time and has characteristics
you wish to record. These characteristics can be stored as data and
then processed as information in exactly the same manner as a table
that represents some specific object. Examples of events you might
need to record include judicial hearings, distributions of funds, lab
test results, and geological surveys..


** primary key
A primary key is a field or group of fields that uniquely identifies
each record within a table. (When a primary key is composed of two or
more fields, it is known as a /composite primary key/.) The primary key
is the most important for two reasons: Its value identifies a specific
record throughout the entire database, and its field identifies a
given table throughout the entire database. Primary keys also enforce
table-level integrity and help establish relationships with other
tables. Every table in your database should have a primary key.

** foreign key
When you determine that a pair of tables has a relationship to each
other, you typically establish the relationship by taking a copy of
the primary key from the first table and inserting it into the second
table, where it becomes a foreign key. (The term foreign key is
derived from the fact that the second table already has a primary key
of its own, and the primary key you are introducing from the first
table is foreign to the second table.)

Foreign keys are important not only for the obvious reason that they
help establish relationships between pairs of tables but also because
they help ensure relationship- level integrity. This means that the
records in both tables will always be properly related because the
values of a foreign key must be drawn from the values of the primary
key to which it refers. Foreign keys also help you avoid the dreaded
“orphaned records,” a classic example of which is an order record
without an associated customer.

** Views
A view is a virtual table composed of fields from one or more tables
in the database.  The tables that comprise the view are known as base
tables. The relational model refers to a view as virtual because it
draws data from base tables rather than storing any data on its
own. In fact, the only information about a view that is stored in the
database is its structure

In many RDBMS programs, a view is commonly implemented and referred to
as a saved query or, more simply, a query.

** Relationships
Three types of relationships can exist between a pair of tables:
one-to-one, one-to-many, or many-to-many.

*** one-to-one
A pair of tables has a one-to-one relationship when a single record in
the first table is related to only one record in the second table, and
a single record in the second table is related to only one record in
the first table. In this type of relationship, one table is referred
to as the primary table, and the other is referred to as the secondary
table.  The relationship is established by taking the primary key of
the primary table and inserting it into the secondary table, where it
becomes a foreign key. This is a special type of relationship because
in nearly all cases the foreign key also acts as the primary key of
the secondary table.

*** one-to-many
When a pair of tables has a one-to-many relationship, a single record
in the first table can be related to many records in the second table,
but a single record in the second table can be related to only one
record in the first table. This relationship is established by taking
the primary key of the table on the “one” side and inserting it into
the table on the “many” side, where it becomes a foreign key.
e.g.
- ONE customer MANY orders
- ONE category MANY products
- ONE department MANY employees

*** many-to-many
A pair of tables is in a many-to-many relationship when a single
record in the first table can be related to many records in the second
table, and a single record in the second table can be related to many
records in the first table. In order to establish this relationship
properly, you must create what is known as a linking table. This table
provides an easy way to associate records from one table with those of
the other and will help to ensure that you have no problems adding,
deleting, or modifying any related data. You define a linking table by
taking a copy of the primary key of each table in the relationship and
using them to form the structure of the new table. These fields
actually serve two distinct roles: Together they form the composite
primary key of the linking table, and separately they each serve as a
foreign key.
e.g.

author
| id | name           |   zip |
|----+----------------+-------|
| 74 | Jordan Winters | 83542 |
| 75 | Fred Summers   | 39749 |
| 76 | John Marr      | 98347 |

title
| id | title      | isbn   |
|----+------------+--------|
|  1 | DB design  | abc123 |
|  2 | sharepoint | def456 |
|  3 | SQL Server | FGH789 |


authortitle
| id | authorid | titleid |
|----+----------+---------|
|  1 |       74 |       1 |
|  2 |       74 |       3 |
|  3 |       76 |       3 |
|  4 |       75 |       2 |

this is the linking table, it has a one-to-many relationship with the
each of the above tables (author and title)

* Sound Structures
** Fine-Tuning Fields
- Is the name descriptive and meaningful to your entire organization?
- Is the field name clear and unambiguous?
  + Make sure that each field in your database has a unique name and
    that it appears only once in the entire database structure. The
    only exception to this rule is when a field is being used to
    establish a relationship between two tables.
- Did you use an acronym or abbreviation as a field name? DON'T DO IT.
- Did you use a name that implicitly or explicitly identifies more
  than one characteristic?
- Make sure the field represents a specific characteristic of the subject of the table.
- Make certain that the field contains only a single value (Multivalued and multipart fields can wreak havoc in your database).
- Make sure the field does not store the result of a calculation or concatenation.
- Make certain the field appears only once in the entire database.
** Fine-Tuning Tables
- Is the name unique and descriptive enough to be meaningful to your
  entire organization?
- Does the name accurately, clearly, and unambiguously identify the
  subject of the table?
- Does the name contain words that convey physical characteristics?
  Avoid using words such as File, Record, and Table in the table name
  because they introduce a level of confusion that you don’t need.
- Did you use an acronym or abbreviation as a table name? If the
  answer to this question is “Yes,” change the name right now!
- Did you use a name that implicitly or explicitly identifies more
  than one subject?
- Make certain you used the plural form of the name. You use the
  plural form because a table stores a collection of instances of the
  subject of the table. Using the plural form also helps you to
  distinguish a table name from a field name.
-  Make sure the table represents a single subject. Also remember that
  the subject represented by the table can be an *object* or *event*. By
  “object” we mean something that is tangible, such as employees,
  vendors, machines, buildings, or departments, whereas an “event” is
  something that happens at a given point in time that has
  characteristics you want to record. The best example of an event
  that everyone can relate to is a doctor’s appointment.
- Make certain each table has a primary key.
- Make sure the table does not contain any multipart or multivalued fields.
- Make sure there are no calculated fields in the table.
- Make certain the table is free of any unnecessary duplicate fields.

*** sound primary key
- Do the fields uniquely identify each record in the table?
- Does this field or combination of fields contain unique values?
- Will these fields ever contain unknown values?
- Can the value of these fields ever be optional?
- Is this a multipart field?
- Can the value of these fields ever be modified?

*** solid relationships

**** one-to-one relationship
     You establish a one-to-one relationship by taking the primary key
     from the primary table and inserting it into the subordinate
     table, where it becomes a foreign key. This is a special type of
     relationship because in many cases the foreign key will also act
     as the primary key of the subordinate table.

**** one-to-many relationship
     You establish a one-to-many relationship by taking the primary
     key of the table on the “one” side and inserting it into the
     table on the “many” side, where it becomes a foreign key.

**** many-to-many relationship
     You establish a many-to-many relationship by creating a linking
     table.  Define the linking table by taking a copy of the primary
     key of each table in the relationship and using them to form the
     structure of the new table. These fields commonly serve two
     distinct roles: Together, they form the composite primary key of
     the linking table; separately, they each serve as a foreign key.

***** Establishing a Deletion Rule
A deletion rule dictates what happens when a user makes a request to
delete a record in the primary table of a one-to-one relationship or
in the table on the “one” side of a one-to-many relationship. You can
guard against orphaned records by establishing this rule. (Orphaned
records are those records in the subordinate table of a one-to- one
relationship that don’t have related records in the primary table, or
records in the table on the “many” side of a one-to-many relationship
that don’t have related records in the table on the “one” side.)

- restrict
- cascade

First, select a pair of tables, and then ask yourself the following
question: “If a record in [name of primary or ‘one’ side table] is
deleted, should related records in [name of subordinate or ‘many’ side
table] be deleted as well?”

***** Setting the Type of Participation
When you establish a relationship between a pair of tables, each table
participates in a particular manner. The type of participation
assigned to a given table determines whether a record must exist in
that table before you can enter a record into the other table. There
are two types of participation:

- Mandatory: At least one record must exist in this table before you
  can enter any records into the other table.

- Optional: There is no requirement for any records to exist in this
  table before you enter any records in the other table.

***** Setting the Degree of Participation
This process is known as identifying a table’s degree of
participation. The degree of participation for a given table is
represented by two numbers that are separated with a comma and
enclosed within parentheses. The first number indicates the minimum
possible number of related records, and the second number indicates
the maximum possible number of related records.

You must figure out to what degree each table will participate. You do
this by determining the minimum and maximum number of records in one
table that can be related to a single record in the other table.
* miscellaneous
** Codd's Relational Model
- A relation (table) is a set of tuples (rows) (d1, d2, d3,... dn).
- Each *element in a tuple* (cell value) dj is a member of Dj, a *data domain* (set of allowed values).

** SELECT and WHERE

#+BEGIN_SRC sql
select 'farhad.hsni@gmail.com' like '%gmail.com' -- true
#+END_SRC

#+BEGIN_SRC
SELECT * FROM Customer WHERE FirstName LIKE '____'
#+END_SRC

|----------------------+------------------------------------------|
| >, <, >=, <=, =      | age >= 21                                |
| Not equal: <> or !=. | isDeleted != TRUE                        |
| Within a range       | temperature BETWEEN 68 AND 75            |
| Member of a set      | companyname IN ('Microsoft', 'LinkedIn') |
| String ends with     | email LIKE '%.gov'                       |
| String includes      | summary LIKE '%spicy%'                   |
| String length        | billing_state LIKE '__'                  |

*** Logical Boolean Operators
AND, OR, NOT
- Boolean (logic) operators
- Operate on conditions
- Parens for clarity
#+BEGIN_SRC sql
SELECT productname FROM Product WHERE (unitprice > 60 AND unitsinstock > 20)
#+END_SRC

** Core Functions
Core Functions
- Each database's set of core functions is slightly different (SQLite,
  MySQL, PostgreSQL)
- Some of these work across databases (lower, max, min, count, substr,
  etc...)
- Fine to use them in a comparison
- ...or as an additional column
#+BEGIN_SRC sql
  select * from customer where lower(companyname) like lower('%Taq%') or
  lower(contactname) like lower('%JOHN%')
#+END_SRC

** Sorting
Sorting
- An =ORDER BY= clause declares the desired sorting of the result set
- Specify sort direction as =ASC= or =DESC=
- Multiple sorts and directions may be provided, separated by commas
#+BEGIN_SRC sql
  SELECT productname, unitprice FROM Product WHERE unitprice BETWEEN 9.6
  AND 11 ORDER BY unitprice ASC, productname DESC
#+END_SRC

** Limiting
When dealing with large result sets, sometimes we just want the first N rows
- A LIMIT clause allows us to specify how many we want
- Performance can be much higher, if the database doesn't have to examine
each record for sorting purposes
#+BEGIN_SRC sql
SELECT productname, unitprice
FROM Product
ORDER BY unitprice DESC
LIMIT 3
#+END_SRC
** Offsetting
- Means "Start with the Nth result"
- We can paginate over a set of results using a LIMIT and OFFSET
#+BEGIN_SRC sql
SELECT productname,
unitprice
FROM Product
ORDER BY unitprice DESC
LIMIT 3
OFFSET 3
#+END_SRC

** Relationships
#+BEGIN_SRC

(customerid)
(employeeid)
ORDER⚞⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯ CUSTOMER
 \|/
  |
  |
  |
EMPLOYEE
#+END_SRC
- Order belongs to Customer
- Customer has many Orders
- Order belongs to Employee
- Employee has many Orders

ORDER
|    id | customerid | employeeid |
|-------+------------+------------|
| 10625 | ANATR      |          3 |
| 10835 | ALFKI      |          1 |
| 12617 | ANTON      |          2 |

CUSTOMER
| id    | companyname         | contactname           |
|-------+---------------------+-----------------------|
| ALFKI | Alfreds             | Maria Anders          |
| ANATR | Ana Futterkiste     | Ana Trujillo          |
| ANTON | Antonio Emparedados | Moreno Antonio Moreno |

EMPLOYEE
| id | firstname | lastname  |
|----+-----------+-----------|
|  1 | Nancy     | Davolio   |
|  2 | Andrew    | Fuller    |
|  3 | Janet     | Leverling |

** JOIN: Assemble tables together
The JOINing is done on a related column between the tables

- Four types of join, that differ in terms of how "incomplete" matches are handled
- Simplified example

*customerorder*
| id | customerid | amount | notes         | month |
|----+------------+--------+---------------+-------|
|  1 |          1 |     99 | order 1 notes |     5 |
|  2 |          1 |    212 | order 2 notes |     3 |
|  4 |         12 |   1000 | order 4 notes |    11 |
|  3 |          3 |   14.5 | order 3 notes |     3 |
|  5 |          1 |    199 | orde 5 notes  |     3 |

*customer*
| id | name             | notes        |
|----+------------------+--------------|
|  2 | Mark Grabanski   | mark's notes |
|  1 | Mike North       | mike's notes |
|  3 | Lisa Huang-North | lisa's notes |

incomplete matches:
- order 4 has customerid of 12 but we don't have any customer with that id
- customer 2 doesn't have any order

*** INNER JOIN
Only rows that have "both ends" of the match will be selected for the
sample tables demonstrated above, =customer 2= and =order 4= will be
dropped.
#+BEGIN_SRC sql
select
    *
from
    customerorder as o
inner join customer as c on
    o.customerid = c.id
#+END_SRC

| id | customerid | amount | notes         | month | id | name             | notes        |
|----+------------+--------+---------------+-------+----+------------------+--------------|
|  1 |          1 |     99 | order 1 notes |     5 |  1 | Mike North       | mike's notes |
|  2 |          1 |    212 | order 2 notes |     3 |  1 | Mike North       | mike's notes |
|  3 |          3 |   14.5 | order 3 notes |     3 |  3 | Lisa Huang-North | lisa's notes |
|  5 |          1 |    199 | orde 5 notes  |     3 |  1 | Mike North       | mike's notes |

*** LEFT JOIN
Rows from LEFT of join will be selected no matter what
#+BEGIN_SRC sql
select
    *
from
    customerorder as o
left join customer as c on
    o.customerid = c.id
#+END_SRC
|id |customerid |amount |notes         |month |id |name             |notes        |
|---|-----------|-------|--------------|------|---|-----------------|-------------|
|1  |1          |99     |order 1 notes |5     |1  |Mike North       |mike's notes |
|2  |1          |212    |order 2 notes |3     |1  |Mike North       |mike's notes |
|4  |12         |1000   |order 4 notes |11    |   |                 |             |
|3  |3          |14.5   |order 3 notes |3     |3  |Lisa Huang-North |lisa's notes |
|5  |1          |199    |orde 5 notes  |3     |1  |Mike North       |mike's notes |
As you can see order 4 stil exist although it doesn't have any
customer
*** RIGHT JOIN
Rows from RIGHT of join will be selected no matter what

#+BEGIN_SRC sql
select
    *
from
    customerorder as o
right join customer as c on
    o.customerid = c.id
#+END_SRC
|id |customerid |amount |notes         |month |id |name             |notes        |
|---|-----------|-------|--------------|------|---|-----------------|-------------|
|1  |1          |99     |order 1 notes |5     |1  |Mike North       |mike's notes |
|2  |1          |212    |order 2 notes |3     |1  |Mike North       |mike's notes |
|3  |3          |14.5   |order 3 notes |3     |3  |Lisa Huang-North |lisa's notes |
|5  |1          |199    |orde 5 notes  |3     |1  |Mike North       |mike's notes |
|   |           |       |              |      |2  |Mark Grabanski   |mark's notes |

as you can see customer 2 despite the fact that he doesn't have any
order, he made it into the result

*** FULL JOIN
All rows in both tables are selected

#+BEGIN_SRC sql
select
    *
from
    customerorder as o
full join customer as c on
    o.customerid = c.id
#+END_SRC

| id | customerid | amount | notes         | month | id | name             | notes        |
|----+------------+--------+---------------+-------+----+------------------+--------------|
|  1 |          1 |     99 | order 1 notes |     5 |  1 | Mike North       | mike's notes |
|  2 |          1 |    212 | order 2 notes |     3 |  1 | Mike North       | mike's notes |
|  4 |         12 |   1000 | order 4 notes |    11 |    |                  |              |
|  3 |          3 |   14.5 | order 3 notes |     3 |  3 | Lisa Huang-North | lisa's notes |
|  5 |          1 |    199 | orde 5 notes  |     3 |  1 | Mike North       | mike's notes |
|    |            |        |               |       |  2 | Mark Grabanski   | mark's notes |

As you can see there're two gaps

*** OUTER JOIN
- =LEFT=, =RIGHT= and =FULL JOIN= are sometimes referred to as =OUTER= joins

- In general, an =OUTER= join allows for the possibility that one or
  more rows may be partially empty, due to not having a corresponding
  match in the other table
*** JOIN - Selecting Columns
- =SELECT= * is generally a bad idea, and it's particularly dangerous
  in the context of a JOIN
- Choose columns with care, and alias any duplicates

#+BEGIN_SRC sql
select
    o.id,
    o.customerid,
    o.amount,
    c.name
from
    customerorder as o
left join customer as c on
    o.customerid = c.id
#+END_SRC
| id | customerid | amount | name             |
|----+------------+--------+------------------|
|  1 |          1 |     99 | Mike North       |
|  2 |          1 |    212 | Mike North       |
|  4 |         12 |   1000 |                  |
|  3 |          3 |   14.5 | Lisa Huang-North |
|  5 |          1 |    199 | Mike North       |

** Aggregate Functions
- Perform a calculation on a set of values, to arrive at a single
  value
- Each RDBMS has its own functions, but they all generally have a
  foundational set
  + =SUM= - Adds values together
  + =COUNT= - Counts the number of values
  + =MIN/MAX= - Finds the min/max value
  + =AVG= - Calculates the mean of the values

** Aggregate Functions and GROUP BY
TIP:  What you =SELECT=, aggregate and =GROUP BY= must agree.

*customerorder*
| id | customerid | amount | notes         | month |
|----+------------+--------+---------------+-------|
|  1 |          1 |     99 | order 1 notes |     5 |
|  2 |          1 |    212 | order 2 notes |     3 |
|  4 |         12 |   1000 | order 4 notes |    11 |
|  3 |          3 |   14.5 | order 3 notes |     3 |
|  5 |          1 |    199 | orde 5 notes  |     3 |

*customer*
| id | name             | notes        |
|----+------------------+--------------|
|  2 | Mark Grabanski   | mark's notes |
|  1 | Mike North       | mike's notes |
|  3 | Lisa Huang-North | lisa's notes |

- Imagine we have this JOIN query, and we want total amount per customer

total spent by each customer
#+BEGIN_SRC sql
select
    c.id,
    c.name,
    sum( o.amount )
from
    customerorder as o
inner join customer as c on o.customerid=c.id
group by c.name,c.id
#+END_SRC

*RESULT*:
|id |name             |sum  |
|---|-----------------|-----|
|1  |Mike North       |510  |
|3  |Lisa Huang-North |14.5 |


total spent by each customer per month
#+BEGIN_SRC sql
select
    c.id,
    c.name,
    o.m,
    sum( o.amount )
from
    customerorder as o
inner join customer as c on o.customerid=c.id
group by c.name,c.id,o.m
#+END_SRC

*RESULT*:
|id |name             |m |sum  |
|---|-----------------|--|-----|
|1  |Mike North       |5 |99   |
|1  |Mike North       |3 |411  |
|3  |Lisa Huang-North |3 |14.5 |


impementation specific aggregators:

#+BEGIN_SRC sql
select
    c.id,
    c.name,
    string_agg( cast( o.id as text ), ', ' ) as orders
from
    customer as c
left join customerorder as o on
    c.id = o.customerid
group by
    c.id,
    c.name
order by
    c.id
#+END_SRC
| id | name             | orders  |
|----+------------------+---------|
|  1 | Mike North       | 1, 2, 5 |
|  2 | Mark Grabanski   |         |
|  3 | Lisa Huang-North | 3       |

** Filtering *grouped* results
- A =WHERE= clause is used to examine individual rows. It cannot be used
  with an aggregate function
- A =HAVING= clause is used to examine groups, and include or exclude
  them from the result set
- It's totally fine to use both in the same query. =WHERE= to
  disregard irrelevant rows =HAVING= to disregard irrelevant groups

#+BEGIN_SRC sql
select
    m,
    sum(amount) as sum_month
from
    customerorder
where
    sum_month > 300
group by
    m
#+END_SRC
#+BEGIN_SRC
ERROR: COLUMN "SUM_MONTH" DOES NOT EXIST
#+END_SRC

WITH =HAVING=
#+BEGIN_SRC SQL
SELECT
    M,
    SUM( AMOUNT ) AS SUM_MONTH
FROM
    CUSTOMERORDER
GROUP BY
    M
HAVING
    SUM( AMOUNT ) > 300
#+END_SRC

|  M | SUM_MONTH |
|----+-----------|
| 11 |      1000 |
|  3 |     425.5 |

** Subquery
- A =SELECT= query can be nested in another query
- Useful when results from the database are needed in order to define
  "outer" query
- Inner query cannot mutate data
- Sometimes your RDBMS doesn't support ORDER BY within the subquery

We need products which are in the category of 'Beverages', so first we
get the id of 'Beverages' category from category table.
#+BEGIN_SRC sql
select
    *
from
    Product
where
    categoryid =(
    select
        id
    from
        Category
    where
        categoryname = 'Beverages' );
#+END_SRC

** Creating Records
- Add new records to a table via an INSERT INTO statement, indicating
  the table to insert into
- This must be followed by a VALUES expression, with an array
  containing the corresponding data, in the order aligned with the
  table's columns
#+BEGIN_SRC sql
INSERT INTO Customer VALUES (8424, 'Tanner Thompson', 'Likes scotch');
#+END_SRC
- Sometimes, columns can have default (or other auto-generated) values
  and we need only provide data for SOME columns.
- Specify the column names in your INSERT INTO statement, and ensure
  your VALUES array is in the respective order.
#+BEGIN_SRC sql
INSERT INTO Customer (name, notes)
VALUES ('Tanner Thompson', 'Likes scotch');
#+END_SRC

** SQL Injection
- Anytime new data is added to your database, it must be appropriately
  sanitized
- Most of the time your SQL driver (library) helps you out

#+BEGIN_SRC javascript
db.exec(`INSERT INTO Customer (name, notes)
VALUES ($1, $2)`, ['Tanner', 'Tanner notes']);
#+END_SRC

** Deleting Records
- Delete a table completely, including column definitions, indices,
  etc... =DROP TABLE Customer=;
- Delete all records from a table, while leaving the structure and indices intact =DELETE FROM Customer;=
- One or more rows can be deleted while leaving the rest intact, via a =WHERE= clause
#+BEGIN_SRC sql
DELETE FROM Customer WHERE name = 'Juicero';
#+END_SRC

** Transactions
- A transaction is a list of database operations that must be executed
  atomically (Atomic operations are performed in a single step: they
  can’t half-execute).
- Sometimes we need to perform multi-statement operations (i.e.,
  create an =Order= and several =OrderDetail= items)
- What would happen if the =Order= was created, but something went wrong
  with creating one of the =OrderDetails=?
#+BEGIN_SRC sql
INSERT INTO CustomerOrder ...; -- create new order
INSERT INTO OrderDetail ...;
INSERT INTO OrderDetail ...; -- ERROR happens
#+END_SRC
- Surround multiple statements with =BEGIN= and =COMMIT= to include them
  in a transaction
#+BEGIN_SRC sql
BEGIN;
    INSERT INTO CustomerOrder ...; -- create new order
    INSERT INTO OrderDetail ...; -- add order item to it
    INSERT INTO OrderDetail ...;
    INSERT INTO OrderDetail ...;
COMMIT; -- save! -- or in case of error we can say ROLLBACK
#+END_SRC

*** ACID
Principles that guarantee data consistency, even when things go wrong
- Atomic: All of the operations are treated as a single "all or
  nothing" unit
- Consistent: Changes from one valid state to another (never halfway)
- Isolated: How visible are particulars of a transaction before it's
  complete? When? To whom?
- Durable: Once it completes, the transaction's results are stored
  permanently in the system

*** Transaction Isolation Levels
- The degree to which other queries to the database can see, or be
  influenced by an in-progress transaction
- There are levels of isolation, and we as developers have a choice
- Often this is a concurrency vs. safety and consistency trade-off
**** Read Phenomena: Dirty Reads
#+BEGIN_SRC sql
BEGIN;
SELECT month FROM CustomerOrder WHERE id = 21; -- 3
                                                                    BEGIN;
                                                                    UPDATE CustomerOrder SET month=4 WHERE id = 21;
SELECT month FROM CustomerOrder WHERE id = 21; -- 4 OOPS
                                                                    ROLLBACK;
COMMIT;
#+END_SRC
*month is not 4*. The transation on the right which set month to 4
failed and rolled back.

**** Read Phenomena: Non-Repeatable Reads
#+BEGIN_SRC sql
BEGIN;
SELECT month FROM CustomerOrder WHERE id = 21; -- 3
                                                                  BEGIN;
                                                                  UPDATE CustomerOrder SET month=4 WHERE id = 21;
                                                                  COMMIT;
SELECT month FROM CustomerOrder WHERE id = 21 -- 4 OOPS, it changed during the transaction
#+END_SRC
**** Read Phenomena: Phantom Reads
| id | customerid | amount | month |
|----+------------+--------+-------|
| 19 |          1 |  99.00 |     5 |
| 20 |          1 | 212.00 |     3 |
| 21 |          3 |  14.50 |     3 |

#+BEGIN_SRC sql
BEGIN;
SELECT SUM(amount) FROM CustomerOrder WHERE month BETWEEN 3 AND 5 -- 226.50
                                                                                BEGIN;
                                                                                INSERT INTO CustomerOrder(customer_id, amount, month) VALUES (22, 40000, 3);
                                                                                COMMIT;
SELECT SUM(amount) FROM CustomerOrder WHERE month BETWEEN 3 AND 5 -- 40226.50 -- OOPS
#+END_SRC
A new record has been added within the range of criteria which we were
interested in.

**** Transaction Isolation Levels
- *Read Uncommitted*: Dirty reads are possible.
- *Read Committed*: Write locks are obtained across the whole
  transaction, read locks are obtained only for the duration of a
  =SELECT=. Dirty reads are not possible.
- *Repeatable Read*: Read and write locks are obtained across the whole
  transaction.
- *Serializable*: Read and write locks are obtained on selected data,
  range locks are obtained for =WHERE= clauses.

** Updating Records
- One or more records may be updated at a time
#+BEGIN_SRC sql
UPDATE OrderDetail SET discount = 0.15 WHERE orderid = 10793
#+END_SRC
- Sometimes we want to use current values to calculate new ones
#+BEGIN_SRC sql
UPDATE OrderDetail
    SET discount = 0.15,
        unitprice = (1 - 0.15) * (SELECT unitprice FROM Product WHERE id = OrderDetail.productid)
WHERE orderid = 10793
#+END_SRC

** Schema Migration
When we need to change the database structure, we create a schema
migration script. It automatically upgrades the schema and transforms
existing data accordingly. Typically, these scripts can also undo
their changes.

- Incremental changes to a database
- Ideally, reversible
- May start with an initial “seed” script
- “Applied” migrations are stored in a special DB table
- Ideally, backwards compatible
#+BEGIN_SRC
                        |--------------|
                        | Setup & Seed |
                        |--------------|
                                ⇊
                                ⇊
                                ⇊
               |----------------------------------|
               | ADD NEW COLUMN TO CUSTOMER TABLE |
               |----------------------------------|
                                ⇊
                                ⇊
                                ⇊
                |--------------------------------|
                | CREATE A NEW BILLINGINFO TABLE |
                |--------------------------------|
                                ⇊
                                ⇊
                                ⇊
|---------------------------------------------------------------|
| INCREASE the width of OF THE “NOTES” IN THE the Account table |
|---------------------------------------------------------------|
#+END_SRC

** Indices - A memory-for-time trade-off
- Extra bookkeeping performed on records for quick retrieval later
- DBMS builds an auxiliary index, mapping row IDs to their respec-
  tive addresses in memory. An index is essentially a self-balancing
  binary search tree. Each row in the table corresponds to
  a node in the tree.
- Indexing fields that have a uniqueness constraint is necessary to be
  able to insert items fast.
- *Sorting*: Indexes help to fetch rows in the indexed fields’ sorted
  order. For instance, if there is an index for the “name” field, we
  can get rows sorted by name without any extra calculations.
- *joint indexes*: When sorting by two fields is required, joint
  indexes are used. They index multiple fields and won’t help finding
  items faster, but they make returning data sorted by the multiple
  fields a breeze.
- *performance*: So indexes are awesome: they allow for super fast
  querying and instant sorted data access. Then why don’t we have
  indexes for all fields in every table? The problem is when a new
  register is inserted to or removed from the table, all its indexes
  must be updated to reflect that. If there are a lot of indexes,
  updating, inserting or removing rows can become computationally
  expensive (remember tree balancing). Moreover, indexes occupy disk
  space, which is not an unlimited resource.
- showcase
    Without indexing
    #+BEGIN_SRC sql
    SELECT * FROM OrderDetail WHERE orderid = 10793 -- 60ms
    #+END_SRC

    ask for query plan
    #+BEGIN_SRC sql
    EXPLAIN SELECT * FROM OrderDetail WHERE orderid = 10793
    #+END_SRC

    Results in
    #+BEGIN_SRC
    QUERY PLAN                                                                    |
    ------------------------------------------------------------------------------|
    Gather  (cost=1000.00..9426.57 rows=46 width=33)                              |
      Workers Planned: 2                                                          |
      ->  Parallel Seq Scan on orderdetail  (cost=0.00..8421.97 rows=19 width=33) |
            Filter: (orderid = 10794)                                             |
    #+END_SRC

    *index*
    #+BEGIN_SRC sql
    CREATE INDEX orderdetail_oid ON OrderDetail(orderid)
    #+END_SRC

    run the same query again after indexing
    #+BEGIN_SRC sql
    SELECT * FROM OrderDetail WHERE orderid = 10794 -- 1ms
    #+END_SRC

    ask for query plan
    #+BEGIN_SRC  sql
    EXPLAIN SELECT * FROM OrderDetail WHERE orderid = 10793
    #+END_SRC

    Results in
    #+BEGIN_SRC
    QUERY PLAN                                                                          |
    ------------------------------------------------------------------------------------|
    Index Scan using orderdetail_oid on orderdetail  (cost=0.42..9.23 rows=46 width=33) |
      Index Cond: (orderid = 10793)                                                     |
    #+END_SRC
- Indices can be created on multiple columns
  #+BEGIN_SRC sql
    CREATE INDEX orderdetail_order_customer ON OrderDetail(orderid, customerid)
  #+END_SRC
- When creating indices, the goal is to reduce (possibly eliminate)
  the exhaustive searching done for common or perf-sensitive queries
- We can remove an index like
  #+BEGIN_SRC sql
  DROP INDEX orderdetail_order_customer;
  #+END_SRC

** Column Constraints - Types
- One of the ways we can constrain values placed in particular columns
  is by types
- Names and properties of these types may vary from system to system
- Choice of column type impacts performance, and options for indexing
  and filtering
*** Create a Table
- Creating a table gives us the opportunity to define columns as
  name/type pairs
  #+BEGIN_SRC sql
  create table UserPreferences
  ( id int primary key,           -- an integer
   favorite_color char( 6 ),      -- Exactly 6 characters
   age smallint,                  -- an "small" integer
   birth_date date,               -- date (may or may not include time)
   notes varchar( 255 ),          -- up to 255 characters
   is_active boolean              -- boolean
   );
  #+END_SRC
*** NOT NULL
- We can forbid null values for one or more columns by adding =NOT NULL=
  #+BEGIN_SRC sql
  create table UserPreferences (
    id int primary key not null, -- required
    favorite_color char( 6 ),
    age smallint,
    birth_date date not null, -- required
    notes varchar( 255 ),
    is_active boolean not null -- required
  );
  #+END_SRC
*** UNIQUE
- A uniqueness constraint may be added to a column via =UNIQUE=
      #+BEGIN_SRC sql
      CREATE TABLE UserAccount (email VARCHAR(255) UNIQUE NOT NULL, name VARCHAR(255));
      #+END_SRC
*** PRIMARY KEY
- A combination of a =NOT NULL= and =UNIQUE= constraint
  #+BEGIN_SRC sql
  CREATE TABLE UserAccount (
      email VARCHAR(255) PRIMARY KEY,
      name VARCHAR(255)
  );

  #+END_SRC
- Often you’ll have one identity column in each that serves as the
  “id” for each addressable record
- Often we want these IDs to auto-increment
- In PostgreSQL we’ll create a SEQUENCE as our source of incrementing values
  #+BEGIN_SRC sql
  create sequence UserAccount_id_seq;

  create table UserAccount (
        id integer primary key default nextval( 'UserAccount_id_seq' ),
        name varchar( 255 )
      );

  alter sequence UserAccount_id_seq owned by UserAccount.id;
  #+END_SRC
  or alternatively
  #+BEGIN_SRC sql
  CREATE TABLE UserAccount (
      id SERIAL PRIMARY KEY,
      name VARCHAR(255)
  );
  #+END_SRC
- composite key
#+BEGIN_SRC sql
CREATE TABLE Interests (
    AnimalId INT NOT NULL,
    SpeciesId INT NOT NULL,
    PRIMARY KEY(AnimalId, SpeciesId),
)
#+END_SRC
*** Foreign Keys
  - Used to enforce the “other end” of a relationship
  - Validates against a column in the “foreign” table

*order*
| id | customerid | amount |
|----+------------+--------|
|  1 |          1 |  99.00 |
|  2 |          1 | 212.00 |
|  3 |          3 |  14.50 |

*customer*

| id | name             |
|----+------------------|
|  1 | Mike North       |
|  2 | Mark Grabanski   |
|  3 | Lisa Huang-North |

#+BEGIN_SRC sql
CREATE TABLE customer (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255)
    );

CREATE TABLE CustomerOrder (
    id SERIAL PRIMARY KEY,
    customerid INTEGER REFERENCES customer(id),
    amount REAL,
    month INTEGER DEFAULT 5 NOT NULL
);

#+END_SRC
**** ON DELETE
What happens when we delete the parent?
- NO ACTION
  + doesn't let you delete the parent. safest option.
- CASCADE
  + *dangerous*, it deletes all the parents referencing that children.
- SET NULL
  + set the reference in child to =NULL=
- SET DEFAULT
  + set the column to whatever is the default of theat column.
**** ON UPDATE
What happens when the parent's id is changed? (well, if it's a primary
key it should never change, but if we are referencing a unique column
that is not a primary key, it might change)
- NO ACTION
  - you can't do this. DB throws
- CASCADE
  - reflects changes on the child too.
- SET NULL
  - changes it to NULL
- SET DEFAULT
  - changes it to default value.

* Normalization
When a database is organized in a way that it is completely free of
duplicate information, we say that the database is =normalized=. The
process of transforming a database with replicated data to one without
is called =normalization=.

** Normal forms
*** 1NF
Basically have a good design. Make things as singular as possible.

- Atomicity (rule of one)
  One column describes only one attribute. Every column is individable.
- Every table should have a primary key.
- Everything in the table should describe the primary key and depend on that.
*** 2NF
The goal of 2NF is to get rid of partial dependency, which we might
have when we have composite keys. It's the situation when a column
depends on part of the primary key. Every column should depend on the
entire key.

*bookauthor*. The composite key is =bookid= and =authorid= columns.
| isbn | bookid | authorid |
|------+--------+----------|
|   26 | John   | Eve      |
This is partial dependency because =isbn= column is only depends on
=bookid=.

*** 3NF
To get rid of transitive dependency, that's when a column depends on the key but
through another column that depends on the PK.
- Every column should only depend on the primary key.

* postgresql
- [[http://www.postgresqltutorial.com/postgresql-cheat-sheet/][postgresql-cheat-sheet]]
- https://wiki.archlinux.org/index.php/PostgreSQL
- ~[postgres]$ initdb -D /var/lib/postgres/data~
  + ~/var/lib/postgres~ should belong to ~postgres~ username
    * ~sudo chown -R postgres:postgres /var/lib/postgres/postgres~
- ~psql -d myDatabaseName~
- ~psql -U username -d myDatabaseName~
- List all users and their permission levels: ~\du~
- Show summary information about all tables in the current database: ~\dt~
- List all databases in the PostgreSQL database server: ~\l~
- show table info: ~\d+ tablename~
- take a look at ~pgcli~
- postgres help (putting it here since the pager doesn't work as
  expected when using ~\?~ in REPL)
  :NOTE:
     General
      \copyright             show PostgreSQL usage and distribution terms
      \crosstabview [COLUMNS] execute query and display results in crosstab
      \errverbose            show most recent error message at maximum verbosity
      \g [FILE] or ;         execute query (and send results to file or |pipe)
      \gdesc                 describe result of query, without executing it
      \gexec                 execute query, then execute each value in its result
      \gset [PREFIX]         execute query and store results in psql variables
      \gx [FILE]             as \g, but forces expanded output mode
      \q                     quit psql
      \watch [SEC]           execute query every SEC seconds

    Help
      \? [commands]          show help on backslash commands
      \? options             show help on psql command-line options
      \? variables           show help on special variables
      \h [NAME]              help on syntax of SQL commands, * for all commands

    Query Buffer
      \e [FILE] [LINE]       edit the query buffer (or file) with external editor
      \ef [FUNCNAME [LINE]]  edit function definition with external editor
      \ev [VIEWNAME [LINE]]  edit view definition with external editor
      \p                     show the contents of the query buffer
      \r                     reset (clear) the query buffer
      \s [FILE]              display history or save it to file
      \w FILE                write query buffer to file

    Input/Output
      \copy ...              perform SQL COPY with data stream to the client host
      \echo [STRING]         write string to standard output
      \i FILE                execute commands from file
      \ir FILE               as \i, but relative to location of current script
      \o [FILE]              send all query results to file or |pipe
      \qecho [STRING]        write string to query output stream (see \o)

    Conditional
      \if EXPR               begin conditional block
      \elif EXPR             alternative within current conditional block
      \else                  final alternative within current conditional block
      \endif                 end conditional block

    Informational
      (options: S = show system objects, + = additional detail)
      \d[S+]                 list tables, views, and sequences
      \d[S+]  NAME           describe table, view, sequence, or index
      \da[S]  [PATTERN]      list aggregates
      \dA[+]  [PATTERN]      list access methods
      \db[+]  [PATTERN]      list tablespaces
      \dc[S+] [PATTERN]      list conversions
      \dC[+]  [PATTERN]      list casts
      \dd[S]  [PATTERN]      show object descriptions not displayed elsewhere
      \dD[S+] [PATTERN]      list domains
      \ddp    [PATTERN]      list default privileges
      \dE[S+] [PATTERN]      list foreign tables
      \det[+] [PATTERN]      list foreign tables
      \des[+] [PATTERN]      list foreign servers
      \deu[+] [PATTERN]      list user mappings
      \dew[+] [PATTERN]      list foreign-data wrappers
      \df[anptw][S+] [PATRN] list [only agg/normal/procedures/trigger/window] functions
      \dF[+]  [PATTERN]      list text search configurations
      \dFd[+] [PATTERN]      list text search dictionaries
      \dFp[+] [PATTERN]      list text search parsers
      \dFt[+] [PATTERN]      list text search templates
      \dg[S+] [PATTERN]      list roles
      \di[S+] [PATTERN]      list indexes
      \dl                    list large objects, same as \lo_list
      \dL[S+] [PATTERN]      list procedural languages
      \dm[S+] [PATTERN]      list materialized views
      \dn[S+] [PATTERN]      list schemas
      \do[S]  [PATTERN]      list operators
      \dO[S+] [PATTERN]      list collations
      \dp     [PATTERN]      list table, view, and sequence access privileges
      \drds [PATRN1 [PATRN2]] list per-database role settings
      \dRp[+] [PATTERN]      list replication publications
      \dRs[+] [PATTERN]      list replication subscriptions
      \ds[S+] [PATTERN]      list sequences
      \dt[S+] [PATTERN]      list tables
      \dT[S+] [PATTERN]      list data types
      \du[S+] [PATTERN]      list roles
      \dv[S+] [PATTERN]      list views
      \dx[+]  [PATTERN]      list extensions
      \dy     [PATTERN]      list event triggers
      \l[+]   [PATTERN]      list databases
      \sf[+]  FUNCNAME       show a function's definition
      \sv[+]  VIEWNAME       show a view's definition
      \z      [PATTERN]      same as \dp

    Formatting
      \a                     toggle between unaligned and aligned output mode
      \C [STRING]            set table title, or unset if none
      \f [STRING]            show or set field separator for unaligned query output
      \H                     toggle HTML output mode (currently off)
      \pset [NAME [VALUE]]   set table output option
                             (NAME := {border|columns|expanded|fieldsep|fieldsep_zero|
                             footer|format|linestyle|null|numericlocale|pager|
                             pager_min_lines|recordsep|recordsep_zero|tableattr|title|
                             tuples_only|unicode_border_linestyle|
                             unicode_column_linestyle|unicode_header_linestyle})
      \t [on|off]            show only rows (currently off)
      \T [STRING]            set HTML <table> tag attributes, or unset if none
      \x [on|off|auto]       toggle expanded output (currently off)

    Connection
      \c[onnect] {[DBNAME|- USER|- HOST|- PORT|-] | conninfo}
                             connect to new database (currently "yep")
      \conninfo              display information about current connection
      \encoding [ENCODING]   show or set client encoding
      \password [USERNAME]   securely change the password for a user

    Operating System
      \cd [DIR]              change the current working directory
      \setenv NAME [VALUE]   set or unset environment variable
      \timing [on|off]       toggle timing of commands (currently off)
      \! [COMMAND]           execute command in shell or start interactive shell

    Variables
      \prompt [TEXT] NAME    prompt user to set internal variable
      \set [NAME [VALUE]]    set internal variable, or list all if no parameters
      \unset NAME            unset (delete) internal variable

    Large Objects
      \lo_export LOBOID FILE
      \lo_import FILE [COMMENT]
      \lo_list
      \lo_unlink LOBOID      large object operations
  :END:
